# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:16+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`unittest` --- Unit testing framework"
msgstr ":mod:`unittest` --- Інфраструктура модульного тестування"

msgid "**Source code:** :source:`Lib/unittest/__init__.py`"
msgstr "**Вихідний код:** :source:`Lib/unittest/__init__.py`"

msgid ""
"(If you are already familiar with the basic concepts of testing, you might "
"want to skip to :ref:`the list of assert methods <assert-methods>`.)"
msgstr ""
"(Якщо ви вже знайомі з основними концепціями тестування, ви можете перейти "
"до :ref:`списку методів assert <assert-methods>`.)"

msgid ""
"The :mod:`unittest` unit testing framework was originally inspired by JUnit "
"and has a similar flavor as major unit testing frameworks in other "
"languages.  It supports test automation, sharing of setup and shutdown code "
"for tests, aggregation of tests into collections, and independence of the "
"tests from the reporting framework."
msgstr ""
"Фреймворк модульного тестування :mod:`unittest` спочатку був натхненний "
"JUnit і має подібний смак, як основні фреймворки модульного тестування "
"іншими мовами. Він підтримує автоматизацію тестування, спільне використання "
"коду налаштування та завершення тестів, об’єднання тестів у колекції та "
"незалежність тестів від структури звітування."

msgid ""
"To achieve this, :mod:`unittest` supports some important concepts in an "
"object-oriented way:"
msgstr ""
"Щоб досягти цього, :mod:`unittest` підтримує деякі важливі концепції в "
"об’єктно-орієнтований спосіб:"

msgid "test fixture"
msgstr "тестове пристосування"

msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or "
"more tests, and any associated cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting a "
"server process."
msgstr ""
":dfn:`test fixture` представляє підготовку, необхідну для виконання одного "
"або кількох тестів і будь-яких пов’язаних дій очищення. Це може включати, "
"наприклад, створення тимчасових або проксі-баз даних, каталогів або запуск "
"серверного процесу."

msgid "test case"
msgstr "тестовий випадок"

msgid ""
"A :dfn:`test case` is the individual unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` provides a "
"base class, :class:`TestCase`, which may be used to create new test cases."
msgstr ""
":dfn:`test case` — це окрема одиниця тестування. Він перевіряє конкретну "
"відповідь на певний набір вхідних даних. :mod:`unittest` надає базовий "
"клас, :class:`TestCase`, який можна використовувати для створення нових "
"тестів."

msgid "test suite"
msgstr "набір тестів"

msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both.  It "
"is used to aggregate tests that should be executed together."
msgstr ""
":dfn:`test suite` — це набір тестів, наборів тестів або обох. Він "
"використовується для агрегування тестів, які слід виконувати разом."

msgid "test runner"
msgstr "тестовий бігун"

msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a graphical "
"interface, a textual interface, or return a special value to indicate the "
"results of executing the tests."
msgstr ""
":dfn:`test runner` — це компонент, який керує виконанням тестів і надає "
"результат користувачеві. Виконувач може використовувати графічний інтерфейс, "
"текстовий інтерфейс або повертати спеціальне значення для вказівки "
"результатів виконання тестів."

msgid "Module :mod:`doctest`"
msgstr "Модуль :mod:`doctest`"

msgid "Another test-support module with a very different flavor."
msgstr "Ще один модуль підтримки тестування з зовсім іншим смаком."

msgid ""
"`Simple Smalltalk Testing: With Patterns <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"`Просте тестування Smalltalk: із шаблонами <https://web.archive.org/"
"web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared "
"by :mod:`unittest`."
msgstr ""
"Оригінальна стаття Кента Бека про тестування фреймворків за шаблоном, яким "
"поділився :mod:`unittest`."

msgid "`pytest <https://docs.pytest.org/>`_"
msgstr "`pytest <https://docs.pytest.org/>`_"

msgid ""
"Third-party unittest framework with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""
"Фреймворк модульного тестування третьої сторони зі спрощеним синтаксисом для "
"написання тестів. Наприклад, ``assert func(10) == 42``."

msgid ""
"`The Python Testing Tools Taxonomy <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"
msgstr ""
"`Таксономія інструментів тестування Python <https://wiki.python.org/moin/"
"PythonTestingToolsTaxonomy>`_"

msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr ""
"Широкий список інструментів тестування Python, включаючи фреймворки "
"функціонального тестування та бібліотеки макетів об’єктів."

msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"
msgstr ""
"`Тестування в списку розсилки Python <http://lists.idyll.org/listinfo/"
"testing-in-python>`_"

msgid ""
"A special-interest-group for discussion of testing, and testing tools, in "
"Python."
msgstr ""
"Група спеціальних інтересів для обговорення тестування та інструментів "
"тестування на Python."

msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot <https://buildbot.net/>`_, "
"`Jenkins <https://jenkins.io/>`_, `GitHub Actions <https://github.com/"
"features/actions>`_, or `AppVeyor <https://www.appveyor.com/>`_."
msgstr ""

msgid "Basic example"
msgstr "Базовий приклад"

msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing and "
"running tests.  This section demonstrates that a small subset of the tools "
"suffice to meet the needs of most users."
msgstr ""
"Модуль :mod:`unittest` надає багатий набір інструментів для побудови та "
"виконання тестів. У цьому розділі показано, що невеликого набору "
"інструментів достатньо для задоволення потреб більшості користувачів."

msgid "Here is a short script to test three string methods::"
msgstr "Ось короткий скрипт для перевірки трьох методів рядків:"

msgid ""
"A testcase is created by subclassing :class:`unittest.TestCase`.  The three "
"individual tests are defined with methods whose names start with the letters "
"``test``.  This naming convention informs the test runner about which "
"methods represent tests."
msgstr ""
"Тестовий приклад створюється підкласом :class:`unittest.TestCase`. Три "
"окремі тести визначаються методами, назви яких починаються з літер ``test``. "
"Ця домовленість про найменування інформує виконавця тестів про те, які "
"методи представляють тести."

msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check "
"for an expected result; :meth:`~TestCase.assertTrue` or :meth:`~TestCase."
"assertFalse` to verify a condition; or :meth:`~TestCase.assertRaises` to "
"verify that a specific exception gets raised.  These methods are used "
"instead of the :keyword:`assert` statement so the test runner can accumulate "
"all test results and produce a report."
msgstr ""
"Суть кожного тесту полягає у виклику :meth:`~TestCase.assertEqual` для "
"перевірки очікуваного результату; :meth:`~TestCase.assertTrue` або :meth:"
"`~TestCase.assertFalse` для перевірки умови; або :meth:`~TestCase."
"assertRaises`, щоб перевірити, чи виникає певний виняток. Ці методи "
"використовуються замість оператора :keyword:`assert`, щоб виконавець тесту "
"міг накопичувати всі результати тестування та створювати звіт."

msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow you "
"to define instructions that will be executed before and after each test "
"method. They are covered in more detail in the section :ref:`organizing-"
"tests`."
msgstr ""
"Методи :meth:`~TestCase.setUp` і :meth:`~TestCase.tearDown` дозволяють "
"визначати інструкції, які виконуватимуться до і після кожного методу "
"тестування. Більш детально вони описані в розділі :ref:`organizing-tests`."

msgid ""
"The final block shows a simple way to run the tests. :func:`unittest.main` "
"provides a command-line interface to the test script.  When run from the "
"command line, the above script produces an output that looks like this::"
msgstr ""
"Останній блок показує простий спосіб виконання тестів. :func:`unittest.main` "
"надає інтерфейс командного рядка для тестового сценарію. Під час запуску з "
"командного рядка наведений вище сценарій створює вихідні дані, які "
"виглядають так:"

msgid ""
"Passing the ``-v`` option to your test script will instruct :func:`unittest."
"main` to enable a higher level of verbosity, and produce the following "
"output::"
msgstr ""
"Передача параметра ``-v`` у ваш тестовий сценарій вказує :func:`unittest."
"main` увімкнути вищий рівень докладності та створить такий вихід:"

msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder of "
"the documentation explores the full feature set from first principles."
msgstr ""
"Наведені вище приклади показують найпоширеніші функції :mod:`unittest`, яких "
"достатньо для задоволення багатьох щоденних потреб тестування. У решті "
"документації розглядається повний набір функцій із перших принципів."

msgid ""
"The behavior of returning a value from a test method (other than the default "
"``None`` value), is now deprecated."
msgstr ""

msgid "Command-Line Interface"
msgstr "Інтерфейс командного рядка"

msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr ""
"Модуль unittest можна використовувати з командного рядка для запуску тестів "
"із модулів, класів або навіть окремих методів тестування:"

msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr ""
"Ви можете передати список із будь-якою комбінацією імен модулів і повних "
"імен класів або методів."

msgid "Test modules can be specified by file path as well::"
msgstr "Тестові модулі також можна вказати шляхом до файлу:"

msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path is "
"converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""
"Це дозволяє використовувати завершення назви файлу оболонки для визначення "
"тестового модуля. Зазначений файл усе ще має бути імпортованим як модуль. "
"Шлях перетворюється на назву модуля шляхом видалення \".py\" та перетворення "
"роздільників шляху на \".\". Якщо ви хочете виконати тестовий файл, який не "
"можна імпортувати як модуль, вам слід виконати цей файл безпосередньо."

msgid ""
"You can run tests with more detail (higher verbosity) by passing in the -v "
"flag::"
msgstr ""
"Ви можете запустити тести з більшою деталізацією (вищою детальністю), "
"передавши прапор -v::"

msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is started::"
msgstr ""
"При виконанні без аргументів :ref:`unittest-test-discovery` запускається::"

msgid "For a list of all the command-line options::"
msgstr "Список усіх параметрів командного рядка:"

msgid ""
"In earlier versions it was only possible to run individual test methods and "
"not modules or classes."
msgstr ""
"У попередніх версіях було можливо запускати лише окремі методи тестування, а "
"не модулі чи класи."

msgid "Command-line options"
msgstr "Параметри командного рядка"

msgid ":program:`unittest` supports these command-line options:"
msgstr ":program:`unittest` підтримує такі параметри командного рядка:"

msgid ""
"The standard output and standard error streams are buffered during the test "
"run. Output during a passing test is discarded. Output is echoed normally on "
"test fail or error and is added to the failure messages."
msgstr ""
"Стандартний вихід і стандартні потоки помилок буферизуються під час "
"виконання тесту. Вихідні дані під час проходження тесту відкидаються. "
"Вихідні дані зазвичай відтворюються у разі невдачі тесту або помилки та "
"додаються до повідомлень про помилки."

msgid ""
":kbd:`Control-C` during the test run waits for the current test to end and "
"then reports all the results so far. A second :kbd:`Control-C` raises the "
"normal :exc:`KeyboardInterrupt` exception."
msgstr ""
":kbd:`Control-C` під час тестового запуску чекає завершення поточного тесту, "
"а потім повідомляє всі результати. Другий :kbd:`Control-C` викликає "
"звичайний виняток :exc:`KeyboardInterrupt`."

msgid ""
"See `Signal Handling`_ for the functions that provide this functionality."
msgstr ""
"Перегляньте Обробка сигналів (`Signal Handling`_) для функцій, які "
"забезпечують цю функціональність."

msgid "Stop the test run on the first error or failure."
msgstr "Зупиніть тестовий запуск при першій помилці або невдачі."

msgid ""
"Only run test methods and classes that match the pattern or substring. This "
"option may be used multiple times, in which case all test cases that match "
"any of the given patterns are included."
msgstr ""
"Запускайте лише тестові методи та класи, які відповідають шаблону або "
"підрядку. Цю опцію можна використовувати кілька разів, і в цьому випадку "
"будуть включені всі тестові випадки, які відповідають будь-якому із заданих "
"шаблонів."

msgid ""
"Patterns that contain a wildcard character (``*``) are matched against the "
"test name using :meth:`fnmatch.fnmatchcase`; otherwise simple case-sensitive "
"substring matching is used."
msgstr ""
"Шаблони, які містять символ підстановки (``*``), зіставляються з назвою "
"тесту за допомогою :meth:`fnmatch.fnmatchcase`; інакше використовується "
"просте зіставлення підрядка з урахуванням регістру."

msgid ""
"Patterns are matched against the fully qualified test method name as "
"imported by the test loader."
msgstr ""
"Шаблони зіставляються з повною назвою методу тестування, імпортованою "
"завантажувачем тестів."

msgid ""
"For example, ``-k foo`` matches ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, but not ``bar_tests.FooTest."
"test_something``."
msgstr ""
"Наприклад, ``-k foo`` відповідає ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_something``, але не ``bar_tests.FooTest."
"test_something``."

msgid "Show local variables in tracebacks."
msgstr "Показати локальні змінні в трасуваннях."

msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr "Додано параметри командного рядка ``-b``, ``-c`` і ``-f``."

msgid "The command-line option ``--locals``."
msgstr "Параметр командного рядка ``--locals``."

msgid "The command-line option ``-k``."
msgstr "Параметр командного рядка ``-k``."

msgid ""
"The command line can also be used for test discovery, for running all of the "
"tests in a project or just a subset."
msgstr ""
"Командний рядок також можна використовувати для виявлення тестів, для "
"запуску всіх тестів у проекті або лише підмножини."

msgid "Test Discovery"
msgstr "Тестове відкриття"

msgid ""
"Unittest supports simple test discovery. In order to be compatible with test "
"discovery, all of the test files must be :ref:`modules <tut-modules>` or :"
"ref:`packages <tut-packages>` importable from the top-level directory of the "
"project (this means that their filenames must be valid :ref:`identifiers "
"<identifiers>`)."
msgstr ""

msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can also "
"be used from the command line. The basic command-line usage is::"
msgstr ""
"Виявлення тесту реалізовано в :meth:`TestLoader.discover`, але його також "
"можна використовувати з командного рядка. Основне використання командного "
"рядка:"

msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""
"Як скорочення, ``python -m unittest`` є еквівалентом ``python -m unittest "
"discover``. Якщо ви хочете передати аргументи для перевірки виявлення, "
"підкоманду ``discover`` слід використовувати явно."

msgid "The ``discover`` sub-command has the following options:"
msgstr "Підкоманда ``discover`` має такі параметри:"

msgid "Verbose output"
msgstr "Детальний висновок"

msgid "Directory to start discovery (``.`` default)"
msgstr "Каталог для початку виявлення (``.`` за замовчуванням)"

msgid "Pattern to match test files (``test*.py`` default)"
msgstr ""
"Шаблон для відповідності тестовим файлам (``test*.py`` за замовчуванням)"

msgid "Top level directory of project (defaults to start directory)"
msgstr ""
"Каталог верхнього рівня проекту (за замовчуванням це початковий каталог)"

msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in as "
"positional arguments in that order. The following two command lines are "
"equivalent::"
msgstr ""
"Параметри :option:`-s`, :option:`-p` і :option:`-t` можна передати як "
"позиційні аргументи в такому порядку. Наступні два командні рядки "
"еквівалентні:"

msgid ""
"As well as being a path it is possible to pass a package name, for example "
"``myproject.subpackage.test``, as the start directory. The package name you "
"supply will then be imported and its location on the filesystem will be used "
"as the start directory."
msgstr ""
"Окрім шляху, можна передати назву пакета, наприклад ``myproject.subpackage."
"test``, як початковий каталог. Указане вами ім’я пакета буде імпортовано, а "
"його розташування у файловій системі використовуватиметься як початковий "
"каталог."

msgid ""
"Test discovery loads tests by importing them. Once test discovery has found "
"all the test files from the start directory you specify it turns the paths "
"into package names to import. For example :file:`foo/bar/baz.py` will be "
"imported as ``foo.bar.baz``."
msgstr ""
"Відкриття тестів завантажує тести, імпортуючи їх. Після того як тестове "
"виявлення знайде всі тестові файли з початкового каталогу, який ви вкажете, "
"воно перетворює шляхи на імена пакетів для імпорту. Наприклад, :file:`foo/"
"bar/baz.py` буде імпортовано як ``foo.bar.baz``."

msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the wrong "
"place. If this happens test discovery will warn you and exit."
msgstr ""
"Якщо у вас глобально встановлено пакет, і ви намагаєтеся виявити тест на "
"іншій копії пакета, то імпорт *може* відбутися не з того місця. Якщо це "
"станеться, тестове виявлення попередить вас і вийде."

msgid ""
"If you supply the start directory as a package name rather than a path to a "
"directory then discover assumes that whichever location it imports from is "
"the location you intended, so you will not get the warning."
msgstr ""
"Якщо ви вказуєте початковий каталог як назву пакета, а не як шлях до "
"каталогу, тоді виявлення припускає, що будь-яке місце, з якого він імпортує, "
"є тим розташуванням, яке ви хотіли, тому ви не отримаєте попередження."

msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr ""
"Тестові модулі та пакети можуть налаштувати тестове завантаження та "
"виявлення за допомогою `load_tests protocol`_."

msgid ""
"Test discovery supports :term:`namespace packages <namespace package>` for "
"the start directory. Note that you need to specify the top level directory "
"too (e.g. ``python -m unittest discover -s root/namespace -t root``)."
msgstr ""
"Тестове виявлення підтримує :term:`пакети простору імен <namespace package>` "
"для початкового каталогу. Зауважте, що вам також потрібно вказати каталог "
"верхнього рівня (наприклад, ``python -m unittest discover -s root/namespace -"
"t root``)."

msgid ""
"Python 3.11 dropped the :term:`namespace packages <namespace package>` "
"support. It has been broken since Python 3.7. Start directory and "
"subdirectories containing tests must be regular package that have ``__init__."
"py`` file."
msgstr ""

msgid ""
"Directories containing start directory still can be a namespace package. In "
"this case, you need to specify start directory as dotted package name, and "
"target directory explicitly. For example::"
msgstr ""

msgid "Organizing test code"
msgstr "Організація тестового коду"

msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- single "
"scenarios that must be set up and checked for correctness.  In :mod:"
"`unittest`, test cases are represented by :class:`unittest.TestCase` "
"instances. To make your own test cases you must write subclasses of :class:"
"`TestCase` or use :class:`FunctionTestCase`."
msgstr ""
"Основними будівельними блоками модульного тестування є :dfn:`test cases` --- "
"окремі сценарії, які необхідно налаштувати та перевірити на правильність. У :"
"mod:`unittest` тестові випадки представлені екземплярами :class:`unittest."
"TestCase`. Щоб створити власні тестові випадки, ви повинні написати "
"підкласи :class:`TestCase` або використати :class:`FunctionTestCase`."

msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ""
"Тестовий код екземпляра :class:`TestCase` має бути повністю самостійним, щоб "
"його можна було запускати окремо або в довільній комбінації з будь-якою "
"кількістю інших тестів."

msgid ""
"The simplest :class:`TestCase` subclass will simply implement a test method "
"(i.e. a method whose name starts with ``test``) in order to perform specific "
"testing code::"
msgstr ""
"Найпростіший підклас :class:`TestCase` просто реалізує тестовий метод (тобто "
"метод, назва якого починається з ``test``), щоб виконати певний код "
"тестування:"

msgid ""
"Note that in order to test something, we use one of the :meth:`assert\\*` "
"methods provided by the :class:`TestCase` base class.  If the test fails, an "
"exception will be raised with an explanatory message, and :mod:`unittest` "
"will identify the test case as a :dfn:`failure`.  Any other exceptions will "
"be treated as :dfn:`errors`."
msgstr ""
"Зауважте, що для того, щоб перевірити щось, ми використовуємо один із "
"методів :meth:`assert\\*`, наданих базовим класом :class:`TestCase`. Якщо "
"тест не вдасться, буде створено виняток із пояснювальним повідомленням, і :"
"mod:`unittest` ідентифікує тестовий випадок як :dfn:`failure`. Будь-які інші "
"винятки розглядатимуться як :dfn:`errors`."

msgid ""
"Tests can be numerous, and their set-up can be repetitive.  Luckily, we can "
"factor out set-up code by implementing a method called :meth:`~TestCase."
"setUp`, which the testing framework will automatically call for every single "
"test we run::"
msgstr ""
"Тестів може бути багато, а їх налаштування можуть повторюватися. На щастя, "
"ми можемо виключити код налаштування, реалізувавши метод під назвою :meth:"
"`~TestCase.setUp`, який система тестування автоматично викличе для кожного "
"тесту, який ми виконуємо:"

msgid ""
"The order in which the various tests will be run is determined by sorting "
"the test method names with respect to the built-in ordering for strings."
msgstr ""
"Порядок, у якому виконуватимуться різні тести, визначається сортуванням назв "
"методів тестування відповідно до вбудованого порядку для рядків."

msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test is "
"running, the framework will consider the test to have suffered an error, and "
"the test method will not be executed."
msgstr ""
"Якщо метод :meth:`~TestCase.setUp` викликає виняток під час виконання тесту, "
"фреймворк вважатиме, що тест зазнав помилки, і метод тесту не буде виконано."

msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies up "
"after the test method has been run::"
msgstr ""
"Подібним чином ми можемо надати метод :meth:`~TestCase.tearDown`, який "
"наводить порядок після виконання тестового методу:"

msgid ""
"If :meth:`~TestCase.setUp` succeeded, :meth:`~TestCase.tearDown` will be run "
"whether the test method succeeded or not."
msgstr ""
"Якщо :meth:`~TestCase.setUp` виконано успішно, :meth:`~TestCase.tearDown` "
"буде запущено незалежно від того, чи вдався метод тестування."

msgid ""
"Such a working environment for the testing code is called a :dfn:`test "
"fixture`.  A new TestCase instance is created as a unique test fixture used "
"to execute each individual test method.  Thus :meth:`~TestCase.setUp`, :meth:"
"`~TestCase.tearDown`, and :meth:`~TestCase.__init__` will be called once per "
"test."
msgstr ""
"Таке робоче середовище для коду тестування називається :dfn:`test fixture`. "
"Новий екземпляр TestCase створюється як унікальний тестовий прилад, який "
"використовується для виконання кожного окремого методу тестування. Таким "
"чином, :meth:`~TestCase.setUp`, :meth:`~TestCase.tearDown` і :meth:"
"`~TestCase.__init__` буде викликано один раз на тест."

msgid ""
"It is recommended that you use TestCase implementations to group tests "
"together according to the features they test.  :mod:`unittest` provides a "
"mechanism for this: the :dfn:`test suite`, represented by :mod:`unittest`'s :"
"class:`TestSuite` class.  In most cases, calling :func:`unittest.main` will "
"do the right thing and collect all the module's test cases for you and "
"execute them."
msgstr ""
"Рекомендується використовувати реалізації TestCase для групування тестів "
"відповідно до функцій, які вони тестують. :mod:`unittest` забезпечує "
"механізм для цього: :dfn:`test suite`, представлений :mod:`unittest` класом :"
"class:`TestSuite`. У більшості випадків виклик :func:`unittest.main` зробить "
"правильну річ і збере для вас усі тестові приклади модуля та виконає їх."

msgid ""
"However, should you want to customize the building of your test suite, you "
"can do it yourself::"
msgstr ""
"Однак, якщо ви хочете налаштувати збірку свого набору тестів, ви можете "
"зробити це самостійно:"

msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but there "
"are several advantages to placing the test code in a separate module, such "
"as :file:`test_widget.py`:"
msgstr ""
"Ви можете розмістити визначення тестів і наборів тестів у тих самих модулях, "
"що й код, який вони мають тестувати (наприклад, :file:`widget.py`), але є "
"кілька переваг розміщення тестового коду в окремому модулі, наприклад :file:"
"`test_widget.py`:"

msgid "The test module can be run standalone from the command line."
msgstr "Тестовий модуль можна запускати автономно з командного рядка."

msgid "The test code can more easily be separated from shipped code."
msgstr "Тестовий код можна легше відокремити від надісланого коду."

msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr ""
"Менше спокуси змінити тестовий код, щоб відповідати коду, який він тестує, "
"без вагомої причини."

msgid ""
"Test code should be modified much less frequently than the code it tests."
msgstr "Тестовий код слід змінювати набагато рідше, ніж код, який він тестує."

msgid "Tested code can be refactored more easily."
msgstr "Перевірений код можна легше рефакторингувати."

msgid ""
"Tests for modules written in C must be in separate modules anyway, so why "
"not be consistent?"
msgstr ""
"Тести для модулів, написаних мовою C, у будь-якому разі повинні бути "
"окремими модулями, то чому б не бути послідовними?"

msgid ""
"If the testing strategy changes, there is no need to change the source code."
msgstr ""
"Якщо стратегія тестування змінюється, немає необхідності змінювати вихідний "
"код."

msgid "Re-using old test code"
msgstr "Повторне використання старого тестового коду"

msgid ""
"Some users will find that they have existing test code that they would like "
"to run from :mod:`unittest`, without converting every old test function to "
"a :class:`TestCase` subclass."
msgstr ""
"Деякі користувачі виявлять, що у них є тестовий код, який вони хотіли б "
"запустити з :mod:`unittest`, не перетворюючи кожну стару тестову функцію на "
"підклас :class:`TestCase`."

msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` class. "
"This subclass of :class:`TestCase` can be used to wrap an existing test "
"function.  Set-up and tear-down functions can also be provided."
msgstr ""
"З цієї причини :mod:`unittest` надає клас :class:`FunctionTestCase`. Цей "
"підклас :class:`TestCase` можна використовувати для обгортання існуючої "
"тестової функції. Також можуть бути передбачені функції налаштування та "
"демонтажу."

msgid "Given the following test function::"
msgstr "Дано таку тестову функцію:"

msgid ""
"one can create an equivalent test case instance as follows, with optional "
"set-up and tear-down methods::"
msgstr ""
"можна створити еквівалентний екземпляр тестового сценарію наступним чином із "
"додатковими методами налаштування та демонтажу:"

msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this approach "
"is not recommended.  Taking the time to set up proper :class:`TestCase` "
"subclasses will make future test refactorings infinitely easier."
msgstr ""
"Незважаючи на те, що :class:`FunctionTestCase` можна використовувати для "
"швидкого перетворення наявної тестової бази на систему на основі :mod:"
"`unittest`\\, цей підхід не рекомендується. Витративши час на налаштування "
"належних підкласів :class:`TestCase`, ви значно спростите рефакторинг "
"майбутніх тестів."

msgid ""
"In some cases, the existing tests may have been written using the :mod:"
"`doctest` module.  If so, :mod:`doctest` provides a :class:`DocTestSuite` "
"class that can automatically build :class:`unittest.TestSuite` instances "
"from the existing :mod:`doctest`\\ -based tests."
msgstr ""
"У деяких випадках існуючі тести могли бути написані за допомогою модуля :mod:"
"`doctest`. Якщо так, :mod:`doctest` надає клас :class:`DocTestSuite`, який "
"може автоматично створювати екземпляри :class:`unittest.TestSuite` з "
"існуючих тестів на основі :mod:`doctest`\\."

msgid "Skipping tests and expected failures"
msgstr "Пропуск тестів і очікувані невдачі"

msgid ""
"Unittest supports skipping individual test methods and even whole classes of "
"tests.  In addition, it supports marking a test as an \"expected failure,\" "
"a test that is broken and will fail, but shouldn't be counted as a failure "
"on a :class:`TestResult`."
msgstr ""
"Unittest підтримує пропуски окремих методів тестування і навіть цілих класів "
"тестів. Крім того, він підтримує позначення тесту як \"очікуваної помилки\", "
"тобто тесту, який зламано і буде невдалим, але його не слід вважати помилкою "
"в :class:`TestResult`."

msgid ""
"Skipping a test is simply a matter of using the :func:`skip` :term:"
"`decorator` or one of its conditional variants, calling :meth:`TestCase."
"skipTest` within a :meth:`~TestCase.setUp` or test method, or raising :exc:"
"`SkipTest` directly."
msgstr ""
"Пропуск тесту – це просто використання :func:`skip` :term:`decorator` або "
"одного з його умовних варіантів, виклик :meth:`TestCase.skipTest` у :meth:"
"`~TestCase.setUp` або тестовий метод або безпосередньо підняти :exc:"
"`SkipTest`."

msgid "Basic skipping looks like this::"
msgstr "Базовий пропуск виглядає так::"

msgid "This is the output of running the example above in verbose mode::"
msgstr "Це результат виконання наведеного вище прикладу в докладному режимі:"

msgid "Classes can be skipped just like methods::"
msgstr "Класи можна пропускати, як і методи:"

msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ""
":meth:`TestCase.setUp` також може пропустити тест. Це корисно, коли ресурс, "
"який потрібно налаштувати, недоступний."

msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr "Очікувані помилки використовують декоратор :func:`expectedFailure`. ::"

msgid ""
"It's easy to roll your own skipping decorators by making a decorator that "
"calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain attribute::"
msgstr ""
"Легко запустити власні декоратори пропуску, створивши декоратор, який "
"викликає :func:`skip` у тесті, коли хоче, щоб його було пропущено. Цей "
"декоратор пропускає перевірку, якщо переданий об’єкт не має певного "
"атрибута::"

msgid ""
"The following decorators and exception implement test skipping and expected "
"failures:"
msgstr ""
"Наступні декоратори та винятки реалізують пропуск тесту та очікувані помилки:"

msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why the "
"test is being skipped."
msgstr ""
"Беззастережно пропустіть оформлений тест. *причина* має описувати, чому тест "
"пропускається."

msgid "Skip the decorated test if *condition* is true."
msgstr "Пропустіть декорований тест, якщо *умова* істинна."

msgid "Skip the decorated test unless *condition* is true."
msgstr "Пропустіть оформлений тест, якщо *умова* не виконується."

msgid ""
"Mark the test as an expected failure or error.  If the test fails or errors "
"in the test function itself (rather than in one of the :dfn:`test fixture` "
"methods) then it will be considered a success.  If the test passes, it will "
"be considered a failure."
msgstr ""
"Позначте тест як очікувану невдачу або помилку. Якщо тест зазнає невдачі або "
"помилки в самій тестовій функції (а не в одному з методів :dfn:`test "
"fixture`), тоді він вважатиметься успішним. Якщо тест буде пройдений, він "
"буде вважатися невдалим."

msgid "This exception is raised to skip a test."
msgstr "Цей виняток створюється, щоб пропустити тест."

msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr ""
"Зазвичай ви можете використовувати :meth:`TestCase.skipTest` або один із "
"декораторів пропуску замість того, щоб піднімати це безпосередньо."

msgid ""
"Skipped tests will not have :meth:`~TestCase.setUp` or :meth:`~TestCase."
"tearDown` run around them. Skipped classes will not have :meth:`~TestCase."
"setUpClass` or :meth:`~TestCase.tearDownClass` run. Skipped modules will not "
"have :func:`setUpModule` or :func:`tearDownModule` run."
msgstr ""
"Пропущені тести не запускатимуть :meth:`~TestCase.setUp` або :meth:"
"`~TestCase.tearDown`. Пропущені класи не виконуватимуться :meth:`~TestCase."
"setUpClass` або :meth:`~TestCase.tearDownClass`. Пропущені модулі не "
"запускатимуть :func:`setUpModule` або :func:`tearDownModule`."

msgid "Distinguishing test iterations using subtests"
msgstr "Розрізнення тестових ітерацій за допомогою субтестів"

msgid ""
"When there are very small differences among your tests, for instance some "
"parameters, unittest allows you to distinguish them inside the body of a "
"test method using the :meth:`~TestCase.subTest` context manager."
msgstr ""
"Якщо між вашими тестами є дуже невеликі відмінності, наприклад деякі "
"параметри, unittest дозволяє розрізняти їх у тілі тестового методу за "
"допомогою контекстного менеджера :meth:`~TestCase.subTest`."

msgid "For example, the following test::"
msgstr "Наприклад, такий тест:"

msgid "will produce the following output::"
msgstr "виведе наступний вихід:"

msgid ""
"Without using a subtest, execution would stop after the first failure, and "
"the error would be less easy to diagnose because the value of ``i`` wouldn't "
"be displayed::"
msgstr ""
"Без використання підтесту виконання зупинилося б після першої помилки, а "
"помилку було б важче діагностувати, оскільки значення ``i`` не відображалося "
"б::"

msgid "Classes and functions"
msgstr "Класи та функції"

msgid "This section describes in depth the API of :mod:`unittest`."
msgstr "У цьому розділі докладно описано API :mod:`unittest`."

msgid "Test cases"
msgstr "Тестові випадки"

msgid ""
"Instances of the :class:`TestCase` class represent the logical test units in "
"the :mod:`unittest` universe.  This class is intended to be used as a base "
"class, with specific tests being implemented by concrete subclasses.  This "
"class implements the interface needed by the test runner to allow it to "
"drive the tests, and methods that the test code can use to check for and "
"report various kinds of failure."
msgstr ""
"Екземпляри класу :class:`TestCase` представляють логічні тестові одиниці у "
"всесвіті :mod:`unittest`. Цей клас призначений для використання в якості "
"базового класу з конкретними тестами, реалізованими конкретними підкласами. "
"Цей клас реалізує інтерфейс, необхідний виконавцю тестів, щоб дозволити йому "
"керувати тестами, і методи, які тестовий код може використовувати для "
"перевірки та звітування про різні види помилок."

msgid ""
"Each instance of :class:`TestCase` will run a single base method: the method "
"named *methodName*. In most uses of :class:`TestCase`, you will neither "
"change the *methodName* nor reimplement the default ``runTest()`` method."
msgstr ""
"Кожен екземпляр :class:`TestCase` запускатиме один базовий метод: метод під "
"назвою *methodName*. У більшості випадків використання :class:`TestCase` ви "
"не змінюєте *methodName* і не реалізуєте метод за замовчуванням "
"``runTest()``."

msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"*methodName*. This makes it easier to experiment with :class:`TestCase` from "
"the interactive interpreter."
msgstr ""
":class:`TestCase` можна успішно створити без надання *methodName*. Це "
"полегшує експерименти з :class:`TestCase` з інтерактивного інтерпретатора."

msgid ""
":class:`TestCase` instances provide three groups of methods: one group used "
"to run the test, another used by the test implementation to check conditions "
"and report failures, and some inquiry methods allowing information about the "
"test itself to be gathered."
msgstr ""
"Екземпляри :class:`TestCase` забезпечують три групи методів: одна група "
"використовується для запуску тесту, інша використовується реалізацією тесту "
"для перевірки умов і звітування про помилки, а також деякі методи запиту, "
"які дозволяють збирати інформацію про сам тест."

msgid "Methods in the first group (running the test) are:"
msgstr "Методи першої групи (проведення тесту) це:"

msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or :exc:"
"`SkipTest`, any exception raised by this method will be considered an error "
"rather than a test failure. The default implementation does nothing."
msgstr ""
"Метод, який називається для підготовки випробувального матеріалу. Це "
"викликається безпосередньо перед викликом тестового методу; крім :exc:"
"`AssertionError` або :exc:`SkipTest`, будь-який виняток, викликаний цим "
"методом, вважатиметься помилкою, а не помилкою тесту. Стандартна реалізація "
"нічого не робить."

msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be particularly "
"careful about checking internal state.  Any exception, other than :exc:"
"`AssertionError` or :exc:`SkipTest`, raised by this method will be "
"considered an additional error rather than a test failure (thus increasing "
"the total number of reported errors). This method will only be called if "
"the :meth:`setUp` succeeds, regardless of the outcome of the test method. "
"The default implementation does nothing."
msgstr ""
"Метод викликається відразу після виклику тестового методу та запису "
"результату. Це викликається, навіть якщо метод тестування викликав виняток, "
"тому реалізація в підкласах може потребувати особливої обережності щодо "
"перевірки внутрішнього стану. Будь-які винятки, окрім :exc:`AssertionError` "
"або :exc:`SkipTest`, викликані цим методом, вважатимуться додатковою "
"помилкою, а не помилкою тесту (таким чином збільшуючи загальну кількість "
"повідомлених помилок). Цей метод буде викликано, лише якщо :meth:`setUp` "
"завершиться успішно, незалежно від результату тестового методу. Стандартна "
"реалізація нічого не робить."

msgid ""
"A class method called before tests in an individual class are run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""
"Метод класу, який викликається перед виконанням тестів в окремому класі. "
"``setUpClass`` викликається з класом як єдиним аргументом і має бути "
"оформлений як :func:`classmethod`::"

msgid "See `Class and Module Fixtures`_ for more details."
msgstr "Додаткову інформацію див. у розділі `Class and Module Fixtures`_."

msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must be "
"decorated as a :meth:`classmethod`::"
msgstr ""
"Метод класу, який викликається після виконання тестів в окремому класі. "
"``tearDownClass`` викликається з класом як єдиним аргументом і має бути "
"оформлений як :meth:`classmethod`::"

msgid ""
"Run the test, collecting the result into the :class:`TestResult` object "
"passed as *result*.  If *result* is omitted or ``None``, a temporary result "
"object is created (by calling the :meth:`defaultTestResult` method) and "
"used. The result object is returned to :meth:`run`'s caller."
msgstr ""
"Запустіть тест, зібравши результат в об’єкт :class:`TestResult`, переданий "
"як *result*. Якщо *результат* пропущено або ``None``, створюється та "
"використовується тимчасовий об’єкт результату (викликом методу :meth:"
"`defaultTestResult`). Об’єкт результату повертається до виклику :meth:`run`."

msgid ""
"The same effect may be had by simply calling the :class:`TestCase` instance."
msgstr ""
"Такого ж ефекту можна отримати, просто викликавши екземпляр :class:"
"`TestCase`."

msgid ""
"Previous versions of ``run`` did not return the result. Neither did calling "
"an instance."
msgstr ""
"Попередні версії ``run`` не повертали результат. Також не викликав інстанції."

msgid ""
"Calling this during a test method or :meth:`setUp` skips the current test.  "
"See :ref:`unittest-skipping` for more information."
msgstr ""
"Виклик цього під час тестового методу або :meth:`setUp` пропускає поточний "
"тест. Перегляньте :ref:`unittest-skipping` для отримання додаткової "
"інформації."

msgid ""
"Return a context manager which executes the enclosed code block as a "
"subtest.  *msg* and *params* are optional, arbitrary values which are "
"displayed whenever a subtest fails, allowing you to identify them clearly."
msgstr ""
"Повертає контекстний менеджер, який виконує вкладений блок коду як підтест. "
"*msg* і *params* є необов’язковими, довільними значеннями, які "
"відображаються щоразу, коли субтест проходить невдало, що дозволяє їх чітко "
"ідентифікувати."

msgid ""
"A test case can contain any number of subtest declarations, and they can be "
"arbitrarily nested."
msgstr ""
"Тестовий приклад може містити будь-яку кількість оголошень субтесту, і вони "
"можуть бути довільно вкладеними."

msgid "See :ref:`subtests` for more information."
msgstr "Перегляньте :ref:`subtests` для отримання додаткової інформації."

msgid ""
"Run the test without collecting the result.  This allows exceptions raised "
"by the test to be propagated to the caller, and can be used to support "
"running tests under a debugger."
msgstr ""
"Виконайте тест без отримання результату. Це дозволяє поширювати винятки, "
"викликані тестом, до викликаючого, і може бути використано для підтримки "
"запуску тестів під налагоджувачем."

msgid ""
"The :class:`TestCase` class provides several assert methods to check for and "
"report failures.  The following table lists the most commonly used methods "
"(see the tables below for more assert methods):"
msgstr ""
"Клас :class:`TestCase` надає кілька методів підтвердження для перевірки "
"помилок і звітування про них. У наведеній нижче таблиці перераховано "
"найпоширеніші методи (перегляньте таблиці нижче, щоб отримати більше методів "
"підтвердження):"

msgid "Method"
msgstr "метод"

msgid "Checks that"
msgstr "Перевіряє це"

msgid "New in"
msgstr "Нове в"

msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

msgid "``a == b``"
msgstr "``a == b``"

msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

msgid "``a != b``"
msgstr "``a != b``"

msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

msgid "``bool(x) is True``"
msgstr "``bool(x) має значення True``"

msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

msgid "``bool(x) is False``"
msgstr "``bool(x) є False``"

msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

msgid "``a is b``"
msgstr "``a є b``"

msgid "3.1"
msgstr "3.1"

msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

msgid "``a is not b``"
msgstr "``a не є b``"

msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

msgid "``x is None``"
msgstr "``x не має значення``"

msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

msgid "``x is not None``"
msgstr "``x не є None``"

msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ":meth:`assertIn(a, b) <TestCase.assertIn>`"

msgid "``a in b``"
msgstr "``a в b``"

msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"

msgid "``a not in b``"
msgstr "``a не в b``"

msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"

msgid "``isinstance(a, b)``"
msgstr "``isinstance(a, b)``"

msgid "3.2"
msgstr "3.2"

msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"

msgid "``not isinstance(a, b)``"
msgstr "``не екземпляр(a, b)``"

msgid ""
"All the assert methods accept a *msg* argument that, if specified, is used "
"as the error message on failure (see also :data:`longMessage`). Note that "
"the *msg* keyword argument can be passed to :meth:`assertRaises`, :meth:"
"`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` only when "
"they are used as a context manager."
msgstr ""
"Усі методи assert приймають аргумент *msg*, який, якщо вказано, "
"використовується як повідомлення про помилку у разі помилки (див. також :"
"data:`longMessage`). Зауважте, що аргумент ключового слова *msg* можна "
"передати до :meth:`assertRaises`, :meth:`assertRaisesRegex`, :meth:"
"`assertWarns`, :meth:`assertWarnsRegex` лише тоді, коли вони "
"використовуються як менеджер контексту."

msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr ""
"Перевірте, що *перше* і *друге* рівні. Якщо порівняльні значення не "
"однакові, тест буде невдалим."

msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""
"Крім того, якщо *first* і *second* мають той самий тип і один із list, "
"tuple, dict, set, frozenset або str або будь-який тип, який підклас реєструє "
"за допомогою :meth:`addTypeEqualityFunc`, специфічна для типу функція "
"рівності буде викликано, щоб створити більш корисне повідомлення про помилку "
"за замовчуванням (див. також :ref:`список специфічних для типу методів <type-"
"specific-methods>`)."

msgid "Added the automatic calling of type-specific equality function."
msgstr "Додано автоматичний виклик функції рівності для певного типу."

msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function for "
"comparing strings."
msgstr ""
":meth:`assertMultiLineEqual` додано як функцію рівності типів за умовчанням "
"для порівняння рядків."

msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr ""
"Перевірте, що *перше* і *друге* не рівні. Якщо порівняльні значення "
"однакові, тест буде невдалим."

msgid "Test that *expr* is true (or false)."
msgstr "Перевірте, що *expr* є істинним (або хибним)."

msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr is "
"True`` (use ``assertIs(expr, True)`` for the latter).  This method should "
"also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""
"Зауважте, що це еквівалентно ``bool(expr) is True``, а не ``expr is True`` "
"(використовуйте ``assertIs(expr, True)`` для останнього). Також слід уникати "
"цього методу, якщо доступні більш специфічні методи (наприклад, "
"``assertEqual(a, b)`` замість ``assertTrue(a == b)``), тому що вони надають "
"краще повідомлення про помилку в разі невдачі ."

msgid "Test that *first* and *second* are (or are not) the same object."
msgstr "Перевірте, чи *перший* і *другий* є (чи не є) одним і тим же об’єктом."

msgid "Test that *expr* is (or is not) ``None``."
msgstr "Перевірте, що *expr* є (чи не є) ``None``."

msgid "Test that *member* is (or is not) in *container*."
msgstr "Перевірте, чи *член* є (чи ні) у *контейнері*."

msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class or "
"a tuple of classes, as supported by :func:`isinstance`). To check for the "
"exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""
"Перевірте, що *obj* є (або не є) екземпляром *cls* (який може бути класом "
"або кортежем класів, як підтримується :func:`isinstance`). Щоб перевірити "
"точний тип, використовуйте :func:`assertIs(type(obj), cls) <assertIs>`."

msgid ""
"It is also possible to check the production of exceptions, warnings, and log "
"messages using the following methods:"
msgstr ""
"Також можна перевірити створення винятків, попереджень і повідомлень журналу "
"за допомогою таких методів:"

msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"

msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr "``fun(*args, **kwds)`` підвищує *exc*"

msgid ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"
msgstr ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) <TestCase."
"assertRaisesRegex>`"

msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` викликає *exc* і повідомлення відповідає регулярному "
"виразу *r*"

msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"

msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr "``fun(*args, **kwds)`` викликає *попередження*"

msgid ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"
msgstr ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) <TestCase."
"assertWarnsRegex>`"

msgid "``fun(*args, **kwds)`` raises *warn* and the message matches regex *r*"
msgstr ""
"``fun(*args, **kwds)`` викликає *warn* і повідомлення відповідає регулярному "
"виразу *r*"

msgid ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"
msgstr ":meth:`assertLogs(реєстратор, рівень) <TestCase.assertLogs>`"

msgid "The ``with`` block logs on *logger* with minimum *level*"
msgstr "Блок ``with`` реєструє *реєстратор* з мінімальним *рівнем*"

msgid "3.4"
msgstr "3.4"

msgid ":meth:`assertNoLogs(logger, level) <TestCase.assertNoLogs>`"
msgstr ":meth:`assertNoLogs(реєстратор, рівень) <TestCase.assertNoLogs>`"

msgid "The ``with`` block does not log on"
msgstr "Блок ``with`` не входить в систему"

msgid "*logger* with minimum *level*"
msgstr "*логгер* з мінімальним *рівнем*"

msgid "3.10"
msgstr "3.10"

msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertRaises`.  The test passes if *exception* is raised, is an error if "
"another exception is raised, or fails if no exception is raised. To catch "
"any of a group of exceptions, a tuple containing the exception classes may "
"be passed as *exception*."
msgstr ""
"Перевірте, чи виникає виняток, коли *callable* викликається з будь-якими "
"позиційними або ключовими аргументами, які також передаються в :meth:"
"`assertRaises`. Перевірка проходить, якщо виникає *виняток*, вважається "
"помилкою, якщо викликається інший виняток, або не виконується, якщо винятку "
"не виникає. Щоб перехопити будь-яку групу винятків, кортеж, що містить класи "
"винятків, можна передати як *виняток*."

msgid ""
"If only the *exception* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Якщо подано лише аргументи *exception* і, можливо, *msg*, поверніть "
"диспетчер контексту, щоб тестований код можна було записати вбудовано, а не "
"як функцію::"

msgid ""
"When used as a context manager, :meth:`assertRaises` accepts the additional "
"keyword argument *msg*."
msgstr ""
"У разі використання як менеджера контексту :meth:`assertRaises` приймає "
"додатковий аргумент ключового слова *msg*."

msgid ""
"The context manager will store the caught exception object in its :attr:"
"`exception` attribute.  This can be useful if the intention is to perform "
"additional checks on the exception raised::"
msgstr ""
"Менеджер контексту збереже спійманий об’єкт винятку в своєму атрибуті :attr:"
"`exception`. Це може бути корисним, якщо планується виконати додаткові "
"перевірки викликаного винятку:"

msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ""
"Додано можливість використовувати :meth:`assertRaises` як контекстний "
"менеджер."

msgid "Added the :attr:`exception` attribute."
msgstr "Додано атрибут :attr:`exception`."

msgid "Added the *msg* keyword argument when used as a context manager."
msgstr ""
"Додано аргумент ключового слова *msg*, коли він використовується як менеджер "
"контексту."

msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the string "
"representation of the raised exception.  *regex* may be a regular expression "
"object or a string containing a regular expression suitable for use by :func:"
"`re.search`.  Examples::"
msgstr ""
"Подібно до :meth:`assertRaises`, але також перевіряє, що *regex* відповідає "
"рядковому представленню викликаного винятку. *regex* може бути об’єктом "
"регулярного виразу або рядком, що містить регулярний вираз, придатний для "
"використання :func:`re.search`. Приклади::"

msgid "or::"
msgstr "або::"

msgid "Added under the name ``assertRaisesRegexp``."
msgstr "Додано під назвою ``assertRaisesRegexp``."

msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr "Перейменовано на :meth:`assertRaisesRegex`."

msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to :meth:"
"`assertWarns`.  The test passes if *warning* is triggered and fails if it "
"isn't.  Any exception is an error. To catch any of a group of warnings, a "
"tuple containing the warning classes may be passed as *warnings*."
msgstr ""
"Перевірте, чи спрацьовує попередження, коли *callable* викликається з будь-"
"якими позиційними або ключовими аргументами, які також передаються до :meth:"
"`assertWarns`. Тест проходить, якщо спрацьовує *попередження*, і не "
"виконується, якщо ні. Будь-який виняток є помилкою. Щоб перехопити будь-яку "
"групу попереджень, кортеж, що містить класи попереджень, можна передати як "
"*попередження*."

msgid ""
"If only the *warning* and possibly the *msg* arguments are given, return a "
"context manager so that the code under test can be written inline rather "
"than as a function::"
msgstr ""
"Якщо надано лише аргументи *попередження* і, можливо, *повідомлення*, "
"поверніть диспетчер контексту, щоб тестований код можна було записати "
"вбудовано, а не як функцію::"

msgid ""
"When used as a context manager, :meth:`assertWarns` accepts the additional "
"keyword argument *msg*."
msgstr ""
"У разі використання як менеджера контексту :meth:`assertWarns` приймає "
"додатковий аргумент ключового слова *msg*."

msgid ""
"The context manager will store the caught warning object in its :attr:"
"`warning` attribute, and the source line which triggered the warnings in "
"the :attr:`filename` and :attr:`lineno` attributes. This can be useful if "
"the intention is to perform additional checks on the warning caught::"
msgstr ""
"Менеджер контексту збереже спійманий об’єкт попередження в атрибуті :attr:"
"`warning`, а вихідний рядок, який викликав попередження, в атрибутах :attr:"
"`filename` і :attr:`lineno`. Це може бути корисним, якщо планується виконати "
"додаткові перевірки виявленого попередження:"

msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr ""
"Цей метод працює незалежно від фільтрів попереджень під час його виклику."

msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the message "
"of the triggered warning.  *regex* may be a regular expression object or a "
"string containing a regular expression suitable for use by :func:`re."
"search`.  Example::"
msgstr ""
"Подібно до :meth:`assertWarns`, але також перевіряє відповідність *regex* у "
"повідомленні викликаного попередження. *regex* може бути об’єктом "
"регулярного виразу або рядком, що містить регулярний вираз, придатний для "
"використання :func:`re.search`. Приклад::"

msgid ""
"A context manager to test that at least one message is logged on the "
"*logger* or one of its children, with at least the given *level*."
msgstr ""
"Менеджер контексту для перевірки того, що принаймні одне повідомлення "
"зареєстровано в *реєстраторі* або одному з його дочірніх елементів, "
"принаймні з заданим *рівнем*."

msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages that were not blocked by a non-propagating "
"descendent logger."
msgstr ""
"Якщо задано, *logger* має бути об’єктом :class:`logging.Logger` або :class:"
"`str`, що вказує назву реєстратора. За замовчуванням використовується "
"кореневий реєстратор, який фіксуватиме всі повідомлення, які не були "
"заблоковані нащадковим реєстратором без розповсюдження."

msgid ""
"If given, *level* should be either a numeric logging level or its string "
"equivalent (for example either ``\"ERROR\"`` or :attr:`logging.ERROR`).  The "
"default is :attr:`logging.INFO`."
msgstr ""
"Якщо задано, *level* має бути або числовим рівнем журналювання, або його "
"еквівалентом у рядку (наприклад, ``\"ERROR\"`` або :attr:`logging.ERROR`). "
"Типовим є :attr:`logging.INFO`."

msgid ""
"The test passes if at least one message emitted inside the ``with`` block "
"matches the *logger* and *level* conditions, otherwise it fails."
msgstr ""
"Тест проходить, якщо принаймні одне повідомлення, видане всередині блоку "
"``with``, відповідає умовам *logger* і *level*, в іншому випадку він не "
"виконується."

msgid ""
"The object returned by the context manager is a recording helper which keeps "
"tracks of the matching log messages.  It has two attributes:"
msgstr ""
"Об’єкт, який повертає менеджер контексту, є помічником запису, який "
"відстежує відповідні повідомлення журналу. Він має два атрибути:"

msgid ""
"A list of :class:`logging.LogRecord` objects of the matching log messages."
msgstr ""
"Список об’єктів :class:`logging.LogRecord` відповідних повідомлень журналу."

msgid ""
"A list of :class:`str` objects with the formatted output of matching "
"messages."
msgstr ""
"Список об’єктів :class:`str` із відформатованим виведенням відповідних "
"повідомлень."

msgid "Example::"
msgstr "Приклад::"

msgid ""
"A context manager to test that no messages are logged on the *logger* or one "
"of its children, with at least the given *level*."
msgstr ""
"Менеджер контексту для перевірки того, що жодні повідомлення не реєструються "
"в *реєстраторі* або одному з його дочірніх елементів, принаймні з заданим "
"*рівнем*."

msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a :class:"
"`str` giving the name of a logger.  The default is the root logger, which "
"will catch all messages."
msgstr ""
"Якщо задано, *logger* має бути об’єктом :class:`logging.Logger` або :class:"
"`str`, що вказує назву реєстратора. Типовим є кореневий реєстратор, який "
"фіксуватиме всі повідомлення."

msgid ""
"Unlike :meth:`assertLogs`, nothing will be returned by the context manager."
msgstr ""
"На відміну від :meth:`assertLogs`, контекстний менеджер нічого не "
"повертатиме."

msgid ""
"There are also other methods used to perform more specific checks, such as:"
msgstr ""
"Існують також інші методи, які використовуються для виконання більш "
"конкретних перевірок, наприклад:"

msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"

msgid "``round(a-b, 7) == 0``"
msgstr "``round(a-b, 7) == 0``"

msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"

msgid "``round(a-b, 7) != 0``"
msgstr "``округлення(a-b, 7) != 0``"

msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"

msgid "``a > b``"
msgstr "``a > b``"

msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"

msgid "``a >= b``"
msgstr "``a >= b``"

msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ":meth:`assertLess(a, b) <TestCase.assertLess>`"

msgid "``a < b``"
msgstr "``a < b``"

msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"

msgid "``a <= b``"
msgstr "``a <= b``"

msgid ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"
msgstr ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"

msgid "``r.search(s)``"
msgstr "``r.search(s)``"

msgid ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"
msgstr ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"

msgid "``not r.search(s)``"
msgstr "``не r.search(s)``"

msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"

msgid ""
"*a* and *b* have the same elements in the same number, regardless of their "
"order."
msgstr ""
"*a* і *b* містять однакові елементи в однаковій кількості, незалежно від їх "
"порядку."

msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of decimal "
"*places* (default 7), and comparing to zero.  Note that these methods round "
"the values to the given number of *decimal places* (i.e. like the :func:"
"`round` function) and not *significant digits*."
msgstr ""
"Перевірте, що *перший* і *другий* приблизно (чи не приблизно) рівні, "
"обчислюючи різницю, округляючи до вказаної кількості десяткових *розрядів* "
"(за замовчуванням 7) і порівнюючи з нулем. Зауважте, що ці методи округлюють "
"значення до заданої кількості *десяткових знаків* (тобто як функція :func:"
"`round`), а не до *значущих цифр*."

msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""
"Якщо замість *розрядів* вказано *delta*, тоді різниця між *першим* і "
"*другим* має бути менше або дорівнювати (або більше) *delta*."

msgid "Supplying both *delta* and *places* raises a :exc:`TypeError`."
msgstr "Надання *delta* і *places* викликає :exc:`TypeError`."

msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects that "
"compare equal.  :meth:`assertNotAlmostEqual` automatically fails if the "
"objects compare equal.  Added the *delta* keyword argument."
msgstr ""
":meth:`assertAlmostEqual` автоматично вважає майже рівні об’єкти, які "
"порівнюються рівними. :meth:`assertNotAlmostEqual` автоматично не "
"виконується, якщо об’єкти порівнюються. Додано аргумент ключового слова "
"*дельта*."

msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending on "
"the method name.  If not, the test will fail::"
msgstr ""
"Перевірте, що *first* відповідно >, >=, < або <= ніж *second* залежно від "
"назви методу. Якщо ні, тест не пройде:"

msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case of "
"failure, the error message will include the pattern and the *text* (or the "
"pattern and the part of *text* that unexpectedly matched).  *regex* may be a "
"regular expression object or a string containing a regular expression "
"suitable for use by :func:`re.search`."
msgstr ""
"Перевірте, чи *регулярний вираз* пошуку відповідає (або не відповідає) "
"*тексту*. У разі помилки повідомлення про помилку міститиме шаблон і *текст* "
"(або шаблон і частину *тексту*, які неочікувано збіглися). *regex* може бути "
"об’єктом регулярного виразу або рядком, що містить регулярний вираз, "
"придатний для використання :func:`re.search`."

msgid "Added under the name ``assertRegexpMatches``."
msgstr "Додано під назвою ``assertRegexpMatches``."

msgid ""
"The method ``assertRegexpMatches()`` has been renamed to :meth:`."
"assertRegex`."
msgstr ""
"Метод ``assertRegexpMatches()`` було перейменовано на :meth:`.assertRegex`."

msgid ":meth:`.assertNotRegex`."
msgstr ":meth:`.assertNotRegex`."

msgid ""
"The name ``assertNotRegexpMatches`` is a deprecated alias for :meth:`."
"assertNotRegex`."
msgstr ""
"Назва ``assertNotRegexpMatches`` є застарілим псевдонімом для :meth:`."
"assertNotRegex`."

msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""
"Перевірте, чи послідовність *first* містить ті самі елементи, що й *second*, "
"незалежно від їх порядку. Якщо цього не зробити, буде згенеровано "
"повідомлення про помилку з переліком відмінностей між послідовностями."

msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*. It "
"verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), Counter(list(second)))`` "
"but works with sequences of unhashable objects as well."
msgstr ""
"Повторювані елементи *не* ігноруються під час порівняння *першого* та "
"*другого*. Він перевіряє, чи кожен елемент має однакову кількість в обох "
"послідовностях. Еквівалент: ``assertEqual(Counter(list(first)), "
"Counter(list(second)))``, але також працює з послідовностями нехешованих "
"об’єктів."

msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects of "
"the same type to different type-specific methods.  These methods are already "
"implemented for most of the built-in types, but it's also possible to "
"register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""
"Метод :meth:`assertEqual` надсилає перевірку рівності для об’єктів одного "
"типу до різних методів, що залежать від типу. Ці методи вже реалізовано для "
"більшості вбудованих типів, але також можна зареєструвати нові методи за "
"допомогою :meth:`addTypeEqualityFunc`:"

msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check if "
"two objects of exactly the same *typeobj* (not subclasses) compare equal.  "
"*function* must take two positional arguments and a third msg=None keyword "
"argument just as :meth:`assertEqual` does.  It must raise :data:`self."
"failureException(msg) <failureException>` when inequality between the first "
"two parameters is detected -- possibly providing useful information and "
"explaining the inequalities in details in the error message."
msgstr ""
"Реєструє специфічний для типу метод, викликаний :meth:`assertEqual`, щоб "
"перевірити, чи порівнюються два об’єкти абсолютно однакового *typeobj* (не "
"підкласи). *функція* має приймати два позиційних аргументи та третій "
"аргумент ключового слова msg=None так само, як це робить :meth:"
"`assertEqual`. Він повинен викликати :data:`self.failureException(msg) "
"<failureException>`, коли виявлено нерівність між першими двома параметрами "
"— можливо, надаючи корисну інформацію та докладно пояснюючи нерівності в "
"повідомленні про помилку."

msgid ""
"The list of type-specific methods automatically used by :meth:`~TestCase."
"assertEqual` are summarized in the following table.  Note that it's usually "
"not necessary to invoke these methods directly."
msgstr ""
"Список специфічних для типу методів, які автоматично використовує :meth:"
"`~TestCase.assertEqual`, підсумовано в наступній таблиці. Зауважте, що "
"зазвичай не потрібно безпосередньо викликати ці методи."

msgid "Used to compare"
msgstr "Використовується для порівняння"

msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

msgid "strings"
msgstr "рядки"

msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

msgid "sequences"
msgstr "послідовності"

msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

msgid "lists"
msgstr "списки"

msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

msgid "tuples"
msgstr "кортежі"

msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

msgid "sets or frozensets"
msgstr "набори або заморожені набори"

msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

msgid "dicts"
msgstr "дикт"

msgid ""
"Test that the multiline string *first* is equal to the string *second*. When "
"not equal a diff of the two strings highlighting the differences will be "
"included in the error message. This method is used by default when comparing "
"strings with :meth:`assertEqual`."
msgstr ""
"Перевірте, чи багаторядковий рядок *перший* дорівнює рядку *другий*. Якщо "
"відмінність двох рядків не дорівнює, у повідомленні про помилку буде "
"включено виділення відмінностей. Цей метод використовується за замовчуванням "
"під час порівняння рядків із :meth:`assertEqual`."

msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be "
"raised.  If the sequences are different an error message is constructed that "
"shows the difference between the two."
msgstr ""
"Перевіряє рівність двох послідовностей. Якщо вказано *seq_type*, і *first*, "
"і *second* мають бути екземплярами *seq_type*, інакше виникне помилка. Якщо "
"послідовності відрізняються, створюється повідомлення про помилку, яке "
"показує різницю між ними."

msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used to "
"implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""
"Цей метод не викликається безпосередньо :meth:`assertEqual`, але він "
"використовується для реалізації :meth:`assertListEqual` і :meth:"
"`assertTupleEqual`."

msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is "
"also raised if either of the parameters are of the wrong type. These methods "
"are used by default when comparing lists or tuples with :meth:`assertEqual`."
msgstr ""
"Перевіряє рівність двох списків або кортежів. Якщо ні, створюється "
"повідомлення про помилку, яке показує лише відмінності між ними. Помилка "
"також виникає, якщо один із параметрів має неправильний тип. Ці методи "
"використовуються за замовчуванням під час порівняння списків або кортежів "
"із :meth:`assertEqual`."

msgid ""
"Tests that two sets are equal.  If not, an error message is constructed that "
"lists the differences between the sets.  This method is used by default when "
"comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""
"Перевіряє рівність двох наборів. Якщо ні, створюється повідомлення про "
"помилку, яке містить перелік відмінностей між наборами. Цей метод "
"використовується за замовчуванням під час порівняння наборів або заморожених "
"наборів за допомогою :meth:`assertEqual`."

msgid ""
"Fails if either of *first* or *second* does not have a :meth:`set."
"difference` method."
msgstr ""
"Помилка, якщо *first* або *second* не має методу :meth:`set.difference`."

msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method will "
"be used by default to compare dictionaries in calls to :meth:`assertEqual`."
msgstr ""
"Перевірте рівність двох словників. Якщо ні, створюється повідомлення про "
"помилку, яке показує відмінності в словниках. Цей метод "
"використовуватиметься за умовчанням для порівняння словників у викликах :"
"meth:`assertEqual`."

msgid ""
"Finally the :class:`TestCase` provides the following methods and attributes:"
msgstr "Нарешті, :class:`TestCase` надає такі методи та атрибути:"

msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the error "
"message."
msgstr ""
"Безумовно сигналізує про помилку тесту за допомогою *msg* або ``None`` для "
"повідомлення про помилку."

msgid ""
"This class attribute gives the exception raised by the test method.  If a "
"test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to \"play "
"fair\" with the framework.  The initial value of this attribute is :exc:"
"`AssertionError`."
msgstr ""
"Цей атрибут класу дає виняток, викликаний методом тестування. Якщо тестова "
"структура потребує використання спеціалізованого винятку, можливо, для "
"передачі додаткової інформації, вона повинна створити підклас цього винятку, "
"щоб \"грати чесно\" з структурою. Початковим значенням цього атрибута є :exc:"
"`AssertionError`."

msgid ""
"This class attribute determines what happens when a custom failure message "
"is passed as the msg argument to an assertXYY call that fails. ``True`` is "
"the default value. In this case, the custom message is appended to the end "
"of the standard failure message. When set to ``False``, the custom message "
"replaces the standard message."
msgstr ""
"Цей атрибут класу визначає, що відбувається, коли настроюване повідомлення "
"про помилку передається як аргумент msg для виклику assertXYY, який "
"завершується помилкою. ``True`` - значення за умовчанням. У цьому випадку "
"спеціальне повідомлення додається в кінець стандартного повідомлення про "
"помилку. Якщо встановлено значення ``False``, спеціальне повідомлення "
"замінює стандартне повідомлення."

msgid ""
"The class setting can be overridden in individual test methods by assigning "
"an instance attribute, self.longMessage, to ``True`` or ``False`` before "
"calling the assert methods."
msgstr ""
"Налаштування класу можна перевизначити в окремих методах тестування, "
"призначивши атрибуту екземпляра self.longMessage значення ``True`` або "
"``False`` перед викликом методів assert."

msgid "The class setting gets reset before each test call."
msgstr "Налаштування класу скидається перед кожним тестовим викликом."

msgid ""
"This attribute controls the maximum length of diffs output by assert methods "
"that report diffs on failure. It defaults to 80*8 characters. Assert methods "
"affected by this attribute are :meth:`assertSequenceEqual` (including all "
"the sequence comparison methods that delegate to it), :meth:"
"`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""
"Цей атрибут контролює максимальну довжину виведення відмінностей методами "
"assert, які повідомляють про відмінності у разі помилки. За замовчуванням "
"80*8 символів. Методи підтвердження, на які впливає цей атрибут: :meth:"
"`assertSequenceEqual` (включно з усіма методами порівняння послідовностей, "
"які йому делегують), :meth:`assertDictEqual` і :meth:`assertMultiLineEqual`."

msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr ""
"Встановлення ``maxDiff`` на ``None`` означає, що не існує максимальної "
"довжини відмінностей."

msgid ""
"Testing frameworks can use the following methods to collect information on "
"the test:"
msgstr ""
"Платформи тестування можуть використовувати такі методи для збору інформації "
"про тест:"

msgid ""
"Return the number of tests represented by this test object.  For :class:"
"`TestCase` instances, this will always be ``1``."
msgstr ""
"Повертає кількість тестів, представлених цим тестовим об’єктом. Для "
"екземплярів :class:`TestCase` це завжди буде ``1``."

msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the :meth:`run` "
"method)."
msgstr ""
"Повертає екземпляр класу результатів тесту, який слід використовувати для "
"цього класу тестів (якщо для методу :meth:`run` не надано інший екземпляр "
"результату)."

msgid ""
"For :class:`TestCase` instances, this will always be an instance of :class:"
"`TestResult`; subclasses of :class:`TestCase` should override this as "
"necessary."
msgstr ""
"Для екземплярів :class:`TestCase` це завжди буде екземпляр :class:"
"`TestResult`; підкласи :class:`TestCase` мають замінити це, якщо необхідно."

msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr ""
"Повертає рядок, що ідентифікує конкретний тест. Зазвичай це повна назва "
"тестового методу, включаючи назву модуля та класу."

msgid ""
"Returns a description of the test, or ``None`` if no description has been "
"provided.  The default implementation of this method returns the first line "
"of the test method's docstring, if available, or ``None``."
msgstr ""
"Повертає опис тесту або ``None``, якщо опис не надано. Реалізація цього "
"методу за замовчуванням повертає перший рядок документації тестового методу, "
"якщо доступний, або ``None``."

msgid ""
"In 3.1 this was changed to add the test name to the short description even "
"in the presence of a docstring.  This caused compatibility issues with "
"unittest extensions and adding the test name was moved to the :class:"
"`TextTestResult` in Python 3.2."
msgstr ""
"У 3.1 це було змінено, щоб додати назву тесту до короткого опису навіть за "
"наявності рядка документації. Це викликало проблеми сумісності з "
"розширеннями unittest, і додавання назви тесту було перенесено до :class:"
"`TextTestResult` у Python 3.2."

msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources used "
"during the test. Functions will be called in reverse order to the order they "
"are added (:abbr:`LIFO (last-in, first-out)`).  They are called with any "
"arguments and keyword arguments passed into :meth:`addCleanup` when they are "
"added."
msgstr ""
"Додайте функцію, яка буде викликатися після :meth:`tearDown` для очищення "
"ресурсів, використаних під час тесту. Функції будуть викликані в порядку, "
"зворотному порядку їх додавання (:abbr:`LIFO (останній прийшов, перший "
"вийшов)`). Вони викликаються з будь-якими аргументами та ключовими "
"аргументами, які передаються в :meth:`addCleanup` під час їх додавання."

msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then "
"any cleanup functions added will still be called."
msgstr ""
"Якщо :meth:`setUp` не вдається, тобто :meth:`tearDown` не викликається, тоді "
"будь-які додані функції очищення все одно будуть викликані."

msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:`addCleanup` "
"and return the result of the :meth:`~object.__enter__` method."
msgstr ""

msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after :meth:"
"`setUp` if :meth:`setUp` raises an exception."
msgstr ""
"Цей метод викликається безумовно після :meth:`tearDown` або після :meth:"
"`setUp`, якщо :meth:`setUp` викликає виняткову ситуацію."

msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addCleanup`. If you need cleanup functions to be called *prior* to :meth:"
"`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""
"Він відповідає за виклик усіх функцій очищення, доданих :meth:`addCleanup`. "
"Якщо вам потрібно, щоб функції очищення викликалися *перед* :meth:"
"`tearDown`, ви можете викликати :meth:`doCleanups` самостійно."

msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at a "
"time, so it can be called at any time."
msgstr ""
":meth:`doCleanups` витягує методи зі стеку функцій очищення по одному, тому "
"їх можна викликати будь-коли."

msgid ""
"Add a function to be called after :meth:`tearDownClass` to cleanup resources "
"used during the test class. Functions will be called in reverse order to the "
"order they are added (:abbr:`LIFO (last-in, first-out)`). They are called "
"with any arguments and keyword arguments passed into :meth:`addClassCleanup` "
"when they are added."
msgstr ""
"Додайте функцію, яка буде викликатися після :meth:`tearDownClass` до "
"ресурсів очищення, використаних під час тестового класу. Функції будуть "
"викликані в порядку, зворотному порядку їх додавання (:abbr:`LIFO (останній "
"прийшов, перший вийшов)`). Вони викликаються з будь-якими аргументами та "
"ключовими аргументами, які передаються в :meth:`addClassCleanup` під час їх "
"додавання."

msgid ""
"If :meth:`setUpClass` fails, meaning that :meth:`tearDownClass` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Якщо :meth:`setUpClass` не вдається, тобто :meth:`tearDownClass` не "
"викликається, тоді будь-які додані функції очищення все одно будуть "
"викликані."

msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :meth:"
"`addClassCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""

msgid ""
"This method is called unconditionally after :meth:`tearDownClass`, or after :"
"meth:`setUpClass` if :meth:`setUpClass` raises an exception."
msgstr ""
"Цей метод викликається безумовно після :meth:`tearDownClass` або після :meth:"
"`setUpClass`, якщо :meth:`setUpClass` викликає виняток."

msgid ""
"It is responsible for calling all the cleanup functions added by :meth:"
"`addClassCleanup`. If you need cleanup functions to be called *prior* to :"
"meth:`tearDownClass` then you can call :meth:`doClassCleanups` yourself."
msgstr ""
"Він відповідає за виклик усіх функцій очищення, доданих :meth:"
"`addClassCleanup`. Якщо вам потрібно, щоб функції очищення викликалися "
"*перед* :meth:`tearDownClass`, ви можете викликати :meth:`doClassCleanups` "
"самостійно."

msgid ""
":meth:`doClassCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":meth:`doClassCleanups` витягує методи зі стеку функцій очищення по одному, "
"тому їх можна викликати будь-коли."

msgid ""
"This class provides an API similar to :class:`TestCase` and also accepts "
"coroutines as test functions."
msgstr ""
"Цей клас надає API, подібний до :class:`TestCase`, а також приймає "
"співпрограми як тестові функції."

msgid ""
"Method called to prepare the test fixture. This is called after :meth:"
"`setUp`. This is called immediately before calling the test method; other "
"than :exc:`AssertionError` or :exc:`SkipTest`, any exception raised by this "
"method will be considered an error rather than a test failure. The default "
"implementation does nothing."
msgstr ""
"Метод, який називається для підготовки випробувального матеріалу. Це "
"викликається після :meth:`setUp`. Це викликається безпосередньо перед "
"викликом тестового методу; крім :exc:`AssertionError` або :exc:`SkipTest`, "
"будь-який виняток, викликаний цим методом, вважатиметься помилкою, а не "
"помилкою тесту. Стандартна реалізація нічого не робить."

msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called before :meth:`tearDown`. This is called "
"even if the test method raised an exception, so the implementation in "
"subclasses may need to be particularly careful about checking internal "
"state.  Any exception, other than :exc:`AssertionError` or :exc:`SkipTest`, "
"raised by this method will be considered an additional error rather than a "
"test failure (thus increasing the total number of reported errors). This "
"method will only be called if the :meth:`asyncSetUp` succeeds, regardless of "
"the outcome of the test method. The default implementation does nothing."
msgstr ""
"Метод викликається відразу після виклику тестового методу та запису "
"результату. Це викликається перед :meth:`tearDown`. Це викликається, навіть "
"якщо метод тестування викликав виняток, тому реалізація в підкласах може "
"потребувати особливої обережності щодо перевірки внутрішнього стану. Будь-"
"які винятки, окрім :exc:`AssertionError` або :exc:`SkipTest`, викликані цим "
"методом, вважатимуться додатковою помилкою, а не помилкою тесту (таким чином "
"збільшуючи загальну кількість повідомлених помилок). Цей метод буде "
"викликано, лише якщо :meth:`asyncSetUp` завершиться успішно, незалежно від "
"результату тестового методу. Стандартна реалізація нічого не робить."

msgid "This method accepts a coroutine that can be used as a cleanup function."
msgstr ""
"Цей метод приймає співпрограму, яку можна використовувати як функцію "
"очищення."

msgid ""
"Enter the supplied :term:`asynchronous context manager`.  If successful, "
"also add its :meth:`~object.__aexit__` method as a cleanup function by :meth:"
"`addAsyncCleanup` and return the result of the :meth:`~object.__aenter__` "
"method."
msgstr ""

msgid ""
"Sets up a new event loop to run the test, collecting the result into the :"
"class:`TestResult` object passed as *result*.  If *result* is omitted or "
"``None``, a temporary result object is created (by calling the :meth:"
"`defaultTestResult` method) and used. The result object is returned to :meth:"
"`run`'s caller. At the end of the test all the tasks in the event loop are "
"cancelled."
msgstr ""
"Встановлює новий цикл подій для запуску тесту, збираючи результат в об’єкт :"
"class:`TestResult`, переданий як *результат*. Якщо *результат* пропущено або "
"``None``, створюється та використовується тимчасовий об’єкт результату "
"(викликом методу :meth:`defaultTestResult`). Об’єкт результату повертається "
"до виклику :meth:`run`. Після закінчення тесту всі завдання в циклі подій "
"скасовуються."

msgid "An example illustrating the order::"
msgstr "Приклад, що ілюструє порядок::"

msgid ""
"After running the test, ``events`` would contain ``[\"setUp\", "
"\"asyncSetUp\", \"test_response\", \"asyncTearDown\", \"tearDown\", "
"\"cleanup\"]``."
msgstr ""
"Після виконання тесту ``події`` міститимуть ``[\"setUp\", \"asyncSetUp\", "
"\"test_response\", \"asyncTearDown\", \"tearDown\", \"cleanup\"]``."

msgid ""
"This class implements the portion of the :class:`TestCase` interface which "
"allows the test runner to drive the test, but does not provide the methods "
"which test code can use to check and report errors.  This is used to create "
"test cases using legacy test code, allowing it to be integrated into a :mod:"
"`unittest`-based test framework."
msgstr ""
"Цей клас реалізує частину інтерфейсу :class:`TestCase`, яка дозволяє "
"виконавцю тесту управляти тестом, але не надає методів, які тестовий код "
"може використовувати для перевірки та звітування про помилки. Це "
"використовується для створення тестів із використанням застарілого тестового "
"коду, що дозволяє інтегрувати його в тестову структуру на основі :mod:"
"`unittest`."

msgid "Deprecated aliases"
msgstr "Застарілі псевдоніми"

msgid ""
"For historical reasons, some of the :class:`TestCase` methods had one or "
"more aliases that are now deprecated.  The following table lists the correct "
"names along with their deprecated aliases:"
msgstr ""
"З історичних причин деякі з методів :class:`TestCase` мали один або більше "
"псевдонімів, які зараз застаріли. У наведеній нижче таблиці наведено "
"правильні імена разом із їхніми застарілими псевдонімами:"

msgid "Method Name"
msgstr "Назва методу"

msgid "Deprecated alias"
msgstr "Застарілий псевдонім"

msgid ":meth:`.assertEqual`"
msgstr ":meth:`.assertEqual`"

msgid "failUnlessEqual"
msgstr "failUnlessEqual"

msgid "assertEquals"
msgstr "assertEquals"

msgid ":meth:`.assertNotEqual`"
msgstr ":meth:`.assertNotEqual`"

msgid "failIfEqual"
msgstr "failIfEqual"

msgid "assertNotEquals"
msgstr "assertNotEquals"

msgid ":meth:`.assertTrue`"
msgstr ":meth:`.assertTrue`"

msgid "failUnless"
msgstr "failUnless"

msgid "assert\\_"
msgstr "стверджувати\\_"

msgid ":meth:`.assertFalse`"
msgstr ":meth:`.assertFalse`"

msgid "failIf"
msgstr "failIf"

msgid ":meth:`.assertRaises`"
msgstr ":meth:`.assertRaises`"

msgid "failUnlessRaises"
msgstr "failUnlessRaises"

msgid ":meth:`.assertAlmostEqual`"
msgstr ":meth:`.assertAlmostEqual`"

msgid "failUnlessAlmostEqual"
msgstr "failUnlessAlmostEqual"

msgid "assertAlmostEquals"
msgstr "assertAlmostEquals"

msgid ":meth:`.assertNotAlmostEqual`"
msgstr ":meth:`.assertNotAlmostEqual`"

msgid "failIfAlmostEqual"
msgstr "failIfAlmostEqual"

msgid "assertNotAlmostEquals"
msgstr "assertNotAlmostEquals"

msgid ":meth:`.assertRegex`"
msgstr ":meth:`.assertRegex`"

msgid "assertRegexpMatches"
msgstr "assertRegexpMatches"

msgid ":meth:`.assertNotRegex`"
msgstr ":meth:`.assertNotRegex`"

msgid "assertNotRegexpMatches"
msgstr "assertNotRegexpMatches"

msgid ":meth:`.assertRaisesRegex`"
msgstr ":meth:`.assertRaisesRegex`"

msgid "assertRaisesRegexp"
msgstr "assertRaisesRegexp"

msgid "The fail* aliases listed in the second column have been deprecated."
msgstr "Псевдоніми fail*, перелічені у другому стовпці, застаріли."

msgid "The assert* aliases listed in the third column have been deprecated."
msgstr "Псевдоніми assert*, перелічені в третьому стовпці, застаріли."

msgid ""
"``assertRegexpMatches`` and ``assertRaisesRegexp`` have been renamed to :"
"meth:`.assertRegex` and :meth:`.assertRaisesRegex`."
msgstr ""
"``assertRegexpMatches`` і ``assertRaisesRegexp`` було перейменовано на :meth:"
"`.assertRegex` і :meth:`.assertRaisesRegex`."

msgid ""
"The ``assertNotRegexpMatches`` name is deprecated in favor of :meth:`."
"assertNotRegex`."
msgstr ""
"Назва ``assertNotRegexpMatches`` застаріла на користь :meth:`."
"assertNotRegex`."

msgid "Grouping tests"
msgstr "Групування тестів"

msgid ""
"This class represents an aggregation of individual test cases and test "
"suites. The class presents the interface needed by the test runner to allow "
"it to be run as any other test case.  Running a :class:`TestSuite` instance "
"is the same as iterating over the suite, running each test individually."
msgstr ""
"Цей клас представляє сукупність окремих тестових випадків і наборів тестів. "
"Клас представляє інтерфейс, необхідний виконавцю тесту, щоб дозволити йому "
"запускатися як будь-який інший тестовий приклад. Запуск екземпляра :class:"
"`TestSuite` — це те саме, що ітерація по набору, запускаючи кожен тест "
"окремо."

msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. Additional "
"methods are provided to add test cases and suites to the collection later on."
msgstr ""
"Якщо надано *тести*, це має бути ітерація окремих тестових випадків або "
"інших наборів тестів, які будуть використані для створення набору спочатку. "
"Додаткові методи надаються для додавання тестів і пакетів до колекції "
"пізніше."

msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""
"Об’єкти :class:`TestSuite` поводяться так само, як об’єкти :class:"
"`TestCase`, за винятком того, що вони насправді не реалізують тест. "
"Натомість вони використовуються для агрегування тестів у групи тестів, які "
"слід виконувати разом. Деякі додаткові методи доступні для додавання тестів "
"до екземплярів :class:`TestSuite`:"

msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr "Додайте :class:`TestCase` або :class:`TestSuite` до набору."

msgid ""
"Add all the tests from an iterable of :class:`TestCase` and :class:"
"`TestSuite` instances to this test suite."
msgstr ""
"Додайте всі тести з ітерації екземплярів :class:`TestCase` і :class:"
"`TestSuite` до цього набору тестів."

msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for "
"each element."
msgstr ""
"Це еквівалентно повторенню *тестів*, виклику :meth:`addTest` для кожного "
"елемента."

msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ""
":class:`TestSuite` використовує такі методи спільно з :class:`TestCase`:"

msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike :meth:`TestCase."
"run`, :meth:`TestSuite.run` requires the result object to be passed in."
msgstr ""
"Запустіть тести, пов’язані з цим набором, зібравши результат в об’єкт "
"результату тесту, переданий як *результат*. Зауважте, що на відміну від :"
"meth:`TestCase.run`, :meth:`TestSuite.run` вимагає передачі об’єкта "
"результату."

msgid ""
"Run the tests associated with this suite without collecting the result. This "
"allows exceptions raised by the test to be propagated to the caller and can "
"be used to support running tests under a debugger."
msgstr ""
"Виконуйте тести, пов’язані з цим пакетом, без збору результатів. Це дозволяє "
"поширювати винятки, викликані тестом, до абонента та може використовуватися "
"для підтримки запуску тестів під налагоджувачем."

msgid ""
"Return the number of tests represented by this test object, including all "
"individual tests and sub-suites."
msgstr ""
"Повертає кількість тестів, представлених цим тестовим об’єктом, включаючи "
"всі окремі тести та піднабори."

msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`__iter__`. Note "
"that this method may be called several times on a single suite (for example "
"when counting tests or comparing for equality) so the tests returned by "
"repeated iterations before :meth:`TestSuite.run` must be the same for each "
"call iteration. After :meth:`TestSuite.run`, callers should not rely on the "
"tests returned by this method unless the caller uses a subclass that "
"overrides :meth:`TestSuite._removeTestAtIndex` to preserve test references."
msgstr ""
"Тести, згруповані за :class:`TestSuite`, завжди доступні за допомогою "
"ітерації. Підкласи можуть ліниво надавати тести, перевизначаючи :meth:"
"`__iter__`. Зверніть увагу, що цей метод може бути викликаний кілька разів в "
"одному пакеті (наприклад, під час підрахунку тестів або порівняння на "
"рівність), тому тести, повернуті повторними ітераціями перед :meth:"
"`TestSuite.run`, мають бути однаковими для кожної ітерації виклику. Після :"
"meth:`TestSuite.run` абоненти не повинні покладатися на тести, повернуті цим "
"методом, якщо тільки виклик не використовує підклас, який замінює :meth:"
"`TestSuite._removeTestAtIndex` для збереження посилань на тести."

msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather "
"than through iteration, so overriding :meth:`__iter__` wasn't sufficient for "
"providing tests."
msgstr ""
"У попередніх версіях :class:`TestSuite` отримував доступ до тестів напряму, "
"а не через ітерацію, тому перевизначення :meth:`__iter__` було недостатньо "
"для надання тестів."

msgid ""
"In earlier versions the :class:`TestSuite` held references to each :class:"
"`TestCase` after :meth:`TestSuite.run`. Subclasses can restore that behavior "
"by overriding :meth:`TestSuite._removeTestAtIndex`."
msgstr ""
"У попередніх версіях :class:`TestSuite` містив посилання на кожен :class:"
"`TestCase` після :meth:`TestSuite.run`. Підкласи можуть відновити цю "
"поведінку, замінивши :meth:`TestSuite._removeTestAtIndex`."

msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` method "
"is invoked by a :class:`TestRunner` rather than by the end-user test harness."
msgstr ""
"У типовому використанні об’єкта :class:`TestSuite` метод :meth:`run` "
"викликається :class:`TestRunner`, а не тестовим пакетом кінцевого "
"користувача."

msgid "Loading and running tests"
msgstr "Завантаження та виконання тестів"

msgid ""
"The :class:`TestLoader` class is used to create test suites from classes and "
"modules.  Normally, there is no need to create an instance of this class; "
"the :mod:`unittest` module provides an instance that can be shared as :data:"
"`unittest.defaultTestLoader`.  Using a subclass or instance, however, allows "
"customization of some configurable properties."
msgstr ""
"Клас :class:`TestLoader` використовується для створення наборів тестів із "
"класів і модулів. Зазвичай немає необхідності створювати екземпляр цього "
"класу; модуль :mod:`unittest` надає екземпляр, який можна використовувати "
"як :data:`unittest.defaultTestLoader`. Однак використання підкласу або "
"екземпляра дозволяє налаштувати деякі настроювані властивості."

msgid ":class:`TestLoader` objects have the following attributes:"
msgstr ":class:`TestLoader` об’єкти мають такі атрибути:"

msgid ""
"A list of the non-fatal errors encountered while loading tests. Not reset by "
"the loader at any point. Fatal errors are signalled by the relevant method "
"raising an exception to the caller. Non-fatal errors are also indicated by a "
"synthetic test that will raise the original error when run."
msgstr ""

msgid ":class:`TestLoader` objects have the following methods:"
msgstr "Об’єкти :class:`TestLoader` мають такі методи:"

msgid ""
"Return a suite of all test cases contained in the :class:`TestCase`\\ -"
"derived :class:`testCaseClass`."
msgstr ""
"Повертає набір усіх тестів, що містяться в :class:`TestCase`\\ -похідному :"
"class:`testCaseClass`."

msgid ""
"A test case instance is created for each method named by :meth:"
"`getTestCaseNames`. By default these are the method names beginning with "
"``test``. If :meth:`getTestCaseNames` returns no methods, but the :meth:"
"`runTest` method is implemented, a single test case is created for that "
"method instead."
msgstr ""
"Екземпляр тестового випадку створюється для кожного методу, названого :meth:"
"`getTestCaseNames`. За замовчуванням це імена методів, які починаються з "
"``test``. Якщо :meth:`getTestCaseNames` не повертає жодних методів, але "
"реалізовано метод :meth:`runTest`, натомість для цього методу створюється "
"один тестовий приклад."

msgid ""
"Return a suite of all test cases contained in the given module. This method "
"searches *module* for classes derived from :class:`TestCase` and creates an "
"instance of the class for each test method defined for the class."
msgstr ""
"Повертає набір усіх тестів, що містяться в даному модулі. Цей метод шукає в "
"*module* класи, похідні від :class:`TestCase`, і створює екземпляр класу для "
"кожного тестового методу, визначеного для класу."

msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test methods "
"on base classes that are not intended to be instantiated directly does not "
"play well with this method.  Doing so, however, can be useful when the "
"fixtures are different and defined in subclasses."
msgstr ""
"Хоча використання ієрархії похідних класів :class:`TestCase`\\ може бути "
"зручним для спільного використання фікстур і допоміжних функцій, визначення "
"методів тестування на базових класах, які не призначені для безпосереднього "
"створення екземплярів, не підходить для цього методу. Однак це може бути "
"корисним, коли прилади різні та визначені в підкласах."

msgid ""
"If a module provides a ``load_tests`` function it will be called to load the "
"tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_.  The *pattern* argument is passed as the third "
"argument to ``load_tests``."
msgstr ""
"Якщо модуль надає функцію ``load_tests``, її буде викликано для завантаження "
"тестів. Це дозволяє модулям налаштовувати тестове завантаження. Це протокол "
"`load_tests`_. Аргумент *pattern* передається як третій аргумент у "
"``load_tests``."

msgid "Support for ``load_tests`` added."
msgstr "Додано підтримку ``load_tests``."

msgid ""
"The undocumented and unofficial *use_load_tests* default argument is "
"deprecated and ignored, although it is still accepted for backward "
"compatibility.  The method also now accepts a keyword-only argument "
"*pattern* which is passed to ``load_tests`` as the third argument."
msgstr ""
"Недокументований і неофіційний аргумент *use_load_tests* за замовчуванням "
"застарів і ігнорується, хоча він все ще приймається для зворотної "
"сумісності. Метод також тепер приймає аргумент *pattern*, що містить лише "
"ключове слово, який передається в ``load_tests`` як третій аргумент."

msgid "Return a suite of all test cases given a string specifier."
msgstr "Повертає набір усіх тестів із специфікатором рядка."

msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a :class:"
"`TestSuite` instance, or a callable object which returns a :class:`TestCase` "
"or :class:`TestSuite` instance.  These checks are applied in the order "
"listed here; that is, a method on a possible test case class will be picked "
"up as \"a test method within a test case class\", rather than \"a callable "
"object\"."
msgstr ""
"Специфікатор *name* — це \"ім’я з крапками\", яке може перетворюватися на "
"модуль, клас тестового прикладу, метод тестування в класі тестового випадку, "
"екземпляр :class:`TestSuite` або викликаний об’єкт, який повертає: "
"екземпляр :class:`TestCase` або :class:`TestSuite`. Ці перевірки "
"застосовуються в зазначеному тут порядку; тобто метод у можливому класі "
"тестового випадку буде вибрано як \"метод тестування в класі тестового "
"випадку\", а не як \"об'єкт, який можна викликати\"."

msgid ""
"For example, if you have a module :mod:`SampleTests` containing a :class:"
"`TestCase`\\ -derived class :class:`SampleTestCase` with three test methods "
"(:meth:`test_one`, :meth:`test_two`, and :meth:`test_three`), the specifier "
"``'SampleTests.SampleTestCase'`` would cause this method to return a suite "
"which will run all three test methods. Using the specifier ``'SampleTests."
"SampleTestCase.test_two'`` would cause it to return a test suite which will "
"run only the :meth:`test_two` test method. The specifier can refer to "
"modules and packages which have not been imported; they will be imported as "
"a side-effect."
msgstr ""
"Наприклад, якщо у вас є модуль :mod:`SampleTests`, який містить :class:"
"`TestCase`\\ -похідний клас :class:`SampleTestCase` із трьома методами "
"тестування (:meth:`test_one`, :meth:`test_two` і :meth:`test_three`), "
"специфікатор ``'SampleTests.SampleTestCase'`` призведе до того, що цей метод "
"повертатиме набір, який виконуватиме всі три методи тестування. Використання "
"специфікатора ``'SampleTests.SampleTestCase.test_two`` призведе до "
"повернення набору тестів, який запускатиме лише метод тестування :meth:"
"`test_two`. Специфікатор може посилатися на модулі та пакунки, які не були "
"імпортовані; вони будуть імпортовані як побічний ефект."

msgid "The method optionally resolves *name* relative to the given *module*."
msgstr "Метод необов’язково розпізнає *ім’я* відносно даного *модуля*."

msgid ""
"If an :exc:`ImportError` or :exc:`AttributeError` occurs while traversing "
"*name* then a synthetic test that raises that error when run will be "
"returned. These errors are included in the errors accumulated by self.errors."
msgstr ""
"Якщо :exc:`ImportError` або :exc:`AttributeError` виникає під час обходу "
"*name*, тоді буде повернено синтетичний тест, який викликає цю помилку під "
"час запуску. Ці помилки включено до помилок, накопичених self.errors."

msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names rather "
"than a single name.  The return value is a test suite which supports all the "
"tests defined for each name."
msgstr ""
"Подібно до :meth:`loadTestsFromName`, але приймає послідовність імен, а не "
"одне ім’я. Повернене значення — це набір тестів, який підтримує всі тести, "
"визначені для кожного імені."

msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; this "
"should be a subclass of :class:`TestCase`."
msgstr ""
"Повертає відсортовану послідовність імен методів, знайдених у "
"*testCaseClass*; це має бути підклас :class:`TestCase`."

msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them. "
"Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""
"Знайдіть усі тестові модулі, перейшовши до підкаталогів із зазначеного "
"початкового каталогу, і поверніть об’єкт TestSuite, що містить їх. Будуть "
"завантажені лише тестові файли, які відповідають *шаблону*. (Використовуючи "
"зіставлення шаблону стилю оболонки.) Завантажуватимуться лише імена модулів, "
"які можна імпортувати (тобто є дійсними ідентифікаторами Python)."

msgid ""
"All test modules must be importable from the top level of the project. If "
"the start directory is not the top level directory then the top level "
"directory must be specified separately."
msgstr ""
"Усі тестові модулі мають бути імпортованими з верхнього рівня проекту. Якщо "
"початковий каталог не є каталогом верхнього рівня, тоді каталог верхнього "
"рівня потрібно вказати окремо."

msgid ""
"If importing a module fails, for example due to a syntax error, then this "
"will be recorded as a single error and discovery will continue.  If the "
"import failure is due to :exc:`SkipTest` being raised, it will be recorded "
"as a skip instead of an error."
msgstr ""
"Якщо імпортувати модуль не вдалося, наприклад, через синтаксичну помилку, це "
"буде записано як одну помилку, і виявлення продовжиться. Якщо помилка "
"імпорту спричинена викликом :exc:`SkipTest`, це буде записано як пропуск "
"замість помилки."

msgid ""
"If a package (a directory containing a file named :file:`__init__.py`) is "
"found, the package will be checked for a ``load_tests`` function. If this "
"exists then it will be called ``package.load_tests(loader, tests, "
"pattern)``. Test discovery takes care to ensure that a package is only "
"checked for tests once during an invocation, even if the load_tests function "
"itself calls ``loader.discover``."
msgstr ""
"Якщо пакунок (каталог, що містить файл із назвою :file:`__init__.py`) "
"знайдено, пакунок буде перевірено на наявність функції ``load_tests``. Якщо "
"він існує, він називатиметься ``package.load_tests(loader, tests, "
"pattern)``. Тестове виявлення піклується про те, щоб пакет перевірявся на "
"наявність тестів лише один раз під час виклику, навіть якщо сама функція "
"load_tests викликає ``loader.discover``."

msgid ""
"If ``load_tests`` exists then discovery does *not* recurse into the package, "
"``load_tests`` is responsible for loading all tests in the package."
msgstr ""
"Якщо ``load_tests`` існує, виявлення *не* рекурсує в пакунок, ``load_tests`` "
"відповідає за завантаження всіх тестів у пакунок."

msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves. *top_level_dir* is stored so "
"``load_tests`` does not need to pass this argument in to ``loader."
"discover()``."
msgstr ""
"Шаблон навмисно не зберігається як атрибут завантажувача, щоб пакунки могли "
"самостійно продовжувати пошук. *top_level_dir* зберігається, тому "
"``load_tests`` не потрібно передавати цей аргумент у ``loader.discover()``."

msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr "*start_dir* може бути назвою модуля з крапками, а також каталогом."

msgid ""
"Modules that raise :exc:`SkipTest` on import are recorded as skips, not "
"errors."
msgstr ""
"Модулі, які викликають :exc:`SkipTest` під час імпорту, записуються як "
"пропуски, а не як помилки."

msgid "*start_dir* can be a :term:`namespace packages <namespace package>`."
msgstr ""
"*start_dir* може бути :term:`пакети простору імен <namespace package>`."

msgid ""
"Paths are sorted before being imported so that execution order is the same "
"even if the underlying file system's ordering is not dependent on file name."
msgstr ""
"Шляхи сортуються перед імпортом, щоб порядок виконання був однаковим, навіть "
"якщо порядок базової файлової системи не залежить від імені файлу."

msgid ""
"Found packages are now checked for ``load_tests`` regardless of whether "
"their path matches *pattern*, because it is impossible for a package name to "
"match the default pattern."
msgstr ""
"Знайдені пакунки тепер перевіряються на ``load_tests`` незалежно від того, "
"чи відповідає їхній шлях *шаблону*, оскільки назва пакета не може "
"відповідати шаблону за замовчуванням."

msgid ""
"*start_dir* can not be a :term:`namespace packages <namespace package>`. It "
"has been broken since Python 3.7 and Python 3.11 officially remove it."
msgstr ""

msgid ""
"The following attributes of a :class:`TestLoader` can be configured either "
"by subclassing or assignment on an instance:"
msgstr ""
"Наступні атрибути :class:`TestLoader` можуть бути налаштовані за допомогою "
"підкласу або призначення для екземпляра:"

msgid ""
"String giving the prefix of method names which will be interpreted as test "
"methods.  The default value is ``'test'``."
msgstr ""
"Рядок із префіксом імен методів, які будуть інтерпретуватися як тестові "
"методи. Значення за замовчуванням - ``'test'``."

msgid ""
"This affects :meth:`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` "
"methods."
msgstr ""
"Це впливає на :meth:`getTestCaseNames` і всі методи :meth:`loadTestsFrom\\*`."

msgid ""
"Function to be used to compare method names when sorting them in :meth:"
"`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` methods."
msgstr ""
"Функція для порівняння назв методів під час їх сортування в :meth:"
"`getTestCaseNames` та всіх методах :meth:`loadTestsFrom\\*`."

msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the :class:"
"`TestSuite` class."
msgstr ""
"Викликаний об’єкт, який створює набір тестів зі списку тестів. Жодних "
"методів для отриманого об’єкта не потрібно. Стандартним значенням є клас :"
"class:`TestSuite`."

msgid "This affects all the :meth:`loadTestsFrom\\*` methods."
msgstr "Це впливає на всі методи :meth:`loadTestsFrom\\*`."

msgid ""
"List of Unix shell-style wildcard test name patterns that test methods have "
"to match to be included in test suites (see ``-v`` option)."
msgstr ""
"Список шаблонів назв тестів зі символами узагальнення в стилі оболонки Unix, "
"яким мають відповідати методи тестування, щоб їх було включено до наборів "
"тестів (див. опцію ``-v``)."

msgid ""
"If this attribute is not ``None`` (the default), all test methods to be "
"included in test suites must match one of the patterns in this list. Note "
"that matches are always performed using :meth:`fnmatch.fnmatchcase`, so "
"unlike patterns passed to the ``-v`` option, simple substring patterns will "
"have to be converted using ``*`` wildcards."
msgstr ""
"Якщо цей атрибут не ``None`` (за замовчуванням), усі методи тестування, які "
"будуть включені до наборів тестів, повинні відповідати одному із шаблонів у "
"цьому списку. Зауважте, що збіги завжди виконуються за допомогою :meth:"
"`fnmatch.fnmatchcase`, тому, на відміну від шаблонів, переданих параметром "
"``-v``, прості шаблони підрядків потрібно буде перетворити за допомогою "
"символів узагальнення ``*``."

msgid ""
"This class is used to compile information about which tests have succeeded "
"and which have failed."
msgstr ""
"Цей клас використовується для компіляції інформації про те, які тести були "
"успішними, а які невдалими."

msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The :"
"class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""
"Об’єкт :class:`TestResult` зберігає результати набору тестів. Класи :class:"
"`TestCase` і :class:`TestSuite` забезпечують належний запис результатів; "
"авторам тестів не потрібно турбуватися про запис результатів тестів."

msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the :"
"class:`TestResult` object generated by running a set of tests for reporting "
"purposes; a :class:`TestResult` instance is returned by the :meth:"
"`TestRunner.run` method for this purpose."
msgstr ""
"Фреймворки тестування, створені на основі :mod:`unittest`, можуть "
"потребувати доступу до об’єкта :class:`TestResult`, згенерованого за "
"допомогою виконання набору тестів для цілей звітування; екземпляр :class:"
"`TestResult` повертається методом :meth:`TestRunner.run` для цієї мети."

msgid ""
":class:`TestResult` instances have the following attributes that will be of "
"interest when inspecting the results of running a set of tests:"
msgstr ""
"Екземпляри :class:`TestResult` мають такі атрибути, які будуть цікавими під "
"час перевірки результатів виконання набору тестів:"

msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised an "
"unexpected exception."
msgstr ""
"Список, що містить 2 кортежі екземплярів :class:`TestCase` і рядки, що "
"містять відформатовані відстеження. Кожен кортеж представляє тест, який "
"викликав несподіваний виняток."

msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a failure "
"was explicitly signalled using the :meth:`TestCase.assert\\*` methods."
msgstr ""
"Список, що містить 2 кортежі екземплярів :class:`TestCase` і рядки, що "
"містять відформатовані відстеження. Кожен кортеж представляє тест, де "
"помилка була явно повідомлена за допомогою методів :meth:`TestCase."
"assert\\*`."

msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr ""
"Список, що містить 2 кортежі екземплярів :class:`TestCase` і рядки з "
"причиною пропуску тесту."

msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure or "
"error of the test case."
msgstr ""
"Список, що містить 2 кортежі екземплярів :class:`TestCase` і рядки, що "
"містять відформатовані відстеження. Кожен кортеж представляє очікуваний збій "
"або помилку тестового випадку."

msgid ""
"A list containing :class:`TestCase` instances that were marked as expected "
"failures, but succeeded."
msgstr ""
"Список, що містить екземпляри :class:`TestCase`, які були позначені як "
"очікувані помилки, але були успішними."

msgid ""
"Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr ""
"Установіть значення ``True``, коли виконання тестів має зупинятися на :meth:"
"`stop`."

msgid "The total number of tests run so far."
msgstr "Загальна кількість проведених тестів."

msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and ``sys.stderr`` "
"if the test fails or errors. Any output is also attached to the failure / "
"error message."
msgstr ""
"Якщо встановлено значення true, ``sys.stdout`` і ``sys.stderr`` будуть "
"буферизовані між викликами :meth:`startTest` і :meth:`stopTest`. Зібраний "
"вихід буде відображено на справжній ``sys.stdout`` і ``sys.stderr`` лише у "
"разі невдачі тесту або помилок. Будь-який вихід також додається до "
"повідомлення про збій/помилку."

msgid ""
"If set to true :meth:`stop` will be called on the first failure or error, "
"halting the test run."
msgstr ""
"Якщо встановлено значення true, :meth:`stop` буде викликано при першій "
"невдачі або помилці, зупиняючи тестовий запуск."

msgid "If set to true then local variables will be shown in tracebacks."
msgstr ""
"Якщо встановлено значення true, то локальні змінні відображатимуться у "
"відстеженнях."

msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr ""
"Повертає ``True``, якщо всі тести, запущені до цього моменту, пройдено, "
"інакше повертає ``False``."

msgid ""
"Returns ``False`` if there were any :attr:`unexpectedSuccesses` from tests "
"marked with the :func:`expectedFailure` decorator."
msgstr ""
"Повертає ``False``, якщо були будь-які :attr:`unexpectedSuccesses` від "
"тестів, позначених декоратором :func:`expectedFailure`."

msgid ""
"This method can be called to signal that the set of tests being run should "
"be aborted by setting the :attr:`shouldStop` attribute to ``True``. :class:"
"`TestRunner` objects should respect this flag and return without running any "
"additional tests."
msgstr ""
"Цей метод можна викликати, щоб повідомити про те, що набір запущених тестів "
"має бути перервано, встановивши атрибут :attr:`shouldStop` на ``True``. "
"Об’єкти :class:`TestRunner` мають поважати цей прапор і повертатися без "
"виконання додаткових тестів."

msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to "
"stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""
"Наприклад, ця функція використовується класом :class:`TextTestRunner`, щоб "
"зупинити тестову структуру, коли користувач сигналізує про переривання з "
"клавіатури. Інтерактивні інструменти, які забезпечують реалізації :class:"
"`TestRunner`, можуть використовувати це подібним чином."

msgid ""
"The following methods of the :class:`TestResult` class are used to maintain "
"the internal data structures, and may be extended in subclasses to support "
"additional reporting requirements.  This is particularly useful in building "
"tools which support interactive reporting while tests are being run."
msgstr ""
"Наступні методи класу :class:`TestResult` використовуються для підтримки "
"внутрішніх структур даних і можуть бути розширені в підкласах для підтримки "
"додаткових вимог до звітності. Це особливо корисно для створення "
"інструментів, які підтримують інтерактивне звітування під час виконання "
"тестів."

msgid "Called when the test case *test* is about to be run."
msgstr "Викликається, коли тестовий приклад *test* збирається запустити."

msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr "Викликається після виконання тесту *test*, незалежно від результату."

msgid "Called once before any tests are executed."
msgstr "Викликається один раз перед виконанням будь-яких тестів."

msgid "Called once after all tests are executed."
msgstr "Викликається один раз після виконання всіх тестів."

msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is a "
"tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""
"Викликається, коли тестовий приклад *test* викликає несподіваний виняток. "
"*err* — це кортеж у формі, яку повертає :func:`sys.exc_info`: ``(тип, "
"значення, відстеження)``."

msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`errors` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"Реалізація за замовчуванням додає кортеж ``(test, formatted_err)`` до "
"атрибута екземпляра :attr:`errors`, де *formatted_err* є відформатованим "
"зворотним трасуванням, отриманим від *err*."

msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of the "
"form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Викликається, коли тестовий приклад *test* сигналізує про помилку. *err* — "
"це кортеж у формі, яку повертає :func:`sys.exc_info`: ``(тип, значення, "
"відстеження)``."

msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`failures` attribute, where *formatted_err* is a formatted "
"traceback derived from *err*."
msgstr ""
"Реалізація за замовчуванням додає кортеж ``(test, formatted_err)`` до "
"атрибута екземпляра :attr:`failures`, де *formatted_err* є відформатованим "
"зворотним трасуванням, отриманим від *err*."

msgid "Called when the test case *test* succeeds."
msgstr "Викликається, коли тестовий приклад *test* виконується успішно."

msgid "The default implementation does nothing."
msgstr "Стандартна реалізація нічого не робить."

msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr ""
"Викликається, коли тестовий приклад *test* пропускається. *причина* — "
"причина пропуску тесту."

msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr ""
"Реалізація за замовчуванням додає кортеж ``(test, reason)`` до атрибута "
"екземпляра :attr:`skipped`."

msgid ""
"Called when the test case *test* fails or errors, but was marked with the :"
"func:`expectedFailure` decorator."
msgstr ""
"Викликається, коли тестовий приклад *test* зазнає невдачі або помилки, але "
"його позначено декоратором :func:`expectedFailure`."

msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to the "
"instance's :attr:`expectedFailures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""
"Реалізація за замовчуванням додає кортеж ``(test, formatted_err)`` до "
"атрибута екземпляра :attr:`expectedFailures`, де *formatted_err* є "
"відформатованим зворотним трасуванням, отриманим від *err*."

msgid ""
"Called when the test case *test* was marked with the :func:`expectedFailure` "
"decorator, but succeeded."
msgstr ""
"Викликається, коли тестовий приклад *test* був позначений декоратором :func:"
"`expectedFailure`, але завершився успішно."

msgid ""
"The default implementation appends the test to the instance's :attr:"
"`unexpectedSuccesses` attribute."
msgstr ""
"Стандартна реалізація додає тест до атрибута екземпляра :attr:"
"`unexpectedSuccesses`."

msgid ""
"Called when a subtest finishes.  *test* is the test case corresponding to "
"the test method.  *subtest* is a custom :class:`TestCase` instance "
"describing the subtest."
msgstr ""
"Викликається після завершення підтесту. *test* — тестовий приклад, що "
"відповідає методу тестування. *subtest* — це спеціальний екземпляр :class:"
"`TestCase`, який описує субтест."

msgid ""
"If *outcome* is :const:`None`, the subtest succeeded.  Otherwise, it failed "
"with an exception where *outcome* is a tuple of the form returned by :func:"
"`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"Якщо *результат* :const:`None`, субтест пройшов успішно. В іншому випадку це "
"не вдалося за винятком, коли *результат* є кортежем форми, яку повертає :"
"func:`sys.exc_info`: ``(тип, значення, відстеження)``."

msgid ""
"The default implementation does nothing when the outcome is a success, and "
"records subtest failures as normal failures."
msgstr ""
"Реалізація за замовчуванням не робить нічого, якщо результат є успішним, і "
"записує помилки підтесту як звичайні помилки."

msgid ""
"A concrete implementation of :class:`TestResult` used by the :class:"
"`TextTestRunner`."
msgstr ""
"Конкретна реалізація :class:`TestResult`, яка використовується :class:"
"`TextTestRunner`."

msgid ""
"This class was previously named ``_TextTestResult``. The old name still "
"exists as an alias but is deprecated."
msgstr ""
"Цей клас раніше називався ``_TextTestResult``. Стара назва все ще існує як "
"псевдонім, але не підтримується."

msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""
"Примірник класу :class:`TestLoader` призначений для спільного використання. "
"Якщо налаштування :class:`TestLoader` не потрібні, цей екземпляр можна "
"використовувати замість повторного створення нових екземплярів."

msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the output "
"stream. This class has a few configurable parameters, but is essentially "
"very simple.  Graphical applications which run test suites should provide "
"alternate implementations. Such implementations should accept ``**kwargs`` "
"as the interface to construct runners changes when features are added to "
"unittest."
msgstr ""
"Базова реалізація програми виконання тестів, яка виводить результати в "
"потік. Якщо *stream* має значення ``None``, стандартний :data:`sys.stderr` "
"використовується як вихідний потік. Цей клас має декілька настроюваних "
"параметрів, але по суті дуже простий. Графічні програми, які запускають "
"набори тестів, повинні надавати альтернативні реалізації. Такі реалізації "
"повинні приймати ``**kwargs``, оскільки інтерфейс для створення бігунів "
"змінюється, коли функції додаються до unittest."

msgid ""
"By default this runner shows :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` and :exc:`ImportWarning` "
"even if they are :ref:`ignored by default <warning-ignored>`. Deprecation "
"warnings caused by :ref:`deprecated unittest methods <deprecated-aliases>` "
"are also special-cased and, when the warning filters are ``'default'`` or "
"``'always'``, they will appear only once per-module, in order to avoid too "
"many warning messages.  This behavior can be overridden using Python's :"
"option:`!-Wd` or :option:`!-Wa` options (see :ref:`Warning control <using-on-"
"warnings>`) and leaving *warnings* to ``None``."
msgstr ""
"За умовчанням цей бігун показує :exc:`DeprecationWarning`, :exc:"
"`PendingDeprecationWarning`, :exc:`ResourceWarning` та :exc:`ImportWarning`, "
"навіть якщо вони :ref:`ігноруються за умовчанням <warning-ignored>`. "
"Попередження про застарілу дію, викликані :ref:`застарілими методами "
"unittest <deprecated-aliases>`, також мають особливий регістр, і, коли "
"фільтри попереджень є ``'за замовчуванням`` або ``''завжди'``, вони "
"з’являтимуться лише один раз на модуль, щоб уникнути надто великої кількості "
"попереджень. Цю поведінку можна змінити за допомогою параметрів Python :"
"option:`!-Wd` або :option:`!-Wa` (див. :ref:`Контроль попередження <using-on-"
"warnings>`) і залишити *попередження* на ``None``."

msgid "Added the ``warnings`` argument."
msgstr "Додано аргумент ``попередження``."

msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time rather "
"than import time."
msgstr ""
"Потік за замовчуванням встановлено на :data:`sys.stderr` під час створення "
"екземпляра, а не під час імпорту."

msgid "Added the tb_locals parameter."
msgstr "Додано параметр tb_locals."

msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. It "
"is not intended to be called directly, but can be overridden in subclasses "
"to provide a custom ``TestResult``."
msgstr ""
"Цей метод повертає екземпляр ``TestResult``, який використовується :meth:"
"`run`. Він не призначений для безпосереднього виклику, але може бути "
"замінений у підкласах, щоб надати спеціальний ``TestResult``."

msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It defaults "
"to :class:`TextTestResult` if no ``resultclass`` is provided. The result "
"class is instantiated with the following arguments::"
msgstr ""
"``_makeResult()`` створює екземпляр класу або виклику, переданого в "
"конструкторі ``TextTestRunner`` як аргумент ``resultclass``. За "
"замовчуванням :class:`TextTestResult`, якщо не надано ``resultclass``. Клас "
"результату створюється з такими аргументами:"

msgid ""
"This method is the main public interface to the ``TextTestRunner``. This "
"method takes a :class:`TestSuite` or :class:`TestCase` instance. A :class:"
"`TestResult` is created by calling :func:`_makeResult` and the test(s) are "
"run and the results printed to stdout."
msgstr ""
"Цей метод є основним публічним інтерфейсом для ``TextTestRunner``. Цей метод "
"приймає екземпляр :class:`TestSuite` або :class:`TestCase`. :class:"
"`TestResult` створюється шляхом виклику :func:`_makeResult`, і тест(и) "
"запускаються, а результати виводяться на stdout."

msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. The "
"simplest use for this function is to include the following line at the end "
"of a test script::"
msgstr ""
"Програма командного рядка, яка завантажує набір тестів із *модуля* та "
"запускає їх; це насамперед для того, щоб зробити тестові модулі зручними для "
"виконання. Найпростішим використанням цієї функції є додавання такого рядка "
"в кінці тестового сценарію::"

msgid ""
"You can run tests with more detailed information by passing in the verbosity "
"argument::"
msgstr ""
"Ви можете запустити тести з більш детальною інформацією, передавши аргумент "
"verbosity::"

msgid ""
"The *defaultTest* argument is either the name of a single test or an "
"iterable of test names to run if no test names are specified via *argv*.  If "
"not specified or ``None`` and no test names are provided via *argv*, all "
"tests found in *module* are run."
msgstr ""
"Аргумент *defaultTest* — це або назва окремого тесту, або ітерація імен "
"тестів для запуску, якщо жодні імена тестів не вказані через *argv*. Якщо не "
"вказано або ``None``, а імена тестів не надаються через *argv*, запускаються "
"всі тести, знайдені в *module*."

msgid ""
"The *argv* argument can be a list of options passed to the program, with the "
"first element being the program name.  If not specified or ``None``, the "
"values of :data:`sys.argv` are used."
msgstr ""
"Аргумент *argv* може бути списком параметрів, переданих програмі, з першим "
"елементом, який є назвою програми. Якщо не вказано або ``None``, "
"використовуються значення :data:`sys.argv`."

msgid ""
"The *testRunner* argument can either be a test runner class or an already "
"created instance of it. By default ``main`` calls :func:`sys.exit` with an "
"exit code indicating success or failure of the tests run."
msgstr ""
"Аргумент *testRunner* може бути або класом запуску тестів, або його вже "
"створеним екземпляром. За замовчуванням ``main`` викликає :func:`sys.exit` з "
"кодом виходу, що вказує на успішне або невдале виконання тестів."

msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""
"Аргумент *testLoader* має бути екземпляром :class:`TestLoader` і за "
"умовчанням має значення :data:`defaultTestLoader`."

msgid ""
"``main`` supports being used from the interactive interpreter by passing in "
"the argument ``exit=False``. This displays the result on standard output "
"without calling :func:`sys.exit`::"
msgstr ""
"``main`` підтримує використання з інтерактивного інтерпретатора шляхом "
"передачі аргументу ``exit=False``. Це відображає результат у стандартному "
"виводі без виклику :func:`sys.exit`::"

msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect as "
"the same-name `command-line options`_."
msgstr ""
"Параметри *failfast*, *catchbreak* і *buffer* мають той самий ефект, що й "
"одноіменні параметри командного рядка (`command-line options`_)."

msgid ""
"The *warnings* argument specifies the :ref:`warning filter <warning-filter>` "
"that should be used while running the tests.  If it's not specified, it will "
"remain ``None`` if a :option:`!-W` option is passed to :program:`python` "
"(see :ref:`Warning control <using-on-warnings>`), otherwise it will be set "
"to ``'default'``."
msgstr ""
"Аргумент *попередження* вказує :ref:`фільтр попереджень <warning-filter>`, "
"який слід використовувати під час виконання тестів. Якщо його не вказано, "
"він залишатиметься ``None``, якщо параметр :option:`!-W` передано :program:"
"`python` (див. :ref:`Контроль попередження <using-on-warnings>`), інакше він "
"буде встановлений на ``'за замовчуванням``."

msgid ""
"Calling ``main`` actually returns an instance of the ``TestProgram`` class. "
"This stores the result of the tests run as the ``result`` attribute."
msgstr ""
"Виклик ``main`` фактично повертає екземпляр класу ``TestProgram``. Це "
"зберігає результат виконання тестів як атрибут ``result``."

msgid "The *exit* parameter was added."
msgstr "Додано параметр *exit*."

msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr ""
"Додано параметри *verbosity*, *failfast*, *catchbreak*, *buffer* і "
"*warnings*."

msgid ""
"The *defaultTest* parameter was changed to also accept an iterable of test "
"names."
msgstr ""
"Параметр *defaultTest* було змінено, щоб також приймати ітерацію імен тестів."

msgid "load_tests Protocol"
msgstr "протокол load_tests"

msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr ""
"Модулі або пакунки можуть налаштувати спосіб завантаження тестів з них під "
"час звичайних тестових прогонів або виявлення тестів, реалізувавши функцію "
"під назвою ``load_tests``."

msgid ""
"If a test module defines ``load_tests`` it will be called by :meth:"
"`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""
"Якщо тестовий модуль визначає ``load_tests``, він буде викликаний :meth:"
"`TestLoader.loadTestsFromModule` з такими аргументами::"

msgid ""
"where *pattern* is passed straight through from ``loadTestsFromModule``.  It "
"defaults to ``None``."
msgstr ""
"де *шаблон* передається безпосередньо з ``loadTestsFromModule``. За "
"замовчуванням ``None``."

msgid "It should return a :class:`TestSuite`."
msgstr "Він має повернути :class:`TestSuite`."

msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests "
"from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""
"*loader* — це екземпляр :class:`TestLoader`, який виконує завантаження. "
"*standard_tests* — це тести, які за замовчуванням завантажуватимуться з "
"модуля. Зазвичай тестові модулі хочуть лише додавати або видаляти тести зі "
"стандартного набору тестів. Третій аргумент використовується під час "
"завантаження пакетів у рамках виявлення тесту."

msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of :"
"class:`TestCase` classes may look like::"
msgstr ""
"Типова функція ``load_tests``, яка завантажує тести з певного набору класів :"
"class:`TestCase`, може виглядати так:"

msgid ""
"If discovery is started in a directory containing a package, either from the "
"command line or by calling :meth:`TestLoader.discover`, then the package :"
"file:`__init__.py` will be checked for ``load_tests``.  If that function "
"does not exist, discovery will recurse into the package as though it were "
"just another directory.  Otherwise, discovery of the package's tests will be "
"left up to ``load_tests`` which is called with the following arguments::"
msgstr ""
"Якщо відкриття розпочато в каталозі, що містить пакет, або з командного "
"рядка, або викликом :meth:`TestLoader.discover`, тоді пакет :file:`__init__."
"py` буде перевірено на ``load_tests``. Якщо ця функція не існує, виявлення "
"повториться в пакунку так, ніби це просто інший каталог. В іншому випадку "
"виявлення тестів пакета буде залишено до ``load_tests``, який викликається з "
"такими аргументами::"

msgid ""
"This should return a :class:`TestSuite` representing all the tests from the "
"package. (``standard_tests`` will only contain tests collected from :file:"
"`__init__.py`.)"
msgstr ""
"Це має повернути :class:`TestSuite`, що представляє всі тести з пакета. "
"(``standard_tests`` міститиме лише тести, зібрані з :file:`__init__.py`.)"

msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""
"Оскільки шаблон передається в ``load_tests``, пакунок може продовжувати (і "
"потенційно змінювати) пошук тестів. Функція ``load_tests`` 'нічого не "
"робити' для тестового пакета виглядатиме так:"

msgid ""
"Discovery no longer checks package names for matching *pattern* due to the "
"impossibility of package names matching the default pattern."
msgstr ""
"Discovery більше не перевіряє назви пакетів на відповідність *шаблону* через "
"те, що назви пакетів не відповідають шаблону за замовчуванням."

msgid "Class and Module Fixtures"
msgstr "Фікстури класів і модулів"

msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. When "
"the test suite encounters a test from a new class then :meth:`tearDownClass` "
"from the previous class (if there is one) is called, followed by :meth:"
"`setUpClass` from the new class."
msgstr ""
"Фікстури рівня класу та модуля реалізовано в :class:`TestSuite`. Коли набір "
"тестів зустрічає тест з нового класу, викликається :meth:`tearDownClass` з "
"попереднього класу (якщо він є), а потім :meth:`setUpClass` з нового класу."

msgid ""
"Similarly if a test is from a different module from the previous test then "
"``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""
"Подібним чином, якщо тест виконується з модуля, відмінного від попереднього, "
"тоді запускається ``tearDownModule`` з попереднього модуля, а потім "
"``setUpModule`` з нового модуля."

msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr ""
"Після виконання всіх тестів запускаються остаточні ``tearDownClass`` і "
"``tearDownModule``."

msgid ""
"Note that shared fixtures do not play well with [potential] features like "
"test parallelization and they break test isolation. They should be used with "
"care."
msgstr ""
"Зауважте, що спільні прилади погано працюють із [потенційними] функціями, "
"такими як розпаралелювання тестів, і вони порушують ізоляцію тестів. Їх слід "
"використовувати обережно."

msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will lead "
"to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once per "
"class and module. If you randomize the order, so that tests from different "
"modules and classes are adjacent to each other, then these shared fixture "
"functions may be called multiple times in a single test run."
msgstr ""
"Стандартний порядок тестів, створених завантажувачами тестів unittest, "
"полягає в тому, щоб групувати всі тести з однакових модулів і класів разом. "
"Це призведе до виклику ``setUpClass`` / ``setUpModule`` (і т.д.) рівно один "
"раз для кожного класу та модуля. Якщо ви рандомізуєте порядок, щоб тести з "
"різних модулів і класів були суміжними один з одним, тоді ці спільні функції "
"фікстури можуть викликатися кілька разів під час одного запуску тесту."

msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want to "
"support shared fixtures."
msgstr ""
"Спільні світильники не призначені для роботи з комплектами з нестандартним "
"упорядкуванням. ``BaseTestSuite`` все ще існує для фреймворків, які не "
"хочуть підтримувати спільні фікстури."

msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same "
"interface as a :class:`TestCase`) is created to represent the error. If you "
"are just using the standard unittest test runner then this detail doesn't "
"matter, but if you are a framework author it may be relevant."
msgstr ""
"Якщо є будь-які винятки, викликані під час однієї зі спільних функцій "
"приладу, тест повідомляється як помилка. Оскільки немає відповідного "
"екземпляра тесту, для представлення помилки створюється об’єкт "
"``_ErrorHolder`` (який має той самий інтерфейс, що й :class:`TestCase`). "
"Якщо ви просто використовуєте стандартний модуль тестування, ця деталь не "
"має значення, але якщо ви є автором фреймворку, вона може бути актуальною."

msgid "setUpClass and tearDownClass"
msgstr "setUpClass і tearDownClass"

msgid "These must be implemented as class methods::"
msgstr "Вони повинні бути реалізовані як методи класу:"

msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes called "
"then you must call up to them yourself. The implementations in :class:"
"`TestCase` are empty."
msgstr ""
"Якщо ви хочете викликати ``setUpClass`` і ``tearDownClass`` базових класів, "
"ви повинні викликати їх самостійно. Реалізації в :class:`TestCase` порожні."

msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes will "
"not have ``setUpClass`` or ``tearDownClass`` run. If the exception is a :exc:"
"`SkipTest` exception then the class will be reported as having been skipped "
"instead of as an error."
msgstr ""
"Якщо під час ``setUpClass`` виникає виняток, то тести в класі не "
"запускаються, а ``tearDownClass`` не запускається. Пропущені класи не "
"запускатимуть ``setUpClass`` або ``tearDownClass``. Якщо виняток є винятком :"
"exc:`SkipTest`, тоді клас буде повідомлено як пропущений, а не як помилку."

msgid "setUpModule and tearDownModule"
msgstr "setUpModule і tearDownModule"

msgid "These should be implemented as functions::"
msgstr "Вони повинні бути реалізовані як функції:"

msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in the "
"module will be run and the ``tearDownModule`` will not be run. If the "
"exception is a :exc:`SkipTest` exception then the module will be reported as "
"having been skipped instead of as an error."
msgstr ""
"Якщо в ``setUpModule`` виникає виняток, тоді жоден із тестів у модулі не "
"буде запущено, а ``tearDownModule`` не буде запущено. Якщо виняток є "
"винятком :exc:`SkipTest`, тоді модуль буде повідомлено як пропущений, а не "
"як помилку."

msgid ""
"To add cleanup code that must be run even in the case of an exception, use "
"``addModuleCleanup``:"
msgstr ""
"Щоб додати код очищення, який потрібно запускати навіть у випадку винятку, "
"використовуйте ``addModuleCleanup``:"

msgid ""
"Add a function to be called after :func:`tearDownModule` to cleanup "
"resources used during the test class. Functions will be called in reverse "
"order to the order they are added (:abbr:`LIFO (last-in, first-out)`). They "
"are called with any arguments and keyword arguments passed into :meth:"
"`addModuleCleanup` when they are added."
msgstr ""
"Додайте функцію, яка буде викликатися після :func:`tearDownModule` для "
"очищення ресурсів, використаних під час тестового класу. Функції будуть "
"викликані в порядку, зворотному порядку їх додавання (:abbr:`LIFO (останній "
"прийшов, перший вийшов)`). Вони викликаються з будь-якими аргументами та "
"ключовими аргументами, які передаються в :meth:`addModuleCleanup` під час їх "
"додавання."

msgid ""
"If :meth:`setUpModule` fails, meaning that :func:`tearDownModule` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"Якщо :meth:`setUpModule` не вдається, тобто :func:`tearDownModule` не "
"викликається, тоді будь-які додані функції очищення все одно будуть "
"викликані."

msgid ""
"Enter the supplied :term:`context manager`.  If successful, also add its :"
"meth:`~object.__exit__` method as a cleanup function by :func:"
"`addModuleCleanup` and return the result of the :meth:`~object.__enter__` "
"method."
msgstr ""

msgid ""
"This function is called unconditionally after :func:`tearDownModule`, or "
"after :func:`setUpModule` if :func:`setUpModule` raises an exception."
msgstr ""
"Ця функція викликається безумовно після :func:`tearDownModule` або після :"
"func:`setUpModule`, якщо :func:`setUpModule` викликає виняткову ситуацію."

msgid ""
"It is responsible for calling all the cleanup functions added by :func:"
"`addModuleCleanup`. If you need cleanup functions to be called *prior* to :"
"func:`tearDownModule` then you can call :func:`doModuleCleanups` yourself."
msgstr ""
"Він відповідає за виклик усіх функцій очищення, доданих :func:"
"`addModuleCleanup`. Якщо вам потрібно, щоб функції очищення викликалися "
"*перед* :func:`tearDownModule`, ви можете викликати :func:`doModuleCleanups` "
"самостійно."

msgid ""
":func:`doModuleCleanups` pops methods off the stack of cleanup functions one "
"at a time, so it can be called at any time."
msgstr ""
":func:`doModuleCleanups` витягує методи зі стеку функцій очищення по одному, "
"тому їх можна викликати будь-коли."

msgid "Signal Handling"
msgstr "Обробка сигналів"

msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main()`, provide "
"more friendly handling of control-C during a test run. With catch break "
"behavior enabled control-C will allow the currently running test to "
"complete, and the test run will then end and report all the results so far. "
"A second control-c will raise a :exc:`KeyboardInterrupt` in the usual way."
msgstr ""
"Параметр командного рядка :option:`-c/--catch <unittest -c>` для unittest "
"разом із параметром ``catchbreak`` для :func:`unittest.main()` забезпечують "
"більш зручну обробку control-C під час пробний запуск. Якщо ввімкнути "
"поведінку catch break, Control-C дозволить завершити поточний тест, після "
"чого тестовий запуск завершиться та повідомить усі результати. Другий "
"control-c викличе :exc:`KeyboardInterrupt` у звичайний спосіб."

msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If the "
"``unittest`` handler is called but *isn't* the installed :const:`signal."
"SIGINT` handler, i.e. it has been replaced by the system under test and "
"delegated to, then it calls the default handler. This will normally be the "
"expected behavior by code that replaces an installed handler and delegates "
"to it. For individual tests that need ``unittest`` control-c handling "
"disabled the :func:`removeHandler` decorator can be used."
msgstr ""
"Обробник сигналів обробки control-c намагається залишатися сумісним із кодом "
"або тестами, які встановлюють власний обробник :const:`signal.SIGINT`. Якщо "
"обробник ``unittest`` викликається, але *не* встановлений обробник :const:"
"`signal.SIGINT`, тобто він був замінений тестованою системою та делегований, "
"тоді він викликає обробник за замовчуванням. Зазвичай це буде очікувана "
"поведінка коду, який замінює встановлений обробник і делегує йому. Для "
"окремих тестів, які потребують вимкнення обробки ``unittest`` control-c, "
"можна використовувати декоратор :func:`removeHandler`."

msgid ""
"There are a few utility functions for framework authors to enable control-c "
"handling functionality within test frameworks."
msgstr ""
"Існує кілька службових функцій для авторів фреймворків, щоб увімкнути "
"функціональність обробки control-c у тестових фреймворках."

msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered results "
"have :meth:`~TestResult.stop` called."
msgstr ""
"Встановіть обробник control-c. Коли отримано :const:`signal.SIGINT` "
"(зазвичай у відповідь на натискання користувачем control-c), усі "
"зареєстровані результати викликають :meth:`~TestResult.stop`."

msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering a "
"result stores a weak reference to it, so it doesn't prevent the result from "
"being garbage collected."
msgstr ""
"Зареєструйте об’єкт :class:`TestResult` для обробки control-c. Реєстрація "
"результату зберігає слабке посилання на нього, тому це не запобігає збиранню "
"сміття результату."

msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c "
"handling is not enabled, so test frameworks can unconditionally register all "
"results they create independently of whether or not handling is enabled."
msgstr ""
"Реєстрація об’єкта :class:`TestResult` не має побічних ефектів, якщо обробку "
"control-c не ввімкнено, тому тестові фреймворки можуть беззастережно "
"реєструвати всі створені ними результати незалежно від того, увімкнено "
"обробку чи ні."

msgid ""
"Remove a registered result. Once a result has been removed then :meth:"
"`~TestResult.stop` will no longer be called on that result object in "
"response to a control-c."
msgstr ""
"Видалити зареєстрований результат. Після видалення результату :meth:"
"`~TestResult.stop` більше не викликатиметься для цього об’єкта результату у "
"відповідь на control-c."

msgid ""
"When called without arguments this function removes the control-c handler if "
"it has been installed. This function can also be used as a test decorator to "
"temporarily remove the handler while the test is being executed::"
msgstr ""
"При виклику без аргументів ця функція видаляє обробник control-c, якщо він "
"був встановлений. Цю функцію також можна використовувати як декоратор тесту "
"для тимчасового видалення обробника під час виконання тесту:"
