# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`array` --- Efficient arrays of numeric values"
msgstr ":mod:`array` --- Ефективні масиви числових значень"

msgid ""
"This module defines an object type which can compactly represent an array of "
"basic values: characters, integers, floating point numbers.  Arrays are "
"sequence types and behave very much like lists, except that the type of "
"objects stored in them is constrained.  The type is specified at object "
"creation time by using a :dfn:`type code`, which is a single character.  The "
"following type codes are defined:"
msgstr ""
"Цей модуль визначає тип об’єкта, який може компактно представляти масив "
"основних значень: символів, цілих чисел, чисел з плаваючою комою. Масиви є "
"типами послідовностей і поводяться дуже подібно до списків, за винятком "
"того, що тип об’єктів, які в них зберігаються, обмежений. Тип вказується під "
"час створення об’єкта за допомогою :dfn:`type code`, який є одним символом. "
"Визначаються такі коди типів:"

msgid "Type code"
msgstr "Введіть код"

msgid "C Type"
msgstr "C Тип"

msgid "Python Type"
msgstr "Тип Python"

msgid "Minimum size in bytes"
msgstr "Мінімальний розмір у байтах"

msgid "Notes"
msgstr "Примітки"

msgid "``'b'``"
msgstr "``'b''``"

msgid "signed char"
msgstr "підписаний символ"

msgid "int"
msgstr "внутр"

msgid "1"
msgstr "1"

msgid "``'B'``"
msgstr "``'B'``"

msgid "unsigned char"
msgstr "беззнаковий символ"

msgid "``'u'``"
msgstr "``'u''``"

msgid "wchar_t"
msgstr "wchar_t"

msgid "Unicode character"
msgstr "символ Unicode"

msgid "2"
msgstr "2"

msgid "\\(1)"
msgstr "\\(1)"

msgid "``'h'``"
msgstr "``'h''``"

msgid "signed short"
msgstr "підписаний короткий"

msgid "``'H'``"
msgstr "``'H''``"

msgid "unsigned short"
msgstr "непідписаний короткий"

msgid "``'i'``"
msgstr "``'я''``"

msgid "signed int"
msgstr "підписаний внутр"

msgid "``'I'``"
msgstr "``'Я''``"

msgid "unsigned int"
msgstr "unsigned int"

msgid "``'l'``"
msgstr "``'l'``"

msgid "signed long"
msgstr "підписаний довго"

msgid "4"
msgstr "4"

msgid "``'L'``"
msgstr "``'L'``"

msgid "unsigned long"
msgstr "беззнаковий довгий"

msgid "``'q'``"
msgstr "``'q''``"

msgid "signed long long"
msgstr "підписаний довгий довгий"

msgid "8"
msgstr "8"

msgid "``'Q'``"
msgstr "``'Q''``"

msgid "unsigned long long"
msgstr "без знака довгий довгий"

msgid "``'f'``"
msgstr "``'f''``"

msgid "float"
msgstr "плавати"

msgid "``'d'``"
msgstr "``'d''``"

msgid "double"
msgstr "подвійний"

msgid "Notes:"
msgstr "Примітки:"

msgid "It can be 16 bits or 32 bits depending on the platform."
msgstr "Це може бути 16 або 32 біти залежно від платформи."

msgid ""
"``array('u')`` now uses ``wchar_t`` as C type instead of deprecated "
"``Py_UNICODE``. This change doesn't affect its behavior because "
"``Py_UNICODE`` is alias of ``wchar_t`` since Python 3.3."
msgstr ""
"``array('u')`` тепер використовує ``wchar_t`` як тип C замість застарілого "
"``Py_UNICODE``. Ця зміна не впливає на його поведінку, оскільки "
"``Py_UNICODE`` є псевдонімом ``wchar_t``, починаючи з Python 3.3."

msgid ""
"The actual representation of values is determined by the machine "
"architecture (strictly speaking, by the C implementation).  The actual size "
"can be accessed through the :attr:`itemsize` attribute."
msgstr ""
"Фактичне представлення значень визначається архітектурою машини (строго "
"кажучи, реалізацією C). Фактичний розмір можна отримати через атрибут :attr:"
"`itemsize`."

msgid "The module defines the following type:"
msgstr "Модуль визначає наступний тип:"

msgid ""
"A new array whose items are restricted by *typecode*, and initialized from "
"the optional *initializer* value, which must be a list, a :term:`bytes-like "
"object`, or iterable over elements of the appropriate type."
msgstr ""
"Новий масив, елементи якого обмежені *typecode* та ініціалізуються "
"необов’язковим значенням *ініціалізатора*, яке має бути списком, :term:"
"`bytes-like object` або повторюваним над елементами відповідного типу."

msgid ""
"If given a list or string, the initializer is passed to the new array's :"
"meth:`fromlist`, :meth:`frombytes`, or :meth:`fromunicode` method (see "
"below) to add initial items to the array.  Otherwise, the iterable "
"initializer is passed to the :meth:`extend` method."
msgstr ""
"Якщо задано список або рядок, ініціалізатор передається в новий метод :meth:"
"`fromlist`, :meth:`frombytes` або :meth:`fromunicode` нового масиву (див. "
"нижче), щоб додати початкові елементи до масиву. В іншому випадку "
"ітераційний ініціалізатор передається в метод :meth:`extend`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``array.__new__`` with arguments "
"``typecode``, ``initializer``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``array.__new__`` з аргументами "
"``typecode``, ``initializer``."

msgid "A string with all available type codes."
msgstr "Рядок із усіма доступними кодами типів."

msgid ""
"Array objects support the ordinary sequence operations of indexing, slicing, "
"concatenation, and multiplication.  When using slice assignment, the "
"assigned value must be an array object with the same type code; in all other "
"cases, :exc:`TypeError` is raised. Array objects also implement the buffer "
"interface, and may be used wherever :term:`bytes-like objects <bytes-like "
"object>` are supported."
msgstr ""
"Об’єкти-масиви підтримують звичайні операції послідовності індексування, "
"нарізки, конкатенації та множення. Якщо використовується призначення "
"фрагментів, призначене значення має бути об’єктом масиву з таким же кодом "
"типу; у всіх інших випадках виникає :exc:`TypeError`. Об’єкти-масиви також "
"реалізують інтерфейс буфера, і їх можна використовувати скрізь, де "
"підтримуються :term:`байтоподібні об’єкти <bytes-like object>`."

msgid "The following data items and methods are also supported:"
msgstr "Також підтримуються такі елементи даних і методи:"

msgid "The typecode character used to create the array."
msgstr "Символ коду типу, який використовується для створення масиву."

msgid "The length in bytes of one array item in the internal representation."
msgstr "Довжина в байтах одного елемента масиву у внутрішньому представленні."

msgid "Append a new item with value *x* to the end of the array."
msgstr "Додайте новий елемент зі значенням *x* у кінець масиву."

msgid ""
"Return a tuple ``(address, length)`` giving the current memory address and "
"the length in elements of the buffer used to hold array's contents.  The "
"size of the memory buffer in bytes can be computed as ``array.buffer_info()"
"[1] * array.itemsize``.  This is occasionally useful when working with low-"
"level (and inherently unsafe) I/O interfaces that require memory addresses, "
"such as certain :c:func:`ioctl` operations.  The returned numbers are valid "
"as long as the array exists and no length-changing operations are applied to "
"it."
msgstr ""
"Повертає кортеж ``(адреса, довжина)``, що вказує поточну адресу пам’яті та "
"довжину в елементах буфера, який використовується для зберігання вмісту "
"масиву. Розмір буфера пам'яті в байтах можна обчислити як ``array."
"buffer_info()[1] * array.itemsize``. Іноді це корисно під час роботи з "
"низькорівневими (і за своєю суттю небезпечними) інтерфейсами вводу/виводу, "
"які вимагають адреси пам’яті, наприклад певні операції :c:func:`ioctl`. "
"Повернені числа дійсні, доки існує масив і до нього не застосовуються "
"операції зміни довжини."

msgid ""
"When using array objects from code written in C or C++ (the only way to "
"effectively make use of this information), it makes more sense to use the "
"buffer interface supported by array objects.  This method is maintained for "
"backward compatibility and should be avoided in new code.  The buffer "
"interface is documented in :ref:`bufferobjects`."
msgstr ""
"При використанні об’єктів масиву з коду, написаного на C або C++ (єдиний "
"спосіб ефективного використання цієї інформації), має сенс використовувати "
"інтерфейс буфера, який підтримується об’єктами масиву. Цей метод "
"підтримується для зворотної сумісності, і його слід уникати в новому коді. "
"Інтерфейс буфера задокументовано в :ref:`bufferobjects`."

msgid ""
"\"Byteswap\" all items of the array.  This is only supported for values "
"which are 1, 2, 4, or 8 bytes in size; for other types of values, :exc:"
"`RuntimeError` is raised.  It is useful when reading data from a file "
"written on a machine with a different byte order."
msgstr ""
"\"Побайтувати\" всі елементи масиву. Це підтримується лише для значень "
"розміром 1, 2, 4 або 8 байтів; для інших типів значень виникає :exc:"
"`RuntimeError`. Це корисно під час читання даних із файлу, записаного на "
"машині з іншим порядком байтів."

msgid "Return the number of occurrences of *x* in the array."
msgstr "Повертає кількість входжень *x* в масиві."

msgid ""
"Append items from *iterable* to the end of the array.  If *iterable* is "
"another array, it must have *exactly* the same type code; if not, :exc:"
"`TypeError` will be raised.  If *iterable* is not an array, it must be "
"iterable and its elements must be the right type to be appended to the array."
msgstr ""
"Додайте елементи з *iterable* у кінець масиву. Якщо *iterable* є іншим "
"масивом, він повинен мати *точно* той самий код типу; якщо ні, буде "
"викликано :exc:`TypeError`. Якщо *iterable* не є масивом, він має бути "
"повторюваним, а його елементи мають мати правильний тип для додавання до "
"масиву."

msgid ""
"Appends items from the string, interpreting the string as an array of "
"machine values (as if it had been read from a file using the :meth:"
"`fromfile` method)."
msgstr ""
"Додає елементи з рядка, інтерпретуючи рядок як масив машинних значень (наче "
"його було прочитано з файлу за допомогою методу :meth:`fromfile`)."

msgid ":meth:`fromstring` is renamed to :meth:`frombytes` for clarity."
msgstr ":meth:`fromstring` перейменовано на :meth:`frombytes` для ясності."

msgid ""
"Read *n* items (as machine values) from the :term:`file object` *f* and "
"append them to the end of the array.  If less than *n* items are available, :"
"exc:`EOFError` is raised, but the items that were available are still "
"inserted into the array."
msgstr ""
"Прочитайте *n* елементів (як машинні значення) з :term:`file object` *f* і "
"додайте їх у кінець масиву. Якщо доступно менше *n* елементів, виникає :exc:"
"`EOFError`, але доступні елементи все одно вставляються в масив."

msgid ""
"Append items from the list.  This is equivalent to ``for x in list: a."
"append(x)`` except that if there is a type error, the array is unchanged."
msgstr ""
"Додавання елементів зі списку. Це еквівалентно ``для x у списку: a."
"append(x)`` за винятком того, що якщо є помилка типу, масив не змінюється."

msgid ""
"Extends this array with data from the given unicode string.  The array must "
"be a type ``'u'`` array; otherwise a :exc:`ValueError` is raised.  Use "
"``array.frombytes(unicodestring.encode(enc))`` to append Unicode data to an "
"array of some other type."
msgstr ""
"Розширює цей масив даними з заданого рядка Юнікод. Масив має бути масиву "
"типу ``'u''``; інакше виникає помилка :exc:`ValueError`. Використовуйте "
"``array.frombytes(unicodestring.encode(enc))``, щоб додати дані Unicode до "
"масиву іншого типу."

msgid ""
"Return the smallest *i* such that *i* is the index of the first occurrence "
"of *x* in the array.  The optional arguments *start* and *stop* can be "
"specified to search for *x* within a subsection of the array.  Raise :exc:"
"`ValueError` if *x* is not found."
msgstr ""
"Повертає найменше *i* таке, що *i* є індексом першого входження *x* в "
"масиві. Для пошуку *x* у підрозділі масиву можна вказати необов’язкові "
"аргументи *start* і *stop*. Викликати :exc:`ValueError`, якщо *x* не "
"знайдено."

msgid "Added optional *start* and *stop* parameters."
msgstr "Додано додаткові параметри *start* і *stop*."

msgid ""
"Insert a new item with value *x* in the array before position *i*. Negative "
"values are treated as being relative to the end of the array."
msgstr ""
"Вставте новий елемент зі значенням *x* в масив перед позицією *i*. Від’ємні "
"значення розглядаються як відносні до кінця масиву."

msgid ""
"Removes the item with the index *i* from the array and returns it. The "
"optional argument defaults to ``-1``, so that by default the last item is "
"removed and returned."
msgstr ""
"Вилучає з масиву елемент з індексом *i* і повертає його. Необов’язковий "
"аргумент за умовчанням має значення ``-1``, тому за замовчуванням останній "
"елемент видаляється та повертається."

msgid "Remove the first occurrence of *x* from the array."
msgstr "Видаліть перше входження *x* з масиву."

msgid "Reverse the order of the items in the array."
msgstr "Змінити порядок елементів у масиві."

msgid ""
"Convert the array to an array of machine values and return the bytes "
"representation (the same sequence of bytes that would be written to a file "
"by the :meth:`tofile` method.)"
msgstr ""
"Перетворіть масив на масив машинних значень і поверніть представлення байтів "
"(та сама послідовність байтів, яка була б записана у файл за допомогою "
"методу :meth:`tofile`)."

msgid ":meth:`tostring` is renamed to :meth:`tobytes` for clarity."
msgstr ":meth:`tostring` перейменовано на :meth:`tobytes` для ясності."

msgid "Write all items (as machine values) to the :term:`file object` *f*."
msgstr "Запишіть усі елементи (як машинні значення) в :term:`file object` *f*."

msgid "Convert the array to an ordinary list with the same items."
msgstr "Перетворіть масив на звичайний список з тими самими елементами."

msgid ""
"Convert the array to a unicode string.  The array must be a type ``'u'`` "
"array; otherwise a :exc:`ValueError` is raised. Use ``array.tobytes()."
"decode(enc)`` to obtain a unicode string from an array of some other type."
msgstr ""
"Перетворіть масив на рядок Unicode. Масив має бути масиву типу ``'u''``; "
"інакше виникає помилка :exc:`ValueError`. Використовуйте ``array.tobytes()."
"decode(enc)``, щоб отримати рядок Юнікод із масиву іншого типу."

msgid ""
"When an array object is printed or converted to a string, it is represented "
"as ``array(typecode, initializer)``.  The *initializer* is omitted if the "
"array is empty, otherwise it is a string if the *typecode* is ``'u'``, "
"otherwise it is a list of numbers.  The string is guaranteed to be able to "
"be converted back to an array with the same type and value using :func:"
"`eval`, so long as the :class:`~array.array` class has been imported using "
"``from array import array``. Examples::"
msgstr ""
"Коли об’єкт масиву друкується або перетворюється на рядок, він "
"представляється як ``array(typecode, initializer)``. *Ініціалізатор* "
"пропускається, якщо масив порожній, інакше це рядок, якщо *код типу* є "
"``'u'``, інакше це список чисел. Гарантовано, що рядок можна буде "
"перетворити назад на масив із тим самим типом і значенням за допомогою :func:"
"`eval`, якщо клас :class:`~array.array` було імпортовано за допомогою ``from "
"array import array``. Приклади::"

msgid "Module :mod:`struct`"
msgstr "Модуль :mod:`struct`"

msgid "Packing and unpacking of heterogeneous binary data."
msgstr "Упаковка та розпакування різнорідних двійкових даних."

msgid "Module :mod:`xdrlib`"
msgstr "Модуль :mod:`xdrlib`"

msgid ""
"Packing and unpacking of External Data Representation (XDR) data as used in "
"some remote procedure call systems."
msgstr ""
"Пакування та розпакування даних зовнішнього представлення даних (XDR), які "
"використовуються в деяких системах віддаленого виклику процедур."

msgid "`NumPy <https://numpy.org/>`_"
msgstr "`NumPy <https://numpy.org/>`_"

msgid "The NumPy package defines another array type."
msgstr "Пакет NumPy визначає інший тип масиву."
