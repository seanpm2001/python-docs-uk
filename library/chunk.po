# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:56+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`chunk` --- Read IFF chunked data"
msgstr ":mod:`chunk` --- Читання фрагментованих даних IFF"

msgid "**Source code:** :source:`Lib/chunk.py`"
msgstr "**Вихідний код:** :source:`Lib/chunk.py`"

msgid ""
"The :mod:`chunk` module is deprecated (see :pep:`PEP 594 <594#chunk>` for "
"details)."
msgstr ""
"Модуль :mod:`chunk` є застарілим (див. :pep:`PEP 594 <594#chunk>` для "
"деталей)."

msgid ""
"This module provides an interface for reading files that use EA IFF 85 "
"chunks. [#]_  This format is used in at least the Audio Interchange File "
"Format (AIFF/AIFF-C) and the Real Media File Format (RMFF).  The WAVE audio "
"file format is closely related and can also be read using this module."
msgstr ""
"Цей модуль забезпечує інтерфейс для читання файлів, які використовують "
"фрагменти EA IFF 85. [#]_ Цей формат використовується принаймні у форматі "
"файлів обміну аудіофайлами (AIFF/AIFF-C) і форматі реальних медіафайлів "
"(RMFF). Формат аудіофайлу WAVE тісно пов’язаний і його також можна читати за "
"допомогою цього модуля."

msgid "A chunk has the following structure:"
msgstr "Чанк має таку структуру:"

msgid "Offset"
msgstr "Зсув"

msgid "Length"
msgstr "Довжина"

msgid "Contents"
msgstr "Зміст"

msgid "0"
msgstr "0"

msgid "4"
msgstr "4"

msgid "Chunk ID"
msgstr "ID блоку"

msgid "Size of chunk in big-endian byte order, not including the header"
msgstr "Розмір блоку в порядку байтів у порядку байтів, не включаючи заголовок"

msgid "8"
msgstr "8"

msgid "*n*"
msgstr "*n*"

msgid "Data bytes, where *n* is the size given in the preceding field"
msgstr "Байти даних, де *n* — розмір, указаний у попередньому полі"

msgid "8 + *n*"
msgstr "8 + *n*"

msgid "0 or 1"
msgstr "0 або 1"

msgid "Pad byte needed if *n* is odd and chunk alignment is used"
msgstr ""
"Якщо *n* є непарним і використовується вирівнювання фрагментів, необхідний "
"байт заповнення"

msgid "The ID is a 4-byte string which identifies the type of chunk."
msgstr ""
"Ідентифікатор — це 4-байтовий рядок, який ідентифікує тип послідовності."

msgid ""
"The size field (a 32-bit value, encoded using big-endian byte order) gives "
"the size of the chunk data, not including the 8-byte header."
msgstr ""
"Поле розміру (32-бітне значення, закодоване з використанням порядку байтів у "
"порядку байтів) визначає розмір даних фрагмента, не враховуючи 8-байтовий "
"заголовок."

msgid ""
"Usually an IFF-type file consists of one or more chunks.  The proposed usage "
"of the :class:`Chunk` class defined here is to instantiate an instance at "
"the start of each chunk and read from the instance until it reaches the end, "
"after which a new instance can be instantiated. At the end of the file, "
"creating a new instance will fail with an :exc:`EOFError` exception."
msgstr ""
"Зазвичай файл типу IFF складається з одного або кількох блоків. Пропоноване "
"використання визначеного тут класу :class:`Chunk` полягає в створенні "
"екземпляра на початку кожного блоку та читанні з екземпляра, доки він не "
"досягне кінця, після чого може бути створений новий екземпляр. У кінці файлу "
"створити новий екземпляр не вдасться з виключенням :exc:`EOFError`."

msgid ""
"Class which represents a chunk.  The *file* argument is expected to be a "
"file-like object.  An instance of this class is specifically allowed.  The "
"only method that is needed is :meth:`~io.IOBase.read`.  If the methods :meth:"
"`~io.IOBase.seek` and :meth:`~io.IOBase.tell` are present and don't raise an "
"exception, they are also used. If these methods are present and raise an "
"exception, they are expected to not have altered the object.  If the "
"optional argument *align* is true, chunks are assumed to be aligned on 2-"
"byte boundaries.  If *align* is false, no alignment is assumed.  The default "
"value is true.  If the optional argument *bigendian* is false, the chunk "
"size is assumed to be in little-endian order. This is needed for WAVE audio "
"files. The default value is true.  If the optional argument *inclheader* is "
"true, the size given in the chunk header includes the size of the header.  "
"The default value is false."
msgstr ""
"Клас, який представляє фрагмент. Очікується, що аргумент *file* буде "
"файлоподібним об’єктом. Примірник цього класу спеціально дозволений. Єдиний "
"потрібний метод це :meth:`~io.IOBase.read`. Якщо методи :meth:`~io.IOBase."
"seek` і :meth:`~io.IOBase.tell` присутні й не викликають виняткової "
"ситуації, вони також використовуються. Якщо ці методи присутні та викликають "
"виключення, очікується, що вони не змінили об’єкт. Якщо додатковий аргумент "
"*align* має значення true, блоки вважаються вирівняними за 2-байтовими "
"межами. Якщо *align* має значення false, вирівнювання не передбачається. "
"Значення за замовчуванням - true. Якщо необов’язковий аргумент *bigendian* є "
"хибним, розмір блоку вважається таким, що має порядок кінців від маленького. "
"Це потрібно для аудіофайлів WAVE. Значення за замовчуванням - true. Якщо "
"необов’язковий аргумент *inclheader* має значення true, розмір, указаний у "
"заголовку блоку, включає розмір заголовка. Значення за замовчуванням - false."

msgid "A :class:`Chunk` object supports the following methods:"
msgstr "Об’єкт :class:`Chunk` підтримує такі методи:"

msgid ""
"Returns the name (ID) of the chunk.  This is the first 4 bytes of the chunk."
msgstr "Повертає назву (ID) блоку. Це перші 4 байти блоку."

msgid "Returns the size of the chunk."
msgstr "Повертає розмір шматка."

msgid ""
"Close and skip to the end of the chunk.  This does not close the underlying "
"file."
msgstr "Закрийте та пропустіть до кінця шматка. Це не закриває основний файл."

msgid ""
"The remaining methods will raise :exc:`OSError` if called after the :meth:"
"`close` method has been called.  Before Python 3.3, they used to raise :exc:"
"`IOError`, now an alias of :exc:`OSError`."
msgstr ""
"Решта методів викличуть :exc:`OSError`, якщо їх викликати після виклику "
"методу :meth:`close`. До Python 3.3 вони викликали :exc:`IOError`, тепер це "
"псевдонім :exc:`OSError`."

msgid "Returns ``False``."
msgstr "Повертає ``False``."

msgid ""
"Set the chunk's current position.  The *whence* argument is optional and "
"defaults to ``0`` (absolute file positioning); other values are ``1`` (seek "
"relative to the current position) and ``2`` (seek relative to the file's "
"end).  There is no return value. If the underlying file does not allow seek, "
"only forward seeks are allowed."
msgstr ""
"Установіть поточну позицію фрагмента. Аргумент *whence* є необов’язковим і "
"за умовчанням має значення ``0`` (абсолютне розташування файлу); іншими "
"значеннями є ``1`` (пошук відносно поточної позиції) і ``2`` (пошук відносно "
"кінця файлу). Поверненого значення немає. Якщо основний файл не підтримує "
"пошук, дозволений лише пошук вперед."

msgid "Return the current position into the chunk."
msgstr "Повернути поточну позицію в блок."

msgid ""
"Read at most *size* bytes from the chunk (less if the read hits the end of "
"the chunk before obtaining *size* bytes).  If the *size* argument is "
"negative or omitted, read all data until the end of the chunk.  An empty "
"bytes object is returned when the end of the chunk is encountered "
"immediately."
msgstr ""
"Зчитувати щонайбільше *size* байтів із блоку (менше, якщо зчитування досягає "
"кінця фрагмента до отримання *size* байтів). Якщо аргумент *size* від’ємний "
"або пропущений, читайте всі дані до кінця блоку. Порожній байтовий об’єкт "
"повертається, коли відразу зустрічається кінець блоку."

msgid ""
"Skip to the end of the chunk.  All further calls to :meth:`read` for the "
"chunk will return ``b''``.  If you are not interested in the contents of the "
"chunk, this method should be called so that the file points to the start of "
"the next chunk."
msgstr ""
"Перейти до кінця шматка. Усі подальші виклики :meth:`read` для блоку "
"повертатимуть ``b''``. Якщо вас не цікавить вміст фрагмента, цей метод слід "
"викликати так, щоб файл вказував на початок наступного фрагменту."

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"\"EA IFF 85\" Standard for Interchange Format Files, Jerry Morrison, "
"Electronic Arts, January 1985."
msgstr ""
"\"EA IFF 85\" Стандарт для файлів формату обміну, Джеррі Моррісон, "
"Electronic Arts, січень 1985 р."
