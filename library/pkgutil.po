# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:11+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`pkgutil` --- Package extension utility"
msgstr ":mod:`pkgutil` --- Утиліта розширення пакунків"

msgid "**Source code:** :source:`Lib/pkgutil.py`"
msgstr "**Вихідний код:** :source:`Lib/pkgutil.py`"

msgid ""
"This module provides utilities for the import system, in particular package "
"support."
msgstr ""
"Цей модуль надає утиліти для системи імпорту, зокрема підтримку пакетів."

msgid "A namedtuple that holds a brief summary of a module's info."
msgstr "Іменований кортеж, який містить короткий опис інформації про модуль."

msgid ""
"Extend the search path for the modules which comprise a package.  Intended "
"use is to place the following code in a package's :file:`__init__.py`::"
msgstr ""
"Розширте шлях пошуку для модулів, які складають пакет. Цільове використання "
"– розмістити наступний код у :file:`__init__.py`::"

msgid ""
"This will add to the package's ``__path__`` all subdirectories of "
"directories on :data:`sys.path` named after the package.  This is useful if "
"one wants to distribute different parts of a single logical package as "
"multiple directories."
msgstr ""
"Це додасть до ``__path__`` пакета всі підкаталоги каталогів у :data:`sys."
"path`, названі на честь пакета. Це корисно, якщо потрібно розповсюдити різні "
"частини одного логічного пакета як кілька каталогів."

msgid ""
"It also looks for :file:`\\*.pkg` files beginning where ``*`` matches the "
"*name* argument.  This feature is similar to :file:`\\*.pth` files (see the :"
"mod:`site` module for more information), except that it doesn't special-case "
"lines starting with ``import``.  A :file:`\\*.pkg` file is trusted at face "
"value: apart from checking for duplicates, all entries found in a :file:`\\*."
"pkg` file are added to the path, regardless of whether they exist on the "
"filesystem.  (This is a feature.)"
msgstr ""
"Він також шукає файли :file:`\\*.pkg`, які починаються там, де ``*`` "
"відповідає аргументу *name*. Ця функція подібна до файлів :file:`\\*.pth` "
"(дивіться модуль :mod:`site` для отримання додаткової інформації), за "
"винятком того, що вона не використовує рядки спеціального регістру, які "
"починаються з ``import``. Файл :file:`\\*.pkg` є надійним: окрім перевірки "
"на наявність дублікатів, усі записи, знайдені у файлі :file:`\\*.pkg`, "
"додаються до шляху, незалежно від того, чи існують вони на файлова система. "
"(Це функція.)"

msgid ""
"If the input path is not a list (as is the case for frozen packages) it is "
"returned unchanged.  The input path is not modified; an extended copy is "
"returned.  Items are only appended to the copy at the end."
msgstr ""
"Якщо шлях введення не є списком (як у випадку заморожених пакунків), він "
"повертається без змін. Вхідний шлях не змінено; повертається розширена "
"копія. Елементи додаються до копії лише в кінці."

msgid ""
"It is assumed that :data:`sys.path` is a sequence.  Items of :data:`sys."
"path` that are not strings referring to existing directories are ignored. "
"Unicode items on :data:`sys.path` that cause errors when used as filenames "
"may cause this function to raise an exception (in line with :func:`os.path."
"isdir` behavior)."
msgstr ""
"Передбачається, що :data:`sys.path` є послідовністю. Елементи :data:`sys."
"path`, які не є рядками, що посилаються на існуючі каталоги, ігноруються. "
"Елементи Юнікоду в :data:`sys.path`, які спричиняють помилки, коли "
"використовуються як імена файлів, можуть викликати виняток у цій функції "
"(відповідно до поведінки :func:`os.path.isdir`)."

msgid ":pep:`302` Finder that wraps Python's \"classic\" import algorithm."
msgstr ":pep:`302` Шукач, який обертає \"класичний\" алгоритм імпорту Python."

msgid ""
"If *dirname* is a string, a :pep:`302` finder is created that searches that "
"directory.  If *dirname* is ``None``, a :pep:`302` finder is created that "
"searches the current :data:`sys.path`, plus any modules that are frozen or "
"built-in."
msgstr ""
"Якщо *dirname* є рядком, створюється засіб пошуку :pep:`302`, який шукає в "
"цьому каталозі. Якщо *dirname* має значення ``None``, створюється засіб "
"пошуку :pep:`302`, який шукає поточний :data:`sys.path`, а також будь-які "
"модулі, які заморожені або вбудовані."

msgid ""
"Note that :class:`ImpImporter` does not currently support being used by "
"placement on :data:`sys.meta_path`."
msgstr ""
"Зауважте, що :class:`ImpImporter` наразі не підтримує використання шляхом "
"розміщення на :data:`sys.meta_path`."

msgid ""
"This emulation is no longer needed, as the standard import mechanism is now "
"fully :pep:`302` compliant and available in :mod:`importlib`."
msgstr ""
"Ця емуляція більше не потрібна, оскільки стандартний механізм імпорту тепер "
"повністю сумісний із :pep:`302` і доступний у :mod:`importlib`."

msgid ""
":term:`Loader <loader>` that wraps Python's \"classic\" import algorithm."
msgstr ""
":term:`Loader <loader>`, який обертає \"класичний\" алгоритм імпорту Python."

msgid "Retrieve a module :term:`loader` for the given *fullname*."
msgstr "Отримати модуль :term:`loader` для вказаного *повного імені*."

msgid ""
"This is a backwards compatibility wrapper around :func:`importlib.util."
"find_spec` that converts most failures to :exc:`ImportError` and only "
"returns the loader rather than the full :class:`ModuleSpec`."
msgstr ""
"Це обгортка зворотної сумісності навколо :func:`importlib.util.find_spec`, "
"яка перетворює більшість помилок на :exc:`ImportError` і повертає лише "
"завантажувач, а не повний :class:`ModuleSpec`."

msgid ""
"Updated to be based directly on :mod:`importlib` rather than relying on the "
"package internal :pep:`302` import emulation."
msgstr ""
"Оновлено, щоб базуватися безпосередньо на :mod:`importlib`, а не на "
"внутрішній емуляції імпорту :pep:`302` пакета."

msgid "Updated to be based on :pep:`451`"
msgstr "Оновлено на основі :pep:`451`"

msgid "Retrieve a :term:`finder` for the given *path_item*."
msgstr "Отримати :term:`finder` для заданого *path_item*."

msgid ""
"The returned finder is cached in :data:`sys.path_importer_cache` if it was "
"newly created by a path hook."
msgstr ""
"Повернений засіб пошуку зберігається в :data:`sys.path_importer_cache`, якщо "
"він був щойно створений за допомогою перехоплювача шляху."

msgid ""
"The cache (or part of it) can be cleared manually if a rescan of :data:`sys."
"path_hooks` is necessary."
msgstr ""
"Кеш (або його частину) можна очистити вручну, якщо потрібно повторне "
"сканування :data:`sys.path_hooks`."

msgid "Get a :term:`loader` object for *module_or_name*."
msgstr "Отримайте об’єкт :term:`loader` для *module_or_name*."

msgid ""
"If the module or package is accessible via the normal import mechanism, a "
"wrapper around the relevant part of that machinery is returned.  Returns "
"``None`` if the module cannot be found or imported.  If the named module is "
"not already imported, its containing package (if any) is imported, in order "
"to establish the package ``__path__``."
msgstr ""
"Якщо модуль або пакет доступні через звичайний механізм імпорту, "
"повертається обгортка навколо відповідної частини цього механізму. Повертає "
"``None``, якщо модуль неможливо знайти або імпортувати. Якщо вказаний модуль "
"ще не імпортовано, його пакет (якщо є) імпортується, щоб створити пакет "
"``__path__``."

msgid "Yield :term:`finder` objects for the given module name."
msgstr "Видає об’єкти :term:`finder` для вказаного імені модуля."

msgid ""
"If fullname contains a ``'.'``, the finders will be for the package "
"containing fullname, otherwise they will be all registered top level finders "
"(i.e. those on both :data:`sys.meta_path` and :data:`sys.path_hooks`)."
msgstr ""
"Якщо повне ім’я містить ``'.'``, the finders will be for the package "
"containing fullname, otherwise they will be all registered top level finders "
"(i.e. those on both :data:`sys.meta_path` and :data:`sys.path_hooks`)."

msgid ""
"If the named module is in a package, that package is imported as a side "
"effect of invoking this function."
msgstr ""
"Якщо вказаний модуль міститься в пакеті, цей пакет імпортується як побічний "
"ефект виклику цієї функції."

msgid "If no module name is specified, all top level finders are produced."
msgstr "Якщо ім’я модуля не вказано, створюються всі шукачі верхнього рівня."

msgid ""
"Yields :class:`ModuleInfo` for all submodules on *path*, or, if *path* is "
"``None``, all top-level modules on :data:`sys.path`."
msgstr ""
"Видає :class:`ModuleInfo` для всіх підмодулів на *path* або, якщо *path* має "
"значення ``None``, усі модулі верхнього рівня на :data:`sys.path`."

msgid ""
"*path* should be either ``None`` or a list of paths to look for modules in."
msgstr "*path* має бути або ``None``, або список шляхів для пошуку модулів."

msgid ""
"*prefix* is a string to output on the front of every module name on output."
msgstr ""
"*префікс* — це рядок, який виводиться на початку кожного імені модуля при "
"виведенні."

msgid ""
"Only works for a :term:`finder` which defines an ``iter_modules()`` method. "
"This interface is non-standard, so the module also provides implementations "
"for :class:`importlib.machinery.FileFinder` and :class:`zipimport."
"zipimporter`."
msgstr ""
"Працює лише для :term:`finder`, який визначає метод ``iter_modules()``. Цей "
"інтерфейс є нестандартним, тому модуль також забезпечує реалізації для :"
"class:`importlib.machinery.FileFinder` і :class:`zipimport.zipimporter`."

msgid ""
"Yields :class:`ModuleInfo` for all modules recursively on *path*, or, if "
"*path* is ``None``, all accessible modules."
msgstr ""
"Видає :class:`ModuleInfo` для всіх модулів рекурсивно за *шляхом* або, якщо "
"*шлях* має значення ``None``, усі доступні модулі."

msgid ""
"Note that this function must import all *packages* (*not* all modules!) on "
"the given *path*, in order to access the ``__path__`` attribute to find "
"submodules."
msgstr ""
"Зауважте, що ця функція має імпортувати всі *пакети* (*не* всі модулі!) за "
"вказаним *шляхом*, щоб отримати доступ до атрибута ``__path__`` для пошуку "
"підмодулів."

msgid ""
"*onerror* is a function which gets called with one argument (the name of the "
"package which was being imported) if any exception occurs while trying to "
"import a package.  If no *onerror* function is supplied, :exc:"
"`ImportError`\\s are caught and ignored, while all other exceptions are "
"propagated, terminating the search."
msgstr ""
"*onerror* — це функція, яка викликається з одним аргументом (назва пакета, "
"який імпортувався), якщо під час спроби імпортувати пакет виникає будь-яка "
"виняткова ситуація. Якщо функція *onerror* не надається, :exc:"
"`ImportError`\\s перехоплюються та ігноруються, тоді як усі інші винятки "
"поширюються, припиняючи пошук."

msgid "Examples::"
msgstr "Приклади::"

msgid "Get a resource from a package."
msgstr "Отримати ресурс із пакету."

msgid ""
"This is a wrapper for the :term:`loader` :meth:`get_data <importlib.abc."
"ResourceLoader.get_data>` API.  The *package* argument should be the name of "
"a package, in standard module format (``foo.bar``).  The *resource* argument "
"should be in the form of a relative filename, using ``/`` as the path "
"separator.  The parent directory name ``..`` is not allowed, and nor is a "
"rooted name (starting with a ``/``)."
msgstr ""
"Це оболонка для API :term:`loader` :meth:`get_data <importlib.abc."
"ResourceLoader.get_data>`. Аргумент *package* має бути назвою пакета в "
"стандартному форматі модуля (``foo.bar``). Аргумент *resource* має бути у "
"формі відносного імені файлу, використовуючи ``/`` як роздільник шляху. Ім’я "
"батьківського каталогу ``..`` не допускається, а також коренева назва "
"(починається з ``/``)."

msgid ""
"The function returns a binary string that is the contents of the specified "
"resource."
msgstr "Функція повертає двійковий рядок, який є вмістом зазначеного ресурсу."

msgid ""
"For packages located in the filesystem, which have already been imported, "
"this is the rough equivalent of::"
msgstr ""
"Для пакетів, розташованих у файловій системі, які вже були імпортовані, це "
"приблизний еквівалент::"

msgid ""
"If the package cannot be located or loaded, or it uses a :term:`loader` "
"which does not support :meth:`get_data <importlib.abc.ResourceLoader."
"get_data>`, then ``None`` is returned.  In particular, the :term:`loader` "
"for :term:`namespace packages <namespace package>` does not support :meth:"
"`get_data <importlib.abc.ResourceLoader.get_data>`."
msgstr ""
"Якщо пакет не вдається знайти або завантажити, або він використовує :term:"
"`loader`, який не підтримує :meth:`get_data <importlib.abc.ResourceLoader."
"get_data>`, повертається ``None``. Зокрема, :term:`loader` для :term:"
"`пакетів простору імен <namespace package>` не підтримує :meth:`get_data "
"<importlib.abc.ResourceLoader.get_data>`."

msgid "Resolve a name to an object."
msgstr "Розв’яжіть ім’я з об’єктом."

msgid ""
"This functionality is used in numerous places in the standard library (see :"
"issue:`12915`) - and equivalent functionality is also in widely used third-"
"party packages such as setuptools, Django and Pyramid."
msgstr ""
"Ця функціональність використовується в багатьох місцях у стандартній "
"бібліотеці (див. :issue:`12915`), а еквівалентна функціональність також є в "
"широко використовуваних пакетах сторонніх розробників, таких як setuptools, "
"Django та Pyramid."

msgid ""
"It is expected that *name* will be a string in one of the following formats, "
"where W is shorthand for a valid Python identifier and dot stands for a "
"literal period in these pseudo-regexes:"
msgstr ""
"Очікується, що *ім’я* буде рядком в одному з таких форматів, де W є "
"скороченням дійсного ідентифікатора Python, а крапка означає крапку в цих "
"псевдорегулярних виразах:"

msgid "``W(.W)*``"
msgstr "``W(.W)*``"

msgid "``W(.W)*:(W(.W)*)?``"
msgstr "``W(.W)*:(W(.W)*)?``"

msgid ""
"The first form is intended for backward compatibility only. It assumes that "
"some part of the dotted name is a package, and the rest is an object "
"somewhere within that package, possibly nested inside other objects. Because "
"the place where the package stops and the object hierarchy starts can't be "
"inferred by inspection, repeated attempts to import must be done with this "
"form."
msgstr ""
"Перша форма призначена лише для зворотної сумісності. Припускається, що "
"деяка частина назви з крапками є пакетом, а решта є об’єктом десь у цьому "
"пакеті, можливо, вкладеним в інші об’єкти. Оскільки місце, де зупиняється "
"пакет і починається ієрархія об’єктів, не може бути встановлено шляхом "
"перевірки, повторні спроби імпорту потрібно робити за допомогою цієї форми."

msgid ""
"In the second form, the caller makes the division point clear through the "
"provision of a single colon: the dotted name to the left of the colon is a "
"package to be imported, and the dotted name to the right is the object "
"hierarchy within that package. Only one import is needed in this form. If it "
"ends with the colon, then a module object is returned."
msgstr ""
"У другій формі абонент чітко пояснює точку розділення за допомогою однієї "
"двокрапки: назва з крапками ліворуч від двокрапки означає пакет, який "
"потрібно імпортувати, а назва з крапками праворуч — це ієрархія об’єктів у "
"цьому пакеті. . У цій формі потрібен лише один імпорт. Якщо він закінчується "
"двокрапкою, повертається об’єкт модуля."

msgid ""
"The function will return an object (which might be a module), or raise one "
"of the following exceptions:"
msgstr ""
"Функція поверне об’єкт (який може бути модулем) або викличе одне з таких "
"винятків:"

msgid ":exc:`ValueError` -- if *name* isn't in a recognised format."
msgstr ":exc:`ValueError` -- якщо *ім'я* не в розпізнаному форматі."

msgid ":exc:`ImportError` -- if an import failed when it shouldn't have."
msgstr ":exc:`ImportError` -- якщо імпорт не вдався, а не мав бути."

msgid ""
":exc:`AttributeError` -- If a failure occurred when traversing the object "
"hierarchy within the imported package to get to the desired object."
msgstr ""
":exc:`AttributeError` -- Якщо сталася помилка під час проходження ієрархії "
"об’єктів в імпортованому пакеті, щоб дістатися до потрібного об’єкта."
