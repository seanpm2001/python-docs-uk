# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:03+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`copy` --- Shallow and deep copy operations"
msgstr ":mod:`copy` --- Операції поверхневого та глибокого копіювання"

msgid "**Source code:** :source:`Lib/copy.py`"
msgstr "**Вихідний код:** :source:`Lib/copy.py`"

msgid ""
"Assignment statements in Python do not copy objects, they create bindings "
"between a target and an object. For collections that are mutable or contain "
"mutable items, a copy is sometimes needed so one can change one copy without "
"changing the other. This module provides generic shallow and deep copy "
"operations (explained below)."
msgstr ""
"Оператори присвоєння в Python не копіюють об’єкти, вони створюють прив’язки "
"між метою та об’єктом. Для колекцій, які є змінними або містять змінні "
"елементи, іноді потрібна копія, щоб можна було змінити одну копію, не "
"змінюючи іншу. Цей модуль забезпечує загальні операції поверхневого та "
"глибокого копіювання (пояснення нижче)."

msgid "Interface summary:"
msgstr "Короткий опис інтерфейсу:"

msgid "Return a shallow copy of *x*."
msgstr "Повернути мілку копію *x*."

msgid "Return a deep copy of *x*."
msgstr "Повернути глибоку копію *x*."

msgid "Raised for module specific errors."
msgstr "Піднято для конкретних помилок модуля."

msgid ""
"The difference between shallow and deep copying is only relevant for "
"compound objects (objects that contain other objects, like lists or class "
"instances):"
msgstr ""
"Різниця між поверхневим і глибоким копіюванням актуальна лише для складених "
"об’єктів (об’єктів, які містять інші об’єкти, наприклад списки чи екземпляри "
"класу):"

msgid ""
"A *shallow copy* constructs a new compound object and then (to the extent "
"possible) inserts *references* into it to the objects found in the original."
msgstr ""
"*Неглибока копія* створює новий складений об’єкт, а потім (наскільки це "
"можливо) вставляє в нього *посилання* на об’єкти, знайдені в оригіналі."

msgid ""
"A *deep copy* constructs a new compound object and then, recursively, "
"inserts *copies* into it of the objects found in the original."
msgstr ""
"*Глибока копія* створює новий складений об’єкт, а потім рекурсивно вставляє "
"в нього *копії* об’єктів, знайдених в оригіналі."

msgid ""
"Two problems often exist with deep copy operations that don't exist with "
"shallow copy operations:"
msgstr ""
"З операціями глибокого копіювання часто існують дві проблеми, яких немає з "
"операціями поверхневого копіювання:"

msgid ""
"Recursive objects (compound objects that, directly or indirectly, contain a "
"reference to themselves) may cause a recursive loop."
msgstr ""
"Рекурсивні об’єкти (складені об’єкти, які прямо чи опосередковано містять "
"посилання на себе) можуть спричинити рекурсивний цикл."

msgid ""
"Because deep copy copies everything it may copy too much, such as data which "
"is intended to be shared between copies."
msgstr ""
"Оскільки глибока копія копіює все, що може скопіювати занадто багато, "
"наприклад дані, які призначені для спільного використання між копіями."

msgid "The :func:`deepcopy` function avoids these problems by:"
msgstr "Функція :func:`deepcopy` дозволяє уникнути цих проблем за допомогою:"

msgid ""
"keeping a ``memo`` dictionary of objects already copied during the current "
"copying pass; and"
msgstr ""
"ведення словника ``memo`` об'єктів, уже скопійованих під час поточного "
"проходу копіювання; і"

msgid ""
"letting user-defined classes override the copying operation or the set of "
"components copied."
msgstr ""
"дозволяючи визначеним користувачем класам перевизначати операцію копіювання "
"або набір скопійованих компонентів."

msgid ""
"This module does not copy types like module, method, stack trace, stack "
"frame, file, socket, window, or any similar types.  It does \"copy\" "
"functions and classes (shallow and deeply), by returning the original object "
"unchanged; this is compatible with the way these are treated by the :mod:"
"`pickle` module."
msgstr ""
"Цей модуль не копіює такі типи, як модуль, метод, трасування стека, фрейм "
"стека, файл, сокет, вікно або будь-які подібні типи. Він \"копіює\" функції "
"та класи (неглибокі та глибокі), повертаючи вихідний об’єкт без змін; це "
"сумісно з тим, як вони обробляються модулем :mod:`pickle`."

msgid ""
"Shallow copies of dictionaries can be made using :meth:`dict.copy`, and of "
"lists by assigning a slice of the entire list, for example, ``copied_list = "
"original_list[:]``."
msgstr ""
"Неглибокі копії словників можна зробити за допомогою :meth:`dict.copy`, а "
"списків — шляхом призначення частини всього списку, наприклад, ``copied_list "
"= original_list[:]``."

msgid ""
"Classes can use the same interfaces to control copying that they use to "
"control pickling.  See the description of module :mod:`pickle` for "
"information on these methods.  In fact, the :mod:`copy` module uses the "
"registered pickle functions from the :mod:`copyreg` module."
msgstr ""
"Класи можуть використовувати ті самі інтерфейси для керування копіюванням, "
"які вони використовують для керування травленням. Перегляньте опис модуля :"
"mod:`pickle` для отримання інформації про ці методи. Фактично, модуль :mod:"
"`copy` використовує зареєстровані функції pickle з модуля :mod:`copyreg`."

msgid ""
"In order for a class to define its own copy implementation, it can define "
"special methods :meth:`__copy__` and :meth:`__deepcopy__`.  The former is "
"called to implement the shallow copy operation; no additional arguments are "
"passed. The latter is called to implement the deep copy operation; it is "
"passed one argument, the ``memo`` dictionary.  If the :meth:`__deepcopy__` "
"implementation needs to make a deep copy of a component, it should call the :"
"func:`deepcopy` function with the component as first argument and the memo "
"dictionary as second argument. The memo dictionary should be treated as an "
"opaque object."
msgstr ""
"Щоб клас міг визначити власну реалізацію копіювання, він може визначити "
"спеціальні методи :meth:`__copy__` і :meth:`__deepcopy__`. Перший "
"викликається для реалізації операції поверхневого копіювання; додаткові "
"аргументи не передаються. Останній викликається для реалізації операції "
"глибокого копіювання; йому передається один аргумент, словник ``memo``. Якщо "
"реалізація :meth:`__deepcopy__` потребує створення глибокої копії "
"компонента, вона повинна викликати функцію :func:`deepcopy` з компонентом як "
"першим аргументом і словником memo як другим аргументом. Словник memo слід "
"розглядати як непрозорий об’єкт."

msgid "Module :mod:`pickle`"
msgstr "Модуль :mod:`pickle`"

msgid ""
"Discussion of the special methods used to support object state retrieval and "
"restoration."
msgstr ""
"Обговорення спеціальних методів, які використовуються для підтримки пошуку "
"та відновлення стану об'єкта."
