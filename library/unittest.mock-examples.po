# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-29 17:18+0300\n"
"PO-Revision-Date: 2022-07-05 15:38+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`unittest.mock` --- getting started"
msgstr ":mod:`unittest.mock` --- початок роботи"

msgid "Using Mock"
msgstr "Використання Mock"

msgid "Mock Patching Methods"
msgstr "Імітаційні методи виправлення"

msgid "Common uses for :class:`Mock` objects include:"
msgstr "Загальні випадки використання об’єктів :class:`Mock` включають:"

msgid "Patching methods"
msgstr "Методи латання"

msgid "Recording method calls on objects"
msgstr "Виклики методів запису на об'єктах"

msgid ""
"You might want to replace a method on an object to check that it is called "
"with the correct arguments by another part of the system:"
msgstr ""
"Можливо, ви захочете замінити метод на об’єкті, щоб перевірити, чи "
"викликається він із правильними аргументами іншою частиною системи:"

msgid ""
"Once our mock has been used (``real.method`` in this example) it has methods "
"and attributes that allow you to make assertions about how it has been used."
msgstr ""
"Після того, як наш макет був використаний (``real.method`` у цьому "
"прикладі), він має методи та атрибути, які дозволяють робити твердження про "
"те, як він використовувався."

msgid ""
"In most of these examples the :class:`Mock` and :class:`MagicMock` classes "
"are interchangeable. As the ``MagicMock`` is the more capable class it makes "
"a sensible one to use by default."
msgstr ""
"У більшості цих прикладів класи :class:`Mock` і :class:`MagicMock` "
"взаємозамінні. Оскільки ``MagicMock`` є більш потужним класом, його доцільно "
"використовувати за замовчуванням."

msgid ""
"Once the mock has been called its :attr:`~Mock.called` attribute is set to "
"``True``. More importantly we can use the :meth:`~Mock.assert_called_with` "
"or :meth:`~Mock.assert_called_once_with` method to check that it was called "
"with the correct arguments."
msgstr ""
"Після виклику макета його атрибут :attr:`~Mock. called` має значення "
"``True``. Що ще важливіше, ми можемо використовувати метод :meth:`~Mock."
"assert_ called_with` або :meth:`~Mock.assert_ called_once_with`, щоб "
"перевірити, чи його було викликано з правильними аргументами."

msgid ""
"This example tests that calling ``ProductionClass().method`` results in a "
"call to the ``something`` method:"
msgstr ""
"Цей приклад перевіряє, що виклик ``ProductionClass().method`` призводить до "
"виклику ``something`` методу:"

msgid "Mock for Method Calls on an Object"
msgstr "Макет для викликів методів об’єкта"

msgid ""
"In the last example we patched a method directly on an object to check that "
"it was called correctly. Another common use case is to pass an object into a "
"method (or some part of the system under test) and then check that it is "
"used in the correct way."
msgstr ""
"В останньому прикладі ми патчили метод безпосередньо на об’єкті, щоб "
"перевірити, чи правильно його викликали. Іншим поширеним випадком "
"використання є передача об’єкта в метод (або деяку частину тестованої "
"системи), а потім перевірка його правильного використання."

msgid ""
"The simple ``ProductionClass`` below has a ``closer`` method. If it is "
"called with an object then it calls ``close`` on it."
msgstr ""
"Простий ``ProductionClass`` нижче має метод ``closer``. Якщо він "
"викликається з об’єктом, він викликає для нього ``close``."

msgid ""
"So to test it we need to pass in an object with a ``close`` method and check "
"that it was called correctly."
msgstr ""
"Отже, щоб перевірити його, нам потрібно передати об’єкт за допомогою методу "
"``close`` і перевірити, чи він правильно викликаний."

msgid ""
"We don't have to do any work to provide the 'close' method on our mock. "
"Accessing close creates it. So, if 'close' hasn't already been called then "
"accessing it in the test will create it, but :meth:`~Mock."
"assert_called_with` will raise a failure exception."
msgstr ""
"Нам не потрібно нічого робити, щоб забезпечити метод \"close\" у нашому "
"макеті. Доступ до close створює його. Отже, якщо 'close' ще не було "
"викликано, тоді доступ до нього в тесті створить його, але :meth:`~Mock."
"assert_ called_with` викличе виняток помилки."

msgid "Mocking Classes"
msgstr "Знущальні класи"

msgid ""
"A common use case is to mock out classes instantiated by your code under "
"test. When you patch a class, then that class is replaced with a mock. "
"Instances are created by *calling the class*. This means you access the "
"\"mock instance\" by looking at the return value of the mocked class."
msgstr ""
"Поширений випадок використання - це макетування класів, створених вашим "
"тестованим кодом. Коли ви виправляєте клас, цей клас замінюється макетом. "
"Екземпляри створюються шляхом *виклику класу*. Це означає, що ви отримуєте "
"доступ до \"макетного екземпляра\", дивлячись на значення, що повертається "
"імітованим класом."

msgid ""
"In the example below we have a function ``some_function`` that instantiates "
"``Foo`` and calls a method on it. The call to :func:`patch` replaces the "
"class ``Foo`` with a mock. The ``Foo`` instance is the result of calling the "
"mock, so it is configured by modifying the mock :attr:`~Mock."
"return_value`. ::"
msgstr ""
"У наведеному нижче прикладі ми маємо функцію ``some_function``, яка створює "
"екземпляр ``Foo`` і викликає на ньому метод. Виклик :func:`patch` замінює "
"клас ``Foo`` на макет. Екземпляр ``Foo`` є результатом виклику mock, тому "
"він налаштовується шляхом модифікації mock :attr:`~Mock.return_value`. ::"

msgid "Naming your mocks"
msgstr "Називання своїх макетів"

msgid ""
"It can be useful to give your mocks a name. The name is shown in the repr of "
"the mock and can be helpful when the mock appears in test failure messages. "
"The name is also propagated to attributes or methods of the mock:"
msgstr ""
"Може бути корисно дати своїм макетам назву. Ім’я відображається у "
"відображенні макета та може бути корисним, коли макет з’являється в "
"повідомленнях про помилку тесту. Назва також поширюється на атрибути або "
"методи макета:"

msgid "Tracking all Calls"
msgstr "Відстеження всіх дзвінків"

msgid ""
"Often you want to track more than a single call to a method. The :attr:"
"`~Mock.mock_calls` attribute records all calls to child attributes of the "
"mock - and also to their children."
msgstr ""
"Часто потрібно відстежувати більше ніж один виклик методу. Атрибут :attr:"
"`~Mock.mock_calls` записує всі виклики дочірніх атрибутів mock, а також до "
"їхніх дочірніх атрибутів."

msgid ""
"If you make an assertion about ``mock_calls`` and any unexpected methods "
"have been called, then the assertion will fail. This is useful because as "
"well as asserting that the calls you expected have been made, you are also "
"checking that they were made in the right order and with no additional calls:"
msgstr ""
"Якщо ви робите твердження щодо ``mock_calls`` і були викликані будь-які "
"неочікувані методи, тоді твердження не вдасться. Це корисно, оскільки ви не "
"тільки стверджуєте, що дзвінки, які ви очікували, були здійснені, але й "
"перевіряєте, що вони були здійснені в правильному порядку та без додаткових "
"дзвінків:"

msgid ""
"You use the :data:`call` object to construct lists for comparing with "
"``mock_calls``:"
msgstr ""
"Ви використовуєте об’єкт :data:`call` для створення списків для порівняння з "
"``mock_calls``:"

msgid ""
"However, parameters to calls that return mocks are not recorded, which means "
"it is not possible to track nested calls where the parameters used to create "
"ancestors are important:"
msgstr ""
"Однак параметри викликів, які повертають імітації, не записуються, що "
"означає, що неможливо відстежувати вкладені виклики, де важливі параметри, "
"які використовуються для створення предків:"

msgid "Setting Return Values and Attributes"
msgstr "Налаштування повернених значень і атрибутів"

msgid "Setting the return values on a mock object is trivially easy:"
msgstr ""
"Встановлення повернених значень для макетного об’єкта тривіально легко:"

msgid "Of course you can do the same for methods on the mock:"
msgstr "Звичайно, ви можете зробити те саме для методів на mock:"

msgid "The return value can also be set in the constructor:"
msgstr "Повернене значення також можна встановити в конструкторі:"

msgid "If you need an attribute setting on your mock, just do it:"
msgstr "Якщо вам потрібне налаштування атрибута на макеті, просто зробіть це:"

msgid ""
"Sometimes you want to mock up a more complex situation, like for example "
"``mock.connection.cursor().execute(\"SELECT 1\")``. If we wanted this call "
"to return a list, then we have to configure the result of the nested call."
msgstr ""
"Іноді потрібно змакувати складнішу ситуацію, як, наприклад, ``mock."
"connection.cursor().execute(\"SELECT 1\")``. Якщо ми хочемо, щоб цей виклик "
"повертав список, ми повинні налаштувати результат вкладеного виклику."

msgid ""
"We can use :data:`call` to construct the set of calls in a \"chained call\" "
"like this for easy assertion afterwards:"
msgstr ""
"Ми можемо використовувати :data:`call`, щоб створити набір викликів у "
"\"ланцюжковому виклику\", подібному до цього для легкого твердження згодом:"

msgid ""
"It is the call to ``.call_list()`` that turns our call object into a list of "
"calls representing the chained calls."
msgstr ""
"Саме виклик ``.call_list()`` перетворює наш об’єкт виклику на список "
"викликів, що представляють ланцюгові виклики."

msgid "Raising exceptions with mocks"
msgstr "Створення винятків за допомогою моків"

msgid ""
"A useful attribute is :attr:`~Mock.side_effect`. If you set this to an "
"exception class or instance then the exception will be raised when the mock "
"is called."
msgstr ""
"Корисним атрибутом є :attr:`~Mock.side_effect`. Якщо ви встановите це як "
"клас винятку або екземпляр, тоді виняток буде викликано під час виклику "
"макета."

msgid "Side effect functions and iterables"
msgstr "Функції побічних ефектів та ітерації"

msgid ""
"``side_effect`` can also be set to a function or an iterable. The use case "
"for ``side_effect`` as an iterable is where your mock is going to be called "
"several times, and you want each call to return a different value. When you "
"set ``side_effect`` to an iterable every call to the mock returns the next "
"value from the iterable:"
msgstr ""
"``side_effect`` також може бути встановлено як функція або iterable. Варіант "
"використання ``side_effect`` як ітерації полягає в тому, що ваш макет буде "
"викликатися кілька разів, і ви хочете, щоб кожен виклик повертав інше "
"значення. Коли ви встановлюєте ``side_effect`` на iterable, кожен виклик "
"mock повертає наступне значення з iterable:"

msgid ""
"For more advanced use cases, like dynamically varying the return values "
"depending on what the mock is called with, ``side_effect`` can be a "
"function. The function will be called with the same arguments as the mock. "
"Whatever the function returns is what the call returns:"
msgstr ""
"Для більш складних випадків використання, як-от динамічне змінення "
"повернених значень залежно від того, з чим викликається макет, "
"``side_effect`` може бути функцією. Функція буде викликана з тими самими "
"аргументами, що й макет. Усе, що повертає функція, повертає виклик:"

msgid "Mocking asynchronous iterators"
msgstr "Знущання над асинхронними ітераторами"

msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-iterators` through ``__aiter__``. The :attr:`~Mock.return_value` "
"attribute of ``__aiter__`` can be used to set the return values to be used "
"for iteration."
msgstr ""
"Починаючи з Python 3.8, ``AsyncMock`` і ``MagicMock`` підтримують імітацію :"
"ref:`async-iterators` через ``__aiter__``. Атрибут :attr:`~Mock."
"return_value` ``__aiter__`` можна використовувати для встановлення "
"повернених значень, які будуть використовуватися для ітерації."

msgid "Mocking asynchronous context manager"
msgstr "Знущання над асинхронним контекстним менеджером"

msgid ""
"Since Python 3.8, ``AsyncMock`` and ``MagicMock`` have support to mock :ref:"
"`async-context-managers` through ``__aenter__`` and ``__aexit__``. By "
"default, ``__aenter__`` and ``__aexit__`` are ``AsyncMock`` instances that "
"return an async function."
msgstr ""
"Починаючи з Python 3.8, ``AsyncMock`` і ``MagicMock`` підтримують імітацію :"
"ref:`async-context-managers` через ``__aenter__`` і ``__aexit__``. За "
"замовчуванням ``__aenter__`` і ``__aexit__`` є екземплярами ``AsyncMock``, "
"які повертають асинхронну функцію."

msgid "Creating a Mock from an Existing Object"
msgstr "Створення макету з існуючого об’єкта"

msgid ""
"One problem with over use of mocking is that it couples your tests to the "
"implementation of your mocks rather than your real code. Suppose you have a "
"class that implements ``some_method``. In a test for another class, you "
"provide a mock of this object that *also* provides ``some_method``. If later "
"you refactor the first class, so that it no longer has ``some_method`` - "
"then your tests will continue to pass even though your code is now broken!"
msgstr ""
"Однією з проблем із надмірним використанням mocking є те, що воно поєднує "
"ваші тести з реалізацією ваших mocks, а не з вашим реальним кодом. "
"Припустімо, у вас є клас, який реалізує ``some_method``. У тесті для іншого "
"класу ви надаєте макет цього об’єкта, який *також* надає ``some_method``. "
"Якщо пізніше ви переробите перший клас, щоб він більше не мав "
"``some_method``, тоді ваші тести продовжуватимуть проходити, навіть якщо ваш "
"код зараз зламаний!"

msgid ""
":class:`Mock` allows you to provide an object as a specification for the "
"mock, using the *spec* keyword argument. Accessing methods / attributes on "
"the mock that don't exist on your specification object will immediately "
"raise an attribute error. If you change the implementation of your "
"specification, then tests that use that class will start failing immediately "
"without you having to instantiate the class in those tests."
msgstr ""
":class:`Mock` дозволяє вам надати об’єкт як специфікацію для mock, "
"використовуючи аргумент ключового слова *spec*. Доступ до методів/атрибутів "
"у макеті, які не існують у вашому об’єкті специфікації, негайно призведе до "
"помилки атрибута. Якщо ви зміните реалізацію вашої специфікації, тоді тести, "
"які використовують цей клас, негайно почнуть виходити з ладу без "
"необхідності створення екземпляра класу в цих тестах."

msgid ""
"Using a specification also enables a smarter matching of calls made to the "
"mock, regardless of whether some parameters were passed as positional or "
"named arguments::"
msgstr ""
"Використання специфікації також дає змогу розумніше зіставляти виклики, "
"зроблені для mock, незалежно від того, чи були деякі параметри передані як "
"позиційні чи іменовані аргументи:"

msgid ""
"If you want this smarter matching to also work with method calls on the "
"mock, you can use :ref:`auto-speccing <auto-speccing>`."
msgstr ""
"Якщо ви бажаєте, щоб ця розумніша відповідність також працювала з викликами "
"методів на mock, ви можете використовувати :ref:`auto-speccing <auto-"
"speccing>`."

msgid ""
"If you want a stronger form of specification that prevents the setting of "
"arbitrary attributes as well as the getting of them then you can use "
"*spec_set* instead of *spec*."
msgstr ""
"Якщо вам потрібна сильніша форма специфікації, яка запобігає встановленню "
"довільних атрибутів, а також їх отриманню, ви можете використовувати "
"*spec_set* замість *spec*."

msgid "Patch Decorators"
msgstr "Декоратори патчів"

msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"З :func:`patch` важливо, щоб ви латали об’єкти в просторі імен, де вони "
"шукаються. Зазвичай це просто, але для короткого посібника прочитайте :ref:"
"`де патч <where-to-patch>`."

msgid ""
"A common need in tests is to patch a class attribute or a module attribute, "
"for example patching a builtin or patching a class in a module to test that "
"it is instantiated. Modules and classes are effectively global, so patching "
"on them has to be undone after the test or the patch will persist into other "
"tests and cause hard to diagnose problems."
msgstr ""
"Загальною потребою в тестах є виправлення атрибута класу або атрибута "
"модуля, наприклад, виправлення вбудованого модуля або виправлення класу в "
"модулі, щоб перевірити, чи створено його екземпляр. Модулі та класи фактично "
"є глобальними, тому після тесту потрібно скасувати їх виправлення, інакше "
"виправлення збережеться в інших тестах і спричинить проблеми, які важко "
"діагностувати."

msgid ""
"mock provides three convenient decorators for this: :func:`patch`, :func:"
"`patch.object` and :func:`patch.dict`. ``patch`` takes a single string, of "
"the form ``package.module.Class.attribute`` to specify the attribute you are "
"patching. It also optionally takes a value that you want the attribute (or "
"class or whatever) to be replaced with. 'patch.object' takes an object and "
"the name of the attribute you would like patched, plus optionally the value "
"to patch it with."
msgstr ""
"mock надає для цього три зручні декоратори: :func:`patch`, :func:`patch."
"object` і :func:`patch.dict`. ``patch`` приймає один рядок у формі ``package."
"module.Class.attribute``, щоб визначити атрибут, який ви виправляєте. Він "
"також необов’язково приймає значення, яким ви бажаєте замінити атрибут (або "
"клас чи щось інше). 'patch.object' приймає об'єкт і ім'я атрибута, який ви "
"бажаєте виправити, а також необов'язково значення, з яким його потрібно "
"виправити."

msgid "``patch.object``::"
msgstr "``patch.object``::"

msgid ""
"If you are patching a module (including :mod:`builtins`) then use :func:"
"`patch` instead of :func:`patch.object`:"
msgstr ""
"Якщо ви виправляєте модуль (включаючи :mod:`builtins`), використовуйте :func:"
"`patch` замість :func:`patch.object`:"

msgid ""
"The module name can be 'dotted', in the form ``package.module`` if needed::"
msgstr ""
"Ім’я модуля може бути розділене крапкою у формі ``package.module``, якщо "
"необхідно:"

msgid "A nice pattern is to actually decorate test methods themselves:"
msgstr "Хороший зразок — це фактично прикрасити самі методи тестування:"

msgid ""
"If you want to patch with a Mock, you can use :func:`patch` with only one "
"argument (or :func:`patch.object` with two arguments). The mock will be "
"created for you and passed into the test function / method:"
msgstr ""
"Якщо ви хочете виправити за допомогою Mock, ви можете використовувати :func:"
"`patch` лише з одним аргументом (або :func:`patch.object` з двома "
"аргументами). Макет буде створено для вас і передано в тестову функцію/метод:"

msgid "You can stack up multiple patch decorators using this pattern::"
msgstr ""
"Ви можете скласти кілька декораторів патчів, використовуючи цей шаблон:"

msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``test_module.ClassName2`` is passed in first."
msgstr ""
"Коли ви вкладаєте декоратори латок, макети передаються до декорованої "
"функції в тому ж порядку, в якому вони застосовані (звичайний *Python* "
"порядок застосування декораторів). Це означає знизу вгору, тому у наведеному "
"вище прикладі спочатку передається макет для ``test_module.ClassName2``."

msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr ""
"Існує також :func:`patch.dict` для встановлення значень у словнику лише під "
"час області видимості та відновлення словника до вихідного стану після "
"завершення тесту:"

msgid ""
"``patch``, ``patch.object`` and ``patch.dict`` can all be used as context "
"managers."
msgstr ""
"``patch``, ``patch.object`` і ``patch.dict`` можна використовувати як "
"контекстні менеджери."

msgid ""
"Where you use :func:`patch` to create a mock for you, you can get a "
"reference to the mock using the \"as\" form of the with statement:"
msgstr ""
"Там, де ви використовуєте :func:`patch` для створення макету, ви можете "
"отримати посилання на макет за допомогою форми \"as\" оператора with:"

msgid ""
"As an alternative ``patch``, ``patch.object`` and ``patch.dict`` can be used "
"as class decorators. When used in this way it is the same as applying the "
"decorator individually to every method whose name starts with \"test\"."
msgstr ""
"Як альтернативу ``patch``, ``patch.object`` і ``patch.dict`` можна "
"використовувати як декоратори класів. При такому використанні це те саме, що "
"застосувати декоратор окремо до кожного методу, назва якого починається з "
"\"test\"."

msgid "Further Examples"
msgstr "Подальші приклади"

msgid "Here are some more examples for some slightly more advanced scenarios."
msgstr "Ось ще кілька прикладів для деяких трохи складніших сценаріїв."

msgid "Mocking chained calls"
msgstr "Знущальні ланцюгові дзвінки"

msgid ""
"Mocking chained calls is actually straightforward with mock once you "
"understand the :attr:`~Mock.return_value` attribute. When a mock is called "
"for the first time, or you fetch its ``return_value`` before it has been "
"called, a new :class:`Mock` is created."
msgstr ""
"Висмішувати ланцюгові виклики насправді просто за допомогою mock, коли ви "
"розумієте атрибут :attr:`~Mock.return_value`. Коли макет викликається вперше "
"або ви отримуєте його ``return_value`` до його виклику, створюється новий :"
"class:`Mock`."

msgid ""
"This means that you can see how the object returned from a call to a mocked "
"object has been used by interrogating the ``return_value`` mock:"
msgstr ""
"Це означає, що ви можете побачити, як об’єкт, повернутий викликом "
"імітованого об’єкта, використовувався, запитуючи макет ``return_value``:"

msgid ""
"From here it is a simple step to configure and then make assertions about "
"chained calls. Of course another alternative is writing your code in a more "
"testable way in the first place..."
msgstr ""
"Звідси це простий крок, щоб налаштувати та зробити твердження щодо "
"ланцюжкових викликів. Звісно, іншою альтернативою є написання коду більш "
"придатним для перевірки способом..."

msgid "So, suppose we have some code that looks a little bit like this:"
msgstr "Отже, припустімо, що ми маємо код, який виглядає приблизно так:"

msgid ""
"Assuming that ``BackendProvider`` is already well tested, how do we test "
"``method()``? Specifically, we want to test that the code section ``# more "
"code`` uses the response object in the correct way."
msgstr ""
"Якщо припустити, що ``BackendProvider`` вже добре перевірено, як ми "
"перевіримо ``method()``? Зокрема, ми хочемо перевірити, чи розділ коду ``# "
"more code`` правильно використовує об’єкт відповіді."

msgid ""
"As this chain of calls is made from an instance attribute we can monkey "
"patch the ``backend`` attribute on a ``Something`` instance. In this "
"particular case we are only interested in the return value from the final "
"call to ``start_call`` so we don't have much configuration to do. Let's "
"assume the object it returns is 'file-like', so we'll ensure that our "
"response object uses the builtin :func:`open` as its ``spec``."
msgstr ""
"Оскільки цей ланцюжок викликів здійснюється з атрибута екземпляра, ми можемо "
"виправити атрибут ``backend`` на екземплярі ``Something``. У цьому "
"конкретному випадку нас цікавить лише значення, яке повертає останній виклик "
"``start_call``, тому нам не потрібно робити багато налаштувань. Припустімо, "
"що об’єкт, який він повертає, є \"файлоподібним\", тому ми переконаємося, що "
"наш об’єкт відповіді використовує вбудований :func:`open` як свою "
"``специфікацію``."

msgid ""
"To do this we create a mock instance as our mock backend and create a mock "
"response object for it. To set the response as the return value for that "
"final ``start_call`` we could do this::"
msgstr ""
"Для цього ми створюємо макет екземпляра як наш макет бекенда та створюємо "
"для нього об’єкт імітації відповіді. Щоб встановити відповідь як значення, "
"що повертається для цього останнього ``start_call``, ми можемо зробити так:"

msgid ""
"We can do that in a slightly nicer way using the :meth:`~Mock."
"configure_mock` method to directly set the return value for us::"
msgstr ""
"Ми можемо зробити це трохи зручнішим способом, використовуючи метод :meth:"
"`~Mock.configure_mock`, щоб напряму встановити значення, що повертається:"

msgid ""
"With these we monkey patch the \"mock backend\" in place and can make the "
"real call::"
msgstr ""
"За допомогою них ми, як мавпи, виправляємо \"імітацію бекенда\" на місці та "
"можемо зробити справжній виклик:"

msgid ""
"Using :attr:`~Mock.mock_calls` we can check the chained call with a single "
"assert. A chained call is several calls in one line of code, so there will "
"be several entries in ``mock_calls``. We can use :meth:`call.call_list` to "
"create this list of calls for us::"
msgstr ""
"Використовуючи :attr:`~Mock.mock_calls`, ми можемо перевірити ланцюжковий "
"виклик за допомогою одного твердження. Зв’язаний виклик — це кілька викликів "
"в одному рядку коду, тому в ``mock_calls`` буде кілька записів. Ми можемо "
"використовувати :meth:`call.call_list`, щоб створити цей список дзвінків для "
"нас::"

msgid "Partial mocking"
msgstr "Часткове глузування"

msgid ""
"In some tests I wanted to mock out a call to :meth:`datetime.date.today` to "
"return a known date, but I didn't want to prevent the code under test from "
"creating new date objects. Unfortunately :class:`datetime.date` is written "
"in C, and so I couldn't just monkey-patch out the static :meth:`date.today` "
"method."
msgstr ""
"У деяких тестах я хотів імітувати виклик :meth:`datetime.date.today` для "
"повернення відомої дати, але я не хотів перешкоджати тестованому коду "
"створювати нові об’єкти дати. На жаль, :class:`datetime.date` написаний на "
"C, тому я не міг просто виправити статичний метод :meth:`date.today`."

msgid ""
"I found a simple way of doing this that involved effectively wrapping the "
"date class with a mock, but passing through calls to the constructor to the "
"real class (and returning real instances)."
msgstr ""
"Я знайшов простий спосіб зробити це, який передбачав ефективне обгортання "
"класу дати макетом, але передачу викликів конструктору до реального класу (і "
"повернення реальних екземплярів)."

msgid ""
"The :func:`patch decorator <patch>` is used here to mock out the ``date`` "
"class in the module under test. The :attr:`side_effect` attribute on the "
"mock date class is then set to a lambda function that returns a real date. "
"When the mock date class is called a real date will be constructed and "
"returned by ``side_effect``. ::"
msgstr ""
":func:`decorator patch <patch>` використовується тут, щоб імітувати клас "
"``date`` у тестованому модулі. Атрибут :attr:`side_effect` класу фіктивної "
"дати потім встановлюється на лямбда-функцію, яка повертає справжню дату. "
"Коли клас фіктивної дати викликається, справжня дата буде створена та "
"повернена ``side_effect``. ::"

msgid ""
"Note that we don't patch :class:`datetime.date` globally, we patch ``date`` "
"in the module that *uses* it. See :ref:`where to patch <where-to-patch>`."
msgstr ""
"Зверніть увагу, що ми не виправляємо :class:`datetime.date` глобально, ми "
"виправляємо ``date`` в модулі, який *використовує* його. Дивіться :ref:`де "
"виправити <where-to-patch>`."

msgid ""
"When ``date.today()`` is called a known date is returned, but calls to the "
"``date(...)`` constructor still return normal dates. Without this you can "
"find yourself having to calculate an expected result using exactly the same "
"algorithm as the code under test, which is a classic testing anti-pattern."
msgstr ""
"Коли викликається ``date.today()``, повертається відома дата, але виклики "
"конструктора ``date(...)`` повертають звичайні дати. Без цього вам може "
"знадобитися розрахувати очікуваний результат, використовуючи точно такий "
"самий алгоритм, як і тестовий код, який є класичним тестовим антишаблоном."

msgid ""
"Calls to the date constructor are recorded in the ``mock_date`` attributes "
"(``call_count`` and friends) which may also be useful for your tests."
msgstr ""
"Виклики конструктора дат записуються в атрибутах mock_date (call_count і "
"friends), що також може бути корисним для ваших тестів."

msgid ""
"An alternative way of dealing with mocking dates, or other builtin classes, "
"is discussed in `this blog entry <https://williambert.online/2011/07/how-to-"
"unit-testing-in-django-with-mocking-and-patching/>`_."
msgstr ""
"Альтернативний спосіб роботи з імітаційними датами або іншими вбудованими "
"класами обговорюється в `цьому записі блогу <https://williambert."
"online/2011/07/how-to-unit-testing-in-django-with-mocking-and-patching/>`_."

msgid "Mocking a Generator Method"
msgstr "Висміювання методу генератора"

msgid ""
"A Python generator is a function or method that uses the :keyword:`yield` "
"statement to return a series of values when iterated over [#]_."
msgstr ""
"Генератор Python — це функція або метод, який використовує оператор :keyword:"
"`yield` для повернення ряду значень під час ітерації [#]_."

msgid ""
"A generator method / function is called to return the generator object. It "
"is the generator object that is then iterated over. The protocol method for "
"iteration is :meth:`~container.__iter__`, so we can mock this using a :class:"
"`MagicMock`."
msgstr ""
"Метод/функція генератора викликається для повернення об’єкта генератора. Це "
"об’єкт генератора, який потім повторюється. Методом протоколу для ітерації "
"є :meth:`~container.__iter__`, тому ми можемо імітувати це за допомогою :"
"class:`MagicMock`."

msgid ""
"Here's an example class with an \"iter\" method implemented as a generator:"
msgstr "Ось приклад класу з методом \"iter\", реалізованим як генератор:"

msgid "How would we mock this class, and in particular its \"iter\" method?"
msgstr "Як би ми висміювали цей клас, і зокрема його метод \"iter\"?"

msgid ""
"To configure the values returned from the iteration (implicit in the call "
"to :class:`list`), we need to configure the object returned by the call to "
"``foo.iter()``."
msgstr ""
"Щоб налаштувати значення, що повертаються з ітерації (неявно у виклику :"
"class:`list`), нам потрібно налаштувати об’єкт, що повертається викликом "
"``foo.iter()``."

msgid ""
"There are also generator expressions and more `advanced uses <http://www."
"dabeaz.com/coroutines/index.html>`_ of generators, but we aren't concerned "
"about them here. A very good introduction to generators and how powerful "
"they are is: `Generator Tricks for Systems Programmers <http://www.dabeaz."
"com/generators/>`_."
msgstr ""
"Існують також вирази-генератори та більш `просунуті способи використання "
"<http://www.dabeaz.com/coroutines/index.html>`_ генераторів, але вони тут "
"нас не хвилюють. Дуже гарний вступ до генераторів і їхньої потужності: "
"`Трюки генераторів для системних програмістів <http://www.dabeaz.com/"
"generators/>`_."

msgid "Applying the same patch to every test method"
msgstr "Застосування того самого патча до кожного методу тестування"

msgid ""
"If you want several patches in place for multiple test methods the obvious "
"way is to apply the patch decorators to every method. This can feel like "
"unnecessary repetition. Instead, you can use :func:`patch` (in all its "
"various forms) as a class decorator. This applies the patches to all test "
"methods on the class. A test method is identified by methods whose names "
"start with ``test``::"
msgstr ""
"Якщо ви хочете встановити декілька патчів для кількох методів тестування, "
"очевидним способом є застосування декораторів патчів до кожного методу. Це "
"може здатися непотрібним повторенням. Замість цього ви можете "
"використовувати :func:`patch` (у всіх його різноманітних формах) як "
"декоратор класу. Це застосовує патчі до всіх методів тестування в класі. "
"Тестовий метод визначається методами, імена яких починаються з ``test``::"

msgid ""
"An alternative way of managing patches is to use the :ref:`start-and-stop`. "
"These allow you to move the patching into your ``setUp`` and ``tearDown`` "
"methods. ::"
msgstr ""
"Альтернативним способом керування патчами є використання :ref:`start-and-"
"stop`. Це дозволяє вам перемістити виправлення у ваші методи ``setUp`` і "
"``tearDown``. ::"

msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the setUp then tearDown is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"Якщо ви використовуєте цю техніку, ви повинні переконатися, що виправлення "
"\"скасовано\", викликавши ``stop``. Це може бути складніше, ніж ви могли б "
"подумати, тому що якщо виняток виникає в SetUp, tearDown не викликається. :"
"meth:`unittest.TestCase.addCleanup` полегшує це::"

msgid "Mocking Unbound Methods"
msgstr "Висміювання незв'язаних методів"

msgid ""
"Whilst writing tests today I needed to patch an *unbound method* (patching "
"the method on the class rather than on the instance). I needed self to be "
"passed in as the first argument because I want to make asserts about which "
"objects were calling this particular method. The issue is that you can't "
"patch with a mock for this, because if you replace an unbound method with a "
"mock it doesn't become a bound method when fetched from the instance, and so "
"it doesn't get self passed in. The workaround is to patch the unbound method "
"with a real function instead. The :func:`patch` decorator makes it so simple "
"to patch out methods with a mock that having to create a real function "
"becomes a nuisance."
msgstr ""
"Сьогодні під час написання тестів мені потрібно було виправити *незв’язаний "
"метод* (виправити метод у класі, а не в екземплярі). Мені потрібно було "
"передати self як перший аргумент, оскільки я хочу зробити твердження про те, "
"які об’єкти викликають цей конкретний метод. Проблема полягає в тому, що ви "
"не можете виправити за допомогою макету для цього, тому що якщо ви заміните "
"неприв’язаний метод на макет, він не стане зв’язаним методом під час "
"отримання з примірника, і тому він не передається самостійно. Обхідним "
"шляхом є заміна незв’язаного методу реальною функцією. Декоратор :func:"
"`patch` робить так простим виправлення методів за допомогою макету, що "
"створення справжньої функції стає незручністю."

msgid ""
"If you pass ``autospec=True`` to patch then it does the patching with a "
"*real* function object. This function object has the same signature as the "
"one it is replacing, but delegates to a mock under the hood. You still get "
"your mock auto-created in exactly the same way as before. What it means "
"though, is that if you use it to patch out an unbound method on a class the "
"mocked function will be turned into a bound method if it is fetched from an "
"instance. It will have ``self`` passed in as the first argument, which is "
"exactly what I wanted:"
msgstr ""
"Якщо ви передаєте ``autospec=True`` для виправлення, тоді він виконує "
"виправлення за допомогою *реального* функціонального об’єкта. Цей "
"функціональний об’єкт має таку саму сигнатуру, як і той, який він замінює, "
"але делегує макет під капотом. Ви все ще автоматично створюєте свій макет "
"точно так само, як і раніше. Однак це означає, що якщо ви використовуєте "
"його для виправлення незв’язаного методу в класі, імітована функція буде "
"перетворена на зв’язаний метод, якщо її буде отримано з екземпляра. Першим "
"аргументом буде передано ``self``, а це саме те, що я хотів:"

msgid ""
"If we don't use ``autospec=True`` then the unbound method is patched out "
"with a Mock instance instead, and isn't called with ``self``."
msgstr ""
"Якщо ми не використовуємо ``autospec=True``, тоді неприв’язаний метод "
"замість цього виправляється за допомогою екземпляра Mock і не викликається "
"за допомогою ``self``."

msgid "Checking multiple calls with mock"
msgstr "Перевірка кількох викликів за допомогою імітації"

msgid ""
"mock has a nice API for making assertions about how your mock objects are "
"used."
msgstr ""
"mock має гарний API для створення тверджень про те, як використовуються ваші "
"макетні об’єкти."

msgid ""
"If your mock is only being called once you can use the :meth:"
"`assert_called_once_with` method that also asserts that the :attr:"
"`call_count` is one."
msgstr ""
"Якщо ваш макет викликається лише один раз, ви можете використати метод :meth:"
"`assert_ called_once_with`, який також підтверджує, що :attr:`call_count` "
"дорівнює одиниці."

msgid ""
"Both ``assert_called_with`` and ``assert_called_once_with`` make assertions "
"about the *most recent* call. If your mock is going to be called several "
"times, and you want to make assertions about *all* those calls you can use :"
"attr:`~Mock.call_args_list`:"
msgstr ""
"І ``assert_ called_with``, і ``assert_ called_once_with`` створюють "
"твердження щодо *останнього* виклику. Якщо ваш макет буде викликано кілька "
"разів, і ви хочете зробити твердження щодо *всіх* цих викликів, ви можете "
"використовувати :attr:`~Mock.call_args_list`:"

msgid ""
"The :data:`call` helper makes it easy to make assertions about these calls. "
"You can build up a list of expected calls and compare it to "
"``call_args_list``. This looks remarkably similar to the repr of the "
"``call_args_list``:"
msgstr ""
"Помічник :data:`call` полегшує створення тверджень щодо цих викликів. Ви "
"можете створити список очікуваних викликів і порівняти його з "
"``call_args_list``. Це виглядає надзвичайно схожим на відображення ``списку "
"викликів_аргів``:"

msgid "Coping with mutable arguments"
msgstr "Робота зі змінними аргументами"

msgid ""
"Another situation is rare, but can bite you, is when your mock is called "
"with mutable arguments. ``call_args`` and ``call_args_list`` store "
"*references* to the arguments. If the arguments are mutated by the code "
"under test then you can no longer make assertions about what the values were "
"when the mock was called."
msgstr ""
"Інша ситуація рідкісна, але може вас вкусити, коли вашу імітацію викликають "
"зі змінними аргументами. ``call_args`` і ``call_args_list`` зберігають "
"*посилання* на аргументи. Якщо аргументи змінено кодом, що тестується, ви "
"більше не зможете робити твердження про те, якими були значення під час "
"виклику макету."

msgid ""
"Here's some example code that shows the problem. Imagine the following "
"functions defined in 'mymodule'::"
msgstr ""
"Ось приклад коду, який показує проблему. Уявіть собі такі функції, визначені "
"в 'mymodule'::"

msgid ""
"When we try to test that ``grob`` calls ``frob`` with the correct argument "
"look what happens::"
msgstr ""
"Коли ми намагаємося перевірити, що ``grob`` викликає ``frob`` з правильним "
"аргументом, подивіться, що відбувається:"

msgid ""
"One possibility would be for mock to copy the arguments you pass in. This "
"could then cause problems if you do assertions that rely on object identity "
"for equality."
msgstr ""
"Однією з можливостей було б імітаційне копіювання аргументів, які ви "
"передаєте. Це може спричинити проблеми, якщо ви робите твердження, які "
"покладаються на ідентичність об’єкта для рівності."

msgid ""
"Here's one solution that uses the :attr:`side_effect` functionality. If you "
"provide a ``side_effect`` function for a mock then ``side_effect`` will be "
"called with the same args as the mock. This gives us an opportunity to copy "
"the arguments and store them for later assertions. In this example I'm using "
"*another* mock to store the arguments so that I can use the mock methods for "
"doing the assertion. Again a helper function sets this up for me. ::"
msgstr ""
"Ось одне рішення, яке використовує функцію :attr:`side_effect`. Якщо ви "
"надасте функцію ``side_effect`` для макета, то ``side_effect`` буде "
"викликано з тими самими аргументами, що й макет. Це дає нам можливість "
"скопіювати аргументи та зберегти їх для подальших тверджень. У цьому "
"прикладі я використовую *інший* макет для зберігання аргументів, щоб я міг "
"використовувати макетні методи для виконання твердження. Знову допоміжна "
"функція встановлює це для мене. ::"

msgid ""
"``copy_call_args`` is called with the mock that will be called. It returns a "
"new mock that we do the assertion on. The ``side_effect`` function makes a "
"copy of the args and calls our ``new_mock`` with the copy."
msgstr ""
"``copy_call_args`` викликається з макетом, який буде викликано. Він повертає "
"новий макет, на основі якого ми виконуємо твердження. Функція "
"``side_effect`` створює копію аргументів і викликає наш ``new_mock`` разом "
"із копією."

msgid ""
"If your mock is only going to be used once there is an easier way of "
"checking arguments at the point they are called. You can simply do the "
"checking inside a ``side_effect`` function."
msgstr ""
"Якщо ваш макет використовуватиметься лише один раз, є простіший спосіб "
"перевірити аргументи в момент їх виклику. Ви можете просто зробити перевірку "
"всередині функції ``side_effect``."

msgid ""
"An alternative approach is to create a subclass of :class:`Mock` or :class:"
"`MagicMock` that copies (using :func:`copy.deepcopy`) the arguments. Here's "
"an example implementation:"
msgstr ""
"Альтернативним підходом є створення підкласу :class:`Mock` або :class:"
"`MagicMock`, який копіює (за допомогою :func:`copy.deepcopy`) аргументи. Ось "
"приклад реалізації:"

msgid ""
"When you subclass ``Mock`` or ``MagicMock`` all dynamically created "
"attributes, and the ``return_value`` will use your subclass automatically. "
"That means all children of a ``CopyingMock`` will also have the type "
"``CopyingMock``."
msgstr ""
"Коли ви створюєте підклас ``Mock`` або ``MagicMock``, усі динамічно створені "
"атрибути та ``return_value`` автоматично використовуватимуть ваш підклас. Це "
"означає, що всі нащадки ``CopyingMock`` також матимуть тип ``CopyingMock``."

msgid "Nesting Patches"
msgstr "Патчі гніздування"

msgid ""
"Using patch as a context manager is nice, but if you do multiple patches you "
"can end up with nested with statements indenting further and further to the "
"right::"
msgstr ""
"Використовувати patch як менеджер контексту добре, але якщо ви робите кілька "
"патчів, ви можете отримати вкладені з операторами відступи все далі й далі "
"праворуч::"

msgid ""
"With unittest ``cleanup`` functions and the :ref:`start-and-stop` we can "
"achieve the same effect without the nested indentation. A simple helper "
"method, ``create_patch``, puts the patch in place and returns the created "
"mock for us::"
msgstr ""
"За допомогою функцій очищення unittest і :ref:`start-and-stop` ми можемо "
"досягти того самого ефекту без вкладеного відступу. Простий допоміжний "
"метод, ``create_patch``, ставить патч на місце та повертає створений макет "
"для нас::"

msgid "Mocking a dictionary with MagicMock"
msgstr "Знущання над словником за допомогою MagicMock"

msgid ""
"You may want to mock a dictionary, or other container object, recording all "
"access to it whilst having it still behave like a dictionary."
msgstr ""
"Можливо, ви захочете імітувати словник або інший об’єкт-контейнер, записуючи "
"всі доступи до нього, водночас залишаючи його поведінку як словник."

msgid ""
"We can do this with :class:`MagicMock`, which will behave like a dictionary, "
"and using :data:`~Mock.side_effect` to delegate dictionary access to a real "
"underlying dictionary that is under our control."
msgstr ""
"Ми можемо зробити це за допомогою :class:`MagicMock`, який поводитиметься як "
"словник, і за допомогою :data:`~Mock.side_effect` для делегування доступу до "
"словника справжньому базовому словнику, який знаходиться під нашим контролем."

msgid ""
"When the :meth:`__getitem__` and :meth:`__setitem__` methods of our "
"``MagicMock`` are called (normal dictionary access) then ``side_effect`` is "
"called with the key (and in the case of ``__setitem__`` the value too). We "
"can also control what is returned."
msgstr ""
"Коли викликаються методи :meth:`__getitem__` і :meth:`__setitem__` нашого "
"``MagicMock`` (звичайний доступ до словника), тоді ``side_effect`` "
"викликається з ключем (а у випадку ``__setitem__`` значення також). Ми також "
"можемо контролювати те, що повертається."

msgid ""
"After the ``MagicMock`` has been used we can use attributes like :data:"
"`~Mock.call_args_list` to assert about how the dictionary was used:"
msgstr ""
"Після використання ``MagicMock`` ми можемо використовувати такі атрибути, "
"як :data:`~Mock.call_args_list`, щоб підтвердити, як використовувався "
"словник:"

msgid ""
"An alternative to using ``MagicMock`` is to use ``Mock`` and *only* provide "
"the magic methods you specifically want:"
msgstr ""
"Альтернативою використанню ``MagicMock`` є використання ``Mock`` і *лише* "
"надання магічних методів, які вам потрібні:"

msgid ""
"A *third* option is to use ``MagicMock`` but passing in ``dict`` as the "
"*spec* (or *spec_set*) argument so that the ``MagicMock`` created only has "
"dictionary magic methods available:"
msgstr ""
"*Третій* варіант — використовувати ``MagicMock``, але передаючи ``dict`` як "
"аргумент *spec* (або *spec_set*), щоб створений ``MagicMock`` мав доступні "
"лише магічні методи словника:"

msgid ""
"With these side effect functions in place, the ``mock`` will behave like a "
"normal dictionary but recording the access. It even raises a :exc:`KeyError` "
"if you try to access a key that doesn't exist."
msgstr ""
"З цими функціями побічних ефектів ``мокет`` поводитиметься як звичайний "
"словник, але записуватиме доступ. Він навіть викликає :exc:`KeyError`, якщо "
"ви намагаєтеся отримати доступ до ключа, якого не існує."

msgid ""
"After it has been used you can make assertions about the access using the "
"normal mock methods and attributes:"
msgstr ""
"Після його використання ви можете робити твердження щодо доступу за "
"допомогою звичайних методів і атрибутів:"

msgid "Mock subclasses and their attributes"
msgstr "Макетні підкласи та їхні атрибути"

msgid ""
"There are various reasons why you might want to subclass :class:`Mock`. One "
"reason might be to add helper methods. Here's a silly example:"
msgstr ""
"Існують різні причини, чому ви можете створити підклас :class:`Mock`. Однією "
"з причин може бути додавання допоміжних методів. Ось дурний приклад:"

msgid ""
"The standard behaviour for ``Mock`` instances is that attributes and the "
"return value mocks are of the same type as the mock they are accessed on. "
"This ensures that ``Mock`` attributes are ``Mocks`` and ``MagicMock`` "
"attributes are ``MagicMocks`` [#]_. So if you're subclassing to add helper "
"methods then they'll also be available on the attributes and return value "
"mock of instances of your subclass."
msgstr ""
"Стандартна поведінка екземплярів ``Mock`` полягає в тому, що атрибути та "
"значення, що повертаються mocks, мають той самий тип, що й макет, з якого до "
"них здійснюється доступ. Це гарантує, що атрибути ``Mock`` є ``Mocks``, а "
"``MagicMock`` атрибути ``MagicMocks`` [#]_. Отже, якщо ви створюєте підкласи "
"для додавання допоміжних методів, вони також будуть доступні в атрибутах і "
"повертаються значеннях екземплярів вашого підкласу."

msgid ""
"Sometimes this is inconvenient. For example, `one user <https://code.google."
"com/archive/p/mock/issues/105>`_ is subclassing mock to created a `Twisted "
"adaptor <https://twistedmatrix.com/documents/11.0.0/api/twisted.python."
"components.html>`_. Having this applied to attributes too actually causes "
"errors."
msgstr ""
"Іноді це незручно. Наприклад, `один користувач <https://code.google.com/"
"archive/p/mock/issues/105>`_ створює підклас, щоб створити `Twisted adapter "
"<https://twistedmatrix.com/documents/11.0.0/api/twisted.python.components."
"html>`_. Застосування цього до атрибутів також спричиняє помилки."

msgid ""
"``Mock`` (in all its flavours) uses a method called ``_get_child_mock`` to "
"create these \"sub-mocks\" for attributes and return values. You can prevent "
"your subclass being used for attributes by overriding this method. The "
"signature is that it takes arbitrary keyword arguments (``**kwargs``) which "
"are then passed onto the mock constructor:"
msgstr ""
"``Mock`` (у всіх його варіантах) використовує метод під назвою "
"``_get_child_mock``, щоб створити ці \"під-моки\" для атрибутів і "
"повертаються значень. Ви можете запобігти використанню вашого підкласу для "
"атрибутів, замінивши цей метод. Підпис полягає в тому, що він приймає "
"довільні аргументи ключового слова (``**kwargs``), які потім передаються в "
"макетний конструктор:"

msgid ""
"An exception to this rule are the non-callable mocks. Attributes use the "
"callable variant because otherwise non-callable mocks couldn't have callable "
"methods."
msgstr ""
"Винятком із цього правила є невикликані моки. Атрибути використовують "
"викликаючий варіант, оскільки інакше невикликані макети не могли б мати "
"викликані методи."

msgid "Mocking imports with patch.dict"
msgstr "Знущання над імпортом за допомогою patch.dict"

msgid ""
"One situation where mocking can be hard is where you have a local import "
"inside a function. These are harder to mock because they aren't using an "
"object from the module namespace that we can patch out."
msgstr ""
"Одна ситуація, коли насмішка може бути важкою, це коли у вас є локальний "
"імпорт всередині функції. Їх важче висміяти, оскільки вони не використовують "
"об’єкт із простору імен модуля, який ми можемо виправити."

msgid ""
"Generally local imports are to be avoided. They are sometimes done to "
"prevent circular dependencies, for which there is *usually* a much better "
"way to solve the problem (refactor the code) or to prevent \"up front "
"costs\" by delaying the import. This can also be solved in better ways than "
"an unconditional local import (store the module as a class or module "
"attribute and only do the import on first use)."
msgstr ""
"Загалом слід уникати місцевого імпорту. Іноді їх роблять, щоб запобігти "
"циклічним залежностям, для яких *зазвичай* існує набагато кращий спосіб "
"вирішити проблему (рефакторити код) або запобігти \"попереднім витратам\" "
"шляхом затримки імпорту. Це також можна вирішити кращим способом, ніж "
"безумовний локальний імпорт (зберігайте модуль як клас або атрибут модуля та "
"виконуйте імпорт лише під час першого використання)."

msgid ""
"That aside there is a way to use ``mock`` to affect the results of an "
"import. Importing fetches an *object* from the :data:`sys.modules` "
"dictionary. Note that it fetches an *object*, which need not be a module. "
"Importing a module for the first time results in a module object being put "
"in `sys.modules`, so usually when you import something you get a module "
"back. This need not be the case however."
msgstr ""
"Крім того, існує спосіб використання ``mock`` для впливу на результати "
"імпорту. Імпорт отримує *об’єкт* зі словника :data:`sys.modules`. Зверніть "
"увагу, що він отримує *об’єкт*, який не обов’язково повинен бути модулем. "
"Імпортування модуля вперше призводить до того, що об’єкт модуля поміщається "
"в `sys.modules`, тому зазвичай, коли ви імпортуєте щось, ви отримуєте модуль "
"назад. Однак це не повинно бути так."

msgid ""
"This means you can use :func:`patch.dict` to *temporarily* put a mock in "
"place in :data:`sys.modules`. Any imports whilst this patch is active will "
"fetch the mock. When the patch is complete (the decorated function exits, "
"the with statement body is complete or ``patcher.stop()`` is called) then "
"whatever was there previously will be restored safely."
msgstr ""
"Це означає, що ви можете використовувати :func:`patch.dict`, щоб *тимчасово* "
"розмістити макет на місці в :data:`sys.modules`. Будь-який імпорт, поки цей "
"патч активний, отримуватиме макет. Коли виправлення завершено (декорована "
"функція завершує роботу, тіло оператора with завершено або викликається "
"``patcher.stop()``), тоді все, що було раніше, буде безпечно відновлено."

msgid "Here's an example that mocks out the 'fooble' module."
msgstr "Ось приклад, який висміює модуль \"fooble\"."

msgid ""
"As you can see the ``import fooble`` succeeds, but on exit there is no "
"'fooble' left in :data:`sys.modules`."
msgstr ""
"Як ви бачите, ``імпорт fooble`` вдається, але після виходу в :data:`sys."
"modules` не залишилося жодного 'fooble'."

msgid "This also works for the ``from module import name`` form:"
msgstr "Це також працює для форми ``from module import name``:"

msgid "With slightly more work you can also mock package imports:"
msgstr ""
"Доклавши трохи більше зусиль, ви також можете імітувати імпорт пакетів:"

msgid "Tracking order of calls and less verbose call assertions"
msgstr "Відстеження порядку викликів і менш докладні підтвердження викликів"

msgid ""
"The :class:`Mock` class allows you to track the *order* of method calls on "
"your mock objects through the :attr:`~Mock.method_calls` attribute. This "
"doesn't allow you to track the order of calls between separate mock objects, "
"however we can use :attr:`~Mock.mock_calls` to achieve the same effect."
msgstr ""
"Клас :class:`Mock` дозволяє вам відстежувати *порядок* викликів методів "
"ваших фіктивних об’єктів за допомогою атрибута :attr:`~Mock.method_calls`. "
"Це не дозволяє відстежувати порядок викликів між окремими макетними "
"об’єктами, однак ми можемо використовувати :attr:`~Mock.mock_calls` для "
"досягнення того самого ефекту."

msgid ""
"Because mocks track calls to child mocks in ``mock_calls``, and accessing an "
"arbitrary attribute of a mock creates a child mock, we can create our "
"separate mocks from a parent one. Calls to those child mock will then all be "
"recorded, in order, in the ``mock_calls`` of the parent:"
msgstr ""
"Оскільки mocks відстежують виклики дочірніх mocks у ``mock_calls``, а доступ "
"до довільного атрибута mock створює дочірній mock, ми можемо створювати "
"окремі моки від батьківського. Виклики цих дочірніх маніпуляцій будуть "
"записані по порядку в ``mock_calls`` батьківського:"

msgid ""
"We can then assert about the calls, including the order, by comparing with "
"the ``mock_calls`` attribute on the manager mock:"
msgstr ""
"Потім ми можемо стверджувати про виклики, включаючи порядок, порівнюючи з "
"атрибутом ``mock_calls`` макет менеджера:"

msgid ""
"If ``patch`` is creating, and putting in place, your mocks then you can "
"attach them to a manager mock using the :meth:`~Mock.attach_mock` method. "
"After attaching calls will be recorded in ``mock_calls`` of the manager. ::"
msgstr ""
"Якщо ``patch`` створює та розміщує ваші макети, ви можете прикріпити їх до "
"макета менеджера за допомогою методу :meth:`~Mock.attach_mock`. Після "
"прикріплення виклики будуть записані в ``mock_calls`` менеджера. ::"

msgid ""
"If many calls have been made, but you're only interested in a particular "
"sequence of them then an alternative is to use the :meth:`~Mock."
"assert_has_calls` method. This takes a list of calls (constructed with the :"
"data:`call` object). If that sequence of calls are in :attr:`~Mock."
"mock_calls` then the assert succeeds."
msgstr ""
"Якщо було зроблено багато викликів, але вас цікавить лише певна їх "
"послідовність, альтернативою є використання методу :meth:`~Mock."
"assert_has_calls`. Це бере список викликів (створений за допомогою об’єкта :"
"data:`call`). Якщо ця послідовність викликів міститься в :attr:`~Mock."
"mock_calls`, тоді твердження буде успішним."

msgid ""
"Even though the chained call ``m.one().two().three()`` aren't the only calls "
"that have been made to the mock, the assert still succeeds."
msgstr ""
"Незважаючи на те, що зв’язаний виклик ``m.one().two().three()`` не єдиний "
"виклик, який було зроблено для mock, твердження все одно успішне."

msgid ""
"Sometimes a mock may have several calls made to it, and you are only "
"interested in asserting about *some* of those calls. You may not even care "
"about the order. In this case you can pass ``any_order=True`` to "
"``assert_has_calls``:"
msgstr ""
"Іноді макет може мати кілька звернень до нього, і ви зацікавлені лише в "
"підтвердженні *деяких* із цих викликів. Ви можете навіть не дбати про "
"порядок. У цьому випадку ви можете передати ``any_order=True`` до "
"``assert_has_calls``:"

msgid "More complex argument matching"
msgstr "Складніше зіставлення аргументів"

msgid ""
"Using the same basic concept as :data:`ANY` we can implement matchers to do "
"more complex assertions on objects used as arguments to mocks."
msgstr ""
"Використовуючи ту саму основну концепцію, що й :data:`ANY`, ми можемо "
"реалізувати збіги для більш складних тверджень щодо об’єктів, які "
"використовуються як аргументи для імітації."

msgid ""
"Suppose we expect some object to be passed to a mock that by default "
"compares equal based on object identity (which is the Python default for "
"user defined classes). To use :meth:`~Mock.assert_called_with` we would need "
"to pass in the exact same object. If we are only interested in some of the "
"attributes of this object then we can create a matcher that will check these "
"attributes for us."
msgstr ""
"Припустімо, ми очікуємо, що якийсь об’єкт буде передано макету, який за "
"замовчуванням порівнює рівність на основі ідентичності об’єкта (що є "
"стандартним значенням Python для визначених користувачем класів). Щоб "
"використовувати :meth:`~Mock.assert_ called_with`, нам потрібно буде "
"передати той самий об’єкт. Якщо нас цікавлять лише деякі атрибути цього "
"об’єкта, ми можемо створити відповідник, який перевірить ці атрибути для нас."

msgid ""
"You can see in this example how a 'standard' call to ``assert_called_with`` "
"isn't sufficient:"
msgstr ""
"У цьому прикладі ви можете побачити, як \"стандартного\" виклику ``assert_ "
"called_with`` недостатньо:"

msgid ""
"A comparison function for our ``Foo`` class might look something like this:"
msgstr ""
"Функція порівняння для нашого класу ``Foo`` може виглядати приблизно так:"

msgid ""
"And a matcher object that can use comparison functions like this for its "
"equality operation would look something like this:"
msgstr ""
"І об’єкт відповідності, який може використовувати такі функції порівняння "
"для своєї операції рівності, виглядатиме приблизно так:"

msgid "Putting all this together:"
msgstr "Зібравши все це разом:"

msgid ""
"The ``Matcher`` is instantiated with our compare function and the ``Foo`` "
"object we want to compare against. In ``assert_called_with`` the ``Matcher`` "
"equality method will be called, which compares the object the mock was "
"called with against the one we created our matcher with. If they match then "
"``assert_called_with`` passes, and if they don't an :exc:`AssertionError` is "
"raised:"
msgstr ""
"Екземпляр ``Matcher`` створюється нашою функцією порівняння та об’єктом "
"``Foo``, з яким ми хочемо порівняти. У ``assert_ called_with`` буде "
"викликаний метод рівності ``Matcher``, який порівнює об’єкт, з яким було "
"викликано макет, з тим, з яким ми створили наш збігувач. Якщо вони "
"збігаються, ``assert_ called_with`` пропускається, а якщо вони не "
"збігаються, виникає :exc:`AssertionError`:"

msgid ""
"With a bit of tweaking you could have the comparison function raise the :exc:"
"`AssertionError` directly and provide a more useful failure message."
msgstr ""
"Трохи налаштувавши функцію порівняння, ви могли б безпосередньо викликати :"
"exc:`AssertionError` і надавати більш корисне повідомлення про помилку."

msgid ""
"As of version 1.5, the Python testing library `PyHamcrest <https://"
"pyhamcrest.readthedocs.io/>`_ provides similar functionality, that may be "
"useful here, in the form of its equality matcher (`hamcrest.library."
"integration.match_equality <https://pyhamcrest.readthedocs.io/en/release-1.8/"
"integration/#module-hamcrest.library.integration.match_equality>`_)."
msgstr ""
"Починаючи з версії 1.5, тестова бібліотека Python `PyHamcrest <https://"
"pyhamcrest.readthedocs.io/>`_ надає подібну функціональність, яка може бути "
"корисною тут, у формі її відповідника рівності (`hamcrest.library."
"integration.match_equality <https://pyhamcrest.readthedocs.io/en/release-1.8/"
"integration/#module-hamcrest.library.integration.match_equality>`_)."
