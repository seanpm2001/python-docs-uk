# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-29 17:18+0300\n"
"PO-Revision-Date: 2022-07-05 15:37+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`os.path` --- Common pathname manipulations"
msgstr ":mod:`os.path` --- Типові маніпуляції з іменами шляху"

msgid ""
"**Source code:** :source:`Lib/posixpath.py` (for POSIX) and :source:`Lib/"
"ntpath.py` (for Windows)."
msgstr ""
"**Вихідний код:** :source:`Lib/posixpath.py` (для POSIX) і :source:`Lib/"
"ntpath.py` (для Windows)."

msgid ""
"This module implements some useful functions on pathnames. To read or write "
"files see :func:`open`, and for accessing the filesystem see the :mod:`os` "
"module. The path parameters can be passed as strings, or bytes, or any "
"object implementing the :class:`os.PathLike` protocol."
msgstr ""
"Цей модуль реалізує деякі корисні функції для шляхів. Щоб прочитати або "
"записати файли, перегляньте :func:`open`, а для доступу до файлової системи "
"перегляньте модуль :mod:`os`. Параметри шляху можна передати як рядки, або "
"байти, або будь-який об’єкт, що реалізує протокол :class:`os.PathLike`."

msgid ""
"Unlike a unix shell, Python does not do any *automatic* path expansions. "
"Functions such as :func:`expanduser` and :func:`expandvars` can be invoked "
"explicitly when an application desires shell-like path expansion.  (See also "
"the :mod:`glob` module.)"
msgstr ""
"На відміну від оболонки Unix, Python не виконує *автоматичних* розширень "
"шляху. Такі функції, як :func:`expanduser` і :func:`expandvars`, можна "
"викликати явно, коли програма бажає розширення шляху, подібного до оболонки. "
"(Див. також модуль :mod:`glob`.)"

msgid "The :mod:`pathlib` module offers high-level path objects."
msgstr "Модуль :mod:`pathlib` пропонує об’єкти шляху високого рівня."

msgid ""
"All of these functions accept either only bytes or only string objects as "
"their parameters.  The result is an object of the same type, if a path or "
"file name is returned."
msgstr ""
"Усі ці функції приймають як параметри лише байти або лише рядкові об’єкти. "
"Результатом є об’єкт того самого типу, якщо повертається шлях або ім’я файлу."

msgid ""
"Since different operating systems have different path name conventions, "
"there are several versions of this module in the standard library.  The :mod:"
"`os.path` module is always the path module suitable for the operating system "
"Python is running on, and therefore usable for local paths.  However, you "
"can also import and use the individual modules if you want to manipulate a "
"path that is *always* in one of the different formats.  They all have the "
"same interface:"
msgstr ""
"Оскільки різні операційні системи мають різні імена шляхів, у стандартній "
"бібліотеці є кілька версій цього модуля. Модуль :mod:`os.path` завжди є "
"модулем шляху, який підходить для операційної системи, у якій працює Python, "
"і тому його можна використовувати для локальних шляхів. Однак ви також "
"можете імпортувати та використовувати окремі модулі, якщо хочете "
"маніпулювати шляхом, який *завжди* має один із різних форматів. Усі вони "
"мають однаковий інтерфейс:"

msgid ":mod:`posixpath` for UNIX-style paths"
msgstr ":mod:`posixpath` для шляхів у стилі UNIX"

msgid ":mod:`ntpath` for Windows paths"
msgstr ":mod:`ntpath` для шляхів Windows"

msgid ""
":func:`exists`, :func:`lexists`, :func:`isdir`, :func:`isfile`, :func:"
"`islink`, and :func:`ismount` now return ``False`` instead of raising an "
"exception for paths that contain characters or bytes unrepresentable at the "
"OS level."
msgstr ""
":func:`exists`, :func:`lexists`, :func:`isdir`, :func:`isfile`, :func:"
"`islink` і :func:`ismount` тепер замість цього повертають ``False`` "
"створення винятку для шляхів, які містять символи або байти, які неможливо "
"відобразити на рівні ОС."

msgid ""
"Return a normalized absolutized version of the pathname *path*. On most "
"platforms, this is equivalent to calling the function :func:`normpath` as "
"follows: ``normpath(join(os.getcwd(), path))``."
msgstr ""
"Повертає нормалізовану абсолютизовану версію імені шляху *path*. На "
"більшості платформ це еквівалентно виклику функції :func:`normpath` таким "
"чином: ``normpath(join(os.getcwd(), path))``."

msgid "Accepts a :term:`path-like object`."
msgstr "Приймає :term:`path-like object`."

msgid ""
"Return the base name of pathname *path*.  This is the second element of the "
"pair returned by passing *path* to the function :func:`split`.  Note that "
"the result of this function is different from the Unix :program:`basename` "
"program; where :program:`basename` for ``'/foo/bar/'`` returns ``'bar'``, "
"the :func:`basename` function returns an empty string (``''``)."
msgstr ""
"Повертає базову назву шляху *path*. Це другий елемент пари, що повертається "
"шляхом передачі *path* до функції :func:`split`. Зверніть увагу, що "
"результат цієї функції відрізняється від програми Unix :program:`basename`; "
"де :program:`basename` для ``'/foo/bar/'`` повертає ``'bar'``, функція :func:"
"`basename` повертає порожній рядок (``''``)."

msgid ""
"Return the longest common sub-path of each pathname in the sequence "
"*paths*.  Raise :exc:`ValueError` if *paths* contain both absolute and "
"relative pathnames, the *paths* are on the different drives or if *paths* is "
"empty.  Unlike :func:`commonprefix`, this returns a valid path."
msgstr ""
"Повертає найдовший спільний підшлях кожного шляху в послідовності *шляхи*. "
"Викликайте :exc:`ValueError`, якщо *шляхи* містять як абсолютні, так і "
"відносні шляхи, *шляхи* знаходяться на різних дисках або якщо *шляхи* "
"порожні. На відміну від :func:`commonprefix`, це повертає дійсний шлях."

msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Наявність <availability>`: Unix, Windows."

msgid "Accepts a sequence of :term:`path-like objects <path-like object>`."
msgstr "Приймає послідовність :term:`шляхових об’єктів <path-like object>`."

msgid ""
"Return the longest path prefix (taken character-by-character) that is a "
"prefix of all paths in  *list*.  If *list* is empty, return the empty string "
"(``''``)."
msgstr ""
"Повертає найдовший префікс шляху (взятий посимвольно), який є префіксом усіх "
"шляхів у *списку*. Якщо *список* порожній, поверніть порожній рядок (``''``)."

msgid ""
"This function may return invalid paths because it works a character at a "
"time.  To obtain a valid path, see :func:`commonpath`."
msgstr ""
"Ця функція може повертати недійсні шляхи, оскільки вона працює по символам "
"за раз. Щоб отримати правильний шлях, перегляньте :func:`commonpath`."

msgid ""
"Return the directory name of pathname *path*.  This is the first element of "
"the pair returned by passing *path* to the function :func:`split`."
msgstr ""
"Повертає назву каталогу *path*. Це перший елемент пари, який повертається "
"шляхом передачі *шляху* до функції :func:`split`."

msgid ""
"Return ``True`` if *path* refers to an existing path or an open file "
"descriptor.  Returns ``False`` for broken symbolic links.  On some "
"platforms, this function may return ``False`` if permission is not granted "
"to execute :func:`os.stat` on the requested file, even if the *path* "
"physically exists."
msgstr ""
"Повертає ``True``, якщо *path* посилається на існуючий шлях або дескриптор "
"відкритого файлу. Повертає ``False`` для пошкоджених символічних посилань. "
"На деяких платформах ця функція може повертати ``False``, якщо не надано "
"дозвіл на виконання :func:`os.stat` над запитуваним файлом, навіть якщо "
"*шлях* фізично існує."

msgid ""
"*path* can now be an integer: ``True`` is returned if it is an  open file "
"descriptor, ``False`` otherwise."
msgstr ""
"*шлях* тепер може бути цілим числом: ``True`` повертається, якщо це "
"дескриптор відкритого файлу, ``False`` інакше."

msgid ""
"Return ``True`` if *path* refers to an existing path. Returns ``True`` for "
"broken symbolic links.   Equivalent to :func:`exists` on platforms lacking :"
"func:`os.lstat`."
msgstr ""
"Повертає ``True``, якщо *path* посилається на існуючий шлях. Повертає "
"``True`` для пошкоджених символічних посилань. Еквівалент :func:`exists` на "
"платформах, на яких відсутній :func:`os.lstat`."

msgid ""
"On Unix and Windows, return the argument with an initial component of ``~`` "
"or ``~user`` replaced by that *user*'s home directory."
msgstr ""
"В Unix і Windows поверніть аргумент із початковим компонентом ``~`` або "
"``~user``, заміненим домашнім каталогом *користувача*."

msgid ""
"On Unix, an initial ``~`` is replaced by the environment variable :envvar:"
"`HOME` if it is set; otherwise the current user's home directory is looked "
"up in the password directory through the built-in module :mod:`pwd`. An "
"initial ``~user`` is looked up directly in the password directory."
msgstr ""
"В Unix початковий ``~`` замінюється змінною середовища :envvar:`HOME`, якщо "
"вона встановлена; інакше домашній каталог поточного користувача шукається в "
"каталозі паролів за допомогою вбудованого модуля :mod:`pwd`. Початковий "
"``~користувач`` шукається безпосередньо в каталозі паролів."

msgid ""
"On Windows, :envvar:`USERPROFILE` will be used if set, otherwise a "
"combination of :envvar:`HOMEPATH` and :envvar:`HOMEDRIVE` will be used.  An "
"initial ``~user`` is handled by checking that the last directory component "
"of the current user's home directory matches :envvar:`USERNAME`, and "
"replacing it if so."
msgstr ""
"У Windows :envvar:`USERPROFILE` використовуватиметься, якщо встановлено, "
"інакше використовуватиметься комбінація :envvar:`HOMEPATH` і :envvar:"
"`HOMEDRIVE`. Початковий ``~користувач`` обробляється шляхом перевірки "
"відповідності останнього компонента каталогу домашнього каталогу поточного "
"користувача :envvar:`ІМ'Я КОРИСТУВАЧА` та його заміни, якщо так."

msgid ""
"If the expansion fails or if the path does not begin with a tilde, the path "
"is returned unchanged."
msgstr ""
"Якщо розширення не вдається або якщо шлях не починається з тильди, шлях "
"повертається без змін."

msgid "No longer uses :envvar:`HOME` on Windows."
msgstr "Більше не використовує :envvar:`HOME` у Windows."

msgid ""
"Return the argument with environment variables expanded.  Substrings of the "
"form ``$name`` or ``${name}`` are replaced by the value of environment "
"variable *name*.  Malformed variable names and references to non-existing "
"variables are left unchanged."
msgstr ""
"Повертає аргумент із розгорнутими змінними середовища. Підрядки у формі "
"``$name`` або ``${name}`` замінюються значенням змінної середовища *name*. "
"Неправильні назви змінних і посилання на неіснуючі змінні залишаються без "
"змін."

msgid ""
"On Windows, ``%name%`` expansions are supported in addition to ``$name`` and "
"``${name}``."
msgstr ""
"У Windows підтримуються розширення ``%name%`` на додаток до ``$name`` і "
"``${name}``."

msgid ""
"Return the time of last access of *path*.  The return value is a floating "
"point number giving the number of seconds since the epoch (see the  :mod:"
"`time` module).  Raise :exc:`OSError` if the file does not exist or is "
"inaccessible."
msgstr ""
"Повертає час останнього доступу до *path*. Поверненим значенням є число з "
"плаваючою комою, що вказує кількість секунд після епохи (див. модуль :mod:"
"`time`). Викликати :exc:`OSError`, якщо файл не існує або недоступний."

msgid ""
"Return the time of last modification of *path*.  The return value is a "
"floating point number giving the number of seconds since the epoch (see "
"the  :mod:`time` module). Raise :exc:`OSError` if the file does not exist or "
"is inaccessible."
msgstr ""
"Повертає час останньої зміни *шляху*. Поверненим значенням є число з "
"плаваючою комою, що вказує кількість секунд після епохи (див. модуль :mod:"
"`time`). Викликати :exc:`OSError`, якщо файл не існує або недоступний."

msgid ""
"Return the system's ctime which, on some systems (like Unix) is the time of "
"the last metadata change, and, on others (like Windows), is the creation "
"time for *path*. The return value is a number giving the number of seconds "
"since the epoch (see the  :mod:`time` module).  Raise :exc:`OSError` if the "
"file does not exist or is inaccessible."
msgstr ""
"Повертає системний час ctime, який у деяких системах (наприклад, Unix) є "
"часом останньої зміни метаданих, а в інших (наприклад, Windows) є часом "
"створення *шляху*. Поверненим значенням є число, що вказує кількість секунд "
"з моменту епохи (див. модуль :mod:`time`). Викликати :exc:`OSError`, якщо "
"файл не існує або недоступний."

msgid ""
"Return the size, in bytes, of *path*.  Raise :exc:`OSError` if the file does "
"not exist or is inaccessible."
msgstr ""
"Повертає розмір у байтах *шляху*. Викликати :exc:`OSError`, якщо файл не "
"існує або недоступний."

msgid ""
"Return ``True`` if *path* is an absolute pathname.  On Unix, that means it "
"begins with a slash, on Windows that it begins with a (back)slash after "
"chopping off a potential drive letter."
msgstr ""
"Повертає ``True``, якщо *path* є абсолютним шляхом. В Unix це означає, що "
"він починається з похилої риски, а в Windows – із (зворотної) похилої риски "
"після відрізання потенційної літери диска."

msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` regular file. This "
"follows symbolic links, so both :func:`islink` and :func:`isfile` can be "
"true for the same path."
msgstr ""
"Повертає ``True``, якщо *path* є :func:`існуючим <exists>` звичайним файлом. "
"Це йде за символічними посиланнями, тому і :func:`islink`, і :func:`isfile` "
"можуть бути істинними для одного шляху."

msgid ""
"Return ``True`` if *path* is an :func:`existing <exists>` directory.  This "
"follows symbolic links, so both :func:`islink` and :func:`isdir` can be true "
"for the same path."
msgstr ""
"Повертає ``True``, якщо *path* є :func:`існуючим каталогом <exists>`. Це "
"слідує за символічними посиланнями, тому і :func:`islink`, і :func:`isdir` "
"можуть бути вірними для одного шляху."

msgid ""
"Return ``True`` if *path* refers to an :func:`existing <exists>` directory "
"entry that is a symbolic link.  Always ``False`` if symbolic links are not "
"supported by the Python runtime."
msgstr ""
"Повертає ``True``, якщо *path* посилається на :func:`існуючий запис каталогу "
"<exists>`, який є символічним посиланням. Завжди ``False``, якщо символічні "
"посилання не підтримуються середовищем виконання Python."

msgid ""
"Return ``True`` if pathname *path* is a :dfn:`mount point`: a point in a "
"file system where a different file system has been mounted.  On POSIX, the "
"function checks whether *path*'s parent, :file:`{path}/..`, is on a "
"different device than *path*, or whether :file:`{path}/..` and *path* point "
"to the same i-node on the same device --- this should detect mount points "
"for all Unix and POSIX variants.  It is not able to reliably detect bind "
"mounts on the same filesystem.  On Windows, a drive letter root and a share "
"UNC are always mount points, and for any other path ``GetVolumePathName`` is "
"called to see if it is different from the input path."
msgstr ""
"Повертає ``True``, якщо шлях *path* є :dfn:`mount point`: точкою у файловій "
"системі, де була змонтована інша файлова система. У POSIX функція перевіряє, "
"чи батьківський елемент *path*, :file:`{path}/..`, знаходиться на іншому "
"пристрої, ніж *path*, або :file:`{path}/..` і *шлях* вказує на той самий i-"
"node на тому самому пристрої --- це має виявити точки монтування для всіх "
"варіантів Unix і POSIX. Він не в змозі надійно виявити монтування прив’язки "
"на тій же файловій системі. У Windows коренева буква диска та спільний UNC "
"завжди є точками монтування, а для будь-якого іншого шляху викликається "
"GetVolumePathName, щоб перевірити, чи відрізняється він від шляху введення."

msgid "Support for detecting non-root mount points on Windows."
msgstr "Підтримка виявлення некореневих точок монтування в Windows."

msgid ""
"Join one or more path components intelligently.  The return value is the "
"concatenation of *path* and any members of *\\*paths* with exactly one "
"directory separator following each non-empty part except the last, meaning "
"that the result will only end in a separator if the last part is empty.  If "
"a component is an absolute path, all previous components are thrown away and "
"joining continues from the absolute path component."
msgstr ""
"Розумно об’єднайте один або кілька компонентів шляху. Повернене значення є "
"конкатенацією *path* і будь-яких членів *\\*paths* із рівно одним "
"роздільником каталогу після кожної непорожньої частини, крім останньої, "
"тобто результат завершуватиметься роздільником, лише якщо остання частина "
"порожня . Якщо компонент є абсолютним шляхом, усі попередні компоненти "
"відкидаються, а приєднання продовжується з компонента абсолютного шляху."

msgid ""
"On Windows, the drive letter is not reset when an absolute path component (e."
"g., ``r'\\foo'``) is encountered.  If a component contains a drive letter, "
"all previous components are thrown away and the drive letter is reset.  Note "
"that since there is a current directory for each drive, ``os.path.join(\"c:"
"\", \"foo\")`` represents a path relative to the current directory on drive :"
"file:`C:`(:file:`c:foo`), not :file:`c:\\\\foo`."
msgstr ""
"У Windows літера диска не скидається, коли зустрічається компонент "
"абсолютного шляху (наприклад, ``r'\\foo'``). Якщо компонент містить букву "
"диска, усі попередні компоненти викидаються, а літеру диска скидається. "
"Зауважте, що оскільки для кожного диска існує поточний каталог, os.path."
"join(\"c:\", \"foo\")`` представляє шлях відносно поточного каталогу на "
"диску :file:`C:`( :file:`c:foo`), а не :file:`c:\\\\foo`."

msgid "Accepts a :term:`path-like object` for *path* and *paths*."
msgstr "Приймає :term:`path-like object` для *path* і *paths*."

msgid ""
"Normalize the case of a pathname.  On Windows, convert all characters in the "
"pathname to lowercase, and also convert forward slashes to backward slashes. "
"On other operating systems, return the path unchanged."
msgstr ""
"Нормалізуйте регістр імені шляху. У Windows перетворіть усі символи в імені "
"шляху на малі літери, а також перетворіть косі риски на зворотні. В інших "
"операційних системах повертайте шлях без змін."

msgid ""
"Normalize a pathname by collapsing redundant separators and up-level "
"references so that ``A//B``, ``A/B/``, ``A/./B`` and ``A/foo/../B`` all "
"become ``A/B``.  This string manipulation may change the meaning of a path "
"that contains symbolic links.  On Windows, it converts forward slashes to "
"backward slashes. To normalize case, use :func:`normcase`."
msgstr ""
"Нормалізуйте шлях шляхом згортання надлишкових роздільників і посилань "
"верхнього рівня, щоб ``A//B``, ``A/B/``, ``A/./B`` і ``A/foo/.. /B`` всі "
"стають ``A/B``. Ця маніпуляція рядком може змінити значення шляху, який "
"містить символічні посилання. У Windows він перетворює косі риски на "
"зворотні. Щоб нормалізувати регістр, використовуйте :func:`normcase`."

msgid ""
"On POSIX systems, in accordance with `IEEE Std 1003.1 2013 Edition; 4.13 "
"Pathname Resolution <http://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_, if a pathname begins with exactly two "
"slashes, the first component following the leading characters may be "
"interpreted in an implementation-defined manner, although more than two "
"leading characters shall be treated as a single character."
msgstr ""
"У системах POSIX, відповідно до `IEEE Std 1003.1 2013 Edition; 4.13 "
"Розділення імені шляху <http://pubs.opengroup.org/onlinepubs/9699919799/"
"basedefs/V1_chap04.html#tag_04_13>`_, якщо ім’я шляху починається рівно з "
"двох похилих рисок, перший компонент після початкових символів може бути "
"інтерпретований у спосіб, визначений реалізацією, хоча більше ніж два "
"початкові символи повинні розглядатися як один символ."

msgid ""
"Return the canonical path of the specified filename, eliminating any "
"symbolic links encountered in the path (if they are supported by the "
"operating system)."
msgstr ""
"Повертає канонічний шлях до вказаного імені файлу, усуваючи будь-які "
"символічні посилання, які зустрічаються в шляху (якщо вони підтримуються "
"операційною системою)."

msgid ""
"If a path doesn't exist or a symlink loop is encountered, and *strict* is "
"``True``, :exc:`OSError` is raised. If *strict* is ``False``, the path is "
"resolved as far as possible and any remainder is appended without checking "
"whether it exists."
msgstr ""
"Якщо шлях не існує або виникає цикл символічного посилання, а *strict* має "
"значення ``True``, виникає :exc:`OSError`. Якщо *strict* має значення "
"``False``, шлях розв’язується, наскільки це можливо, і будь-який залишок "
"додається без перевірки його існування."

msgid ""
"This function emulates the operating system's procedure for making a path "
"canonical, which differs slightly between Windows and UNIX with respect to "
"how links and subsequent path components interact."
msgstr ""
"Ця функція емулює процедуру операційної системи, щоб зробити шлях "
"канонічним, який дещо відрізняється між Windows і UNIX стосовно того, як "
"взаємодіють посилання та наступні компоненти шляху."

msgid ""
"Operating system APIs make paths canonical as needed, so it's not normally "
"necessary to call this function."
msgstr ""
"API операційної системи роблять шляхи канонічними за потреби, тому зазвичай "
"не потрібно викликати цю функцію."

msgid "Symbolic links and junctions are now resolved on Windows."
msgstr "Символічні зв’язки та з’єднання тепер розпізнаються у Windows."

msgid "The *strict* parameter was added."
msgstr "Додано параметр *strict*."

msgid ""
"Return a relative filepath to *path* either from the current directory or "
"from an optional *start* directory.  This is a path computation:  the "
"filesystem is not accessed to confirm the existence or nature of *path* or "
"*start*.  On Windows, :exc:`ValueError` is raised when *path* and *start* "
"are on different drives."
msgstr ""
"Повертає відносний шлях до файлу до *path* або з поточного каталогу, або з "
"додаткового каталогу *start*. Це обчислення шляху: доступ до файлової "
"системи не здійснюється для підтвердження існування або природи *шляху* або "
"*початку*. У Windows :exc:`ValueError` виникає, коли *шлях* і *початок* "
"знаходяться на різних дисках."

msgid "*start* defaults to :attr:`os.curdir`."
msgstr "*start* за замовчуванням :attr:`os.curdir`."

msgid ""
"Return ``True`` if both pathname arguments refer to the same file or "
"directory. This is determined by the device number and i-node number and "
"raises an exception if an :func:`os.stat` call on either pathname fails."
msgstr ""
"Повертає ``True``, якщо обидва аргументи шляху посилаються на той самий файл "
"або каталог. Це визначається номером пристрою та номером i-вузла та викликає "
"виняток, якщо виклик :func:`os.stat` будь-якого шляху не вдається."

msgid "Added Windows support."
msgstr "Додана підтримка Windows."

msgid "Windows now uses the same implementation as all other platforms."
msgstr ""
"Windows тепер використовує ту саму реалізацію, що й усі інші платформи."

msgid ""
"Return ``True`` if the file descriptors *fp1* and *fp2* refer to the same "
"file."
msgstr ""
"Повертає ``True``, якщо файлові дескриптори *fp1* і *fp2* стосуються одного "
"файлу."

msgid ""
"Return ``True`` if the stat tuples *stat1* and *stat2* refer to the same "
"file. These structures may have been returned by :func:`os.fstat`, :func:`os."
"lstat`, or :func:`os.stat`.  This function implements the underlying "
"comparison used by :func:`samefile` and :func:`sameopenfile`."
msgstr ""
"Повертає ``True``, якщо кортежі статистики *stat1* і *stat2* посилаються на "
"той самий файл. Ці структури могли бути повернуті :func:`os.fstat`, :func:"
"`os.lstat` або :func:`os.stat`. Ця функція реалізує основне порівняння, яке "
"використовується :func:`samefile` і :func:`sameopenfile`."

msgid ""
"Split the pathname *path* into a pair, ``(head, tail)`` where *tail* is the "
"last pathname component and *head* is everything leading up to that.  The "
"*tail* part will never contain a slash; if *path* ends in a slash, *tail* "
"will be empty.  If there is no slash in *path*, *head* will be empty.  If "
"*path* is empty, both *head* and *tail* are empty.  Trailing slashes are "
"stripped from *head* unless it is the root (one or more slashes only).  In "
"all cases, ``join(head, tail)`` returns a path to the same location as "
"*path* (but the strings may differ).  Also see the functions :func:`dirname` "
"and :func:`basename`."
msgstr ""
"Розділіть шлях *path* на пару, ``(head, tail)``, де *tail* — це останній "
"компонент шляху, а *head* — усе, що веде до нього. Частина *хвоста* ніколи "
"не міститиме косу риску; якщо *шлях* закінчується скісною рискою, *хвіст* "
"буде порожнім. Якщо в *path* немає скісної риски, *head* буде порожнім. Якщо "
"*шлях* порожній, і *голова*, і *хвіст* порожні. Кінцеві похилі риски "
"видаляються з *голови*, якщо це не корінь (лише одна або кілька похилих). У "
"всіх випадках ``join(head, tail)`` повертає шлях до того самого місця, що й "
"*path* (але рядки можуть відрізнятися). Також перегляньте функції :func:"
"`dirname` і :func:`basename`."

msgid ""
"Split the pathname *path* into a pair ``(drive, tail)`` where *drive* is "
"either a mount point or the empty string.  On systems which do not use drive "
"specifications, *drive* will always be the empty string.  In all cases, "
"``drive + tail`` will be the same as *path*."
msgstr ""
"Розділіть назву шляху *path* на пару ``(диск, хвіст)``, де *диск* є або "
"точкою монтування, або порожнім рядком. У системах, які не використовують "
"специфікації дисків, *drive* завжди буде порожнім рядком. У всіх випадках "
"``drive + tail`` буде таким самим, як *path*."

msgid ""
"On Windows, splits a pathname into drive/UNC sharepoint and relative path."
msgstr "У Windows розділяє шлях на диск/загальну точку UNC і відносний шлях."

msgid ""
"If the path contains a drive letter, drive will contain everything up to and "
"including the colon::"
msgstr ""
"Якщо шлях містить букву диска, диск міститиме все, аж до двокрапки включно::"

msgid ""
"If the path contains a UNC path, drive will contain the host name and share, "
"up to but not including the fourth separator::"
msgstr ""
"Якщо шлях містить UNC-шлях, диск міститиме ім’я хоста та спільний ресурс, до "
"четвертого роздільника, але не включаючи::"

msgid ""
"Split the pathname *path* into a pair ``(root, ext)``  such that ``root + "
"ext == path``, and the extension, *ext*, is empty or begins with a period "
"and contains at most one period."
msgstr ""
"Розділіть назву шляху *path* на пару ``(root, ext)`` таким чином, ``root + "
"ext == path``, а розширення *ext* буде порожнім або починається з крапки та "
"містить щонайбільше один період."

msgid "If the path contains no extension, *ext* will be ``''``::"
msgstr "Якщо шлях не містить розширення, *ext* буде ``''``::"

msgid ""
"If the path contains an extension, then *ext* will be set to this extension, "
"including the leading period. Note that previous periods will be ignored::"
msgstr ""
"Якщо шлях містить розширення, то *ext* буде встановлено для цього "
"розширення, включаючи початкову точку. Зауважте, що попередні періоди "
"ігноруватимуться:"

msgid ""
"Leading periods of the last component of the path are considered to be part "
"of the root::"
msgstr ""
"Початкові періоди останнього компонента шляху вважаються частиною кореня::"

msgid ""
"``True`` if arbitrary Unicode strings can be used as file names (within "
"limitations imposed by the file system)."
msgstr ""
"``True``, якщо довільні рядки Unicode можуть використовуватися як імена "
"файлів (в межах обмежень, накладених файловою системою)."
