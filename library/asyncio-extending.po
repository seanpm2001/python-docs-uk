# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-29 17:18+0300\n"
"PO-Revision-Date: 2022-07-05 15:39+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Extending"
msgstr "Розширення"

msgid ""
"The main direction for :mod:`asyncio` extending is writing custom *event "
"loop* classes. Asyncio has helpers that could be used to simplify this task."
msgstr ""
"Основним напрямком розширення :mod:`asyncio` є написання спеціальних класів "
"*циклу подій*. У Asyncio є помічники, які можна використати для спрощення "
"цього завдання."

msgid ""
"Third-parties should reuse existing asyncio code with caution, a new Python "
"version is free to break backward compatibility in *internal* part of API."
msgstr ""
"Третім сторонам слід обережно повторно використовувати існуючий асинхронний "
"код, нова версія Python може порушити зворотну сумісність у *внутрішній* "
"частині API."

msgid "Writing a Custom Event Loop"
msgstr "Написання спеціального циклу подій"

msgid ""
":class:`asyncio.AbstractEventLoop` declares very many methods.  Implementing "
"all them from scratch is a tedious job."
msgstr ""
":class:`asyncio.AbstractEventLoop` оголошує дуже багато методів. "
"Впроваджувати їх усі з нуля – клопітка робота."

msgid ""
"A loop can get many common methods implementation for free by inheriting "
"from :class:`asyncio.BaseEventLoop`."
msgstr ""
"Цикл може безкоштовно реалізувати багато поширених методів, успадкувавши "
"від :class:`asyncio.BaseEventLoop`."

msgid ""
"In turn, the successor should implement a bunch of *private* methods "
"declared but not implemented in :class:`asyncio.BaseEventLoop`."
msgstr ""
"У свою чергу, наступник повинен реалізувати купу *приватних* методів, "
"оголошених, але не реалізованих у :class:`asyncio.BaseEventLoop`."

msgid ""
"For example, ``loop.create_connection()`` checks arguments, resolves DNS "
"addresses, and calls ``loop._make_socket_transport()`` that should be "
"implemented by inherited class. The ``_make_socket_transport()`` method is "
"not documented and is considered as an *internal* API."
msgstr ""
"Наприклад, ``loop.create_connection()`` перевіряє аргументи, розпізнає "
"адреси DNS і викликає ``loop._make_socket_transport()``, який має бути "
"реалізований успадкованим класом. Метод ``_make_socket_transport()`` не "
"задокументований і вважається *внутрішнім* API."

msgid "Future and Task private constructors"
msgstr "Приватні конструктори \"Майбутнє і Задача\"."

msgid ""
":class:`asyncio.Future` and :class:`asyncio.Task` should be never created "
"directly, please use corresponding :meth:`loop.create_future` and :meth:"
"`loop.create_task`, or :func:`asyncio.create_task` factories instead."
msgstr ""
":class:`asyncio.Future` і :class:`asyncio.Task` ніколи не слід створювати "
"безпосередньо, Натомість використовуйте відповідні фабрики :meth:`loop."
"create_future` і :meth:`loop.create_task` або :func:`asyncio.create_task`."

msgid ""
"However, third-party *event loops* may *reuse* built-in future and task "
"implementations for the sake of getting a complex and highly optimized code "
"for free."
msgstr ""
"Проте сторонні *цикли подій* можуть *повторно використовувати* вбудовані "
"майбутні реалізації та реалізації завдань заради безкоштовного отримання "
"складного та високооптимізованого коду."

msgid "For this purpose the following, *private* constructors are listed:"
msgstr "Для цього перераховані такі *приватні* конструктори:"

msgid "Create a built-in future instance."
msgstr "Створіть вбудований майбутній екземпляр."

msgid "*loop* is an optional event loop instance."
msgstr "*loop* є необов’язковим екземпляром циклу подій."

msgid "Create a built-in task instance."
msgstr "Створіть вбудований екземпляр завдання."

msgid ""
"*loop* is an optional event loop instance. The rest of arguments are "
"described in :meth:`loop.create_task` description."
msgstr ""
"*loop* є необов’язковим екземпляром циклу подій. Решта аргументів описано в "
"описі :meth:`loop.create_task`."

msgid "*context* argument is added."
msgstr "додається аргумент *context*."

msgid ""
"Return ``True`` if *future* is attached to the same loop as the task, "
"``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо *future* приєднано до того самого циклу, що й "
"завдання, ``False`` інакше."

msgid "Task lifetime support"
msgstr "Довічна підтримка завдання"

msgid ""
"A third party task implementation should call the following functions to "
"keep a task visible by :func:`asyncio.get_tasks` and :func:`asyncio."
"current_task`:"
msgstr ""
"Реалізація завдання третьої сторони має викликати такі функції, щоб завдання "
"залишалося видимим для :func:`asyncio.get_tasks` і :func:`asyncio."
"current_task`:"

msgid "Register a new *task* as managed by *asyncio*."
msgstr "Зареєструйте нове *завдання* під керуванням *asyncio*."

msgid "Call the function from a task constructor."
msgstr "Виклик функції з конструктора завдань."

msgid "Unregister a *task* from *asyncio* internal structures."
msgstr "Скасувати реєстрацію *завдання* у внутрішніх структурах *asyncio*."

msgid "The function should be called when a task is about to finish."
msgstr "Функцію слід викликати, коли завдання майже завершено."

msgid "Switch the current task to the *task* argument."
msgstr "Перемкніть поточне завдання на аргумент *завдання*."

msgid ""
"Call the function just before executing a portion of embedded *coroutine* (:"
"meth:`coroutine.send` or :meth:`coroutine.throw`)."
msgstr ""
"Викликайте функцію безпосередньо перед виконанням частини вбудованої "
"*coroutine* (:meth:`coroutine.send` або :meth:`coroutine.throw`)."

msgid "Switch the current task back from *task* to ``None``."
msgstr "Повернути поточне завдання з *завдання* на ``None``."

msgid ""
"Call the function just after :meth:`coroutine.send` or :meth:`coroutine."
"throw` execution."
msgstr ""
"Викликайте функцію одразу після виконання :meth:`coroutine.send` або :meth:"
"`coroutine.throw`."
