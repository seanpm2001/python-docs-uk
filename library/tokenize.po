# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:16+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`tokenize` --- Tokenizer for Python source"
msgstr ":mod:`tokenize` --- Токенізатор для джерела Python"

msgid "**Source code:** :source:`Lib/tokenize.py`"
msgstr "**Вихідний код:** :source:`Lib/tokenize.py`"

msgid ""
"The :mod:`tokenize` module provides a lexical scanner for Python source "
"code, implemented in Python.  The scanner in this module returns comments as "
"tokens as well, making it useful for implementing \"pretty-printers\", "
"including colorizers for on-screen displays."
msgstr ""
"Модуль :mod:`tokenize` забезпечує лексичний сканер вихідного коду Python, "
"реалізований на Python. Сканер у цьому модулі також повертає коментарі як "
"токени, що робить його корисним для реалізації \"красивих принтерів\", "
"включаючи розфарбовувачі для екранних дисплеїв."

msgid ""
"To simplify token stream handling, all :ref:`operator <operators>` and :ref:"
"`delimiter <delimiters>` tokens and :data:`Ellipsis` are returned using the "
"generic :data:`~token.OP` token type.  The exact type can be determined by "
"checking the ``exact_type`` property on the :term:`named tuple` returned "
"from :func:`tokenize.tokenize`."
msgstr ""
"Щоб спростити обробку потоку маркерів, усі маркери :ref:`operator "
"<operators>` і :ref:`delimiter <delimiters>` і :data:`Ellipsis` повертаються "
"за допомогою загального типу токена :data:`~token.OP`. Точний тип можна "
"визначити, перевіривши властивість ``exact_type`` кортежу :term:`named "
"tuple`, який повертається з :func:`tokenize.tokenize`."

msgid "Tokenizing Input"
msgstr "Токенізований вхід"

msgid "The primary entry point is a :term:`generator`:"
msgstr "Основною точкою входу є :term:`generator`:"

msgid ""
"The :func:`.tokenize` generator requires one argument, *readline*, which "
"must be a callable object which provides the same interface as the :meth:`io."
"IOBase.readline` method of file objects.  Each call to the function should "
"return one line of input as bytes."
msgstr ""
"Для генератора :func:`.tokenize` потрібен один аргумент, *readline*, який "
"має бути викликаним об’єктом, який забезпечує той самий інтерфейс, що й "
"метод :meth:`io.IOBase.readline` файлових об’єктів. Кожен виклик функції має "
"повертати один рядок введення у вигляді байтів."

msgid ""
"The generator produces 5-tuples with these members: the token type; the "
"token string; a 2-tuple ``(srow, scol)`` of ints specifying the row and "
"column where the token begins in the source; a 2-tuple ``(erow, ecol)`` of "
"ints specifying the row and column where the token ends in the source; and "
"the line on which the token was found. The line passed (the last tuple item) "
"is the *physical* line.  The 5 tuple is returned as a :term:`named tuple` "
"with the field names: ``type string start end line``."
msgstr ""
"Генератор створює 5-кортежі з такими членами: тип маркера; рядок маркера; 2-"
"кортеж ``(srow, scol)`` int, що визначає рядок і стовпець, де починається "
"маркер у джерелі; 2-кортеж ``(erow, ecol)`` int, що визначає рядок і "
"стовпець, де закінчується маркер у джерелі; і рядок, на якому було знайдено "
"маркер. Пропущений рядок (останній елемент кортежу) є *фізичним* рядком. "
"Кортеж 5 повертається як :term:`named tuple` з іменами полів: ``type string "
"start end line``."

msgid ""
"The returned :term:`named tuple` has an additional property named "
"``exact_type`` that contains the exact operator type for :data:`~token.OP` "
"tokens.  For all other token types ``exact_type`` equals the named tuple "
"``type`` field."
msgstr ""
"Повернений кортеж :term:`named tuple` має додаткову властивість під назвою "
"``exact_type``, яка містить точний тип оператора для токенів :data:`~token."
"OP`. Для всіх інших типів токенів ``точний_тип`` дорівнює іменованому полю "
"``тип`` кортежу."

msgid "Added support for named tuples."
msgstr "Додано підтримку іменованих кортежів."

msgid "Added support for ``exact_type``."
msgstr "Додано підтримку ``exact_type``."

msgid ""
":func:`.tokenize` determines the source encoding of the file by looking for "
"a UTF-8 BOM or encoding cookie, according to :pep:`263`."
msgstr ""
":func:`.tokenize` визначає вихідне кодування файлу, шукаючи специфікацію "
"UTF-8 або кодування cookie, відповідно до :pep:`263`."

msgid "Tokenize a source reading unicode strings instead of bytes."
msgstr "Токенізуйте джерело, яке читає рядки Unicode замість байтів."

msgid ""
"Like :func:`.tokenize`, the *readline* argument is a callable returning a "
"single line of input. However, :func:`generate_tokens` expects *readline* to "
"return a str object rather than bytes."
msgstr ""
"Як і :func:`.tokenize`, аргумент *readline* є викликом, що повертає один "
"рядок введення. Однак :func:`generate_tokens` очікує, що *readline* "
"повертатиме об’єкт str, а не байти."

msgid ""
"The result is an iterator yielding named tuples, exactly like :func:`."
"tokenize`. It does not yield an :data:`~token.ENCODING` token."
msgstr ""
"Результатом є ітератор, який видає іменовані кортежі, точно як :func:`."
"tokenize`. Він не дає маркер :data:`~token.ENCODING`."

msgid ""
"All constants from the :mod:`token` module are also exported from :mod:"
"`tokenize`."
msgstr ""
"Усі константи з модуля :mod:`token` також експортуються з :mod:`tokenize`."

msgid ""
"Another function is provided to reverse the tokenization process. This is "
"useful for creating tools that tokenize a script, modify the token stream, "
"and write back the modified script."
msgstr ""
"Ще одна функція передбачена для зворотного процесу токенізації. Це корисно "
"для створення інструментів, які токенізують сценарій, змінюють потік "
"маркерів і записують назад змінений сценарій."

msgid ""
"Converts tokens back into Python source code.  The *iterable* must return "
"sequences with at least two elements, the token type and the token string. "
"Any additional sequence elements are ignored."
msgstr ""
"Перетворює маркери назад у вихідний код Python. *iterable* має повертати "
"послідовності принаймні з двома елементами, типом маркера та рядком маркера. "
"Будь-які додаткові елементи послідовності ігноруються."

msgid ""
"The reconstructed script is returned as a single string.  The result is "
"guaranteed to tokenize back to match the input so that the conversion is "
"lossless and round-trips are assured.  The guarantee applies only to the "
"token type and token string as the spacing between tokens (column positions) "
"may change."
msgstr ""
"Реконструйований сценарій повертається як один рядок. Результат гарантовано "
"токенізуватиметься назад, щоб відповідати вхідним даним, так що перетворення "
"буде без втрат і зворотні передачі будуть забезпечені. Гарантія поширюється "
"лише на тип маркера та рядок маркера, оскільки відстань між маркерами "
"(позиції стовпців) може змінюватися."

msgid ""
"It returns bytes, encoded using the :data:`~token.ENCODING` token, which is "
"the first token sequence output by :func:`.tokenize`. If there is no "
"encoding token in the input, it returns a str instead."
msgstr ""
"Він повертає байти, закодовані за допомогою маркера :data:`~token.ENCODING`, "
"який є першою послідовністю маркерів, виведеною :func:`.tokenize`. Якщо у "
"вхідних даних немає маркера кодування, натомість повертається str."

msgid ""
":func:`.tokenize` needs to detect the encoding of source files it tokenizes. "
"The function it uses to do this is available:"
msgstr ""
":func:`.tokenize` має визначити кодування вихідних файлів, які він "
"токенізує. Доступна функція, яку він використовує для цього:"

msgid ""
"The :func:`detect_encoding` function is used to detect the encoding that "
"should be used to decode a Python source file. It requires one argument, "
"readline, in the same way as the :func:`.tokenize` generator."
msgstr ""
"Функція :func:`detect_encoding` використовується для визначення кодування, "
"яке слід використовувати для декодування вихідного файлу Python. Для нього "
"потрібен один аргумент, readline, так само, як і генератор :func:`.tokenize`."

msgid ""
"It will call readline a maximum of twice, and return the encoding used (as a "
"string) and a list of any lines (not decoded from bytes) it has read in."
msgstr ""
"Він викличе readline щонайбільше двічі та поверне використане кодування (як "
"рядок) і список будь-яких рядків (не декодованих із байтів), які він "
"прочитав."

msgid ""
"It detects the encoding from the presence of a UTF-8 BOM or an encoding "
"cookie as specified in :pep:`263`. If both a BOM and a cookie are present, "
"but disagree, a :exc:`SyntaxError` will be raised. Note that if the BOM is "
"found, ``'utf-8-sig'`` will be returned as an encoding."
msgstr ""
"Він визначає кодування за наявністю специфікації UTF-8 або файлу cookie "
"кодування, як зазначено в :pep:`263`. Якщо і специфікація, і файл cookie "
"присутні, але не узгоджуються, виникне :exc:`SyntaxError`. Зауважте, що якщо "
"специфікацію буде знайдено, як кодування буде повернуто ``'utf-8-sig``."

msgid ""
"If no encoding is specified, then the default of ``'utf-8'`` will be "
"returned."
msgstr ""
"Якщо кодування не вказано, буде повернено значення за замовчуванням "
"``'utf-8``."

msgid ""
"Use :func:`.open` to open Python source files: it uses :func:"
"`detect_encoding` to detect the file encoding."
msgstr ""
"Використовуйте :func:`.open` для відкриття вихідних файлів Python: він "
"використовує :func:`detect_encoding` для визначення кодування файлу."

msgid ""
"Open a file in read only mode using the encoding detected by :func:"
"`detect_encoding`."
msgstr ""
"Відкрийте файл у режимі лише для читання, використовуючи кодування, "
"визначене :func:`detect_encoding`."

msgid ""
"Raised when either a docstring or expression that may be split over several "
"lines is not completed anywhere in the file, for example::"
msgstr ""
"Викликається, коли рядок документа або вираз, які можуть бути розділені на "
"кілька рядків, не завершені ніде у файлі, наприклад::"

msgid "or::"
msgstr "або::"

msgid ""
"Note that unclosed single-quoted strings do not cause an error to be raised. "
"They are tokenized as :data:`~token.ERRORTOKEN`, followed by the "
"tokenization of their contents."
msgstr ""
"Зауважте, що незакриті рядки в одинарних лапках не викликають помилки. Вони "
"токенізуються як :data:`~token.ERRORTOKEN`, після чого відбувається "
"токенізація їхнього вмісту."

msgid "Command-Line Usage"
msgstr "Використання командного рядка"

msgid ""
"The :mod:`tokenize` module can be executed as a script from the command "
"line. It is as simple as:"
msgstr ""
"Модуль :mod:`tokenize` можна запустити як скрипт із командного рядка. Це так "
"просто:"

msgid "The following options are accepted:"
msgstr "Приймаються такі варіанти:"

msgid "show this help message and exit"
msgstr "показати це довідкове повідомлення та вийти"

msgid "display token names using the exact type"
msgstr "відображати імена токенів, використовуючи точний тип"

msgid ""
"If :file:`filename.py` is specified its contents are tokenized to stdout. "
"Otherwise, tokenization is performed on stdin."
msgstr ""
"Якщо вказано :file:`filename.py`, його вміст токенізується до stdout. В "
"іншому випадку токенізація виконується на stdin."

msgid "Examples"
msgstr "Приклади"

msgid ""
"Example of a script rewriter that transforms float literals into Decimal "
"objects::"
msgstr ""
"Приклад сценарію переписувача, який перетворює плаваючі літерали в десяткові "
"об’єкти::"

msgid "Example of tokenizing from the command line.  The script::"
msgstr "Приклад токенізації з командного рядка. Сценарій::"

msgid ""
"will be tokenized to the following output where the first column is the "
"range of the line/column coordinates where the token is found, the second "
"column is the name of the token, and the final column is the value of the "
"token (if any)"
msgstr ""
"буде токенизовано до наступного виводу, де перший стовпець — діапазон "
"координат рядка/стовпця, де знайдено маркер, другий стовпець — ім’я маркера, "
"а останній стовпець — значення маркера (якщо є)"

msgid ""
"The exact token type names can be displayed using the :option:`-e` option:"
msgstr ""
"Точні назви типів маркерів можна відобразити за допомогою параметра :option:"
"`-e`:"

msgid ""
"Example of tokenizing a file programmatically, reading unicode strings "
"instead of bytes with :func:`generate_tokens`::"
msgstr ""
"Приклад токенізації файлу програмним шляхом, зчитування рядків Unicode "
"замість байтів за допомогою :func:`generate_tokens`::"

msgid "Or reading bytes directly with :func:`.tokenize`::"
msgstr "Або читання байтів безпосередньо за допомогою :func:`.tokenize`::"
