# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# hellowfacey, 2022
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:16+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`typing` --- Support for type hints"
msgstr ":mod:`typing` --- Підтримка підказок типу"

msgid "**Source code:** :source:`Lib/typing.py`"
msgstr "**Вихідний код:** :source:`Lib/typing.py`"

msgid ""
"The Python runtime does not enforce function and variable type annotations. "
"They can be used by third party tools such as type checkers, IDEs, linters, "
"etc."
msgstr ""
"Середовище виконання Python не використовує анотації типів функцій чи "
"змінних. Вони можуть використовуватися сторонніми інструментами, на кшталт "
"аналізаторів типів, IDE, лінтерів тощо."

msgid ""
"This module provides runtime support for type hints. The most fundamental "
"support consists of the types :data:`Any`, :data:`Union`, :data:`Callable`, :"
"class:`TypeVar`, and :class:`Generic`. For a full specification, please see :"
"pep:`484`. For a simplified introduction to type hints, see :pep:`483`."
msgstr ""
"Цей модуль впроваджує підтримку підказок типу під час виконання. Найбільш "
"фундаментальна підтримка складається з типів :data:`Any`, :data:`Union`, :"
"data:`Callable`, :class:`TypeVar` і :class:`Generic`. Повну специфікацію "
"див. :pep:`484`. Для спрощеного вступу до підказок типу див. :pep:`483`."

msgid ""
"The function below takes and returns a string and is annotated as follows::"
msgstr ""
"Наведена нижче функція приймає та повертає рядок і анотується таким чином:"

msgid ""
"In the function ``greeting``, the argument ``name`` is expected to be of "
"type :class:`str` and the return type :class:`str`. Subtypes are accepted as "
"arguments."
msgstr ""
"У функції ``greeting`` аргумент ``name`` має мати тип :class:`str` і тип "
"повернення :class:`str`. Підтипи приймаються як аргументи."

msgid ""
"New features are frequently added to the ``typing`` module. The "
"`typing_extensions <https://pypi.org/project/typing-extensions/>`_ package "
"provides backports of these new features to older versions of Python."
msgstr ""
"До модуля ``введення`` часто додаються нові функції. Пакет "
"`typing_extensions <https://pypi.org/project/typing-extensions/>`_ "
"забезпечує зворотні порти цих нових функцій для старіших версій Python."

msgid ""
"For a summary of deprecated features and a deprecation timeline, please see "
"`Deprecation Timeline of Major Features`_."
msgstr ""

msgid ""
"The documentation at https://typing.readthedocs.io/ serves as useful "
"reference for type system features, useful typing related tools and typing "
"best practices."
msgstr ""

msgid "Relevant PEPs"
msgstr "PEP'и за темою"

msgid ""
"Since the initial introduction of type hints in :pep:`484` and :pep:`483`, a "
"number of PEPs have modified and enhanced Python's framework for type "
"annotations. These include:"
msgstr ""
"З моменту появи підказок типів у :pep:`484` і :pep:`483` низка PEP'ів "
"змінили та покращили структуру Python для анотацій типів. Серед них:"

msgid ":pep:`526`: Syntax for Variable Annotations"
msgstr ":pep:`526`: Синтаксис для анотацій змінних"

msgid ""
"*Introducing* syntax for annotating variables outside of function "
"definitions, and :data:`ClassVar`"
msgstr ""
"*Представляємо* синтаксис для анотування змінних поза визначеннями функцій "
"і :data:`ClassVar`"

msgid ":pep:`544`: Protocols: Structural subtyping (static duck typing)"
msgstr ":pep:`544`: Протоколи: структурне підтипування (статичне типування)"

msgid ""
"*Introducing* :class:`Protocol` and the :func:"
"`@runtime_checkable<runtime_checkable>` decorator"
msgstr ""
"*Представляємо* :class:`Protocol` і декоратор :func:`@runtime_checkable "
"<runtime_checkable>`"

msgid ":pep:`585`: Type Hinting Generics In Standard Collections"
msgstr ":pep:`585`: Підказки узагальнень для стандартних колекцій"

msgid ""
"*Introducing* :class:`types.GenericAlias` and the ability to use standard "
"library classes as :ref:`generic types<types-genericalias>`"
msgstr ""
"*Представляємо* :class:`types.GenericAlias` і можливість використовувати "
"стандартні бібліотечні класи як :ref:` узагальнені типи <types-genericalias>`"

msgid ":pep:`586`: Literal Types"
msgstr ":pep:`586`: Літеральні типи"

msgid "*Introducing* :data:`Literal`"
msgstr "*Представляємо* :data:`Literal`"

msgid ""
":pep:`589`: TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys"
msgstr ""
":pep:`589`: TypedDict: Підказки типів для словників з фіксованим набором "
"ключів"

msgid "*Introducing* :class:`TypedDict`"
msgstr "*Представляємо* :class:`TypedDict`"

msgid ":pep:`591`: Adding a final qualifier to typing"
msgstr ":pep:`591`: Додавання кінцевого кваліфікатора до введення"

msgid "*Introducing* :data:`Final` and the :func:`@final<final>` decorator"
msgstr "*Представляємо* :data:`Final` і декоратор :func:`@final <final>`"

msgid ":pep:`593`: Flexible function and variable annotations"
msgstr ":pep:`593`: Гнучкі анотації функцій та змінних"

msgid "*Introducing* :data:`Annotated`"
msgstr "*Представляємо* :data:`Annotated`"

msgid ":pep:`604`: Allow writing union types as ``X | Y``"
msgstr ":pep:`604`: Дозволити запис типів об’єднань як ``X | Y``"

msgid ""
"*Introducing* :data:`types.UnionType` and the ability to use the binary-or "
"operator ``|`` to signify a :ref:`union of types<types-union>`"
msgstr ""
"*Представляємо* :data:`types.UnionType` і можливість використовувати "
"двійковий оператор ``|`` для позначення :ref:`об’єднання типів <types-union>`"

msgid ":pep:`612`: Parameter Specification Variables"
msgstr ":pep:`612`: Змінні специфікації параметрів"

msgid "*Introducing* :class:`ParamSpec` and :data:`Concatenate`"
msgstr "*Представляємо* :class:`ParamSpec` і :data:`Concatenate`"

msgid ":pep:`613`: Explicit Type Aliases"
msgstr ":pep:`613`: Явні псевдоніми типу"

msgid "*Introducing* :data:`TypeAlias`"
msgstr "*Представляємо* :data:`TypeAlias`"

msgid ":pep:`646`: Variadic Generics"
msgstr ""

msgid "*Introducing* :data:`TypeVarTuple`"
msgstr ""

msgid ":pep:`647`: User-Defined Type Guards"
msgstr ":pep:`647`: Охоронці типу, визначені користувачем"

msgid "*Introducing* :data:`TypeGuard`"
msgstr "*Представляємо* :data:`TypeGuard`"

msgid ""
":pep:`655`: Marking individual TypedDict items as required or potentially "
"missing"
msgstr ""

msgid "*Introducing* :data:`Required` and :data:`NotRequired`"
msgstr ""

msgid ":pep:`673`: Self type"
msgstr ""

msgid "*Introducing* :data:`Self`"
msgstr ""

msgid ":pep:`675`: Arbitrary Literal String Type"
msgstr ""

msgid "*Introducing* :data:`LiteralString`"
msgstr ""

msgid ":pep:`681`: Data Class Transforms"
msgstr ""

msgid ""
"*Introducing* the :func:`@dataclass_transform<dataclass_transform>` decorator"
msgstr ""

msgid "Type aliases"
msgstr "Псевдоніми типів"

msgid ""
"A type alias is defined by assigning the type to the alias. In this example, "
"``Vector`` and ``list[float]`` will be treated as interchangeable synonyms::"
msgstr ""
"Псевдонім типу визначається шляхом призначення типу псевдоніму. У цьому "
"прикладі ``Вектор`` і ``список[float]`` розглядатимуться як взаємозамінні "
"синоніми:"

msgid ""
"Type aliases are useful for simplifying complex type signatures. For "
"example::"
msgstr ""
"Псевдоніми типів корисні для спрощення анотацій складних типів. Наприклад::"

msgid ""
"Note that ``None`` as a type hint is a special case and is replaced by "
"``type(None)``."
msgstr ""
"Зауважте, що ``None`` як підказка типу є окремим випадком і замінюється "
"``type(None)``."

msgid "NewType"
msgstr "NewType"

msgid "Use the :class:`NewType` helper to create distinct types::"
msgstr "Використовуйте помічник :class:`NewType` для створення різних типів::"

msgid ""
"The static type checker will treat the new type as if it were a subclass of "
"the original type. This is useful in helping catch logical errors::"
msgstr ""
"Аналізатор типів розглядатиме новий тип як підклас вихідного типу. Це "
"корисно для виявлення логічних помилок:"

msgid ""
"You may still perform all ``int`` operations on a variable of type "
"``UserId``, but the result will always be of type ``int``. This lets you "
"pass in a ``UserId`` wherever an ``int`` might be expected, but will prevent "
"you from accidentally creating a ``UserId`` in an invalid way::"
msgstr ""
"Ви все ще можете виконувати всі операції ``int`` зі змінною типу ``UserId``, "
"але результат завжди матиме тип ``int``. Це дозволяє передавати ``UserId`` "
"усюди, де можна очікувати ``int``, але запобігає випадковому створенню "
"``UserId`` недійсним способом::"

msgid ""
"Note that these checks are enforced only by the static type checker. At "
"runtime, the statement ``Derived = NewType('Derived', Base)`` will make "
"``Derived`` a callable that immediately returns whatever parameter you pass "
"it. That means the expression ``Derived(some_value)`` does not create a new "
"class or introduce much overhead beyond that of a regular function call."
msgstr ""
"Зауважте, що ці перевірки виконуються лише засобом перевірки статичного "
"типу. Під час виконання оператор ``Derived = NewType('Derived', Base)`` "
"зробить ``Derived`` викликом, який негайно повертає будь-який параметр, який "
"ви йому передаєте. Це означає, що вираз ``Derived(some_value)`` не створює "
"нового класу і не вносить багато додаткових витрат, крім звичайного виклику "
"функції."

msgid ""
"More precisely, the expression ``some_value is Derived(some_value)`` is "
"always true at runtime."
msgstr ""
"Точніше, вираз ``some_value is Derived(some_value)`` завжди вірний під час "
"виконання."

msgid "It is invalid to create a subtype of ``Derived``::"
msgstr "Неможливо створити підтип ``Derived``::"

msgid ""
"However, it is possible to create a :class:`NewType` based on a 'derived' "
"``NewType``::"
msgstr ""
"Однак можна створити :class:`NewType` на основі \"похідного\" ``NewType``::"

msgid "and typechecking for ``ProUserId`` will work as expected."
msgstr "і аналіз типів для ``ProUserId`` працюватиме належним чином."

msgid "See :pep:`484` for more details."
msgstr "Дивіться :pep:`484` для більш детальної інформації."

msgid ""
"Recall that the use of a type alias declares two types to be *equivalent* to "
"one another. Doing ``Alias = Original`` will make the static type checker "
"treat ``Alias`` as being *exactly equivalent* to ``Original`` in all cases. "
"This is useful when you want to simplify complex type signatures."
msgstr ""
"Зверніть увагу, що використання псевдоніма типу оголошує два типи "
"*еквівалентними* один одному. Виконання ``Alias = Original`` змусить засіб "
"перевірки статичного типу розглядати ``Alias`` як *точно еквівалентний* "
"``Original`` у будь-якому випадку. Це корисно, коли ви хочете спростити "
"анотації складних типів."

msgid ""
"In contrast, ``NewType`` declares one type to be a *subtype* of another. "
"Doing ``Derived = NewType('Derived', Original)`` will make the static type "
"checker treat ``Derived`` as a *subclass* of ``Original``, which means a "
"value of type ``Original`` cannot be used in places where a value of type "
"``Derived`` is expected. This is useful when you want to prevent logic "
"errors with minimal runtime cost."
msgstr ""
"На відміну, ``NewType`` оголошує один тип як *підтип* іншого. Якщо виконати "
"``Derived = NewType('Derived', Original)``,  аналізатор типів розглядатиме "
"``Derived`` як *підклас* ``Original``, що означає значення типу ``Original`` "
"не можна використовувати там, де очікується значення типу ``Derived``. Це "
"корисно, коли ви хочете запобігти логічним помилкам з мінімальними витратами "
"на виконання."

msgid ""
"``NewType`` is now a class rather than a function.  There is some additional "
"runtime cost when calling ``NewType`` over a regular function.  However, "
"this cost will be reduced in 3.11.0."
msgstr ""
"``NewType`` тепер є класом, а не функцією. Під час виклику ``NewType`` через "
"звичайну функцію виникає додаткова вартість виконання. Однак ця вартість "
"буде зменшена в 3.11.0."

msgid "Callable"
msgstr "Викличний"

msgid ""
"Frameworks expecting callback functions of specific signatures might be type "
"hinted using ``Callable[[Arg1Type, Arg2Type], ReturnType]``."
msgstr ""
"Фреймворки, які очікують функцій-колбеків з певною сигнатурою, можуть "
"вказати цю підказку типу за допомогою ``Callable[[Arg1Type, Arg2Type], "
"ReturnType]``."

msgid "For example::"
msgstr "Наприклад::"

msgid ""
"It is possible to declare the return type of a callable without specifying "
"the call signature by substituting a literal ellipsis for the list of "
"arguments in the type hint: ``Callable[..., ReturnType]``."
msgstr ""
"Можна оголосити тип повернення викликаного без вказівки підпису виклику, "
"замінивши літеральний еліпс на список аргументів у підказці типу: "
"``Callable[..., ReturnType]``."

msgid ""
"Callables which take other callables as arguments may indicate that their "
"parameter types are dependent on each other using :class:`ParamSpec`. "
"Additionally, if that callable adds or removes arguments from other "
"callables, the :data:`Concatenate` operator may be used.  They take the form "
"``Callable[ParamSpecVariable, ReturnType]`` and "
"``Callable[Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable], "
"ReturnType]`` respectively."
msgstr ""
"Викликаються, які приймають інші викликані як аргументи, можуть вказувати, "
"що їхні типи параметрів залежать один від одного за допомогою :class:"
"`ParamSpec`. Крім того, якщо цей виклик додає або видаляє аргументи з інших "
"викликів, можна використовувати оператор :data:`Concatenate`. Вони приймають "
"форму ``Callable[ParamSpecVariable, ReturnType]`` і "
"``Callable[Concatenate[Arg1Type, Arg2Type, ..., ParamSpecVariable], "
"ReturnType]`` відповідно."

msgid ""
"``Callable`` now supports :class:`ParamSpec` and :data:`Concatenate`. See :"
"pep:`612` for more details."
msgstr ""

msgid ""
"The documentation for :class:`ParamSpec` and :class:`Concatenate` provides "
"examples of usage in ``Callable``."
msgstr ""
"Документація для :class:`ParamSpec` і :class:`Concatenate` містить приклади "
"використання в ``Callable``."

msgid "Generics"
msgstr "Узагальнення"

msgid ""
"Since type information about objects kept in containers cannot be statically "
"inferred in a generic way, abstract base classes have been extended to "
"support subscription to denote expected types for container elements."
msgstr ""
"Оскільки інформація про тип об’єктів, що зберігається в контейнерах, не може "
"бути статично виведена загальним способом, абстрактні базові класи були "
"розширені для підтримки підписки для позначення очікуваних типів для "
"елементів контейнера."

msgid ""
"Generics can be parameterized by using a factory available in typing called :"
"class:`TypeVar`."
msgstr ""
"Універсали можна параметризувати за допомогою фабрики, доступної в типі, яка "
"називається :class:`TypeVar`."

msgid "User-defined generic types"
msgstr "Визначені користувачем загальні типи"

msgid "A user-defined class can be defined as a generic class."
msgstr "Визначений користувачем клас можна визначити як загальний клас."

msgid ""
"``Generic[T]`` as a base class defines that the class ``LoggedVar`` takes a "
"single type parameter ``T`` . This also makes ``T`` valid as a type within "
"the class body."
msgstr ""
"``Generic[T]`` як базовий клас визначає, що клас ``LoggedVar`` приймає один "
"параметр типу ``T``. Це також робить ``T`` дійсним як тип у тілі класу."

msgid ""
"The :class:`Generic` base class defines :meth:`~object.__class_getitem__` so "
"that ``LoggedVar[T]`` is valid as a type::"
msgstr ""

msgid ""
"A generic type can have any number of type variables. All varieties of :"
"class:`TypeVar` are permissible as parameters for a generic type::"
msgstr ""
"Загальний тип може мати будь-яку кількість змінних типу. Усі різновиди :"
"class:`TypeVar` допустимі як параметри для загального типу::"

msgid ""
"Each type variable argument to :class:`Generic` must be distinct. This is "
"thus invalid::"
msgstr ""
"Кожен аргумент змінної типу для :class:`Generic` має бути окремим. Таким "
"чином, це недійсно::"

msgid "You can use multiple inheritance with :class:`Generic`::"
msgstr "Ви можете використовувати множинне успадкування з :class:`Generic`::"

msgid ""
"When inheriting from generic classes, some type variables could be fixed::"
msgstr ""
"При успадкуванні від загальних класів деякі змінні типу можуть бути "
"виправлені:"

msgid "In this case ``MyDict`` has a single parameter, ``T``."
msgstr "У цьому випадку ``MyDict`` має єдиний параметр, ``T``."

msgid ""
"Using a generic class without specifying type parameters assumes :data:`Any` "
"for each position. In the following example, ``MyIterable`` is not generic "
"but implicitly inherits from ``Iterable[Any]``::"
msgstr ""
"Використання загального класу без зазначення параметрів типу передбачає :"
"data:`Any` для кожної позиції. У наступному прикладі ``MyIterable`` не є "
"загальним, але неявно успадковує ``Iterable[Any]``::"

msgid "User defined generic type aliases are also supported. Examples::"
msgstr ""
"Також підтримуються визначені користувачем псевдоніми загального типу. "
"Приклади::"

msgid ":class:`Generic` no longer has a custom metaclass."
msgstr ":class:`Generic` більше не має спеціального метакласу."

msgid ""
"User-defined generics for parameter expressions are also supported via "
"parameter specification variables in the form ``Generic[P]``.  The behavior "
"is consistent with type variables' described above as parameter "
"specification variables are treated by the typing module as a specialized "
"type variable.  The one exception to this is that a list of types can be "
"used to substitute a :class:`ParamSpec`::"
msgstr ""
"Визначені користувачем генерики для виразів параметрів також підтримуються "
"через змінні специфікації параметрів у формі ``Generic[P]``. Поведінка "
"узгоджується зі змінними типу, описаними вище, оскільки змінні специфікації "
"параметрів обробляються модулем типізації як спеціалізована змінна типу. "
"Єдиним винятком із цього є те, що список типів можна використовувати для "
"заміни :class:`ParamSpec`::"

msgid ""
"Furthermore, a generic with only one parameter specification variable will "
"accept parameter lists in the forms ``X[[Type1, Type2, ...]]`` and also "
"``X[Type1, Type2, ...]`` for aesthetic reasons.  Internally, the latter is "
"converted to the former, so the following are equivalent::"
msgstr ""
"Крім того, універсал із лише однією змінною специфікації параметра "
"прийматиме списки параметрів у формах ``X[[Type1, Type2, ...]]``, а також "
"``X[Type1, Type2, ...]`` для естетичні причини. Внутрішньо остання "
"перетворюється на першу, тому наступні еквівалентні:"

msgid ""
"Do note that generics with :class:`ParamSpec` may not have correct "
"``__parameters__`` after substitution in some cases because they are "
"intended primarily for static type checking."
msgstr ""
"Зауважте, що генерики з :class:`ParamSpec` можуть не мати правильних "
"``__parameters__`` після заміни в деяких випадках, оскільки вони призначені "
"в основному для перевірки статичних типів."

msgid ""
":class:`Generic` can now be parameterized over parameter expressions. See :"
"class:`ParamSpec` and :pep:`612` for more details."
msgstr ""
":class:`Generic` тепер можна параметризувати над виразами параметрів. "
"Дивіться :class:`ParamSpec` і :pep:`612` для отримання додаткової інформації."

msgid ""
"A user-defined generic class can have ABCs as base classes without a "
"metaclass conflict. Generic metaclasses are not supported. The outcome of "
"parameterizing generics is cached, and most types in the typing module are "
"hashable and comparable for equality."
msgstr ""
"Визначений користувачем загальний клас може мати ABC як базові класи без "
"конфлікту метакласів. Загальні метакласи не підтримуються. Результат "
"параметризації генериків кешується, і більшість типів у модулі введення "
"можна хешувати та порівняти на рівність."

msgid "The :data:`Any` type"
msgstr "Тип :data:`Any`"

msgid ""
"A special kind of type is :data:`Any`. A static type checker will treat "
"every type as being compatible with :data:`Any` and :data:`Any` as being "
"compatible with every type."
msgstr ""
"Особливий вид типу — :data:`Any`. Засіб перевірки статичних типів "
"розглядатиме кожен тип як сумісний із :data:`Any` і :data:`Any` як сумісні з "
"кожним типом."

msgid ""
"This means that it is possible to perform any operation or method call on a "
"value of type :data:`Any` and assign it to any variable::"
msgstr ""
"Це означає, що можна виконати будь-яку операцію або викликати метод над "
"значенням типу :data:`Any` і призначити його будь-якій змінній::"

msgid ""
"Notice that no type checking is performed when assigning a value of type :"
"data:`Any` to a more precise type. For example, the static type checker did "
"not report an error when assigning ``a`` to ``s`` even though ``s`` was "
"declared to be of type :class:`str` and receives an :class:`int` value at "
"runtime!"
msgstr ""

msgid ""
"Furthermore, all functions without a return type or parameter types will "
"implicitly default to using :data:`Any`::"
msgstr ""
"Крім того, усі функції без типу повернення або типів параметрів неявно "
"використовуватимуть за умовчанням :data:`Any`::"

msgid ""
"This behavior allows :data:`Any` to be used as an *escape hatch* when you "
"need to mix dynamically and statically typed code."
msgstr ""
"Така поведінка дозволяє :data:`Any` використовувати як *вихідний люк*, коли "
"вам потрібно змішати динамічний і статичний код."

msgid ""
"Contrast the behavior of :data:`Any` with the behavior of :class:`object`. "
"Similar to :data:`Any`, every type is a subtype of :class:`object`. However, "
"unlike :data:`Any`, the reverse is not true: :class:`object` is *not* a "
"subtype of every other type."
msgstr ""
"Порівняйте поведінку :data:`Any` з поведінкою :class:`object`. Подібно до :"
"data:`Any`, кожен тип є підтипом :class:`object`. Однак, на відміну від :"
"data:`Any`, зворотне не вірно: :class:`object` *не* є підтипом будь-якого "
"іншого типу."

msgid ""
"That means when the type of a value is :class:`object`, a type checker will "
"reject almost all operations on it, and assigning it to a variable (or using "
"it as a return value) of a more specialized type is a type error. For "
"example::"
msgstr ""
"Це означає, що коли тип значення :class:`object`, засіб перевірки типів "
"відхилить майже всі операції над ним, а присвоєння його змінній (або "
"використання її як значення, що повертається) більш спеціалізованого типу є "
"типом помилка. Наприклад::"

msgid ""
"Use :class:`object` to indicate that a value could be any type in a typesafe "
"manner. Use :data:`Any` to indicate that a value is dynamically typed."
msgstr ""
"Використовуйте :class:`object`, щоб вказати, що значення може мати будь-який "
"тип у безпечний спосіб. Використовуйте :data:`Any`, щоб вказати, що значення "
"вводиться динамічно."

msgid "Nominal vs structural subtyping"
msgstr "Номінальний проти структурного підтипу"

msgid ""
"Initially :pep:`484` defined the Python static type system as using *nominal "
"subtyping*. This means that a class ``A`` is allowed where a class ``B`` is "
"expected if and only if ``A`` is a subclass of ``B``."
msgstr ""
"Спочатку :pep:`484` визначив систему статичних типів Python як таку, що "
"використовує *номінальний підтип*. Це означає, що клас ``A`` дозволений там, "
"де очікується клас ``B``, якщо і тільки якщо ``A`` є підкласом ``B``."

msgid ""
"This requirement previously also applied to abstract base classes, such as :"
"class:`~collections.abc.Iterable`. The problem with this approach is that a "
"class had to be explicitly marked to support them, which is unpythonic and "
"unlike what one would normally do in idiomatic dynamically typed Python "
"code. For example, this conforms to :pep:`484`::"
msgstr ""
"Ця вимога раніше також застосовувалася до абстрактних базових класів, таких "
"як :class:`~collections.abc.Iterable`. Проблема з цим підходом полягає в "
"тому, що клас повинен бути явно позначений для їх підтримки, що не є "
"пітонічним і не схожим на те, що зазвичай робили б у ідіоматичному динамічно "
"введеному коді Python. Наприклад, це відповідає :pep:`484`::"

msgid ""
":pep:`544` allows to solve this problem by allowing users to write the above "
"code without explicit base classes in the class definition, allowing "
"``Bucket`` to be implicitly considered a subtype of both ``Sized`` and "
"``Iterable[int]`` by static type checkers. This is known as *structural "
"subtyping* (or static duck-typing)::"
msgstr ""
":pep:`544` дозволяє вирішити цю проблему, дозволяючи користувачам писати "
"наведений вище код без явних базових класів у визначенні класу, дозволяючи "
"``Bucket`` неявно вважатися підтипом як ``Sized``, так і ``Iterable[int]`` "
"засобами перевірки статичних типів. Це відоме як *структурне підтипування* "
"(або статичне качине типування):"

msgid ""
"Moreover, by subclassing a special class :class:`Protocol`, a user can "
"define new custom protocols to fully enjoy structural subtyping (see "
"examples below)."
msgstr ""
"Крім того, створивши підклас спеціального класу :class:`Protocol`, "
"користувач може визначати нові користувальницькі протоколи, щоб повною мірою "
"користуватися структурними підтипами (див. приклади нижче)."

msgid "Module contents"
msgstr "Зміст модуля"

msgid "The module defines the following classes, functions and decorators."
msgstr "Модуль визначає наступні класи, функції та декоратори."

msgid ""
"This module defines several types that are subclasses of pre-existing "
"standard library classes which also extend :class:`Generic` to support type "
"variables inside ``[]``. These types became redundant in Python 3.9 when the "
"corresponding pre-existing classes were enhanced to support ``[]``."
msgstr ""
"Цей модуль визначає кілька типів, які є підкласами вже існуючих класів "
"стандартної бібліотеки, які також розширюють :class:`Generic` для підтримки "
"змінних типу всередині ``[]``. Ці типи стали надлишковими в Python 3.9, коли "
"відповідні існуючі класи були вдосконалені для підтримки ``[]``."

msgid ""
"The redundant types are deprecated as of Python 3.9 but no deprecation "
"warnings will be issued by the interpreter. It is expected that type "
"checkers will flag the deprecated types when the checked program targets "
"Python 3.9 or newer."
msgstr ""
"Надлишкові типи застаріли, починаючи з Python 3.9, але інтерпретатор не "
"видасть попереджень про застаріння. Очікується, що засоби перевірки типів "
"позначатимуть застарілі типи, якщо перевірена програма призначена для Python "
"3.9 або новішої версії."

msgid ""
"The deprecated types will be removed from the :mod:`typing` module in the "
"first Python version released 5 years after the release of Python 3.9.0. See "
"details in :pep:`585`—*Type Hinting Generics In Standard Collections*."
msgstr ""
"Застарілі типи буде видалено з модуля :mod:`typing` у першій версії Python, "
"випущеній через 5 років після випуску Python 3.9.0. Див. подробиці в :pep:"
"`585`—*Універсальні підказки типів у стандартних колекціях*."

msgid "Special typing primitives"
msgstr "Спеціальні примітиви типізації"

msgid "Special types"
msgstr "Особливі види"

msgid "These can be used as types in annotations and do not support ``[]``."
msgstr ""
"Вони можуть використовуватися як типи в анотаціях і не підтримують ``[]``."

msgid "Special type indicating an unconstrained type."
msgstr "Спеціальний тип, що вказує на необмежений тип."

msgid "Every type is compatible with :data:`Any`."
msgstr "Кожен тип сумісний з :data:`Any`."

msgid ":data:`Any` is compatible with every type."
msgstr ":data:`Any` сумісний з усіма типами."

msgid ""
":data:`Any` can now be used as a base class. This can be useful for avoiding "
"type checker errors with classes that can duck type anywhere or are highly "
"dynamic."
msgstr ""

msgid ""
"Special type that includes only literal strings. A string literal is "
"compatible with ``LiteralString``, as is another ``LiteralString``, but an "
"object typed as just ``str`` is not. A string created by composing "
"``LiteralString``-typed objects is also acceptable as a ``LiteralString``."
msgstr ""

msgid "Example::"
msgstr "Приклад::"

msgid ""
"This is useful for sensitive APIs where arbitrary user-generated strings "
"could generate problems. For example, the two cases above that generate type "
"checker errors could be vulnerable to an SQL injection attack."
msgstr ""

msgid "See :pep:`675` for more details."
msgstr ""

msgid ""
"The `bottom type <https://en.wikipedia.org/wiki/Bottom_type>`_, a type that "
"has no members."
msgstr ""

msgid ""
"This can be used to define a function that should never be called, or a "
"function that never returns::"
msgstr ""

msgid ""
"On older Python versions, :data:`NoReturn` may be used to express the same "
"concept. ``Never`` was added to make the intended meaning more explicit."
msgstr ""

msgid "Special type indicating that a function never returns. For example::"
msgstr ""
"Спеціальний тип, який вказує, що функція ніколи не повертається. Наприклад::"

msgid ""
"``NoReturn`` can also be used as a `bottom type <https://en.wikipedia.org/"
"wiki/Bottom_type>`_, a type that has no values. Starting in Python 3.11, "
"the :data:`Never` type should be used for this concept instead. Type "
"checkers should treat the two equivalently."
msgstr ""

msgid "Special type to represent the current enclosed class. For example::"
msgstr ""

msgid ""
"This annotation is semantically equivalent to the following, albeit in a "
"more succinct fashion::"
msgstr ""

msgid "In general if something currently follows the pattern of::"
msgstr ""

msgid ""
"You should use :data:`Self` as calls to ``SubclassOfFoo.return_self`` would "
"have ``Foo`` as the return type and not ``SubclassOfFoo``."
msgstr ""

msgid "Other common use cases include:"
msgstr ""

msgid ""
":class:`classmethod`\\s that are used as alternative constructors and return "
"instances of the ``cls`` parameter."
msgstr ""

msgid "Annotating an :meth:`~object.__enter__` method which returns self."
msgstr ""

msgid "See :pep:`673` for more details."
msgstr ""

msgid ""
"Special annotation for explicitly declaring a :ref:`type alias <type-"
"aliases>`. For example::"
msgstr ""
"Спеціальна анотація для явного оголошення псевдоніма :ref:`типу <type-"
"aliases>`. Наприклад::"

msgid "See :pep:`613` for more details about explicit type aliases."
msgstr ""
"Перегляньте :pep:`613` для отримання додаткової інформації про явні "
"псевдоніми типів."

msgid "Special forms"
msgstr "Спеціальні форми"

msgid ""
"These can be used as types in annotations using ``[]``, each having a unique "
"syntax."
msgstr ""
"Їх можна використовувати як типи в анотаціях за допомогою ``[]``, кожен з "
"яких має унікальний синтаксис."

msgid ""
"Tuple type; ``Tuple[X, Y]`` is the type of a tuple of two items with the "
"first item of type X and the second of type Y. The type of the empty tuple "
"can be written as ``Tuple[()]``."
msgstr ""
"Тип кортежу; ``Tuple[X, Y]`` — це тип кортежу з двох елементів з першим "
"елементом типу X, а другим — типу Y. Тип порожнього кортежу можна записати "
"як ``Tuple[()]``."

msgid ""
"Example: ``Tuple[T1, T2]`` is a tuple of two elements corresponding to type "
"variables T1 and T2.  ``Tuple[int, float, str]`` is a tuple of an int, a "
"float and a string."
msgstr ""
"Приклад: ``Tuple[T1, T2]`` — це кортеж із двох елементів, що відповідають "
"змінним типу T1 і T2. ``Tuple[int, float, str]`` – це кортеж із int, float і "
"рядка."

msgid ""
"To specify a variable-length tuple of homogeneous type, use literal "
"ellipsis, e.g. ``Tuple[int, ...]``. A plain :data:`Tuple` is equivalent to "
"``Tuple[Any, ...]``, and in turn to :class:`tuple`."
msgstr ""
"Щоб указати кортеж змінної довжини однорідного типу, використовуйте "
"літеральний еліпсис, наприклад. ``Tuple[int, ...]``. Звичайний :data:`Tuple` "
"еквівалентний ``Tuple[Any, ...]`` і, у свою чергу, :class:`tuple`."

msgid ""
":class:`builtins.tuple <tuple>` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""

msgid ""
"Union type; ``Union[X, Y]`` is equivalent to ``X | Y`` and means either X or "
"Y."
msgstr "тип союзу; ``Union[X, Y]`` еквівалентно ``X | Y`` і означає X або Y."

msgid ""
"To define a union, use e.g. ``Union[int, str]`` or the shorthand ``int | "
"str``. Using that shorthand is recommended. Details:"
msgstr ""
"Щоб визначити об’єднання, використовуйте, наприклад, ``Union[int, str]`` або "
"скорочення ``int | str``. Рекомендується використовувати це скорочення. "
"Подробиці:"

msgid "The arguments must be types and there must be at least one."
msgstr "Аргументи мають бути типами і має бути принаймні один."

msgid "Unions of unions are flattened, e.g.::"
msgstr "Союзи союзів зведені, наприклад::"

msgid "Unions of a single argument vanish, e.g.::"
msgstr "Союзи одного аргументу зникають, наприклад::"

msgid "Redundant arguments are skipped, e.g.::"
msgstr "Зайві аргументи пропускаються, наприклад::"

msgid "When comparing unions, the argument order is ignored, e.g.::"
msgstr ""
"Під час порівняння об’єднань порядок аргументів ігнорується, наприклад::"

msgid "You cannot subclass or instantiate a ``Union``."
msgstr "Ви не можете створювати підкласи або екземпляри ``Union``."

msgid "You cannot write ``Union[X][Y]``."
msgstr "Ви не можете писати ``Union[X][Y]``."

msgid "Don't remove explicit subclasses from unions at runtime."
msgstr "Не видаляйте явні підкласи з об’єднань під час виконання."

msgid ""
"Unions can now be written as ``X | Y``. See :ref:`union type "
"expressions<types-union>`."
msgstr ""
"Об’єднання тепер можна записати як ``X | Y``. Див. :ref:`вирази типу union "
"<types-union>`."

msgid "Optional type."
msgstr "Необов'язковий тип."

msgid "``Optional[X]`` is equivalent to ``X | None`` (or ``Union[X, None]``)."
msgstr "``Optional[X]`` еквівалентно ``X | None`` (або ``Union[X, None]``)."

msgid ""
"Note that this is not the same concept as an optional argument, which is one "
"that has a default.  An optional argument with a default does not require "
"the ``Optional`` qualifier on its type annotation just because it is "
"optional. For example::"
msgstr ""
"Зауважте, що це не те саме поняття, що необов’язковий аргумент, який має "
"значення за умовчанням. Необов’язковий аргумент із значенням за "
"замовчуванням не потребує кваліфікатора ``Optional`` в анотації свого типу "
"лише тому, що він є необов’язковим. Наприклад::"

msgid ""
"On the other hand, if an explicit value of ``None`` is allowed, the use of "
"``Optional`` is appropriate, whether the argument is optional or not. For "
"example::"
msgstr ""
"З іншого боку, якщо дозволено явне значення ``None``, використання "
"``Optional`` є доречним, незалежно від того, чи є аргумент необов’язковим. "
"Наприклад::"

msgid ""
"Optional can now be written as ``X | None``. See :ref:`union type "
"expressions<types-union>`."
msgstr ""
"Необов’язковий тепер можна записати як ``X | None``. Див. :ref:`вирази типу "
"union <types-union>`."

msgid "Callable type; ``Callable[[int], str]`` is a function of (int) -> str."
msgstr "Викличний тип; ``Callable[[int], str]`` є функцією (int) -> str."

msgid ""
"The subscription syntax must always be used with exactly two values: the "
"argument list and the return type.  The argument list must be a list of "
"types or an ellipsis; the return type must be a single type."
msgstr ""
"Синтаксис підписки завжди має використовуватися рівно з двома значеннями: "
"список аргументів і тип повернення. Список аргументів має бути списком типів "
"або крапкою; тип повернення має бути одним типом."

msgid ""
"There is no syntax to indicate optional or keyword arguments; such function "
"types are rarely used as callback types. ``Callable[..., ReturnType]`` "
"(literal ellipsis) can be used to type hint a callable taking any number of "
"arguments and returning ``ReturnType``.  A plain :data:`Callable` is "
"equivalent to ``Callable[..., Any]``, and in turn to :class:`collections.abc."
"Callable`."
msgstr ""
"Немає синтаксису для позначення необов’язкових або ключових аргументів; такі "
"типи функцій рідко використовуються як типи зворотного виклику. "
"``Callable[..., ReturnType]`` (буквальний еліпс) можна використовувати для "
"введення підказки викликаного, що приймає будь-яку кількість аргументів і "
"повертає ``ReturnType``. Звичайний :data:`Callable` еквівалентний "
"``Callable[..., Any]`` і, у свою чергу, :class:`collections.abc.Callable`."

msgid ""
":class:`collections.abc.Callable` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid ""
"The documentation for :class:`ParamSpec` and :class:`Concatenate` provide "
"examples of usage with ``Callable``."
msgstr ""
"Документація для :class:`ParamSpec` і :class:`Concatenate` містить приклади "
"використання з ``Callable``."

msgid ""
"Used with :data:`Callable` and :class:`ParamSpec` to type annotate a higher "
"order callable which adds, removes, or transforms parameters of another "
"callable.  Usage is in the form ``Concatenate[Arg1Type, Arg2Type, ..., "
"ParamSpecVariable]``. ``Concatenate`` is currently only valid when used as "
"the first argument to a :data:`Callable`. The last parameter to "
"``Concatenate`` must be a :class:`ParamSpec` or ellipsis (``...``)."
msgstr ""

msgid ""
"For example, to annotate a decorator ``with_lock`` which provides a :class:"
"`threading.Lock` to the decorated function,  ``Concatenate`` can be used to "
"indicate that ``with_lock`` expects a callable which takes in a ``Lock`` as "
"the first argument, and returns a callable with a different type signature.  "
"In this case, the :class:`ParamSpec` indicates that the returned callable's "
"parameter types are dependent on the parameter types of the callable being "
"passed in::"
msgstr ""
"Наприклад, щоб анотувати декоратор ``with_lock``, який надає :class:"
"`threading.Lock` декорованій функції, ``Concatenate`` можна використовувати, "
"щоб вказати, що ``with_lock`` очікує виклик, який приймає в ``Lock`` як "
"перший аргумент і повертає виклик із сигнатурою іншого типу. У цьому "
"випадку :class:`ParamSpec` вказує, що типи параметрів викликаного об’єкта, "
"що повертається, залежать від типів параметрів об’єкта виклику, який "
"передається в::"

msgid ""
":pep:`612` -- Parameter Specification Variables (the PEP which introduced "
"``ParamSpec`` and ``Concatenate``)."
msgstr ""
":pep:`612` -- Змінні специфікації параметрів (PEP, який представив "
"``ParamSpec`` і ``Concatenate``)."

msgid ":class:`ParamSpec` and :class:`Callable`."
msgstr ":class:`ParamSpec` і :class:`Callable`."

msgid ""
"A variable annotated with ``C`` may accept a value of type ``C``. In "
"contrast, a variable annotated with ``Type[C]`` may accept values that are "
"classes themselves -- specifically, it will accept the *class object* of "
"``C``. For example::"
msgstr ""
"Змінна з анотацією ``C`` може приймати значення типу ``C``. На відміну від "
"цього, змінна, анотована ``Type[C]``, може приймати значення, які самі по "
"собі є класами - зокрема, вона прийматиме *об’єкт класу* ``C``. Наприклад::"

msgid "Note that ``Type[C]`` is covariant::"
msgstr "Зауважте, що ``Type[C]`` є коваріантним::"

msgid ""
"The fact that ``Type[C]`` is covariant implies that all subclasses of ``C`` "
"should implement the same constructor signature and class method signatures "
"as ``C``. The type checker should flag violations of this, but should also "
"allow constructor calls in subclasses that match the constructor calls in "
"the indicated base class. How the type checker is required to handle this "
"particular case may change in future revisions of :pep:`484`."
msgstr ""
"Той факт, що ``Type[C]`` є коваріантним, означає, що всі підкласи ``C`` "
"повинні реалізовувати ту саму сигнатуру конструктора та сигнатури методу "
"класу, що й ``C``. Перевірка типів повинна позначати порушення цього, але "
"також повинна дозволяти виклики конструкторів у підкласах, які відповідають "
"викликам конструкторів у вказаному базовому класі. Те, як перевірка типів "
"потрібна для обробки цього конкретного випадку, може змінитися в майбутніх "
"версіях :pep:`484`."

msgid ""
"The only legal parameters for :class:`Type` are classes, :data:`Any`, :ref:"
"`type variables <generics>`, and unions of any of these types. For example::"
msgstr ""
"Єдиними допустимими параметрами для :class:`Type` є класи, :data:`Any`, :ref:"
"`змінні типу <generics>`, а також об’єднання будь-якого з цих типів. "
"Наприклад::"

msgid ""
"``Type[Any]`` is equivalent to ``Type`` which in turn is equivalent to "
"``type``, which is the root of Python's metaclass hierarchy."
msgstr ""
"``Type[Any]`` еквівалентний ``Type``, який, у свою чергу, еквівалентний "
"``type``, який є коренем ієрархії метакласів Python."

msgid ""
":class:`builtins.type <type>` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""

msgid ""
"A type that can be used to indicate to type checkers that the corresponding "
"variable or function parameter has a value equivalent to the provided "
"literal (or one of several literals). For example::"
msgstr ""
"Тип, який можна використовувати для вказівки перевіряючим типам того, що "
"відповідна змінна або параметр функції має значення, еквівалентне наданому "
"літералу (або одному з кількох літералів). Наприклад::"

msgid ""
"``Literal[...]`` cannot be subclassed. At runtime, an arbitrary value is "
"allowed as type argument to ``Literal[...]``, but type checkers may impose "
"restrictions. See :pep:`586` for more details about literal types."
msgstr ""
"``Літерал[...]`` не може бути підкласом. Під час виконання довільне значення "
"допускається як аргумент типу для ``Literal[...]``, але засоби перевірки "
"типу можуть накладати обмеження. Дивіться :pep:`586` для отримання "
"додаткової інформації про літеральні типи."

msgid ""
"``Literal`` now de-duplicates parameters.  Equality comparisons of "
"``Literal`` objects are no longer order dependent. ``Literal`` objects will "
"now raise a :exc:`TypeError` exception during equality comparisons if one of "
"their parameters are not :term:`hashable`."
msgstr ""
"``Літерал`` тепер усуває дублікати параметрів. Порівняння рівності об’єктів "
"``Literal`` більше не залежить від порядку. Об’єкти ``Literal`` тепер "
"створюватимуть виняток :exc:`TypeError` під час порівняння рівності, якщо "
"один із їхніх параметрів не є :term:`hashable`."

msgid "Special type construct to mark class variables."
msgstr "Конструкція спеціального типу для позначення змінних класу."

msgid ""
"As introduced in :pep:`526`, a variable annotation wrapped in ClassVar "
"indicates that a given attribute is intended to be used as a class variable "
"and should not be set on instances of that class. Usage::"
msgstr ""
"Як представлено в :pep:`526`, анотація змінної, загорнена в ClassVar, вказує "
"на те, що даний атрибут призначений для використання як змінна класу і не "
"повинен встановлюватися для екземплярів цього класу. Використання::"

msgid ":data:`ClassVar` accepts only types and cannot be further subscribed."
msgstr ":data:`ClassVar` приймає лише типи і не може бути підписаний далі."

msgid ""
":data:`ClassVar` is not a class itself, and should not be used with :func:"
"`isinstance` or :func:`issubclass`. :data:`ClassVar` does not change Python "
"runtime behavior, but it can be used by third-party type checkers. For "
"example, a type checker might flag the following code as an error::"
msgstr ""
":data:`ClassVar` сам по собі не є класом і не повинен використовуватися з :"
"func:`isinstance` або :func:`issubclass`. :data:`ClassVar` не змінює "
"поведінку Python під час виконання, але його можуть використовувати сторонні "
"засоби перевірки типу. Наприклад, засіб перевірки типу може позначити "
"наступний код як помилку:"

msgid ""
"A special typing construct to indicate to type checkers that a name cannot "
"be re-assigned or overridden in a subclass. For example::"
msgstr ""
"Спеціальна конструкція типізації, яка вказує перевіряючим типам, що ім’я не "
"може бути повторно призначено або перевизначено в підкласі. Наприклад::"

msgid ""
"There is no runtime checking of these properties. See :pep:`591` for more "
"details."
msgstr ""
"Немає жодної перевірки цих властивостей під час виконання. Дивіться :pep:"
"`591` для більш детальної інформації."

msgid ""
"Special typing constructs that mark individual keys of a :class:`TypedDict` "
"as either required or non-required respectively."
msgstr ""

msgid "See :class:`TypedDict` and :pep:`655` for more details."
msgstr ""

msgid ""
"A type, introduced in :pep:`593` (``Flexible function and variable "
"annotations``), to decorate existing types with context-specific metadata "
"(possibly multiple pieces of it, as ``Annotated`` is variadic). "
"Specifically, a type ``T`` can be annotated with metadata ``x`` via the "
"typehint ``Annotated[T, x]``. This metadata can be used for either static "
"analysis or at runtime. If a library (or tool) encounters a typehint "
"``Annotated[T, x]`` and has no special logic for metadata ``x``, it should "
"ignore it and simply treat the type as ``T``. Unlike the ``no_type_check`` "
"functionality that currently exists in the ``typing`` module which "
"completely disables typechecking annotations on a function or a class, the "
"``Annotated`` type allows for both static typechecking of ``T`` (which can "
"safely ignore ``x``) together with runtime access to ``x`` within a specific "
"application."
msgstr ""
"Тип, представлений у :pep:`593` (``Гнучка функція та анотації змінних``), "
"щоб прикрасити існуючі типи контекстно-залежними метаданими (можливо, "
"кількома їх частинами, оскільки ``Анотований`` є варіативним). Зокрема, тип "
"``T`` може бути анотований метаданими ``x`` за допомогою підказки типу "
"``Annotated[T, x]``. Ці метадані можна використовувати для статичного "
"аналізу або під час виконання. Якщо бібліотека (або інструмент) зустрічає "
"підказку типу ``Annotated[T, x]`` і не має спеціальної логіки для метаданих "
"``x``, їй слід ігнорувати це та просто розглядати тип як ``T``. На відміну "
"від функціональності ``no_type_check``, яка наразі існує в модулі "
"``typing``, який повністю вимикає анотації перевірки типу для функції або "
"класу, тип ``Annotated`` дозволяє як статичну перевірку типу ``T`` ( який "
"може безпечно ігнорувати ``x``) разом із доступом під час виконання до ``x`` "
"у певній програмі."

msgid ""
"Ultimately, the responsibility of how to interpret the annotations (if at "
"all) is the responsibility of the tool or library encountering the "
"``Annotated`` type. A tool or library encountering an ``Annotated`` type can "
"scan through the annotations to determine if they are of interest (e.g., "
"using ``isinstance()``)."
msgstr ""
"Зрештою, відповідальність за те, як інтерпретувати анотації (якщо взагалі "
"є), відповідає інструмент або бібліотека, які стикаються з типом "
"``Анотований``. Інструмент або бібліотека, які стикаються з типом "
"``Анотований``, можуть сканувати анотації, щоб визначити, чи представляють "
"вони інтерес (наприклад, за допомогою ``isinstance()``)."

msgid ""
"When a tool or a library does not support annotations or encounters an "
"unknown annotation it should just ignore it and treat annotated type as the "
"underlying type."
msgstr ""
"Якщо інструмент або бібліотека не підтримує анотації або зустрічає невідому "
"анотацію, їм слід просто ігнорувати її та розглядати анотований тип як "
"базовий тип."

msgid ""
"It's up to the tool consuming the annotations to decide whether the client "
"is allowed to have several annotations on one type and how to merge those "
"annotations."
msgstr ""
"Інструмент, який використовує анотації, вирішує, чи дозволено клієнту мати "
"кілька анотацій одного типу та як об’єднати ці анотації."

msgid ""
"Since the ``Annotated`` type allows you to put several annotations of the "
"same (or different) type(s) on any node, the tools or libraries consuming "
"those annotations are in charge of dealing with potential duplicates. For "
"example, if you are doing value range analysis you might allow this::"
msgstr ""
"Оскільки тип ``Анотований`` дозволяє розміщувати кілька анотацій одного (або "
"іншого) типу на будь-якому вузлі, інструменти або бібліотеки, які "
"використовують ці анотації, відповідають за роботу з потенційними "
"дублікатами. Наприклад, якщо ви виконуєте аналіз діапазону значень, ви "
"можете дозволити це:"

msgid ""
"Passing ``include_extras=True`` to :func:`get_type_hints` lets one access "
"the extra annotations at runtime."
msgstr ""
"Передача ``include_extras=True`` до :func:`get_type_hints` дозволяє отримати "
"доступ до додаткових анотацій під час виконання."

msgid "The details of the syntax:"
msgstr "Подробиці синтаксису:"

msgid "The first argument to ``Annotated`` must be a valid type"
msgstr "Перший аргумент ``Анотований`` має бути дійсного типу"

msgid ""
"Multiple type annotations are supported (``Annotated`` supports variadic "
"arguments)::"
msgstr ""
"Підтримуються анотації кількох типів (``Annotated`` підтримує різні "
"аргументи):"

msgid ""
"``Annotated`` must be called with at least two arguments "
"( ``Annotated[int]`` is not valid)"
msgstr ""
"``Annotated`` потрібно викликати принаймні з двома аргументами "
"(``Annotated[int]`` недійсний)"

msgid ""
"The order of the annotations is preserved and matters for equality checks::"
msgstr "Порядок анотацій зберігається і має значення для перевірки рівності:"

msgid ""
"Nested ``Annotated`` types are flattened, with metadata ordered starting "
"with the innermost annotation::"
msgstr ""
"Вкладені ``Анотовані`` типи зведені, метадані впорядковані, починаючи з "
"внутрішньої анотації::"

msgid "Duplicated annotations are not removed::"
msgstr "Дубльовані анотації не видаляються:"

msgid "``Annotated`` can be used with nested and generic aliases::"
msgstr ""
"``Анотований`` можна використовувати з вкладеними та загальними псевдонімами:"

msgid ""
"Special typing form used to annotate the return type of a user-defined type "
"guard function.  ``TypeGuard`` only accepts a single type argument. At "
"runtime, functions marked this way should return a boolean."
msgstr ""
"Спеціальна форма введення, яка використовується для анотації типу повернення "
"визначеної користувачем функції захисту типу. ``TypeGuard`` приймає лише "
"один аргумент типу. Під час виконання функції, позначені таким чином, "
"повинні повертати логічне значення."

msgid ""
"``TypeGuard`` aims to benefit *type narrowing* -- a technique used by static "
"type checkers to determine a more precise type of an expression within a "
"program's code flow.  Usually type narrowing is done by analyzing "
"conditional code flow and applying the narrowing to a block of code.  The "
"conditional expression here is sometimes referred to as a \"type guard\"::"
msgstr ""
"``TypeGuard`` має на меті скористатися *звуженням типу* — технікою, яка "
"використовується засобами перевірки статичних типів для визначення більш "
"точного типу виразу в потоці коду програми. Зазвичай звуження типу "
"виконується шляхом аналізу умовного потоку коду та застосування звуження до "
"блоку коду. Умовний вираз тут іноді називають \"захисним типом\"::"

msgid ""
"Sometimes it would be convenient to use a user-defined boolean function as a "
"type guard.  Such a function should use ``TypeGuard[...]`` as its return "
"type to alert static type checkers to this intention."
msgstr ""
"Іноді було б зручно використовувати логічну функцію, визначену користувачем, "
"як захист типу. Така функція повинна використовувати ``TypeGuard[...]`` як "
"тип повернення, щоб попередити засоби перевірки статичних типів про цей "
"намір."

msgid ""
"Using  ``-> TypeGuard`` tells the static type checker that for a given "
"function:"
msgstr ""
"Використання ``-> TypeGuard`` повідомляє засобу перевірки статичного типу, "
"що для даної функції:"

msgid "The return value is a boolean."
msgstr "Повернене значення є логічним."

msgid ""
"If the return value is ``True``, the type of its argument is the type inside "
"``TypeGuard``."
msgstr ""
"Якщо повертається значення ``True``, тип його аргументу є типом у "
"``TypeGuard``."

msgid ""
"If ``is_str_list`` is a class or instance method, then the type in "
"``TypeGuard`` maps to the type of the second parameter after ``cls`` or "
"``self``."
msgstr ""
"Якщо ``is_str_list`` є методом класу або екземпляра, тоді тип у "
"``TypeGuard`` відображає тип другого параметра після ``cls`` або ``self``."

msgid ""
"In short, the form ``def foo(arg: TypeA) -> TypeGuard[TypeB]: ...``, means "
"that if ``foo(arg)`` returns ``True``, then ``arg`` narrows from ``TypeA`` "
"to ``TypeB``."
msgstr ""
"Коротше кажучи, форма ``def foo(arg: TypeA) -> TypeGuard[TypeB]: ...`` "
"означає, що якщо ``foo(arg)`` повертає ``True``, то ``arg`` звужується від "
"``TypeA`` до ``TypeB``."

msgid ""
"``TypeB`` need not be a narrower form of ``TypeA`` -- it can even be a wider "
"form. The main reason is to allow for things like narrowing ``list[object]`` "
"to ``list[str]`` even though the latter is not a subtype of the former, "
"since ``list`` is invariant. The responsibility of writing type-safe type "
"guards is left to the user."
msgstr ""

msgid ""
"``TypeGuard`` also works with type variables.  See :pep:`647` for more "
"details."
msgstr ""

msgid "Building generic types"
msgstr "Побудова загальних типів"

msgid ""
"These are not used in annotations. They are building blocks for creating "
"generic types."
msgstr ""
"Вони не використовуються в анотаціях. Вони є будівельними блоками для "
"створення загальних типів."

msgid "Abstract base class for generic types."
msgstr "Абстрактний базовий клас для загальних типів."

msgid ""
"A generic type is typically declared by inheriting from an instantiation of "
"this class with one or more type variables. For example, a generic mapping "
"type might be defined as::"
msgstr ""
"Загальний тип зазвичай оголошується шляхом успадкування екземпляра цього "
"класу з однією або декількома змінними типу. Наприклад, загальний тип "
"відображення може бути визначений як:"

msgid "This class can then be used as follows::"
msgstr "Потім цей клас можна використовувати наступним чином:"

msgid "Type variable."
msgstr "Тип змінної."

msgid "Usage::"
msgstr "Використання::"

msgid ""
"Type variables exist primarily for the benefit of static type checkers.  "
"They serve as the parameters for generic types as well as for generic "
"function definitions.  See :class:`Generic` for more information on generic "
"types.  Generic functions work as follows::"
msgstr ""
"Змінні типу існують, перш за все, на користь засобів перевірки статичних "
"типів. Вони служать параметрами для загальних типів, а також для визначення "
"загальних функцій. Перегляньте :class:`Generic` для отримання додаткової "
"інформації про загальні типи. Загальні функції працюють наступним чином:"

msgid ""
"Note that type variables can be *bound*, *constrained*, or neither, but "
"cannot be both bound *and* constrained."
msgstr ""
"Зауважте, що змінні типу можуть бути *зв’язаними*, *обмеженими* або жодними "
"з них, але не можуть бути одночасно зв’язаними *і* обмеженими."

msgid ""
"Bound type variables and constrained type variables have different semantics "
"in several important ways. Using a *bound* type variable means that the "
"``TypeVar`` will be solved using the most specific type possible::"
msgstr ""

msgid ""
"Type variables can be bound to concrete types, abstract types (ABCs or "
"protocols), and even unions of types::"
msgstr ""
"Змінні типу можна прив’язувати до конкретних типів, абстрактних типів (ABC "
"або протоколів) і навіть об’єднань типів::"

msgid ""
"Using a *constrained* type variable, however, means that the ``TypeVar`` can "
"only ever be solved as being exactly one of the constraints given::"
msgstr ""

msgid ""
"At runtime, ``isinstance(x, T)`` will raise :exc:`TypeError`.  In general, :"
"func:`isinstance` and :func:`issubclass` should not be used with types."
msgstr ""
"Під час виконання ``isinstance(x, T)`` викличе :exc:`TypeError`. Загалом, :"
"func:`isinstance` і :func:`issubclass` не слід використовувати з типами."

msgid ""
"Type variables may be marked covariant or contravariant by passing "
"``covariant=True`` or ``contravariant=True``.  See :pep:`484` for more "
"details.  By default, type variables are invariant."
msgstr ""
"Змінні типу можна позначити коваріантними або контраваріантними шляхом "
"передачі ``covariant=True`` або ``contravariant=True``. Дивіться :pep:`484` "
"для більш детальної інформації. За замовчуванням змінні типу є інваріантними."

msgid ""
"Type variable tuple. A specialized form of :class:`type variable <TypeVar>` "
"that enables *variadic* generics."
msgstr ""

msgid ""
"A normal type variable enables parameterization with a single type. A type "
"variable tuple, in contrast, allows parameterization with an *arbitrary* "
"number of types by acting like an *arbitrary* number of type variables "
"wrapped in a tuple. For example::"
msgstr ""

msgid ""
"Note the use of the unpacking operator ``*`` in ``tuple[T, *Ts]``. "
"Conceptually, you can think of ``Ts`` as a tuple of type variables ``(T1, "
"T2, ...)``. ``tuple[T, *Ts]`` would then become ``tuple[T, *(T1, "
"T2, ...)]``, which is equivalent to ``tuple[T, T1, T2, ...]``. (Note that in "
"older versions of Python, you might see this written using :data:`Unpack "
"<Unpack>` instead, as ``Unpack[Ts]``.)"
msgstr ""

msgid ""
"Type variable tuples must *always* be unpacked. This helps distinguish type "
"variable types from normal type variables::"
msgstr ""

msgid ""
"Type variable tuples can be used in the same contexts as normal type "
"variables. For example, in class definitions, arguments, and return types::"
msgstr ""

msgid ""
"Type variable tuples can be happily combined with normal type variables::"
msgstr ""

msgid ""
"However, note that at most one type variable tuple may appear in a single "
"list of type arguments or type parameters::"
msgstr ""

msgid ""
"Finally, an unpacked type variable tuple can be used as the type annotation "
"of ``*args``::"
msgstr ""

msgid ""
"In contrast to non-unpacked annotations of ``*args`` - e.g. ``*args: int``, "
"which would specify that *all* arguments are ``int`` - ``*args: *Ts`` "
"enables reference to the types of the *individual* arguments in ``*args``. "
"Here, this allows us to ensure the types of the ``*args`` passed to "
"``call_soon`` match the types of the (positional) arguments of ``callback``."
msgstr ""

msgid "See :pep:`646` for more details on type variable tuples."
msgstr ""

msgid ""
"A typing operator that conceptually marks an object as having been unpacked. "
"For example, using the unpack operator ``*`` on a :class:`type variable "
"tuple <TypeVarTuple>` is equivalent to using ``Unpack`` to mark the type "
"variable tuple as having been unpacked::"
msgstr ""

msgid ""
"In fact, ``Unpack`` can be used interchangeably with ``*`` in the context of "
"types. You might see ``Unpack`` being used explicitly in older versions of "
"Python, where ``*`` couldn't be used in certain places::"
msgstr ""

msgid ""
"Parameter specification variable.  A specialized version of :class:`type "
"variables <TypeVar>`."
msgstr ""
"Змінна специфікації параметра. Спеціалізована версія :class:`типу змінних "
"<TypeVar>`."

msgid ""
"Parameter specification variables exist primarily for the benefit of static "
"type checkers.  They are used to forward the parameter types of one callable "
"to another callable -- a pattern commonly found in higher order functions "
"and decorators.  They are only valid when used in ``Concatenate``, or as the "
"first argument to ``Callable``, or as parameters for user-defined Generics.  "
"See :class:`Generic` for more information on generic types."
msgstr ""
"Змінні специфікації параметрів існують насамперед для використання засобів "
"перевірки статичних типів. Вони використовуються для пересилання типів "
"параметрів одного викликаного до іншого викликаного — шаблон, який зазвичай "
"зустрічається у функціях вищого порядку та декораторах. Вони дійсні лише "
"тоді, коли використовуються в ``Concatenate``, або як перший аргумент "
"``Callable``, або як параметри для визначених користувачем Generics. "
"Перегляньте :class:`Generic` для отримання додаткової інформації про "
"загальні типи."

msgid ""
"For example, to add basic logging to a function, one can create a decorator "
"``add_logging`` to log function calls.  The parameter specification variable "
"tells the type checker that the callable passed into the decorator and the "
"new callable returned by it have inter-dependent type parameters::"
msgstr ""
"Наприклад, щоб додати базове журналювання до функції, можна створити "
"декоратор ``add_logging`` для журналювання викликів функцій. Змінна "
"специфікації параметра повідомляє перевіряльнику типу, що викликаний, "
"переданий декоратору, і новий викликаний, повернутий ним, мають "
"взаємозалежні параметри типу:"

msgid ""
"Without ``ParamSpec``, the simplest way to annotate this previously was to "
"use a :class:`TypeVar` with bound ``Callable[..., Any]``.  However this "
"causes two problems:"
msgstr ""
"Без ``ParamSpec`` найпростішим способом анотації цього раніше було "
"використання :class:`TypeVar` із прив’язкою ``Callable[..., Any]``. Однак це "
"викликає дві проблеми:"

msgid ""
"The type checker can't type check the ``inner`` function because ``*args`` "
"and ``**kwargs`` have to be typed :data:`Any`."
msgstr ""
"Перевірка типу не може перевірити тип функції ``inner``, тому що ``*args`` і "
"``**kwargs`` мають бути введені :data:`Any`."

msgid ""
":func:`~cast` may be required in the body of the ``add_logging`` decorator "
"when returning the ``inner`` function, or the static type checker must be "
"told to ignore the ``return inner``."
msgstr ""
":func:`~cast` може знадобитися в тілі декоратора ``add_logging`` під час "
"повернення функції ``inner``, або засіб перевірки статичного типу повинен "
"ігнорувати ``return inner``."

msgid ""
"Since ``ParamSpec`` captures both positional and keyword parameters, ``P."
"args`` and ``P.kwargs`` can be used to split a ``ParamSpec`` into its "
"components.  ``P.args`` represents the tuple of positional parameters in a "
"given call and should only be used to annotate ``*args``.  ``P.kwargs`` "
"represents the mapping of keyword parameters to their values in a given "
"call, and should be only be used to annotate ``**kwargs``.  Both attributes "
"require the annotated parameter to be in scope. At runtime, ``P.args`` and "
"``P.kwargs`` are instances respectively of :class:`ParamSpecArgs` and :class:"
"`ParamSpecKwargs`."
msgstr ""
"Оскільки ``ParamSpec`` фіксує як позиційні параметри, так і параметри "
"ключових слів, ``P.args`` і ``P.kwargs`` можна використовувати для поділу "
"``ParamSpec`` на його компоненти. ``P.args`` представляє кортеж позиційних "
"параметрів у заданому виклику, і його слід використовувати лише для анотації "
"``*args``. ``P.kwargs`` представляє зіставлення параметрів ключового слова з "
"їхніми значеннями в заданому виклику, і його слід використовувати лише для "
"анотації ``**kwargs``. Обидва атрибути вимагають, щоб анотований параметр "
"був у межах. Під час виконання ``P.args`` і ``P.kwargs`` є екземплярами "
"відповідно :class:`ParamSpecArgs` і :class:`ParamSpecKwargs`."

msgid ""
"Parameter specification variables created with ``covariant=True`` or "
"``contravariant=True`` can be used to declare covariant or contravariant "
"generic types.  The ``bound`` argument is also accepted, similar to :class:"
"`TypeVar`.  However the actual semantics of these keywords are yet to be "
"decided."
msgstr ""
"Змінні специфікації параметрів, створені за допомогою ``covariant=True`` або "
"``contravariant=True``, можна використовувати для оголошення коваріантних "
"або контраваріантних загальних типів. Аргумент ``bound`` також приймається, "
"подібно до :class:`TypeVar`. Однак фактичну семантику цих ключових слів ще "
"належить визначити."

msgid ""
"Only parameter specification variables defined in global scope can be "
"pickled."
msgstr ""
"Вибирати можна лише змінні специфікації параметрів, визначені в глобальній "
"області видимості."

msgid ":class:`Callable` and :class:`Concatenate`."
msgstr ":class:`Callable` і :class:`Concatenate`."

msgid ""
"Arguments and keyword arguments attributes of a :class:`ParamSpec`. The ``P."
"args`` attribute of a ``ParamSpec`` is an instance of ``ParamSpecArgs``, and "
"``P.kwargs`` is an instance of ``ParamSpecKwargs``. They are intended for "
"runtime introspection and have no special meaning to static type checkers."
msgstr ""
"Аргументи та атрибути ключових аргументів :class:`ParamSpec`. Атрибут ``P."
"args`` ``ParamSpec`` є екземпляром ``ParamSpecArgs``, а ``P.kwargs`` є "
"екземпляром ``ParamSpecKwargs``. Вони призначені для інтроспекції під час "
"виконання і не мають особливого значення для перевірки статичних типів."

msgid ""
"Calling :func:`get_origin` on either of these objects will return the "
"original ``ParamSpec``::"
msgstr ""
"Виклик :func:`get_origin` для будь-якого з цих об’єктів поверне оригінальний "
"``ParamSpec``::"

msgid ""
"``AnyStr`` is a :class:`constrained type variable <TypeVar>` defined as "
"``AnyStr = TypeVar('AnyStr', str, bytes)``."
msgstr ""
"``AnyStr`` — це :class:`обмежена змінна типу <TypeVar>`, визначена як "
"``AnyStr = TypeVar('AnyStr', str, bytes)``."

msgid ""
"It is meant to be used for functions that may accept any kind of string "
"without allowing different kinds of strings to mix. For example::"
msgstr ""
"Він призначений для використання для функцій, які можуть приймати будь-які "
"типи рядків, не допускаючи змішування різних типів рядків. Наприклад::"

msgid ""
"Base class for protocol classes. Protocol classes are defined like this::"
msgstr "Базовий клас для класів протоколу. Класи протоколів визначаються так:"

msgid ""
"Such classes are primarily used with static type checkers that recognize "
"structural subtyping (static duck-typing), for example::"
msgstr ""
"Такі класи в основному використовуються із засобами перевірки статичних "
"типів, які розпізнають структурні підтипи (статичне типування), наприклад:"

msgid ""
"See :pep:`544` for more details. Protocol classes decorated with :func:"
"`runtime_checkable` (described later) act as simple-minded runtime protocols "
"that check only the presence of given attributes, ignoring their type "
"signatures."
msgstr ""

msgid "Protocol classes can be generic, for example::"
msgstr "Класи протоколів можуть бути загальними, наприклад:"

msgid "Mark a protocol class as a runtime protocol."
msgstr "Позначте клас протоколу як протокол виконання."

msgid ""
"Such a protocol can be used with :func:`isinstance` and :func:`issubclass`. "
"This raises :exc:`TypeError` when applied to a non-protocol class.  This "
"allows a simple-minded structural check, very similar to \"one trick "
"ponies\" in :mod:`collections.abc` such as :class:`~collections.abc."
"Iterable`.  For example::"
msgstr ""
"Такий протокол можна використовувати з :func:`isinstance` і :func:"
"`issubclass`. Це викликає :exc:`TypeError`, коли застосовується до "
"непротокольного класу. Це дозволяє здійснити просту структурну перевірку, "
"дуже схожу на \"поні з одним трюком\" у :mod:`collections.abc`, наприклад :"
"class:`~collections.abc.Iterable`. Наприклад::"

msgid ""
":func:`runtime_checkable` will check only the presence of the required "
"methods, not their type signatures. For example, :class:`ssl.SSLObject` is a "
"class, therefore it passes an :func:`issubclass` check against :data:"
"`Callable`.  However, the :meth:`ssl.SSLObject.__init__` method exists only "
"to raise a :exc:`TypeError` with a more informative message, therefore "
"making it impossible to call (instantiate) :class:`ssl.SSLObject`."
msgstr ""
":func:`runtime_checkable` перевірятиме лише наявність необхідних методів, а "
"не їхні сигнатури типів. Наприклад, :class:`ssl.SSLObject` є класом, тому "
"він проходить перевірку :func:`issubclass` на :data:`Callable`. Однак метод :"
"meth:`ssl.SSLObject.__init__` існує лише для того, щоб викликати :exc:"
"`TypeError` з більш інформативним повідомленням, отже, унеможливлюючи виклик "
"(інстанціювання) :class:`ssl.SSLObject`."

msgid "Other special directives"
msgstr "Інші спеціальні директиви"

msgid ""
"These are not used in annotations. They are building blocks for declaring "
"types."
msgstr ""
"Вони не використовуються в анотаціях. Вони є будівельними блоками для "
"оголошення типів."

msgid "Typed version of :func:`collections.namedtuple`."
msgstr "Введена версія :func:`collections.namedtuple`."

msgid "This is equivalent to::"
msgstr "Це еквівалентно::"

msgid ""
"To give a field a default value, you can assign to it in the class body::"
msgstr ""
"Щоб надати полю значення за замовчуванням, ви можете призначити йому в тілі "
"класу::"

msgid ""
"Fields with a default value must come after any fields without a default."
msgstr ""
"Поля зі значенням за замовчуванням мають бути після будь-яких полів без "
"значення за замовчуванням."

msgid ""
"The resulting class has an extra attribute ``__annotations__`` giving a dict "
"that maps the field names to the field types.  (The field names are in the "
"``_fields`` attribute and the default values are in the ``_field_defaults`` "
"attribute, both of which are part of the :func:`~collections.namedtuple` "
"API.)"
msgstr ""
"Отриманий клас має додатковий атрибут ``__annotations__``, що дає диктофон, "
"який зіставляє назви полів із типами полів. (Імена полів містяться в "
"атрибуті ``_fields``, а значення за замовчуванням — в атрибуті "
"``_field_defaults``, обидва з яких є частиною API :func:`~collections."
"namedtuple`.)"

msgid "``NamedTuple`` subclasses can also have docstrings and methods::"
msgstr ""
"Підкласи ``NamedTuple`` також можуть мати рядки документації та методи:"

msgid "``NamedTuple`` subclasses can be generic::"
msgstr ""

msgid "Backward-compatible usage::"
msgstr "Зворотно сумісне використання::"

msgid "Added support for :pep:`526` variable annotation syntax."
msgstr "Додано підтримку синтаксису анотації змінної :pep:`526`."

msgid "Added support for default values, methods, and docstrings."
msgstr "Додано підтримку стандартних значень, методів і рядків документів."

msgid ""
"The ``_field_types`` and ``__annotations__`` attributes are now regular "
"dictionaries instead of instances of ``OrderedDict``."
msgstr ""
"Атрибути ``_field_types`` і ``__annotations__`` тепер є звичайними "
"словниками замість екземплярів ``OrderedDict``."

msgid ""
"Removed the ``_field_types`` attribute in favor of the more standard "
"``__annotations__`` attribute which has the same information."
msgstr ""
"Видалено атрибут ``_field_types`` на користь стандартнішого атрибута "
"``__annotations__``, який містить ту саму інформацію."

msgid "Added support for generic namedtuples."
msgstr ""

msgid ""
"A helper class to indicate a distinct type to a typechecker, see :ref:"
"`distinct`. At runtime it returns an object that returns its argument when "
"called. Usage::"
msgstr ""
"Допоміжний клас для вказівки окремого типу для перевірки типів див. :ref:"
"`distinct`. Під час виконання він повертає об’єкт, який повертає свій "
"аргумент під час виклику. Використання::"

msgid "``NewType`` is now a class rather than a function."
msgstr "``NewType`` тепер є класом, а не функцією."

msgid ""
"Special construct to add type hints to a dictionary. At runtime it is a "
"plain :class:`dict`."
msgstr ""
"Спеціальна конструкція для додавання підказок типу до словника. Під час "
"виконання це звичайний :class:`dict`."

msgid ""
"``TypedDict`` declares a dictionary type that expects all of its instances "
"to have a certain set of keys, where each key is associated with a value of "
"a consistent type. This expectation is not checked at runtime but is only "
"enforced by type checkers. Usage::"
msgstr ""
"``TypedDict`` оголошує тип словника, який очікує, що всі його екземпляри "
"матимуть певний набір ключів, де кожен ключ пов’язаний зі значенням "
"узгодженого типу. Це очікування не перевіряється під час виконання, а "
"виконується лише засобами перевірки типів. Використання::"

msgid ""
"To allow using this feature with older versions of Python that do not "
"support :pep:`526`, ``TypedDict`` supports two additional equivalent "
"syntactic forms:"
msgstr ""

msgid "Using a literal :class:`dict` as the second argument::"
msgstr ""

msgid "Using keyword arguments::"
msgstr ""

msgid ""
"The keyword-argument syntax is deprecated in 3.11 and will be removed in "
"3.13. It may also be unsupported by static type checkers."
msgstr ""

msgid ""
"The functional syntax should also be used when any of the keys are not "
"valid :ref:`identifiers <identifiers>`, for example because they are "
"keywords or contain hyphens. Example::"
msgstr ""
"Функціональний синтаксис також слід використовувати, коли будь-який із "
"ключів недійсний :ref:`identifiers <identifiers>`, наприклад тому, що він є "
"ключовим словом або містить дефіс. Приклад::"

msgid ""
"By default, all keys must be present in a ``TypedDict``. It is possible to "
"mark individual keys as non-required using :data:`NotRequired`::"
msgstr ""

msgid ""
"This means that a ``Point2D`` ``TypedDict`` can have the ``label`` key "
"omitted."
msgstr ""

msgid ""
"It is also possible to mark all keys as non-required by default by "
"specifying a totality of ``False``::"
msgstr ""

msgid ""
"This means that a ``Point2D`` ``TypedDict`` can have any of the keys "
"omitted. A type checker is only expected to support a literal ``False`` or "
"``True`` as the value of the ``total`` argument. ``True`` is the default, "
"and makes all items defined in the class body required."
msgstr ""
"Це означає, що в ``Point2D`` ``TypedDict`` може бути пропущений будь-який із "
"ключів. Очікується, що засіб перевірки типів підтримуватиме лише літерали "
"``False`` або ``True`` як значення аргументу ``total``. ``True`` є типовим і "
"робить обов’язковими всі елементи, визначені в тілі класу."

msgid ""
"Individual keys of a ``total=False`` ``TypedDict`` can be marked as required "
"using :data:`Required`::"
msgstr ""

msgid ""
"It is possible for a ``TypedDict`` type to inherit from one or more other "
"``TypedDict`` types using the class-based syntax. Usage::"
msgstr ""
"Тип ``TypedDict`` може успадкувати від одного або кількох інших типів "
"``TypedDict`` за допомогою синтаксису на основі класу. Використання::"

msgid ""
"``Point3D`` has three items: ``x``, ``y`` and ``z``. It is equivalent to "
"this definition::"
msgstr ""
"``Point3D`` має три елементи: ``x``, ``y`` і ``z``. Це еквівалентно цьому "
"визначенню::"

msgid ""
"A ``TypedDict`` cannot inherit from a non-\\ ``TypedDict`` class, except "
"for :class:`Generic`. For example::"
msgstr ""

msgid "A ``TypedDict`` can be generic::"
msgstr ""

msgid ""
"A ``TypedDict`` can be introspected via annotations dicts (see :ref:"
"`annotations-howto` for more information on annotations best practices), :"
"attr:`__total__`, :attr:`__required_keys__`, and :attr:`__optional_keys__`."
msgstr ""
"``TypedDict`` можна інтроспективно за допомогою dicts анотацій (перегляньте :"
"ref:`annotations-howto` для отримання додаткової інформації про найкращі "
"практики анотацій), :attr:`__total__`, :attr:`__required_keys__` та :attr:"
"`__додаткові_ключі__`."

msgid ""
"``Point2D.__total__`` gives the value of the ``total`` argument. Example::"
msgstr "``Point2D.__total__`` надає значення аргументу ``total``. Приклад::"

msgid ""
"``Point2D.__required_keys__`` and ``Point2D.__optional_keys__`` return :"
"class:`frozenset` objects containing required and non-required keys, "
"respectively."
msgstr ""

msgid ""
"Keys marked with :data:`Required` will always appear in "
"``__required_keys__`` and keys marked with :data:`NotRequired` will always "
"appear in ``__optional_keys__``."
msgstr ""

msgid ""
"For backwards compatibility with Python 3.10 and below, it is also possible "
"to use inheritance to declare both required and non-required keys in the "
"same ``TypedDict`` . This is done by declaring a ``TypedDict`` with one "
"value for the ``total`` argument and then inheriting from it in another "
"``TypedDict`` with a different value for ``total``::"
msgstr ""

msgid ""
"See :pep:`589` for more examples and detailed rules of using ``TypedDict``."
msgstr ""
"Перегляньте :pep:`589` більше прикладів і детальних правил використання "
"``TypedDict``."

msgid ""
"Added support for marking individual keys as :data:`Required` or :data:"
"`NotRequired`. See :pep:`655`."
msgstr ""

msgid "Added support for generic ``TypedDict``\\ s."
msgstr ""

msgid "Generic concrete collections"
msgstr "Типові бетонні колекції"

msgid "Corresponding to built-in types"
msgstr "Відповідає вбудованим типам"

msgid ""
"A generic version of :class:`dict`. Useful for annotating return types. To "
"annotate arguments it is preferred to use an abstract collection type such "
"as :class:`Mapping`."
msgstr ""
"Загальна версія :class:`dict`. Корисно для анотування типів повернення. Щоб "
"анотувати аргументи, бажано використовувати абстрактний тип колекції, такий "
"як :class:`Mapping`."

msgid "This type can be used as follows::"
msgstr "Цей тип можна використовувати наступним чином:"

msgid ""
":class:`builtins.dict <dict>` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""

msgid ""
"Generic version of :class:`list`. Useful for annotating return types. To "
"annotate arguments it is preferred to use an abstract collection type such "
"as :class:`Sequence` or :class:`Iterable`."
msgstr ""
"Загальна версія :class:`list`. Корисно для анотування типів повернення. Щоб "
"анотувати аргументи, бажано використовувати абстрактний тип колекції, "
"наприклад :class:`Sequence` або :class:`Iterable`."

msgid "This type may be used as follows::"
msgstr "Цей тип можна використовувати наступним чином:"

msgid ""
":class:`builtins.list <list>` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""

msgid ""
"A generic version of :class:`builtins.set <set>`. Useful for annotating "
"return types. To annotate arguments it is preferred to use an abstract "
"collection type such as :class:`AbstractSet`."
msgstr ""
"Загальна версія :class:`builtins.set <set>`. Корисно для анотування типів "
"повернення. Щоб анотувати аргументи, бажано використовувати абстрактний тип "
"колекції, такий як :class:`AbstractSet`."

msgid ""
":class:`builtins.set <set>` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`builtins.frozenset <frozenset>`."
msgstr "Загальна версія :class:`builtins.frozenset <frozenset>`."

msgid ""
":class:`builtins.frozenset <frozenset>` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid ":data:`Tuple` is a special form."
msgstr ":data:`Tuple` — це спеціальна форма."

msgid "Corresponding to types in :mod:`collections`"
msgstr "Відповідає типам у :mod:`collections`"

msgid "A generic version of :class:`collections.defaultdict`."
msgstr "Загальна версія :class:`collections.defaultdict`."

msgid ""
":class:`collections.defaultdict` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.OrderedDict`."
msgstr "Загальна версія :class:`collections.OrderedDict`."

msgid ""
":class:`collections.OrderedDict` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.ChainMap`."
msgstr "Загальна версія :class:`collections.ChainMap`."

msgid ""
":class:`collections.ChainMap` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.Counter`."
msgstr "Загальна версія :class:`collections.Counter`."

msgid ""
":class:`collections.Counter` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.deque`."
msgstr "Загальна версія :class:`collections.deque`."

msgid ""
":class:`collections.deque` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""

msgid "Other concrete types"
msgstr "Інші види бетону"

msgid ""
"Generic type ``IO[AnyStr]`` and its subclasses ``TextIO(IO[str])`` and "
"``BinaryIO(IO[bytes])`` represent the types of I/O streams such as returned "
"by :func:`open`."
msgstr ""
"Загальний тип ``IO[AnyStr]`` і його підкласи ``TextIO(IO[str])`` і "
"``BinaryIO(IO[bytes])`` представляють типи потоків вводу/виводу, такі як "
"повертаються :func:`open`."

msgid ""
"The ``typing.io`` namespace is deprecated and will be removed. These types "
"should be directly imported from ``typing`` instead."
msgstr ""
"Простір імен ``typing.io`` застаріло та буде видалено. Натомість ці типи "
"слід імпортувати безпосередньо з ``typing``."

msgid ""
"These type aliases correspond to the return types from :func:`re.compile` "
"and :func:`re.match`.  These types (and the corresponding functions) are "
"generic in ``AnyStr`` and can be made specific by writing ``Pattern[str]``, "
"``Pattern[bytes]``, ``Match[str]``, or ``Match[bytes]``."
msgstr ""
"Ці псевдоніми типів відповідають типам повернення з :func:`re.compile` і :"
"func:`re.match`. Ці типи (і відповідні функції) є загальними в ``AnyStr`` і "
"можуть бути специфічними, написавши ``Pattern[str]``, ``Pattern[bytes]``, "
"``Match[str]``, або ``Збіг [байтів]``."

msgid ""
"The ``typing.re`` namespace is deprecated and will be removed. These types "
"should be directly imported from ``typing`` instead."
msgstr ""
"Простір імен ``typing.re`` застаріло та буде видалено. Натомість ці типи "
"слід імпортувати безпосередньо з ``typing``."

msgid ""
"Classes ``Pattern`` and ``Match`` from :mod:`re` now support ``[]``. See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""
"Класи ``Pattern`` і ``Match`` від :mod:`re` тепер підтримують ``[]``. Див. :"
"pep:`585` і :ref:`types-genericalias`."

msgid ""
"``Text`` is an alias for ``str``. It is provided to supply a forward "
"compatible path for Python 2 code: in Python 2, ``Text`` is an alias for "
"``unicode``."
msgstr ""
"``Текст`` є псевдонімом для ``str``. Він надається для надання прямого "
"сумісного шляху для коду Python 2: у Python 2 \"Текст\" є псевдонімом для "
"\"юнікоду\"."

msgid ""
"Use ``Text`` to indicate that a value must contain a unicode string in a "
"manner that is compatible with both Python 2 and Python 3::"
msgstr ""
"Використовуйте ``Текст``, щоб вказати, що значення має містити рядок Юнікод "
"у спосіб, сумісний як з Python 2, так і з Python 3::"

msgid ""
"Python 2 is no longer supported, and most type checkers also no longer "
"support type checking Python 2 code. Removal of the alias is not currently "
"planned, but users are encouraged to use :class:`str` instead of ``Text`` "
"wherever possible."
msgstr ""

msgid "Abstract Base Classes"
msgstr "Абстрактні базові класи"

msgid "Corresponding to collections in :mod:`collections.abc`"
msgstr "Відповідає колекціям у :mod:`collections.abc`"

msgid "A generic version of :class:`collections.abc.Set`."
msgstr "Загальна версія :class:`collections.abc.Set`."

msgid ""
":class:`collections.abc.Set` now supports subscripting (``[]``). See :pep:"
"`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.ByteString`."
msgstr "Загальна версія :class:`collections.abc.ByteString`."

msgid ""
"This type represents the types :class:`bytes`, :class:`bytearray`, and :"
"class:`memoryview` of byte sequences."
msgstr ""
"Цей тип представляє типи :class:`bytes`, :class:`bytearray` і :class:"
"`memoryview` послідовностей байтів."

msgid ""
"As a shorthand for this type, :class:`bytes` can be used to annotate "
"arguments of any of the types mentioned above."
msgstr ""
"Як скорочення для цього типу, :class:`bytes` можна використовувати для "
"анотації аргументів будь-якого типу, згаданого вище."

msgid ""
":class:`collections.abc.ByteString` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.Collection`"
msgstr "Загальна версія :class:`collections.abc.Collection`"

msgid ""
":class:`collections.abc.Collection` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.Container`."
msgstr "Загальна версія :class:`collections.abc.Container`."

msgid ""
":class:`collections.abc.Container` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.ItemsView`."
msgstr "Загальна версія :class:`collections.abc.ItemsView`."

msgid ""
":class:`collections.abc.ItemsView` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.KeysView`."
msgstr "Загальна версія :class:`collections.abc.KeysView`."

msgid ""
":class:`collections.abc.KeysView` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid ""
"A generic version of :class:`collections.abc.Mapping`. This type can be used "
"as follows::"
msgstr ""
"Загальна версія :class:`collections.abc.Mapping`. Цей тип можна "
"використовувати наступним чином:"

msgid ""
":class:`collections.abc.Mapping` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.MappingView`."
msgstr "Загальна версія :class:`collections.abc.MappingView`."

msgid ""
":class:`collections.abc.MappingView` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.MutableMapping`."
msgstr "Загальна версія :class:`collections.abc.MutableMapping`."

msgid ""
":class:`collections.abc.MutableMapping` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.MutableSequence`."
msgstr "Загальна версія :class:`collections.abc.MutableSequence`."

msgid ""
":class:`collections.abc.MutableSequence` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.MutableSet`."
msgstr "Загальна версія :class:`collections.abc.MutableSet`."

msgid ""
":class:`collections.abc.MutableSet` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.Sequence`."
msgstr "Загальна версія :class:`collections.abc.Sequence`."

msgid ""
":class:`collections.abc.Sequence` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.ValuesView`."
msgstr "Загальна версія :class:`collections.abc.ValuesView`."

msgid ""
":class:`collections.abc.ValuesView` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "Corresponding to other types in :mod:`collections.abc`"
msgstr "Відповідає іншим типам у :mod:`collections.abc`"

msgid "A generic version of :class:`collections.abc.Iterable`."
msgstr "Загальна версія :class:`collections.abc.Iterable`."

msgid ""
":class:`collections.abc.Iterable` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.Iterator`."
msgstr "Загальна версія :class:`collections.abc.Iterator`."

msgid ""
":class:`collections.abc.Iterator` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid ""
"A generator can be annotated by the generic type ``Generator[YieldType, "
"SendType, ReturnType]``. For example::"
msgstr ""
"Генератор може бути анотований загальним типом ``Generator[YieldType, "
"SendType, ReturnType]``. Наприклад::"

msgid ""
"Note that unlike many other generics in the typing module, the ``SendType`` "
"of :class:`Generator` behaves contravariantly, not covariantly or "
"invariantly."
msgstr ""
"Зауважте, що на відміну від багатьох інших загальних засобів у модулі "
"введення, ``SendType`` :class:`Generator` поводиться контраваріантно, а не "
"коваріантно чи інваріантно."

msgid ""
"If your generator will only yield values, set the ``SendType`` and "
"``ReturnType`` to ``None``::"
msgstr ""
"Якщо ваш генератор видаватиме лише значення, встановіть для ``SendType`` і "
"``ReturnType`` значення ``None``::"

msgid ""
"Alternatively, annotate your generator as having a return type of either "
"``Iterable[YieldType]`` or ``Iterator[YieldType]``::"
msgstr ""
"Крім того, позначте свій генератор як такий, що має тип повернення "
"``Iterable[YieldType]`` або ``Iterator[YieldType]``::"

msgid ""
":class:`collections.abc.Generator` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "An alias to :class:`collections.abc.Hashable`."
msgstr "Псевдонім :class:`collections.abc.Hashable`."

msgid "A generic version of :class:`collections.abc.Reversible`."
msgstr "Загальна версія :class:`collections.abc.Reversible`."

msgid ""
":class:`collections.abc.Reversible` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "An alias to :class:`collections.abc.Sized`."
msgstr "Псевдонім :class:`collections.abc.Sized`."

msgid "Asynchronous programming"
msgstr "Асинхронне програмування"

msgid ""
"A generic version of :class:`collections.abc.Coroutine`. The variance and "
"order of type variables correspond to those of :class:`Generator`, for "
"example::"
msgstr ""
"Загальна версія :class:`collections.abc.Coroutine`. Дисперсія та порядок "
"змінних типу відповідають змінним :class:`Generator`, наприклад::"

msgid ""
":class:`collections.abc.Coroutine` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid ""
"An async generator can be annotated by the generic type "
"``AsyncGenerator[YieldType, SendType]``. For example::"
msgstr ""
"Асинхронний генератор може бути анотований загальним типом "
"``AsyncGenerator[YieldType, SendType]``. Наприклад::"

msgid ""
"Unlike normal generators, async generators cannot return a value, so there "
"is no ``ReturnType`` type parameter. As with :class:`Generator`, the "
"``SendType`` behaves contravariantly."
msgstr ""
"На відміну від звичайних генераторів, асинхронні генератори не можуть "
"повертати значення, тому немає параметра типу ``ReturnType``. Як і :class:"
"`Generator`, ``SendType`` поводиться протилежно."

msgid ""
"If your generator will only yield values, set the ``SendType`` to ``None``::"
msgstr ""
"Якщо ваш генератор видаватиме лише значення, встановіть для ``SendType`` "
"значення ``None``::"

msgid ""
"Alternatively, annotate your generator as having a return type of either "
"``AsyncIterable[YieldType]`` or ``AsyncIterator[YieldType]``::"
msgstr ""
"Крім того, позначте свій генератор як такий, що має тип повернення "
"``AsyncIterable[YieldType]`` або ``AsyncIterator[YieldType]``::"

msgid ""
":class:`collections.abc.AsyncGenerator` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.AsyncIterable`."
msgstr "Загальна версія :class:`collections.abc.AsyncIterable`."

msgid ""
":class:`collections.abc.AsyncIterable` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.AsyncIterator`."
msgstr "Загальна версія :class:`collections.abc.AsyncIterator`."

msgid ""
":class:`collections.abc.AsyncIterator` now supports subscripting (``[]``). "
"See :pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`collections.abc.Awaitable`."
msgstr "Загальна версія :class:`collections.abc.Awaitable`."

msgid ""
":class:`collections.abc.Awaitable` now supports subscripting (``[]``). See :"
"pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "Context manager types"
msgstr "Типи контекстного менеджера"

msgid "A generic version of :class:`contextlib.AbstractContextManager`."
msgstr "Загальна версія :class:`contextlib.AbstractContextManager`."

msgid ""
":class:`contextlib.AbstractContextManager` now supports subscripting "
"(``[]``). See :pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "A generic version of :class:`contextlib.AbstractAsyncContextManager`."
msgstr "Загальна версія :class:`contextlib.AbstractAsyncContextManager`."

msgid ""
":class:`contextlib.AbstractAsyncContextManager` now supports subscripting "
"(``[]``). See :pep:`585` and :ref:`types-genericalias`."
msgstr ""

msgid "Protocols"
msgstr "Протоколи"

msgid "These protocols are decorated with :func:`runtime_checkable`."
msgstr "Ці протоколи прикрашені :func:`runtime_checkable`."

msgid ""
"An ABC with one abstract method ``__abs__`` that is covariant in its return "
"type."
msgstr ""
"ABC з одним абстрактним методом ``__abs__``, який є коваріантним у своєму "
"типі повернення."

msgid "An ABC with one abstract method ``__bytes__``."
msgstr "ABC з одним абстрактним методом ``__bytes__``."

msgid "An ABC with one abstract method ``__complex__``."
msgstr "ABC з одним абстрактним методом ``__complex__``."

msgid "An ABC with one abstract method ``__float__``."
msgstr "ABC з одним абстрактним методом ``__float__``."

msgid "An ABC with one abstract method ``__index__``."
msgstr "ABC з одним абстрактним методом ``__index__``."

msgid "An ABC with one abstract method ``__int__``."
msgstr "ABC з одним абстрактним методом ``__int__``."

msgid ""
"An ABC with one abstract method ``__round__`` that is covariant in its "
"return type."
msgstr ""
"ABC з одним абстрактним методом ``__round__``, який є коваріантним у своєму "
"типі повернення."

msgid "Functions and decorators"
msgstr "Функції та декоратори"

msgid "Cast a value to a type."
msgstr "Приведення значення до типу."

msgid ""
"This returns the value unchanged.  To the type checker this signals that the "
"return value has the designated type, but at runtime we intentionally don't "
"check anything (we want this to be as fast as possible)."
msgstr ""
"Це повертає значення без змін. Для засобу перевірки типів це означає, що "
"значення, що повертається, має визначений тип, але під час виконання ми "
"навмисно нічого не перевіряємо (ми хочемо, щоб це було якомога швидше)."

msgid ""
"Ask a static type checker to confirm that *val* has an inferred type of "
"*typ*."
msgstr ""

msgid ""
"When the type checker encounters a call to ``assert_type()``, it emits an "
"error if the value is not of the specified type::"
msgstr ""

msgid ""
"At runtime this returns the first argument unchanged with no side effects."
msgstr ""

msgid ""
"This function is useful for ensuring the type checker's understanding of a "
"script is in line with the developer's intentions::"
msgstr ""

msgid ""
"Ask a static type checker to confirm that a line of code is unreachable."
msgstr ""

msgid ""
"Here, the annotations allow the type checker to infer that the last case can "
"never execute, because ``arg`` is either an :class:`int` or a :class:`str`, "
"and both options are covered by earlier cases. If a type checker finds that "
"a call to ``assert_never()`` is reachable, it will emit an error. For "
"example, if the type annotation for ``arg`` was instead ``int | str | "
"float``, the type checker would emit an error pointing out that "
"``unreachable`` is of type :class:`float`. For a call to ``assert_never`` to "
"pass type checking, the inferred type of the argument passed in must be the "
"bottom type, :data:`Never`, and nothing else."
msgstr ""

msgid "At runtime, this throws an exception when called."
msgstr ""

msgid ""
"`Unreachable Code and Exhaustiveness Checking <https://typing.readthedocs.io/"
"en/latest/source/unreachable.html>`__ has more information about "
"exhaustiveness checking with static typing."
msgstr ""

msgid "Reveal the inferred static type of an expression."
msgstr ""

msgid ""
"When a static type checker encounters a call to this function, it emits a "
"diagnostic with the type of the argument. For example::"
msgstr ""

msgid ""
"This can be useful when you want to debug how your type checker handles a "
"particular piece of code."
msgstr ""

msgid ""
"The function returns its argument unchanged, which allows using it within an "
"expression::"
msgstr ""

msgid ""
"Most type checkers support ``reveal_type()`` anywhere, even if the name is "
"not imported from ``typing``. Importing the name from ``typing`` allows your "
"code to run without runtime errors and communicates intent more clearly."
msgstr ""

msgid ""
"At runtime, this function prints the runtime type of its argument to stderr "
"and returns it unchanged::"
msgstr ""

msgid ""
":data:`~typing.dataclass_transform` may be used to decorate a class, "
"metaclass, or a function that is itself a decorator. The presence of "
"``@dataclass_transform()`` tells a static type checker that the decorated "
"object performs runtime \"magic\" that transforms a class, giving it :func:"
"`dataclasses.dataclass`-like behaviors."
msgstr ""

msgid "Example usage with a decorator function::"
msgstr ""

msgid "On a base class::"
msgstr ""

msgid "On a metaclass::"
msgstr ""

msgid ""
"The ``CustomerModel`` classes defined above will be treated by type checkers "
"similarly to classes created with :func:`@dataclasses.dataclass <dataclasses."
"dataclass>`. For example, type checkers will assume these classes have "
"``__init__`` methods that accept ``id`` and ``name``."
msgstr ""

msgid ""
"The decorated class, metaclass, or function may accept the following bool "
"arguments which type checkers will assume have the same effect as they would "
"have on the :func:`@dataclasses.dataclass<dataclasses.dataclass>` decorator: "
"``init``, ``eq``, ``order``, ``unsafe_hash``, ``frozen``, ``match_args``, "
"``kw_only``, and ``slots``. It must be possible for the value of these "
"arguments (``True`` or ``False``) to be statically evaluated."
msgstr ""

msgid ""
"The arguments to the ``dataclass_transform`` decorator can be used to "
"customize the default behaviors of the decorated class, metaclass, or "
"function:"
msgstr ""

msgid ""
"``eq_default`` indicates whether the ``eq`` parameter is assumed to be "
"``True`` or ``False`` if it is omitted by the caller."
msgstr ""

msgid ""
"``order_default`` indicates whether the ``order`` parameter is assumed to be "
"True or False if it is omitted by the caller."
msgstr ""

msgid ""
"``kw_only_default`` indicates whether the ``kw_only`` parameter is assumed "
"to be True or False if it is omitted by the caller."
msgstr ""

msgid ""
"``field_specifiers`` specifies a static list of supported classes or "
"functions that describe fields, similar to ``dataclasses.field()``."
msgstr ""

msgid ""
"Arbitrary other keyword arguments are accepted in order to allow for "
"possible future extensions."
msgstr ""

msgid ""
"Type checkers recognize the following optional arguments on field specifiers:"
msgstr ""

msgid ""
"``init`` indicates whether the field should be included in the synthesized "
"``__init__`` method. If unspecified, ``init`` defaults to ``True``."
msgstr ""

msgid "``default`` provides the default value for the field."
msgstr ""

msgid ""
"``default_factory`` provides a runtime callback that returns the default "
"value for the field. If neither ``default`` nor ``default_factory`` are "
"specified, the field is assumed to have no default value and must be "
"provided a value when the class is instantiated."
msgstr ""

msgid "``factory`` is an alias for ``default_factory``."
msgstr ""

msgid ""
"``kw_only`` indicates whether the field should be marked as keyword-only. If "
"``True``, the field will be keyword-only. If ``False``, it will not be "
"keyword-only. If unspecified, the value of the ``kw_only`` parameter on the "
"object decorated with ``dataclass_transform`` will be used, or if that is "
"unspecified, the value of ``kw_only_default`` on ``dataclass_transform`` "
"will be used."
msgstr ""

msgid ""
"``alias`` provides an alternative name for the field. This alternative name "
"is used in the synthesized ``__init__`` method."
msgstr ""

msgid ""
"At runtime, this decorator records its arguments in the "
"``__dataclass_transform__`` attribute on the decorated object. It has no "
"other runtime effect."
msgstr ""

msgid "See :pep:`681` for more details."
msgstr ""

msgid ""
"The ``@overload`` decorator allows describing functions and methods that "
"support multiple different combinations of argument types. A series of "
"``@overload``-decorated definitions must be followed by exactly one non-"
"``@overload``-decorated definition (for the same function/method). The "
"``@overload``-decorated definitions are for the benefit of the type checker "
"only, since they will be overwritten by the non-``@overload``-decorated "
"definition, while the latter is used at runtime but should be ignored by a "
"type checker.  At runtime, calling a ``@overload``-decorated function "
"directly will raise :exc:`NotImplementedError`. An example of overload that "
"gives a more precise type than can be expressed using a union or a type "
"variable::"
msgstr ""
"Декоратор ``@overload`` дозволяє описувати функції та методи, які "
"підтримують кілька різних комбінацій типів аргументів. Після серії "
"визначень, прикрашених ``@overload``, має слідувати точно одне визначення, "
"не прикрашене ``@overload`` (для тієї самої функції/методу). Визначення, "
"прикрашені ``@overload``, призначені лише для перевірки типів, оскільки вони "
"будуть перезаписані визначенням, не прикрашеним ``@overload``, тоді як "
"останнє використовується під час виконання, але його слід ігнорувати за "
"допомогою перевірки типу. Під час виконання прямий виклик функції, "
"декорованої ``@overload``, викличе :exc:`NotImplementedError`. Приклад "
"перевантаження, який дає більш точний тип, ніж можна виразити за допомогою "
"об’єднання або змінної типу::"

msgid ""
"See :pep:`484` for more details and comparison with other typing semantics."
msgstr ""

msgid ""
"Overloaded functions can now be introspected at runtime using :func:"
"`get_overloads`."
msgstr ""

msgid ""
"Return a sequence of :func:`@overload <overload>`-decorated definitions for "
"*func*. *func* is the function object for the implementation of the "
"overloaded function. For example, given the definition of ``process`` in the "
"documentation for :func:`@overload <overload>`, ``get_overloads(process)`` "
"will return a sequence of three function objects for the three defined "
"overloads. If called on a function with no overloads, ``get_overloads()`` "
"returns an empty sequence."
msgstr ""

msgid ""
"``get_overloads()`` can be used for introspecting an overloaded function at "
"runtime."
msgstr ""

msgid ""
"Clear all registered overloads in the internal registry. This can be used to "
"reclaim the memory used by the registry."
msgstr ""

msgid ""
"A decorator to indicate to type checkers that the decorated method cannot be "
"overridden, and the decorated class cannot be subclassed. For example::"
msgstr ""
"Декоратор, який вказує засобам перевірки типу, що декорований метод не може "
"бути перевизначений, а декорований клас не може бути підкласом. Наприклад::"

msgid ""
"The decorator will now set the ``__final__`` attribute to ``True`` on the "
"decorated object. Thus, a check like ``if getattr(obj, \"__final__\", "
"False)`` can be used at runtime to determine whether an object ``obj`` has "
"been marked as final. If the decorated object does not support setting "
"attributes, the decorator returns the object unchanged without raising an "
"exception."
msgstr ""

msgid "Decorator to indicate that annotations are not type hints."
msgstr "Декоратор, щоб вказати, що анотації не є підказками типу."

msgid ""
"This works as class or function :term:`decorator`.  With a class, it applies "
"recursively to all methods and classes defined in that class (but not to "
"methods defined in its superclasses or subclasses)."
msgstr ""

msgid "This mutates the function(s) in place."
msgstr "Це змінює діючу функцію(и)."

msgid "Decorator to give another decorator the :func:`no_type_check` effect."
msgstr "Декоратор, щоб надати іншому декоратору ефект :func:`no_type_check`."

msgid ""
"This wraps the decorator with something that wraps the decorated function "
"in :func:`no_type_check`."
msgstr ""
"Це обертає декоратор чимось, що обертає декоровану функцію в :func:"
"`no_type_check`."

msgid "Decorator to mark a class or function to be unavailable at runtime."
msgstr ""
"Декоратор для позначення класу або функції як недоступні під час виконання."

msgid ""
"This decorator is itself not available at runtime. It is mainly intended to "
"mark classes that are defined in type stub files if an implementation "
"returns an instance of a private class::"
msgstr ""
"Сам цей декоратор недоступний під час виконання. В основному він призначений "
"для позначення класів, визначених у файлах-заглушках типу, якщо реалізація "
"повертає екземпляр приватного класу::"

msgid ""
"Note that returning instances of private classes is not recommended. It is "
"usually preferable to make such classes public."
msgstr ""
"Зауважте, що повертати екземпляри приватних класів не рекомендується. "
"Зазвичай бажано зробити такі заняття публічними."

msgid "Introspection helpers"
msgstr "Помічники в самоаналізі"

msgid ""
"Return a dictionary containing type hints for a function, method, module or "
"class object."
msgstr ""
"Повертає словник, що містить підказки типу для функції, методу, модуля або "
"об’єкта класу."

msgid ""
"This is often the same as ``obj.__annotations__``. In addition, forward "
"references encoded as string literals are handled by evaluating them in "
"``globals`` and ``locals`` namespaces. For a class ``C``, return a "
"dictionary constructed by merging all the ``__annotations__`` along ``C."
"__mro__`` in reverse order."
msgstr ""

msgid ""
"The function recursively replaces all ``Annotated[T, ...]`` with ``T``, "
"unless ``include_extras`` is set to ``True`` (see :class:`Annotated` for "
"more information). For example::"
msgstr ""
"Функція рекурсивно замінює всі ``Annotated[T, ...]`` на ``T``, якщо "
"``include_extras`` не встановлено на ``True`` (перегляньте :class:"
"`Annotated` для отримання додаткової інформації) . Наприклад::"

msgid ""
":func:`get_type_hints` does not work with imported :ref:`type aliases <type-"
"aliases>` that include forward references. Enabling postponed evaluation of "
"annotations (:pep:`563`) may remove the need for most forward references."
msgstr ""
":func:`get_type_hints` не працює з імпортованими :ref:`псевдонімами типу "
"<type-aliases>`, які містять прямі посилання. Увімкнення відкладеної оцінки "
"анотацій (:pep:`563`) може позбавити потреби в більшості посилань."

msgid "Added ``include_extras`` parameter as part of :pep:`593`."
msgstr "Додано параметр ``include_extras`` як частину :pep:`593`."

msgid ""
"Previously, ``Optional[t]`` was added for function and method annotations if "
"a default value equal to ``None`` was set. Now the annotation is returned "
"unchanged."
msgstr ""

msgid "Provide basic introspection for generic types and special typing forms."
msgstr ""
"Забезпечити базову самоаналіз для загальних типів і спеціальних форм набору "
"тексту."

msgid ""
"For a typing object of the form ``X[Y, Z, ...]`` these functions return "
"``X`` and ``(Y, Z, ...)``. If ``X`` is a generic alias for a builtin or :mod:"
"`collections` class, it gets normalized to the original class. If ``X`` is a "
"union or :class:`Literal` contained in another generic type, the order of "
"``(Y, Z, ...)`` may be different from the order of the original arguments "
"``[Y, Z, ...]`` due to type caching. For unsupported objects return ``None`` "
"and ``()`` correspondingly. Examples::"
msgstr ""
"Для об’єкта типу ``X[Y, Z, ...]`` ці функції повертають ``X`` і ``(Y, "
"Z, ...)``. Якщо ``X`` є загальним псевдонімом для вбудованого класу або :mod:"
"`collections` класу, він нормалізується до оригінального класу. Якщо ``X`` є "
"об’єднанням або :class:`Literal`, що міститься в іншому загальному типі, "
"порядок ``(Y, Z, ...)`` може відрізнятися від порядку вихідних аргументів "
"``[Y, Z, ...]`` через кешування типів. Для непідтримуваних об’єктів "
"поверніть ``None`` і ``()`` відповідно. Приклади::"

msgid "Check if a type is a :class:`TypedDict`."
msgstr "Перевірте, чи є тип :class:`TypedDict`."

msgid ""
"A class used for internal typing representation of string forward "
"references. For example, ``List[\"SomeClass\"]`` is implicitly transformed "
"into ``List[ForwardRef(\"SomeClass\")]``.  This class should not be "
"instantiated by a user, but may be used by introspection tools."
msgstr ""
"Клас, який використовується для внутрішнього представлення типізації "
"посилань на рядок. Наприклад, ``List[\"SomeClass\"]`` неявно перетворюється "
"на ``List[ForwardRef(\"SomeClass\")]``. Цей клас не повинен створюватися "
"користувачем, але може використовуватися інструментами самоаналізу."

msgid ""
":pep:`585` generic types such as ``list[\"SomeClass\"]`` will not be "
"implicitly transformed into ``list[ForwardRef(\"SomeClass\")]`` and thus "
"will not automatically resolve to ``list[SomeClass]``."
msgstr ""
":pep:`585` загальні типи, такі як ``list[\"SomeClass\"]``, не будуть неявно "
"перетворені в ``list[ForwardRef(\"SomeClass\")]`` і, таким чином, не будуть "
"автоматично перетворені в ``list[ SomeClass]``."

msgid "Constant"
msgstr "Постійний"

msgid ""
"A special constant that is assumed to be ``True`` by 3rd party static type "
"checkers. It is ``False`` at runtime. Usage::"
msgstr ""
"Спеціальна константа, яка вважається ``True`` сторонніми засобами перевірки "
"статичного типу. Це ``False`` під час виконання. Використання::"

msgid ""
"The first type annotation must be enclosed in quotes, making it a \"forward "
"reference\", to hide the ``expensive_mod`` reference from the interpreter "
"runtime.  Type annotations for local variables are not evaluated, so the "
"second annotation does not need to be enclosed in quotes."
msgstr ""
"Анотація першого типу має бути взята в лапки, що робить її \"прямим "
"посиланням\", щоб приховати посилання ``expensive_mod`` від середовища "
"виконання інтерпретатора. Анотації типу для локальних змінних не оцінюються, "
"тому другу анотацію не потрібно брати в лапки."

msgid ""
"If ``from __future__ import annotations`` is used, annotations are not "
"evaluated at function definition time. Instead, they are stored as strings "
"in ``__annotations__``. This makes it unnecessary to use quotes around the "
"annotation (see :pep:`563`)."
msgstr ""
"Якщо використовується ``from __future__ import annotations``, анотації не "
"оцінюються під час визначення функції. Натомість вони зберігаються як рядки "
"в ``__annotations__``. Це робить непотрібним використання лапок навколо "
"анотації (див. :pep:`563`)."

msgid "Deprecation Timeline of Major Features"
msgstr ""

msgid ""
"Certain features in ``typing`` are deprecated and may be removed in a future "
"version of Python. The following table summarizes major deprecations for "
"your convenience. This is subject to change, and not all deprecations are "
"listed."
msgstr ""

msgid "Feature"
msgstr ""

msgid "Deprecated in"
msgstr ""

msgid "Projected removal"
msgstr ""

msgid "PEP/issue"
msgstr ""

msgid "``typing.io`` and ``typing.re`` submodules"
msgstr ""

msgid "3.8"
msgstr ""

msgid "3.13"
msgstr ""

msgid ":issue:`38291`"
msgstr ""

msgid "``typing`` versions of standard collections"
msgstr ""

msgid "3.9"
msgstr ""

msgid "Undecided"
msgstr ""

msgid ":pep:`585`"
msgstr ""

msgid "``typing.Text``"
msgstr ""

msgid "3.11"
msgstr ""

msgid ":gh:`92332`"
msgstr ""
