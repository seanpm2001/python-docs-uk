# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:56+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`codecs` --- Codec registry and base classes"
msgstr ":mod:`codecs` --- Реєстр кодеків і базові класи"

msgid "**Source code:** :source:`Lib/codecs.py`"
msgstr "**Вихідний код:** :source:`Lib/codecs.py`"

msgid ""
"This module defines base classes for standard Python codecs (encoders and "
"decoders) and provides access to the internal Python codec registry, which "
"manages the codec and error handling lookup process. Most standard codecs "
"are :term:`text encodings <text encoding>`, which encode text to bytes (and "
"decode bytes to text), but there are also codecs provided that encode text "
"to text, and bytes to bytes. Custom codecs may encode and decode between "
"arbitrary types, but some module features are restricted to be used "
"specifically with :term:`text encodings <text encoding>` or with codecs that "
"encode to :class:`bytes`."
msgstr ""
"Цей модуль визначає базові класи для стандартних кодеків Python (кодери та "
"декодери) і надає доступ до внутрішнього реєстру кодеків Python, який керує "
"процесом пошуку кодека та обробки помилок. Більшість стандартних кодеків — "
"це :term:`кодування тексту <text encoding>`, які кодують текст у байти (і "
"декодують байти в текст), але є також кодеки, які кодують текст у текст і "
"байти в байти. Спеціальні кодеки можуть кодувати та декодувати між "
"довільними типами, але деякі функції модулів обмежено для використання "
"спеціально з :term:`текстовими кодуваннями <text encoding>` або з кодеками, "
"які кодують у :class:`bytes`."

msgid ""
"The module defines the following functions for encoding and decoding with "
"any codec:"
msgstr ""
"Модуль визначає такі функції для кодування та декодування будь-яким кодеком:"

msgid "Encodes *obj* using the codec registered for *encoding*."
msgstr "Кодує *obj* за допомогою кодека, зареєстрованого для *кодування*."

msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that encoding errors raise :exc:"
"`ValueError` (or a more codec specific subclass, such as :exc:"
"`UnicodeEncodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"*Помилки* можуть бути надані для встановлення потрібної схеми обробки "
"помилок. Обробником помилок за замовчуванням є ``'strict'``, що означає, що "
"помилки кодування викликають :exc:`ValueError` (або більш специфічний "
"підклас кодека, наприклад :exc:`UnicodeEncodeError`). Зверніться до :ref:"
"`codec-base-classes` для отримання додаткової інформації щодо обробки "
"помилок кодека."

msgid "Decodes *obj* using the codec registered for *encoding*."
msgstr "Декодує *obj* за допомогою кодека, зареєстрованого для *кодування*."

msgid ""
"*Errors* may be given to set the desired error handling scheme. The default "
"error handler is ``'strict'`` meaning that decoding errors raise :exc:"
"`ValueError` (or a more codec specific subclass, such as :exc:"
"`UnicodeDecodeError`). Refer to :ref:`codec-base-classes` for more "
"information on codec error handling."
msgstr ""
"*Помилки* можуть бути надані для встановлення потрібної схеми обробки "
"помилок. Обробником помилок за замовчуванням є ``'strict'``, що означає, що "
"помилки декодування викликають :exc:`ValueError` (або більш специфічний "
"підклас кодека, такий як :exc:`UnicodeDecodeError`). Зверніться до :ref:"
"`codec-base-classes` для отримання додаткової інформації про обробку помилок "
"кодека."

msgid "The full details for each codec can also be looked up directly:"
msgstr ""
"Повну інформацію про кожен кодек також можна переглянути безпосередньо:"

msgid ""
"Looks up the codec info in the Python codec registry and returns a :class:"
"`CodecInfo` object as defined below."
msgstr ""
"Шукає інформацію про кодек у реєстрі кодеків Python і повертає об’єкт :class:"
"`CodecInfo`, як визначено нижче."

msgid ""
"Encodings are first looked up in the registry's cache. If not found, the "
"list of registered search functions is scanned. If no :class:`CodecInfo` "
"object is found, a :exc:`LookupError` is raised. Otherwise, the :class:"
"`CodecInfo` object is stored in the cache and returned to the caller."
msgstr ""
"Кодування спочатку шукаються в кеші реєстру. Якщо не знайдено, сканується "
"список зареєстрованих функцій пошуку. Якщо об’єкт :class:`CodecInfo` не "
"знайдено, виникає :exc:`LookupError`. В іншому випадку об’єкт :class:"
"`CodecInfo` зберігається в кеші та повертається абоненту."

msgid ""
"Codec details when looking up the codec registry. The constructor arguments "
"are stored in attributes of the same name:"
msgstr ""
"Відомості про кодек під час пошуку реєстру кодеків. Аргументи конструктора "
"зберігаються в однойменних атрибутах:"

msgid "The name of the encoding."
msgstr "Назва кодування."

msgid ""
"The stateless encoding and decoding functions. These must be functions or "
"methods which have the same interface as the :meth:`~Codec.encode` and :meth:"
"`~Codec.decode` methods of Codec instances (see :ref:`Codec Interface <codec-"
"objects>`). The functions or methods are expected to work in a stateless "
"mode."
msgstr ""
"Функції кодування та декодування без збереження стану. Це мають бути функції "
"чи методи, які мають той самий інтерфейс, що й методи :meth:`~Codec.encode` "
"і :meth:`~Codec.decode` екземплярів кодека (див. :ref:`Інтерфейс кодека "
"<codec-objects>`). Очікується, що функції або методи працюватимуть у режимі "
"без збереження стану."

msgid ""
"Incremental encoder and decoder classes or factory functions. These have to "
"provide the interface defined by the base classes :class:"
"`IncrementalEncoder` and :class:`IncrementalDecoder`, respectively. "
"Incremental codecs can maintain state."
msgstr ""
"Класи інкрементального кодера та декодера або заводські функції. Вони мають "
"забезпечувати інтерфейс, визначений базовими класами :class:"
"`IncrementalEncoder` та :class:`IncrementalDecoder` відповідно. Інкрементні "
"кодеки можуть підтримувати стан."

msgid ""
"Stream writer and reader classes or factory functions. These have to provide "
"the interface defined by the base classes :class:`StreamWriter` and :class:"
"`StreamReader`, respectively. Stream codecs can maintain state."
msgstr ""
"Класи потокового запису та читання або фабричні функції. Вони мають "
"забезпечувати інтерфейс, визначений базовими класами :class:`StreamWriter` "
"і :class:`StreamReader` відповідно. Потокові кодеки можуть підтримувати стан."

msgid ""
"To simplify access to the various codec components, the module provides "
"these additional functions which use :func:`lookup` for the codec lookup:"
msgstr ""
"Щоб спростити доступ до різних компонентів кодека, модуль надає такі "
"додаткові функції, які використовують :func:`lookup` для пошуку кодека:"

msgid ""
"Look up the codec for the given encoding and return its encoder function."
msgstr ""
"Знайдіть кодек для даного кодування та поверніть його функцію кодувальника."

msgid "Raises a :exc:`LookupError` in case the encoding cannot be found."
msgstr "Викликає :exc:`LookupError`, якщо кодування не знайдено."

msgid ""
"Look up the codec for the given encoding and return its decoder function."
msgstr ""
"Знайдіть кодек для даного кодування та поверніть його функцію декодера."

msgid ""
"Look up the codec for the given encoding and return its incremental encoder "
"class or factory function."
msgstr ""
"Знайдіть кодек для даного кодування та поверніть його інкрементний клас "
"кодера або заводську функцію."

msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental encoder."
msgstr ""
"Викликає :exc:`LookupError`, якщо кодування не знайдено або кодек не "
"підтримує інкрементний кодер."

msgid ""
"Look up the codec for the given encoding and return its incremental decoder "
"class or factory function."
msgstr ""
"Знайдіть кодек для даного кодування та поверніть його інкрементний клас "
"декодера або заводську функцію."

msgid ""
"Raises a :exc:`LookupError` in case the encoding cannot be found or the "
"codec doesn't support an incremental decoder."
msgstr ""
"Викликає :exc:`LookupError`, якщо кодування не знайдено або кодек не "
"підтримує інкрементний декодер."

msgid ""
"Look up the codec for the given encoding and return its :class:"
"`StreamReader` class or factory function."
msgstr ""
"Знайдіть кодек для вказаного кодування та поверніть його клас :class:"
"`StreamReader` або фабричну функцію."

msgid ""
"Look up the codec for the given encoding and return its :class:"
"`StreamWriter` class or factory function."
msgstr ""
"Знайдіть кодек для вказаного кодування та поверніть його клас :class:"
"`StreamWriter` або фабричну функцію."

msgid ""
"Custom codecs are made available by registering a suitable codec search "
"function:"
msgstr ""
"Спеціальні кодеки стають доступними, якщо зареєструвати відповідну функцію "
"пошуку кодеків:"

msgid ""
"Register a codec search function. Search functions are expected to take one "
"argument, being the encoding name in all lower case letters with hyphens and "
"spaces converted to underscores, and return a :class:`CodecInfo` object. In "
"case a search function cannot find a given encoding, it should return "
"``None``."
msgstr ""
"Зареєструйте функцію пошуку кодеків. Очікується, що функції пошуку "
"прийматимуть один аргумент, тобто ім’я кодування, яке складається з малих "
"літер із дефісами та пробілами, перетворене на підкреслення, і повертатиме "
"об’єкт :class:`CodecInfo`. Якщо функція пошуку не може знайти задане "
"кодування, вона має повернути ``None``."

msgid "Hyphens and spaces are converted to underscore."
msgstr "Дефіси та пробіли перетворюються на підкреслення."

msgid ""
"Unregister a codec search function and clear the registry's cache. If the "
"search function is not registered, do nothing."
msgstr ""
"Скасуйте реєстрацію функції пошуку кодеків і очистіть кеш реєстру. Якщо "
"функція пошуку не зареєстрована, нічого не робіть."

msgid ""
"While the builtin :func:`open` and the associated :mod:`io` module are the "
"recommended approach for working with encoded text files, this module "
"provides additional utility functions and classes that allow the use of a "
"wider range of codecs when working with binary files:"
msgstr ""
"Хоча вбудований :func:`open` і пов’язаний модуль :mod:`io` є рекомендованим "
"підходом для роботи з кодованими текстовими файлами, цей модуль надає "
"додаткові службові функції та класи, які дозволяють використовувати ширший "
"діапазон кодеків під час роботи з бінарними файлами:"

msgid ""
"Open an encoded file using the given *mode* and return an instance of :class:"
"`StreamReaderWriter`, providing transparent encoding/decoding. The default "
"file mode is ``'r'``, meaning to open the file in read mode."
msgstr ""
"Відкрийте закодований файл у заданому *режимі* та поверніть екземпляр :class:"
"`StreamReaderWriter`, забезпечуючи прозоре кодування/декодування. Типовим "
"режимом файлу є ``'r''``, що означає відкриття файлу в режимі читання."

msgid ""
"If *encoding* is not ``None``, then the underlying encoded files are always "
"opened in binary mode. No automatic conversion of ``'\\n'`` is done on "
"reading and writing. The *mode* argument may be any binary mode acceptable "
"to the built-in :func:`open` function; the ``'b'`` is automatically added."
msgstr ""

msgid ""
"*encoding* specifies the encoding which is to be used for the file. Any "
"encoding that encodes to and decodes from bytes is allowed, and the data "
"types supported by the file methods depend on the codec used."
msgstr ""
"*encoding* визначає кодування, яке буде використано для файлу. Дозволяється "
"будь-яке кодування, яке кодує та декодує з байтів, а типи даних, які "
"підтримуються методами файлів, залежать від використовуваного кодека."

msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'`` which causes a :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"*errors* можуть бути надані для визначення обробки помилок. За замовчуванням "
"встановлено значення ``'strict''``, що спричиняє виникнення :exc:"
"`ValueError` у разі виникнення помилки кодування."

msgid ""
"*buffering* has the same meaning as for the built-in :func:`open` function. "
"It defaults to -1 which means that the default buffer size will be used."
msgstr ""
"*buffering* має те саме значення, що й вбудована функція :func:`open`. За "
"замовчуванням він дорівнює -1, що означає, що буде використано стандартний "
"розмір буфера."

msgid "The ``'U'`` mode has been removed."
msgstr ""

msgid ""
"Return a :class:`StreamRecoder` instance, a wrapped version of *file* which "
"provides transparent transcoding. The original file is closed when the "
"wrapped version is closed."
msgstr ""
"Повертає екземпляр :class:`StreamRecoder`, загорнуту версію *файлу*, яка "
"забезпечує прозоре перекодування. Вихідний файл закривається, коли "
"закривається упакована версія."

msgid ""
"Data written to the wrapped file is decoded according to the given "
"*data_encoding* and then written to the original file as bytes using "
"*file_encoding*. Bytes read from the original file are decoded according to "
"*file_encoding*, and the result is encoded using *data_encoding*."
msgstr ""
"Дані, записані в обгорнутий файл, декодуються відповідно до заданого "
"*data_encoding*, а потім записуються в вихідний файл у вигляді байтів за "
"допомогою *file_encoding*. Байти, зчитані з вихідного файлу, декодуються "
"відповідно до *file_encoding*, а результат кодується за допомогою "
"*data_encoding*."

msgid "If *file_encoding* is not given, it defaults to *data_encoding*."
msgstr "Якщо *file_encoding* не вказано, за умовчанням буде *data_encoding*."

msgid ""
"*errors* may be given to define the error handling. It defaults to "
"``'strict'``, which causes :exc:`ValueError` to be raised in case an "
"encoding error occurs."
msgstr ""
"*errors* можуть бути надані для визначення обробки помилок. За замовчуванням "
"встановлено ``'strict'``, що спричиняє :exc:`ValueError`, що виникає у "
"випадку помилки кодування."

msgid ""
"Uses an incremental encoder to iteratively encode the input provided by "
"*iterator*. This function is a :term:`generator`. The *errors* argument (as "
"well as any other keyword argument) is passed through to the incremental "
"encoder."
msgstr ""
"Використовує інкрементальний кодувальник для ітеративного кодування вхідних "
"даних, наданих *iterator*. Ця функція є :term:`generator`. Аргумент *errors* "
"(як і будь-який інший аргумент ключового слова) передається до "
"інкрементального кодувальника."

msgid ""
"This function requires that the codec accept text :class:`str` objects to "
"encode. Therefore it does not support bytes-to-bytes encoders such as "
"``base64_codec``."
msgstr ""
"Ця функція вимагає, щоб кодек приймав текстові об’єкти :class:`str` для "
"кодування. Тому він не підтримує кодувальники байт-у-байт, такі як "
"``base64_codec``."

msgid ""
"Uses an incremental decoder to iteratively decode the input provided by "
"*iterator*. This function is a :term:`generator`. The *errors* argument (as "
"well as any other keyword argument) is passed through to the incremental "
"decoder."
msgstr ""
"Використовує інкрементальний декодер для ітеративного декодування вхідних "
"даних, наданих *iterator*. Ця функція є :term:`generator`. Аргумент *errors* "
"(як і будь-який інший аргумент ключового слова) передається до "
"інкрементального декодера."

msgid ""
"This function requires that the codec accept :class:`bytes` objects to "
"decode. Therefore it does not support text-to-text encoders such as "
"``rot_13``, although ``rot_13`` may be used equivalently with :func:"
"`iterencode`."
msgstr ""
"Ця функція вимагає, щоб кодек приймав об’єкти :class:`bytes` для "
"декодування. Тому він не підтримує кодувальники тексту в текст, такі як "
"``rot_13``, хоча ``rot_13`` можна використовувати еквівалентно з :func:"
"`iterencode`."

msgid ""
"The module also provides the following constants which are useful for "
"reading and writing to platform dependent files:"
msgstr ""
"Модуль також надає наступні константи, які корисні для читання та запису в "
"залежні від платформи файли:"

msgid ""
"These constants define various byte sequences, being Unicode byte order "
"marks (BOMs) for several encodings. They are used in UTF-16 and UTF-32 data "
"streams to indicate the byte order used, and in UTF-8 as a Unicode "
"signature. :const:`BOM_UTF16` is either :const:`BOM_UTF16_BE` or :const:"
"`BOM_UTF16_LE` depending on the platform's native byte order, :const:`BOM` "
"is an alias for :const:`BOM_UTF16`, :const:`BOM_LE` for :const:"
"`BOM_UTF16_LE` and :const:`BOM_BE` for :const:`BOM_UTF16_BE`. The others "
"represent the BOM in UTF-8 and UTF-32 encodings."
msgstr ""
"Ці константи визначають різні послідовності байтів, будучи мітками порядку "
"байтів Unicode (BOM) для кількох кодувань. Вони використовуються в потоках "
"даних UTF-16 і UTF-32 для позначення використовуваного порядку байтів, а в "
"UTF-8 як підпис Юнікод. :const:`BOM_UTF16` є або :const:`BOM_UTF16_BE`, або :"
"const:`BOM_UTF16_LE` залежно від рідного порядку байтів платформи, :const:"
"`BOM` є псевдонімом для :const:`BOM_UTF16`, :const:`BOM_LE` для :const:"
"`BOM_UTF16_LE` і :const:`BOM_BE` для :const:`BOM_UTF16_BE`. Інші "
"представляють специфікацію в кодуваннях UTF-8 і UTF-32."

msgid "Codec Base Classes"
msgstr "Базові класи кодеків"

msgid ""
"The :mod:`codecs` module defines a set of base classes which define the "
"interfaces for working with codec objects, and can also be used as the basis "
"for custom codec implementations."
msgstr ""
"Модуль :mod:`codecs` визначає набір базових класів, які визначають "
"інтерфейси для роботи з об’єктами кодеків, а також може бути використаний як "
"основа для користувацьких реалізацій кодеків."

msgid ""
"Each codec has to define four interfaces to make it usable as codec in "
"Python: stateless encoder, stateless decoder, stream reader and stream "
"writer. The stream reader and writers typically reuse the stateless encoder/"
"decoder to implement the file protocols. Codec authors also need to define "
"how the codec will handle encoding and decoding errors."
msgstr ""
"Кожен кодек має визначати чотири інтерфейси, щоб зробити його придатним для "
"використання як кодек у Python: кодер без стану, декодер без стану, читач "
"потоку та запис потоку. Зчитувач і записувач потоків зазвичай повторно "
"використовують кодер/декодер без збереження стану для реалізації протоколів "
"файлів. Автори кодеків також повинні визначити, як кодек оброблятиме помилки "
"кодування та декодування."

msgid "Error Handlers"
msgstr "Обробники помилок"

msgid ""
"To simplify and standardize error handling, codecs may implement different "
"error handling schemes by accepting the *errors* string argument:"
msgstr ""
"Щоб спростити та стандартизувати обробку помилок, кодеки можуть "
"реалізовувати різні схеми обробки помилок, приймаючи рядковий аргумент "
"*errors*:"

msgid ""
"The following error handlers can be used with all Python :ref:`standard-"
"encodings` codecs:"
msgstr ""
"Наступні обробники помилок можна використовувати з усіма кодеками Python :"
"ref:`standard-encodings`:"

msgid "Value"
msgstr "Значення"

msgid "Meaning"
msgstr "Значення"

msgid "``'strict'``"
msgstr "``'строгий''``"

msgid ""
"Raise :exc:`UnicodeError` (or a subclass), this is the default. Implemented "
"in :func:`strict_errors`."
msgstr ""
"Викликати :exc:`UnicodeError` (або підклас), це типово. Реалізовано в :func:"
"`strict_errors`."

msgid "``'ignore'``"
msgstr "``'ігнорувати''``"

msgid ""
"Ignore the malformed data and continue without further notice. Implemented "
"in :func:`ignore_errors`."
msgstr ""
"Ігноруйте неправильні дані та продовжуйте без додаткового повідомлення. "
"Реалізовано в :func:`ignore_errors`."

msgid "``'replace'``"
msgstr "``'замінити'``"

msgid ""
"Replace with a replacement marker. On encoding, use ``?`` (ASCII character). "
"On decoding, use ``�`` (U+FFFD, the official REPLACEMENT CHARACTER). "
"Implemented in :func:`replace_errors`."
msgstr ""
"Замініть маркером заміни. У кодуванні використовуйте ``?`` (символ ASCII). "
"Під час декодування використовуйте ``�`` (U+FFFD, офіційний СИМВОЛ ЗАМІНИ). "
"Реалізовано в :func:`replace_errors`."

msgid "``'backslashreplace'``"
msgstr "``'заміна зворотної косої риски''``"

msgid ""
"Replace with backslashed escape sequences. On encoding, use hexadecimal form "
"of Unicode code point with formats ``\\xhh`` ``\\uxxxx`` ``\\Uxxxxxxxx``. On "
"decoding, use hexadecimal form of byte value with format ``\\xhh``. "
"Implemented in :func:`backslashreplace_errors`."
msgstr ""
"Замінити керуючими послідовностями зі зворотною скісною рискою. Під час "
"кодування використовуйте шістнадцяткову форму коду Unicode із форматами "
"``\\xhh`` ``\\uxxxx`` ``\\Uxxxxxxxx``. Під час декодування використовуйте "
"шістнадцяткову форму значення байта у форматі ``\\xhh``. Реалізовано в :func:"
"`backslashreplace_errors`."

msgid "``'surrogateescape'``"
msgstr "``'сурогатна втеча'``"

msgid ""
"On decoding, replace byte with individual surrogate code ranging from "
"``U+DC80`` to ``U+DCFF``. This code will then be turned back into the same "
"byte when the ``'surrogateescape'`` error handler is used when encoding the "
"data. (See :pep:`383` for more.)"
msgstr ""
"Під час декодування замініть байт окремим сурогатним кодом у діапазоні від "
"``U+DC80`` до ``U+DCFF``. Потім цей код буде перетворено назад у той самий "
"байт, коли під час кодування даних використовується обробник помилок "
"``'surrogateescape'``. (Докладніше див. :pep:`383`.)"

msgid ""
"The following error handlers are only applicable to encoding (within :term:"
"`text encodings <text encoding>`):"
msgstr ""
"Наступні обробники помилок застосовуються лише до кодування (в межах :term:"
"`кодування тексту <text encoding>`):"

msgid "``'xmlcharrefreplace'``"
msgstr "``'xmlcharrefreplace'``"

msgid ""
"Replace with XML/HTML numeric character reference, which is a decimal form "
"of Unicode code point with format ``&#num;`` Implemented in :func:"
"`xmlcharrefreplace_errors`."
msgstr ""
"Замініть посиланням на числові символи XML/HTML, які є десятковою формою "
"кодової точки Unicode із форматом ``&#num;``, реалізованим у :func:"
"`xmlcharrefreplace_errors`."

msgid "``'namereplace'``"
msgstr "``'namereplace'``"

msgid ""
"Replace with ``\\N{...}`` escape sequences, what appears in the braces is "
"the Name property from Unicode Character Database. Implemented in :func:"
"`namereplace_errors`."
msgstr ""
"Замініть керуючу послідовність ``\\N{...}``, що відображається в фігурних "
"дужках — це властивість Name із бази даних символів Unicode. Реалізовано в :"
"func:`namereplace_errors`."

msgid ""
"In addition, the following error handler is specific to the given codecs:"
msgstr "Крім того, наступний обробник помилок є специфічним для даних кодеків:"

msgid "Codecs"
msgstr "Кодеки"

msgid "``'surrogatepass'``"
msgstr "``'сурогатний пропуск''``"

msgid "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"
msgstr "utf-8, utf-16, utf-32, utf-16-be, utf-16-le, utf-32-be, utf-32-le"

msgid ""
"Allow encoding and decoding surrogate code point (``U+D800`` - ``U+DFFF``) "
"as normal code point. Otherwise these codecs treat the presence of surrogate "
"code point in :class:`str` as an error."
msgstr ""
"Дозволити кодування та декодування сурогатної кодової точки (``U+D800`` - "
"``U+DFFF``) як звичайну кодову точку. Інакше ці кодеки розглядають наявність "
"сурогатної кодової точки в :class:`str` як помилку."

msgid "The ``'surrogateescape'`` and ``'surrogatepass'`` error handlers."
msgstr "Обробники помилок ``'surrogateescape'`` і ``'surrogatepass'``."

msgid ""
"The ``'surrogatepass'`` error handler now works with utf-16\\* and utf-32\\* "
"codecs."
msgstr ""
"Обробник помилок ``'surrogatepass'`` тепер працює з кодеками utf-16\\* і "
"utf-32\\*."

msgid "The ``'namereplace'`` error handler."
msgstr "Обробник помилок ``'namereplace``."

msgid ""
"The ``'backslashreplace'`` error handler now works with decoding and "
"translating."
msgstr ""
"Обробник помилок ``'backslashreplace'`` тепер працює з декодуванням і "
"перекладом."

msgid ""
"The set of allowed values can be extended by registering a new named error "
"handler:"
msgstr ""
"Набір дозволених значень можна розширити, зареєструвавши новий іменований "
"обробник помилок:"

msgid ""
"Register the error handling function *error_handler* under the name *name*. "
"The *error_handler* argument will be called during encoding and decoding in "
"case of an error, when *name* is specified as the errors parameter."
msgstr ""
"Зареєструйте функцію обробки помилок *error_handler* під назвою *name*. "
"Аргумент *error_handler* буде викликаний під час кодування та декодування у "
"разі помилки, якщо *name* вказано як параметр errors."

msgid ""
"For encoding, *error_handler* will be called with a :exc:"
"`UnicodeEncodeError` instance, which contains information about the location "
"of the error. The error handler must either raise this or a different "
"exception, or return a tuple with a replacement for the unencodable part of "
"the input and a position where encoding should continue. The replacement may "
"be either :class:`str` or :class:`bytes`. If the replacement is bytes, the "
"encoder will simply copy them into the output buffer. If the replacement is "
"a string, the encoder will encode the replacement. Encoding continues on "
"original input at the specified position. Negative position values will be "
"treated as being relative to the end of the input string. If the resulting "
"position is out of bound an :exc:`IndexError` will be raised."
msgstr ""
"Для кодування *error_handler* буде викликано з екземпляром :exc:"
"`UnicodeEncodeError`, який містить інформацію про розташування помилки. "
"Обробник помилок повинен або викликати це чи інше виключення, або повернути "
"кортеж із заміною некодованої частини вхідних даних і позиції, де кодування "
"повинно продовжуватися. Заміна може бути :class:`str` або :class:`bytes`. "
"Якщо заміною є байти, кодер просто скопіює їх у вихідний буфер. Якщо заміна "
"є рядком, кодер закодує заміну. Кодування продовжується на початковому "
"введенні у вказаній позиції. Від’ємні значення позиції розглядатимуться як "
"такі, що відносяться до кінця вхідного рядка. Якщо результуюча позиція "
"виходить за межі, буде викликано :exc:`IndexError`."

msgid ""
"Decoding and translating works similarly, except :exc:`UnicodeDecodeError` "
"or :exc:`UnicodeTranslateError` will be passed to the handler and that the "
"replacement from the error handler will be put into the output directly."
msgstr ""
"Декодування та переклад працює аналогічно, за винятком того, що :exc:"
"`UnicodeDecodeError` або :exc:`UnicodeTranslateError` буде передано "
"обробнику, а заміна з обробника помилок буде введена безпосередньо у вивід."

msgid ""
"Previously registered error handlers (including the standard error handlers) "
"can be looked up by name:"
msgstr ""
"Раніше зареєстровані обробники помилок (включаючи стандартні обробники "
"помилок) можна шукати за назвою:"

msgid "Return the error handler previously registered under the name *name*."
msgstr ""
"Повернути обробник помилок, попередньо зареєстрований під іменем *name*."

msgid "Raises a :exc:`LookupError` in case the handler cannot be found."
msgstr "Викликає :exc:`LookupError`, якщо обробник не знайдено."

msgid ""
"The following standard error handlers are also made available as module "
"level functions:"
msgstr ""
"Наступні стандартні обробники помилок також доступні як функції рівня модуля:"

msgid "Implements the ``'strict'`` error handling."
msgstr "Реалізує ``'сувору'`` обробку помилок."

msgid "Each encoding or decoding error raises a :exc:`UnicodeError`."
msgstr "Кожна помилка кодування або декодування викликає :exc:`UnicodeError`."

msgid "Implements the ``'ignore'`` error handling."
msgstr "Реалізує обробку помилок ``'ignore''``."

msgid ""
"Malformed data is ignored; encoding or decoding is continued without further "
"notice."
msgstr ""
"Некоректні дані ігноруються; кодування або декодування продовжується без "
"додаткового повідомлення."

msgid "Implements the ``'replace'`` error handling."
msgstr "Реалізує обробку помилок ``'replace''``."

msgid ""
"Substitutes ``?`` (ASCII character) for encoding errors or ``�`` (U+FFFD, "
"the official REPLACEMENT CHARACTER) for decoding errors."
msgstr ""
"Замінює ``?`` (символ ASCII) для помилок кодування або ``�`` (U+FFFD, "
"офіційний СИМВОЛ ЗАМІНИ) для помилок декодування."

msgid "Implements the ``'backslashreplace'`` error handling."
msgstr "Реалізує обробку помилок ``'backslashreplace'``."

msgid ""
"Malformed data is replaced by a backslashed escape sequence. On encoding, "
"use the hexadecimal form of Unicode code point with formats ``\\xhh`` "
"``\\uxxxx`` ``\\Uxxxxxxxx``. On decoding, use the hexadecimal form of byte "
"value with format ``\\xhh``."
msgstr ""
"Неправильно сформовані дані замінюються керуючою послідовністю зі зворотною "
"скісною рискою. Під час кодування використовуйте шістнадцяткову форму коду "
"Unicode із форматами ``\\xhh`` ``\\uxxxx`` ``\\Uxxxxxxxx``. Під час "
"декодування використовуйте шістнадцяткову форму значення байта у форматі "
"``\\xhh``."

msgid "Works with decoding and translating."
msgstr "Працює з декодуванням і перекладом."

msgid ""
"Implements the ``'xmlcharrefreplace'`` error handling (for encoding within :"
"term:`text encoding` only)."
msgstr ""
"Реалізує обробку помилок ``'xmlcharrefreplace'`` (лише для кодування в "
"межах :term:`text encoding`)."

msgid ""
"The unencodable character is replaced by an appropriate XML/HTML numeric "
"character reference, which is a decimal form of Unicode code point with "
"format ``&#num;`` ."
msgstr ""
"Некодований символ замінюється відповідним цифровим посиланням на символ XML/"
"HTML, яке є десятковою формою кодової точки Unicode у форматі ``&#num;``."

msgid ""
"Implements the ``'namereplace'`` error handling (for encoding within :term:"
"`text encoding` only)."
msgstr ""
"Реалізує обробку помилок ``'namereplace'`` (лише для кодування в межах :term:"
"`text encoding`)."

msgid ""
"The unencodable character is replaced by a ``\\N{...}`` escape sequence. The "
"set of characters that appear in the braces is the Name property from "
"Unicode Character Database. For example, the German lowercase letter ``'ß'`` "
"will be converted to byte sequence ``\\N{LATIN SMALL LETTER SHARP S}`` ."
msgstr ""
"Некодований символ замінюється керуючою послідовністю ``\\N{...}``. Набір "
"символів, що з’являються в фігурних дужках, є властивістю Name з бази даних "
"символів Unicode. Наприклад, німецьку малу літеру ``'ß'`` буде перетворено "
"на послідовність байтів ``\\N{LATIN SMALL LETTER SHARP S}`` ."

msgid "Stateless Encoding and Decoding"
msgstr "Кодування та декодування без збереження стану"

msgid ""
"The base :class:`Codec` class defines these methods which also define the "
"function interfaces of the stateless encoder and decoder:"
msgstr ""
"Базовий клас :class:`Codec` визначає ці методи, які також визначають "
"функціональні інтерфейси кодера та декодера без збереження стану:"

msgid ""
"Encodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, :term:`text encoding` converts a string object to a "
"bytes object using a particular character set encoding (e.g., ``cp1252`` or "
"``iso-8859-1``)."
msgstr ""
"Кодує об’єкт *input* і повертає кортеж (вихідний об’єкт, споживана довжина). "
"Наприклад, :term:`text encoding` перетворює рядковий об’єкт на об’єкт bytes, "
"використовуючи певне кодування набору символів (наприклад, ``cp1252`` або "
"``iso-8859-1``)."

msgid ""
"The *errors* argument defines the error handling to apply. It defaults to "
"``'strict'`` handling."
msgstr ""
"Аргумент *errors* визначає застосовувану обробку помилок. За замовчуванням "
"``'сувора''`` обробка."

msgid ""
"The method may not store state in the :class:`Codec` instance. Use :class:"
"`StreamWriter` for codecs which have to keep state in order to make encoding "
"efficient."
msgstr ""
"Метод може не зберігати стан в екземплярі :class:`Codec`. Використовуйте :"
"class:`StreamWriter` для кодеків, які мають зберігати стан, щоб зробити "
"кодування ефективним."

msgid ""
"The encoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr ""
"У цій ситуації кодер повинен мати можливість обробляти вхідні дані нульової "
"довжини та повертати порожній об’єкт типу вихідного об’єкта."

msgid ""
"Decodes the object *input* and returns a tuple (output object, length "
"consumed). For instance, for a :term:`text encoding`, decoding converts a "
"bytes object encoded using a particular character set encoding to a string "
"object."
msgstr ""
"Декодує об’єкт *input* і повертає кортеж (вихідний об’єкт, споживана "
"довжина). Наприклад, для :term:`text encoding` декодування перетворює об’єкт "
"bytes, закодований за допомогою кодування певного набору символів, на "
"рядковий об’єкт."

msgid ""
"For text encodings and bytes-to-bytes codecs, *input* must be a bytes object "
"or one which provides the read-only buffer interface -- for example, buffer "
"objects and memory mapped files."
msgstr ""
"Для текстових кодувань і кодеків від байтів до байтів *input* має бути "
"об’єктом bytes або таким, який забезпечує інтерфейс буфера лише для читання "
"– наприклад, об’єкти буфера та файли, відображені в пам’яті."

msgid ""
"The method may not store state in the :class:`Codec` instance. Use :class:"
"`StreamReader` for codecs which have to keep state in order to make decoding "
"efficient."
msgstr ""
"Метод може не зберігати стан в екземплярі :class:`Codec`. Використовуйте :"
"class:`StreamReader` для кодеків, які мають зберігати стан, щоб зробити "
"декодування ефективним."

msgid ""
"The decoder must be able to handle zero length input and return an empty "
"object of the output object type in this situation."
msgstr ""
"У цій ситуації декодер повинен мати можливість обробляти вхідні дані "
"нульової довжини та повертати порожній об’єкт типу вихідного об’єкта."

msgid "Incremental Encoding and Decoding"
msgstr "Інкрементне кодування та декодування"

msgid ""
"The :class:`IncrementalEncoder` and :class:`IncrementalDecoder` classes "
"provide the basic interface for incremental encoding and decoding. Encoding/"
"decoding the input isn't done with one call to the stateless encoder/decoder "
"function, but with multiple calls to the :meth:`~IncrementalEncoder.encode`/:"
"meth:`~IncrementalDecoder.decode` method of the incremental encoder/decoder. "
"The incremental encoder/decoder keeps track of the encoding/decoding process "
"during method calls."
msgstr ""
"Класи :class:`IncrementalEncoder` і :class:`IncrementalDecoder` забезпечують "
"базовий інтерфейс для інкрементного кодування та декодування. Кодування/"
"декодування вхідних даних виконується не одним викликом функції кодувальника/"
"декодера без збереження стану, а кількома викликами методу :meth:"
"`~IncrementalEncoder.encode`/:meth:`~IncrementalDecoder.decode` "
"інкрементального кодувальника /декодер. Інкрементний кодер/декодер відстежує "
"процес кодування/декодування під час викликів методів."

msgid ""
"The joined output of calls to the :meth:`~IncrementalEncoder.encode`/:meth:"
"`~IncrementalDecoder.decode` method is the same as if all the single inputs "
"were joined into one, and this input was encoded/decoded with the stateless "
"encoder/decoder."
msgstr ""
"Об’єднаний вихід викликів методу :meth:`~IncrementalEncoder.encode`/:meth:"
"`~IncrementalDecoder.decode` такий самий, як якби всі окремі входи були "
"об’єднані в один, і цей вхід було закодовано/декодовано за допомогою кодер/"
"декодер без стану."

msgid "IncrementalEncoder Objects"
msgstr "Об’єкти IncrementalEncoder"

msgid ""
"The :class:`IncrementalEncoder` class is used for encoding an input in "
"multiple steps. It defines the following methods which every incremental "
"encoder must define in order to be compatible with the Python codec registry."
msgstr ""
"Клас :class:`IncrementalEncoder` використовується для кодування вхідних "
"даних у кілька кроків. Він визначає наступні методи, які повинен визначити "
"кожен інкрементальний кодер, щоб бути сумісним із реєстром кодеків Python."

msgid "Constructor for an :class:`IncrementalEncoder` instance."
msgstr "Конструктор для екземпляра :class:`IncrementalEncoder`."

msgid ""
"All incremental encoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are "
"used by the Python codec registry."
msgstr ""
"Усі інкрементні кодери повинні забезпечувати цей інтерфейс конструктора. "
"Вони можуть вільно додавати додаткові аргументи ключових слів, але лише ті, "
"що визначені тут, використовуються реєстром кодеків Python."

msgid ""
"The :class:`IncrementalEncoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
":class:`IncrementalEncoder` може реалізовувати різні схеми обробки помилок, "
"надаючи аргумент ключового слова *errors*. Перегляньте :ref:`error-handlers` "
"можливі значення."

msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:"
"`IncrementalEncoder` object."
msgstr ""
"Аргумент *errors* буде призначено однойменному атрибуту. Призначення цьому "
"атрибуту дає змогу перемикатися між різними стратегіями обробки помилок "
"протягом життя об’єкта :class:`IncrementalEncoder`."

msgid ""
"Encodes *object* (taking the current state of the encoder into account) and "
"returns the resulting encoded object. If this is the last call to :meth:"
"`encode` *final* must be true (the default is false)."
msgstr ""
"Кодує *об’єкт* (з урахуванням поточного стану кодувальника) і повертає "
"отриманий закодований об’єкт. Якщо це останній виклик :meth:`encode`, "
"*final* має бути true (за умовчанням — false)."

msgid ""
"Reset the encoder to the initial state. The output is discarded: call ``."
"encode(object, final=True)``, passing an empty byte or text string if "
"necessary, to reset the encoder and to get the output."
msgstr ""
"Скиньте кодер до початкового стану. Вихідні дані відхиляються: викличте ``."
"encode(object, final=True)``, передаючи порожній байт або текстовий рядок, "
"якщо необхідно, щоб скинути кодер і отримати вихідні дані."

msgid ""
"Return the current state of the encoder which must be an integer. The "
"implementation should make sure that ``0`` is the most common state. (States "
"that are more complicated than integers can be converted into an integer by "
"marshaling/pickling the state and encoding the bytes of the resulting string "
"into an integer.)"
msgstr ""
"Повертає поточний стан кодувальника, який має бути цілим числом. Реалізація "
"має гарантувати, що ``0`` є найпоширенішим станом. (Стани, які є "
"складнішими, ніж цілі числа, можна перетворити на ціле число шляхом "
"маршалінгу/вибору стану та кодування байтів результуючого рядка в ціле "
"число.)"

msgid ""
"Set the state of the encoder to *state*. *state* must be an encoder state "
"returned by :meth:`getstate`."
msgstr ""
"Встановіть стан кодера на *state*. *state* має бути станом кодувальника, "
"який повертає :meth:`getstate`."

msgid "IncrementalDecoder Objects"
msgstr "Об’єкти IncrementalDecoder"

msgid ""
"The :class:`IncrementalDecoder` class is used for decoding an input in "
"multiple steps. It defines the following methods which every incremental "
"decoder must define in order to be compatible with the Python codec registry."
msgstr ""
"Клас :class:`IncrementalDecoder` використовується для декодування вхідних "
"даних у кілька кроків. Він визначає наступні методи, які повинен визначити "
"кожен інкрементний декодер, щоб бути сумісним із реєстром кодеків Python."

msgid "Constructor for an :class:`IncrementalDecoder` instance."
msgstr "Конструктор для екземпляра :class:`IncrementalDecoder`."

msgid ""
"All incremental decoders must provide this constructor interface. They are "
"free to add additional keyword arguments, but only the ones defined here are "
"used by the Python codec registry."
msgstr ""
"Усі інкрементні декодери повинні забезпечувати цей інтерфейс конструктора. "
"Вони можуть вільно додавати додаткові аргументи ключових слів, але лише ті, "
"що визначені тут, використовуються реєстром кодеків Python."

msgid ""
"The :class:`IncrementalDecoder` may implement different error handling "
"schemes by providing the *errors* keyword argument. See :ref:`error-"
"handlers` for possible values."
msgstr ""
":class:`IncrementalDecoder` може реалізовувати різні схеми обробки помилок, "
"надаючи аргумент ключового слова *errors*. Перегляньте :ref:`error-handlers` "
"можливі значення."

msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:"
"`IncrementalDecoder` object."
msgstr ""
"Аргумент *errors* буде призначено однойменному атрибуту. Призначення цьому "
"атрибуту дає змогу перемикатися між різними стратегіями обробки помилок "
"протягом життя об’єкта :class:`IncrementalDecoder`."

msgid ""
"Decodes *object* (taking the current state of the decoder into account) and "
"returns the resulting decoded object. If this is the last call to :meth:"
"`decode` *final* must be true (the default is false). If *final* is true the "
"decoder must decode the input completely and must flush all buffers. If this "
"isn't possible (e.g. because of incomplete byte sequences at the end of the "
"input) it must initiate error handling just like in the stateless case "
"(which might raise an exception)."
msgstr ""
"Декодує *об’єкт* (з урахуванням поточного стану декодера) і повертає "
"отриманий декодований об’єкт. Якщо це останній виклик :meth:`decode`, "
"*final* має бути true (за умовчанням — false). Якщо *final* має значення "
"true, декодер повинен повністю декодувати вхідні дані та скинути всі буфери. "
"Якщо це неможливо (наприклад, через неповну послідовність байтів у кінці "
"введення), він повинен ініціювати обробку помилок, як у випадку без стану "
"(що може спричинити виняток)."

msgid "Reset the decoder to the initial state."
msgstr "Скиньте декодер до початкового стану."

msgid ""
"Return the current state of the decoder. This must be a tuple with two "
"items, the first must be the buffer containing the still undecoded input. "
"The second must be an integer and can be additional state info. (The "
"implementation should make sure that ``0`` is the most common additional "
"state info.) If this additional state info is ``0`` it must be possible to "
"set the decoder to the state which has no input buffered and ``0`` as the "
"additional state info, so that feeding the previously buffered input to the "
"decoder returns it to the previous state without producing any output. "
"(Additional state info that is more complicated than integers can be "
"converted into an integer by marshaling/pickling the info and encoding the "
"bytes of the resulting string into an integer.)"
msgstr ""
"Повернути поточний стан декодера. Це має бути кортеж із двома елементами, "
"перший має бути буфером, що містить ще недекодований вхід. Друге має бути "
"цілим числом і може бути додатковою інформацією про стан. (Реалізація має "
"переконатися, що ``0`` є найпоширенішою додатковою інформацією про стан.) "
"Якщо ця додаткова інформація про стан ``0``, має бути можливим встановити "
"декодер у стан, який не має буферизації вхідних даних і ``0`` як додаткову "
"інформацію про стан, так що подача попередньо буферизованого вхідного "
"сигналу в декодер повертає його до попереднього стану без виведення. "
"(Додаткову інформацію про стан, яка є складнішою, ніж цілі числа, можна "
"перетворити на ціле число шляхом маршалінгу/вибору інформації та кодування "
"байтів отриманого рядка в ціле число.)"

msgid ""
"Set the state of the decoder to *state*. *state* must be a decoder state "
"returned by :meth:`getstate`."
msgstr ""
"Встановіть стан декодера на *state*. *state* має бути станом декодера, який "
"повертає :meth:`getstate`."

msgid "Stream Encoding and Decoding"
msgstr "Кодування та декодування потоку"

msgid ""
"The :class:`StreamWriter` and :class:`StreamReader` classes provide generic "
"working interfaces which can be used to implement new encoding submodules "
"very easily. See :mod:`encodings.utf_8` for an example of how this is done."
msgstr ""
"Класи :class:`StreamWriter` і :class:`StreamReader` забезпечують загальні "
"робочі інтерфейси, які можна використовувати для дуже легкої реалізації "
"нових субмодулів кодування. Перегляньте :mod:`encodings.utf_8` для прикладу "
"того, як це робиться."

msgid "StreamWriter Objects"
msgstr "Об’єкти StreamWriter"

msgid ""
"The :class:`StreamWriter` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream writer must define in order to be "
"compatible with the Python codec registry."
msgstr ""
"Клас :class:`StreamWriter` є підкласом :class:`Codec` і визначає наступні "
"методи, які повинен визначити кожен записувач потоків, щоб бути сумісним із "
"реєстром кодеків Python."

msgid "Constructor for a :class:`StreamWriter` instance."
msgstr "Конструктор для екземпляра :class:`StreamWriter`."

msgid ""
"All stream writers must provide this constructor interface. They are free to "
"add additional keyword arguments, but only the ones defined here are used by "
"the Python codec registry."
msgstr ""
"Цей інтерфейс конструктора мають надавати всі автори потоків. Вони можуть "
"вільно додавати додаткові аргументи ключових слів, але лише ті, що визначені "
"тут, використовуються реєстром кодеків Python."

msgid ""
"The *stream* argument must be a file-like object open for writing text or "
"binary data, as appropriate for the specific codec."
msgstr ""
"Аргумент *потік* має бути файлоподібним об’єктом, відкритим для запису "
"тексту або двійкових даних, відповідно до конкретного кодека."

msgid ""
"The :class:`StreamWriter` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
":class:`StreamWriter` може реалізовувати різні схеми обробки помилок, "
"надаючи аргумент ключового слова *errors*. Перегляньте :ref:`error-handlers` "
"для стандартних обробників помилок, які може підтримувати основний потоковий "
"кодек."

msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamWriter` "
"object."
msgstr ""
"Аргумент *errors* буде призначено однойменному атрибуту. Призначення цьому "
"атрибуту дає змогу перемикатися між різними стратегіями обробки помилок "
"протягом життя об’єкта :class:`StreamWriter`."

msgid "Writes the object's contents encoded to the stream."
msgstr "Записує закодований вміст об’єкта в потік."

msgid ""
"Writes the concatenated iterable of strings to the stream (possibly by "
"reusing the :meth:`write` method). Infinite or very large iterables are not "
"supported. The standard bytes-to-bytes codecs do not support this method."
msgstr ""
"Записує конкатенований ітерований рядок у потік (можливо, повторно "
"використовуючи метод :meth:`write`). Нескінченні або дуже великі ітерації не "
"підтримуються. Стандартні кодеки від байтів до байтів не підтримують цей "
"метод."

msgid "Resets the codec buffers used for keeping internal state."
msgstr ""
"Скидає буфери кодеків, які використовуються для збереження внутрішнього "
"стану."

msgid ""
"Calling this method should ensure that the data on the output is put into a "
"clean state that allows appending of new fresh data without having to rescan "
"the whole stream to recover state."
msgstr ""
"Виклик цього методу повинен гарантувати, що дані на виході переведені в "
"чистий стан, який дозволяє додавати нові свіжі дані без необхідності "
"повторного сканування всього потоку для відновлення стану."

msgid ""
"In addition to the above methods, the :class:`StreamWriter` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr ""
"Окрім вищезазначених методів, :class:`StreamWriter` також має успадкувати "
"всі інші методи та атрибути базового потоку."

msgid "StreamReader Objects"
msgstr "Об’єкти StreamReader"

msgid ""
"The :class:`StreamReader` class is a subclass of :class:`Codec` and defines "
"the following methods which every stream reader must define in order to be "
"compatible with the Python codec registry."
msgstr ""
"Клас :class:`StreamReader` є підкласом :class:`Codec` і визначає наступні "
"методи, які повинен визначити кожен зчитувач потоку, щоб бути сумісним із "
"реєстром кодеків Python."

msgid "Constructor for a :class:`StreamReader` instance."
msgstr "Конструктор для екземпляра :class:`StreamReader`."

msgid ""
"All stream readers must provide this constructor interface. They are free to "
"add additional keyword arguments, but only the ones defined here are used by "
"the Python codec registry."
msgstr ""
"Усі зчитувачі потоків повинні надавати цей інтерфейс конструктора. Вони "
"можуть вільно додавати додаткові аргументи ключових слів, але лише ті, що "
"визначені тут, використовуються реєстром кодеків Python."

msgid ""
"The *stream* argument must be a file-like object open for reading text or "
"binary data, as appropriate for the specific codec."
msgstr ""
"Аргумент *потік* має бути файлоподібним об’єктом, відкритим для читання "
"тексту або двійкових даних, відповідно до конкретного кодека."

msgid ""
"The :class:`StreamReader` may implement different error handling schemes by "
"providing the *errors* keyword argument. See :ref:`error-handlers` for the "
"standard error handlers the underlying stream codec may support."
msgstr ""
":class:`StreamReader` може реалізовувати різні схеми обробки помилок, "
"надаючи аргумент ключового слова *errors*. Перегляньте :ref:`error-handlers` "
"для стандартних обробників помилок, які може підтримувати основний потоковий "
"кодек."

msgid ""
"The *errors* argument will be assigned to an attribute of the same name. "
"Assigning to this attribute makes it possible to switch between different "
"error handling strategies during the lifetime of the :class:`StreamReader` "
"object."
msgstr ""
"Аргумент *errors* буде призначено однойменному атрибуту. Призначення цьому "
"атрибуту дає змогу перемикатися між різними стратегіями обробки помилок "
"протягом життя об’єкта :class:`StreamReader`."

msgid ""
"The set of allowed values for the *errors* argument can be extended with :"
"func:`register_error`."
msgstr ""
"Набір дозволених значень для аргументу *errors* можна розширити за "
"допомогою :func:`register_error`."

msgid "Decodes data from the stream and returns the resulting object."
msgstr "Декодує дані з потоку та повертає отриманий об’єкт."

msgid ""
"The *chars* argument indicates the number of decoded code points or bytes to "
"return. The :func:`read` method will never return more data than requested, "
"but it might return less, if there is not enough available."
msgstr ""
"Аргумент *chars* вказує кількість декодованих кодових точок або байтів, які "
"потрібно повернути. Метод :func:`read` ніколи не поверне більше даних, ніж "
"вимагається, але може повернути менше, якщо їх буде недостатньо."

msgid ""
"The *size* argument indicates the approximate maximum number of encoded "
"bytes or code points to read for decoding. The decoder can modify this "
"setting as appropriate. The default value -1 indicates to read and decode as "
"much as possible. This parameter is intended to prevent having to decode "
"huge files in one step."
msgstr ""
"Аргумент *size* вказує на приблизну максимальну кількість закодованих байтів "
"або кодових точок для читання для декодування. Декодер може змінювати цей "
"параметр за потреби. Значення за замовчуванням -1 вказує на читання та "
"декодування якомога більшої кількості. Цей параметр призначений для "
"запобігання необхідності декодувати великі файли за один крок."

msgid ""
"The *firstline* flag indicates that it would be sufficient to only return "
"the first line, if there are decoding errors on later lines."
msgstr ""
"Прапорець *firstline* вказує на те, що було б достатньо повернути лише "
"перший рядок, якщо в наступних рядках є помилки декодування."

msgid ""
"The method should use a greedy read strategy meaning that it should read as "
"much data as is allowed within the definition of the encoding and the given "
"size, e.g.  if optional encoding endings or state markers are available on "
"the stream, these should be read too."
msgstr ""
"Метод повинен використовувати стратегію жадібного читання, тобто він повинен "
"зчитувати стільки даних, скільки дозволено у визначенні кодування та "
"заданого розміру, наприклад. якщо в потоці доступні додаткові закінчення "
"кодування або маркери стану, їх також слід прочитати."

msgid "Read one line from the input stream and return the decoded data."
msgstr "Прочитати один рядок із вхідного потоку та повернути декодовані дані."

msgid ""
"*size*, if given, is passed as size argument to the stream's :meth:`read` "
"method."
msgstr ""
"*size*, якщо задано, передається як аргумент розміру в метод :meth:`read` "
"потоку."

msgid ""
"If *keepends* is false line-endings will be stripped from the lines returned."
msgstr ""
"Якщо *keepends* має значення false, закінчення рядків буде видалено з "
"повернутих рядків."

msgid ""
"Read all lines available on the input stream and return them as a list of "
"lines."
msgstr ""
"Прочитати всі рядки, доступні у вхідному потоці, і повернути їх як список "
"рядків."

msgid ""
"Line-endings are implemented using the codec's :meth:`decode` method and are "
"included in the list entries if *keepends* is true."
msgstr ""
"Закінчення рядків реалізуються за допомогою методу кодека :meth:`decode` і "
"включаються до записів списку, якщо *keepends* має значення true."

msgid ""
"*sizehint*, if given, is passed as the *size* argument to the stream's :meth:"
"`read` method."
msgstr ""
"*sizehint*, якщо його задано, передається як аргумент *size* у метод потоку :"
"meth:`read`."

msgid ""
"Note that no stream repositioning should take place. This method is "
"primarily intended to be able to recover from decoding errors."
msgstr ""
"Зауважте, що переміщення потоку не повинно відбуватися. Цей метод насамперед "
"призначений для відновлення після помилок декодування."

msgid ""
"In addition to the above methods, the :class:`StreamReader` must also "
"inherit all other methods and attributes from the underlying stream."
msgstr ""
"Окрім вищезазначених методів, :class:`StreamReader` також має успадкувати "
"всі інші методи та атрибути базового потоку."

msgid "StreamReaderWriter Objects"
msgstr "Об’єкти StreamReaderWriter"

msgid ""
"The :class:`StreamReaderWriter` is a convenience class that allows wrapping "
"streams which work in both read and write modes."
msgstr ""
":class:`StreamReaderWriter` — це зручний клас, який дозволяє обгортати "
"потоки, які працюють як у режимі читання, так і в режимі запису."

msgid ""
"The design is such that one can use the factory functions returned by the :"
"func:`lookup` function to construct the instance."
msgstr ""
"Конструкція така, що можна використовувати фабричні функції, які повертає "
"функція :func:`lookup` для створення екземпляра."

msgid ""
"Creates a :class:`StreamReaderWriter` instance. *stream* must be a file-like "
"object. *Reader* and *Writer* must be factory functions or classes providing "
"the :class:`StreamReader` and :class:`StreamWriter` interface resp. Error "
"handling is done in the same way as defined for the stream readers and "
"writers."
msgstr ""
"Створює екземпляр :class:`StreamReaderWriter`. *потік* має бути "
"файлоподібним об’єктом. *Reader* і *Writer* повинні бути фабричними "
"функціями або класами, що забезпечують інтерфейс :class:`StreamReader` і :"
"class:`StreamWriter` відповідно. Обробка помилок виконується так само, як "
"визначено для читачів і записів потоку."

msgid ""
":class:`StreamReaderWriter` instances define the combined interfaces of :"
"class:`StreamReader` and :class:`StreamWriter` classes. They inherit all "
"other methods and attributes from the underlying stream."
msgstr ""
"Екземпляри :class:`StreamReaderWriter` визначають комбіновані інтерфейси "
"класів :class:`StreamReader` і :class:`StreamWriter`. Вони успадковують усі "
"інші методи та атрибути від основного потоку."

msgid "StreamRecoder Objects"
msgstr "Об’єкти StreamRecoder"

msgid ""
"The :class:`StreamRecoder` translates data from one encoding to another, "
"which is sometimes useful when dealing with different encoding environments."
msgstr ""
":class:`StreamRecoder` переводить дані з одного кодування в інше, що іноді "
"корисно, коли ви маєте справу з різними середовищами кодування."

msgid ""
"Creates a :class:`StreamRecoder` instance which implements a two-way "
"conversion: *encode* and *decode* work on the frontend — the data visible to "
"code calling :meth:`read` and :meth:`write`, while *Reader* and *Writer* "
"work on the backend — the data in *stream*."
msgstr ""
"Створює екземпляр :class:`StreamRecoder`, який реалізує двостороннє "
"перетворення: *encode* і *decode* працюють на інтерфейсі — дані, видимі для "
"коду, що викликає :meth:`read` і :meth:`write`, а *Reader* і *Writer* "
"працюють на сервері — дані в *потоці*."

msgid ""
"You can use these objects to do transparent transcodings, e.g., from Latin-1 "
"to UTF-8 and back."
msgstr ""
"Ви можете використовувати ці об’єкти для прозорого перекодування, наприклад, "
"з Latin-1 на UTF-8 і назад."

msgid "The *stream* argument must be a file-like object."
msgstr "Аргумент *потік* має бути файлоподібним об’єктом."

msgid ""
"The *encode* and *decode* arguments must adhere to the :class:`Codec` "
"interface. *Reader* and *Writer* must be factory functions or classes "
"providing objects of the :class:`StreamReader` and :class:`StreamWriter` "
"interface respectively."
msgstr ""
"Аргументи *encode* і *decode* мають відповідати інтерфейсу :class:`Codec`. "
"*Reader* і *Writer* повинні бути фабричними функціями або класами, що "
"забезпечують об’єкти інтерфейсу :class:`StreamReader` і :class:"
"`StreamWriter` відповідно."

msgid ""
"Error handling is done in the same way as defined for the stream readers and "
"writers."
msgstr ""
"Обробка помилок виконується так само, як визначено для читачів і записів "
"потоку."

msgid ""
":class:`StreamRecoder` instances define the combined interfaces of :class:"
"`StreamReader` and :class:`StreamWriter` classes. They inherit all other "
"methods and attributes from the underlying stream."
msgstr ""
"Екземпляри :class:`StreamRecoder` визначають комбіновані інтерфейси класів :"
"class:`StreamReader` і :class:`StreamWriter`. Вони успадковують усі інші "
"методи та атрибути основного потоку."

msgid "Encodings and Unicode"
msgstr "Кодування та Unicode"

msgid ""
"Strings are stored internally as sequences of code points in range "
"``U+0000``--``U+10FFFF``. (See :pep:`393` for more details about the "
"implementation.) Once a string object is used outside of CPU and memory, "
"endianness and how these arrays are stored as bytes become an issue. As with "
"other codecs, serialising a string into a sequence of bytes is known as "
"*encoding*, and recreating the string from the sequence of bytes is known as "
"*decoding*. There are a variety of different text serialisation codecs, "
"which are collectivity referred to as :term:`text encodings <text encoding>`."
msgstr ""
"Рядки зберігаються внутрішньо як послідовності кодових точок у діапазоні "
"``U+0000``--``U+10FFFF``. (Див. :pep:`393` для отримання додаткової "
"інформації про реалізацію.) Коли рядковий об’єкт використовується поза "
"центральним процесором і пам’яттю, стає проблемою порядок байтів і те, як ці "
"масиви зберігаються як байти. Як і в інших кодеках, серіалізація рядка в "
"послідовність байтів відома як *кодування*, а відтворення рядка з "
"послідовності байтів відоме як *декодування*. Існує безліч різних кодеків "
"серіалізації тексту, які в сукупності називаються :term:`текстовими "
"кодуваннями <text encoding>`."

msgid ""
"The simplest text encoding (called ``'latin-1'`` or ``'iso-8859-1'``) maps "
"the code points 0--255 to the bytes ``0x0``--``0xff``, which means that a "
"string object that contains code points above ``U+00FF`` can't be encoded "
"with this codec. Doing so will raise a :exc:`UnicodeEncodeError` that looks "
"like the following (although the details of the error message may differ): "
"``UnicodeEncodeError: 'latin-1' codec can't encode character '\\u1234' in "
"position 3: ordinal not in range(256)``."
msgstr ""
"Найпростіше кодування тексту (називається ``'latin-1'`` або "
"``'iso-8859-1'``) відображає кодові точки 0--255 на байти ``0x0``--``0xff``, "
"що означає, що рядковий об’єкт, який містить кодові точки вище ``U+00FF``, "
"не може бути закодований цим кодеком. Це призведе до появи :exc:"
"`UnicodeEncodeError`, яка виглядає так (хоча деталі повідомлення про помилку "
"можуть відрізнятися): ``UnicodeEncodeError: кодек 'latin-1' не може "
"закодувати символ '\\u1234' у позиції 3 : порядковий номер не в діапазоні "
"(256)``."

msgid ""
"There's another group of encodings (the so called charmap encodings) that "
"choose a different subset of all Unicode code points and how these code "
"points are mapped to the bytes ``0x0``--``0xff``. To see how this is done "
"simply open e.g. :file:`encodings/cp1252.py` (which is an encoding that is "
"used primarily on Windows). There's a string constant with 256 characters "
"that shows you which character is mapped to which byte value."
msgstr ""
"Існує ще одна група кодувань (так звані кодування charmap), які вибирають "
"іншу підмножину всіх кодових точок Unicode і те, як ці кодові точки "
"відображаються на байти ``0x0``--``0xff``. Щоб побачити, як це робиться, "
"просто відкрийте, наприклад. :file:`encodings/cp1252.py` (це кодування, яке "
"використовується в основному в Windows). Існує рядкова константа з 256 "
"символами, яка показує, який символ зіставляється з яким значенням байта."

msgid ""
"All of these encodings can only encode 256 of the 1114112 code points "
"defined in Unicode. A simple and straightforward way that can store each "
"Unicode code point, is to store each code point as four consecutive bytes. "
"There are two possibilities: store the bytes in big endian or in little "
"endian order. These two encodings are called ``UTF-32-BE`` and ``UTF-32-LE`` "
"respectively. Their disadvantage is that if e.g. you use ``UTF-32-BE`` on a "
"little endian machine you will always have to swap bytes on encoding and "
"decoding. ``UTF-32`` avoids this problem: bytes will always be in natural "
"endianness. When these bytes are read by a CPU with a different endianness, "
"then bytes have to be swapped though. To be able to detect the endianness of "
"a ``UTF-16`` or ``UTF-32`` byte sequence, there's the so called BOM (\"Byte "
"Order Mark\"). This is the Unicode character ``U+FEFF``. This character can "
"be prepended to every ``UTF-16`` or ``UTF-32`` byte sequence. The byte "
"swapped version of this character (``0xFFFE``) is an illegal character that "
"may not appear in a Unicode text. So when the first character in a "
"``UTF-16`` or ``UTF-32`` byte sequence appears to be a ``U+FFFE`` the bytes "
"have to be swapped on decoding. Unfortunately the character ``U+FEFF`` had a "
"second purpose as a ``ZERO WIDTH NO-BREAK SPACE``: a character that has no "
"width and doesn't allow a word to be split. It can e.g. be used to give "
"hints to a ligature algorithm. With Unicode 4.0 using ``U+FEFF`` as a ``ZERO "
"WIDTH NO-BREAK SPACE`` has been deprecated (with ``U+2060`` (``WORD "
"JOINER``) assuming this role). Nevertheless Unicode software still must be "
"able to handle ``U+FEFF`` in both roles: as a BOM it's a device to determine "
"the storage layout of the encoded bytes, and vanishes once the byte sequence "
"has been decoded into a string; as a ``ZERO WIDTH NO-BREAK SPACE`` it's a "
"normal character that will be decoded like any other."
msgstr ""
"Усі ці кодування можуть кодувати лише 256 із 1114112 кодових точок, "
"визначених у Unicode. Простий і зрозумілий спосіб збереження кожної кодової "
"точки Unicode полягає в тому, щоб зберегти кожну кодову точку у вигляді "
"чотирьох послідовних байтів. Є дві можливості: зберігати байти в порядку "
"старшого або малого порядку. Ці два кодування називаються ``UTF-32-BE`` і "
"``UTF-32-LE`` відповідно. Їх недолік полягає в тому, що якщо напр. якщо ви "
"використовуєте ``UTF-32-BE`` на машині з порядковим порядком байтів, вам "
"завжди доведеться міняти місцями байти під час кодування та декодування. "
"``UTF-32`` уникає цієї проблеми: байти завжди будуть у природному порядку "
"байтів. Коли ці байти зчитуються процесором з іншим порядком байтів, тоді "
"байти потрібно поміняти місцями. Щоб мати можливість виявити порядок байтів "
"послідовності байтів ``UTF-16`` або ``UTF-32``, існує так звана BOM "
"(\"Позначка порядку байтів\"). Це символ Unicode ``U+FEFF``. Цей символ "
"можна додавати до кожної послідовності байтів ``UTF-16`` або ``UTF-32``. "
"Версія цього символу з заміною байтів (``0xFFFE``) є неприпустимим символом, "
"який може не з’являтися в тексті Unicode. Отже, коли перший символ у "
"послідовності байтів ``UTF-16`` або ``UTF-32`` виглядає як ``U+FFFE``, байти "
"потрібно поміняти місцями під час декодування. На жаль, символ ``U+FEFF`` "
"мав другу мету як ``НУЛЬОВА ШИРИНА БЕЗ РОЗБИВУ``: символ, який не має ширини "
"і не дозволяє розділити слово. Це може напр. використовувати для надання "
"підказок алгоритму лігатури. З Юнікодом 4.0 використання ``U+FEFF`` як "
"``НУЛЬОВА ШИРИНА НЕРОЗБИВНОГО ПРОБІЛУ`` застаріло (з ``U+2060`` (``WORD "
"JOINER``) виконує цю роль). Незважаючи на це, програмне забезпечення Unicode "
"все ще має бути в змозі обробляти ``U+FEFF`` в обох ролях: як BOM, це "
"пристрій для визначення макета зберігання закодованих байтів і зникає, коли "
"послідовність байтів була декодована в рядок; як ``НУЛЬОВА ШИРИНА БЕЗ "
"РОЗБИВУ`` це звичайний символ, який буде декодовано, як і будь-який інший."

msgid ""
"There's another encoding that is able to encode the full range of Unicode "
"characters: UTF-8. UTF-8 is an 8-bit encoding, which means there are no "
"issues with byte order in UTF-8. Each byte in a UTF-8 byte sequence consists "
"of two parts: marker bits (the most significant bits) and payload bits. The "
"marker bits are a sequence of zero to four ``1`` bits followed by a ``0`` "
"bit. Unicode characters are encoded like this (with x being payload bits, "
"which when concatenated give the Unicode character):"
msgstr ""
"Є інше кодування, яке може кодувати повний діапазон символів Unicode: UTF-8. "
"UTF-8 — це 8-бітне кодування, що означає, що в UTF-8 немає проблем із "
"порядком байтів. Кожен байт у послідовності байтів UTF-8 складається з двох "
"частин: бітів маркера (старших бітів) і бітів корисного навантаження. Біти "
"маркера являють собою послідовність із нуля до чотирьох бітів ``1``, за "
"якими йде ``0`` біт. Символи Unicode кодуються таким чином (де x є бітами "
"корисного навантаження, які при з’єднанні дають символ Unicode):"

msgid "Range"
msgstr "Діапазон"

msgid "Encoding"
msgstr "Кодування"

msgid "``U-00000000`` ... ``U-0000007F``"
msgstr "``U-00000000`` ... ``U-0000007F``"

msgid "0xxxxxxx"
msgstr "0xxxxxxx"

msgid "``U-00000080`` ... ``U-000007FF``"
msgstr "``U-00000080`` ... ``U-000007FF``"

msgid "110xxxxx 10xxxxxx"
msgstr "110xxxxx 10xxxxxx"

msgid "``U-00000800`` ... ``U-0000FFFF``"
msgstr "``U-00000800`` ... ``U-0000FFFF``"

msgid "1110xxxx 10xxxxxx 10xxxxxx"
msgstr "1110xxxx 10xxxxxx 10xxxxxx"

msgid "``U-00010000`` ... ``U-0010FFFF``"
msgstr "``U-00010000`` ... ``U-0010FFFF``"

msgid "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"
msgstr "11110xxx 10xxxxxx 10xxxxxx 10xxxxxx"

msgid ""
"The least significant bit of the Unicode character is the rightmost x bit."
msgstr "Наймолодшим бітом символу Юнікод є крайній правий біт x."

msgid ""
"As UTF-8 is an 8-bit encoding no BOM is required and any ``U+FEFF`` "
"character in the decoded string (even if it's the first character) is "
"treated as a ``ZERO WIDTH NO-BREAK SPACE``."
msgstr ""
"Оскільки UTF-8 є 8-бітним кодуванням, специфікація матеріалів не потрібна, і "
"будь-який символ ``U+FEFF`` у декодованому рядку (навіть якщо це перший "
"символ) розглядається як ``НУЛЬОВА ШИРИНА БЕЗ РОЗБИВУ`` ."

msgid ""
"Without external information it's impossible to reliably determine which "
"encoding was used for encoding a string. Each charmap encoding can decode "
"any random byte sequence. However that's not possible with UTF-8, as UTF-8 "
"byte sequences have a structure that doesn't allow arbitrary byte sequences. "
"To increase the reliability with which a UTF-8 encoding can be detected, "
"Microsoft invented a variant of UTF-8 (that Python calls ``\"utf-8-sig\"``) "
"for its Notepad program: Before any of the Unicode characters is written to "
"the file, a UTF-8 encoded BOM (which looks like this as a byte sequence: "
"``0xef``, ``0xbb``, ``0xbf``) is written. As it's rather improbable that any "
"charmap encoded file starts with these byte values (which would e.g. map to"
msgstr ""
"Без зовнішньої інформації неможливо достовірно визначити, яке кодування було "
"використано для кодування рядка. Кожне кодування charmap може декодувати "
"будь-яку випадкову послідовність байтів. Однак це неможливо з UTF-8, "
"оскільки послідовності байтів UTF-8 мають структуру, яка не допускає "
"довільних послідовностей байтів. Щоб підвищити надійність виявлення "
"кодування UTF-8, Microsoft винайшла варіант UTF-8 (який Python називає "
"``\"utf-8-sig\"``) для своєї програми Notepad: перед будь-яким із символів "
"Unicode записується у файл, записується BOM у кодуванні UTF-8 (який виглядає "
"так як послідовність байтів: ``0xef``, ``0xbb``, ``0xbf``). Оскільки "
"малоймовірно, щоб будь-який файл, закодований charmap, починався з цих "
"значень байтів (що, наприклад, відображатиметься на"

msgid "LATIN SMALL LETTER I WITH DIAERESIS"
msgstr "МАЛА ЛАТИНСЬКА БУКВА I З ДІАРЕЗИСОМ"

msgid "RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK"
msgstr "ПОДВІЙНІ КУТНІ ЛАПКИ, Спрямовані вправо"

msgid "INVERTED QUESTION MARK"
msgstr "ПЕРЕВЕРНУТИЙ ЗНАК ПИТАННЯ"

msgid ""
"in iso-8859-1), this increases the probability that a ``utf-8-sig`` encoding "
"can be correctly guessed from the byte sequence. So here the BOM is not used "
"to be able to determine the byte order used for generating the byte "
"sequence, but as a signature that helps in guessing the encoding. On "
"encoding the utf-8-sig codec will write ``0xef``, ``0xbb``, ``0xbf`` as the "
"first three bytes to the file. On decoding ``utf-8-sig`` will skip those "
"three bytes if they appear as the first three bytes in the file. In UTF-8, "
"the use of the BOM is discouraged and should generally be avoided."
msgstr ""
"в iso-8859-1), це збільшує ймовірність того, що кодування ``utf-8-sig`` "
"можна правильно вгадати з послідовності байтів. Отже, тут BOM "
"використовується не для визначення порядку байтів, який використовується для "
"створення послідовності байтів, а як підпис, який допомагає вгадати "
"кодування. Під час кодування кодек utf-8-sig записуватиме ``0xef``, "
"``0xbb``, ``0xbf`` як перші три байти до файлу. Під час декодування ``utf-8-"
"sig`` пропустить ці три байти, якщо вони відображаються як перші три байти у "
"файлі. В UTF-8 використання BOM не рекомендується, і його слід уникати."

msgid "Standard Encodings"
msgstr "Стандартні кодування"

msgid ""
"Python comes with a number of codecs built-in, either implemented as C "
"functions or with dictionaries as mapping tables. The following table lists "
"the codecs by name, together with a few common aliases, and the languages "
"for which the encoding is likely used. Neither the list of aliases nor the "
"list of languages is meant to be exhaustive. Notice that spelling "
"alternatives that only differ in case or use a hyphen instead of an "
"underscore are also valid aliases; therefore, e.g. ``'utf-8'`` is a valid "
"alias for the ``'utf_8'`` codec."
msgstr ""
"Python поставляється з низкою вбудованих кодеків, реалізованих як функції C "
"або зі словниками як таблиці відображення. У наведеній нижче таблиці "
"наведено кодеки за назвами разом із кількома поширеними псевдонімами та "
"мовами, для яких, ймовірно, використовується кодування. Ні список "
"псевдонімів, ні список мов не є вичерпними. Зауважте, що варіанти написання, "
"які відрізняються лише регістром або використовують дефіс замість "
"підкреслення, також є дійсними псевдонімами; отже, напр. ``'utf-8''`` є "
"дійсним псевдонімом для ``'utf_8''`` кодека."

msgid ""
"Some common encodings can bypass the codecs lookup machinery to improve "
"performance. These optimization opportunities are only recognized by CPython "
"for a limited set of (case insensitive) aliases: utf-8, utf8, latin-1, "
"latin1, iso-8859-1, iso8859-1, mbcs (Windows only), ascii, us-ascii, utf-16, "
"utf16, utf-32, utf32, and the same using underscores instead of dashes. "
"Using alternative aliases for these encodings may result in slower execution."
msgstr ""
"Деякі поширені кодування можуть обійти механізм пошуку кодеків для "
"підвищення продуктивності. Ці можливості оптимізації розпізнаються CPython "
"лише для обмеженого набору (незалежних від регістру) псевдонімів: utf-8, "
"utf8, latin-1, latin1, iso-8859-1, iso8859-1, mbcs (лише Windows), ascii, us "
"-ascii, utf-16, utf16, utf-32, utf32 і те саме, використовуючи підкреслення "
"замість тире. Використання альтернативних псевдонімів для цих кодувань може "
"призвести до сповільнення виконання."

msgid "Optimization opportunity recognized for us-ascii."
msgstr "Можливість оптимізації визнана для us-ascii."

msgid ""
"Many of the character sets support the same languages. They vary in "
"individual characters (e.g. whether the EURO SIGN is supported or not), and "
"in the assignment of characters to code positions. For the European "
"languages in particular, the following variants typically exist:"
msgstr ""
"Багато наборів символів підтримують однакові мови. Вони відрізняються за "
"окремими символами (наприклад, чи підтримується ЗНАК ЄВРО чи ні), а також за "
"призначенням символів позиціям коду. Зокрема, для європейських мов зазвичай "
"існують такі варіанти:"

msgid "an ISO 8859 codeset"
msgstr "кодовий набір ISO 8859"

msgid ""
"a Microsoft Windows code page, which is typically derived from an 8859 "
"codeset, but replaces control characters with additional graphic characters"
msgstr ""
"кодова сторінка Microsoft Windows, яка зазвичай походить від коду 8859, але "
"замінює контрольні символи додатковими графічними символами"

msgid "an IBM EBCDIC code page"
msgstr "кодову сторінку IBM EBCDIC"

msgid "an IBM PC code page, which is ASCII compatible"
msgstr "кодова сторінка IBM PC, сумісна з ASCII"

msgid "Codec"
msgstr "Кодек"

msgid "Aliases"
msgstr "Псевдоніми"

msgid "Languages"
msgstr "Мови"

msgid "ascii"
msgstr "ascii"

msgid "646, us-ascii"
msgstr "646, us-ascii"

msgid "English"
msgstr "англійська"

msgid "big5"
msgstr "великий5"

msgid "big5-tw, csbig5"
msgstr "big5-tw, csbig5"

msgid "Traditional Chinese"
msgstr "Традиційний китайський"

msgid "big5hkscs"
msgstr "big5hkscs"

msgid "big5-hkscs, hkscs"
msgstr "big5-hkscs, hkscs"

msgid "cp037"
msgstr "cp037"

msgid "IBM037, IBM039"
msgstr "IBM037, IBM039"

msgid "cp273"
msgstr "cp273"

msgid "273, IBM273, csIBM273"
msgstr "273, IBM273, csIBM273"

msgid "German"
msgstr "Німецький"

msgid "cp424"
msgstr "cp424"

msgid "EBCDIC-CP-HE, IBM424"
msgstr "EBCDIC-CP-HE, IBM424"

msgid "Hebrew"
msgstr "іврит"

msgid "cp437"
msgstr "cp437"

msgid "437, IBM437"
msgstr "437, IBM437"

msgid "cp500"
msgstr "cp500"

msgid "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"
msgstr "EBCDIC-CP-BE, EBCDIC-CP-CH, IBM500"

msgid "Western Europe"
msgstr "Західна Європа"

msgid "cp720"
msgstr "cp720"

msgid "Arabic"
msgstr "арабська"

msgid "cp737"
msgstr "cp737"

msgid "Greek"
msgstr "грецька"

msgid "cp775"
msgstr "cp775"

msgid "IBM775"
msgstr "IBM775"

msgid "Baltic languages"
msgstr "Балтійські мови"

msgid "cp850"
msgstr "cp850"

msgid "850, IBM850"
msgstr "850, IBM850"

msgid "cp852"
msgstr "cp852"

msgid "852, IBM852"
msgstr "852, IBM852"

msgid "Central and Eastern Europe"
msgstr "Центральна та Східна Європа"

msgid "cp855"
msgstr "cp855"

msgid "855, IBM855"
msgstr "855, IBM855"

msgid "Bulgarian, Byelorussian, Macedonian, Russian, Serbian"
msgstr "болгарська, білоруська, македонська, російська, сербська"

msgid "cp856"
msgstr "cp856"

msgid "cp857"
msgstr "cp857"

msgid "857, IBM857"
msgstr "857, IBM857"

msgid "Turkish"
msgstr "турецька"

msgid "cp858"
msgstr "cp858"

msgid "858, IBM858"
msgstr "858, IBM858"

msgid "cp860"
msgstr "cp860"

msgid "860, IBM860"
msgstr "860, IBM860"

msgid "Portuguese"
msgstr "португальська"

msgid "cp861"
msgstr "cp861"

msgid "861, CP-IS, IBM861"
msgstr "861, CP-IS, IBM861"

msgid "Icelandic"
msgstr "ісландська"

msgid "cp862"
msgstr "cp862"

msgid "862, IBM862"
msgstr "862, IBM862"

msgid "cp863"
msgstr "cp863"

msgid "863, IBM863"
msgstr "863, IBM863"

msgid "Canadian"
msgstr "канадський"

msgid "cp864"
msgstr "cp864"

msgid "IBM864"
msgstr "IBM864"

msgid "cp865"
msgstr "cp865"

msgid "865, IBM865"
msgstr "865, IBM865"

msgid "Danish, Norwegian"
msgstr "датська, норвезька"

msgid "cp866"
msgstr "cp866"

msgid "866, IBM866"
msgstr "866, IBM866"

msgid "Russian"
msgstr "російський"

msgid "cp869"
msgstr "cp869"

msgid "869, CP-GR, IBM869"
msgstr "869, CP-GR, IBM869"

msgid "cp874"
msgstr "cp874"

msgid "Thai"
msgstr "тайська"

msgid "cp875"
msgstr "cp875"

msgid "cp932"
msgstr "cp932"

msgid "932, ms932, mskanji, ms-kanji"
msgstr "932, ms932, mskanji, ms-kanji"

msgid "Japanese"
msgstr "Японський"

msgid "cp949"
msgstr "cp949"

msgid "949, ms949, uhc"
msgstr "949, ms949, uhc"

msgid "Korean"
msgstr "корейська"

msgid "cp950"
msgstr "cp950"

msgid "950, ms950"
msgstr "950, мс950"

msgid "cp1006"
msgstr "cp1006"

msgid "Urdu"
msgstr "урду"

msgid "cp1026"
msgstr "cp1026"

msgid "ibm1026"
msgstr "ibm1026"

msgid "cp1125"
msgstr "cp1125"

msgid "1125, ibm1125, cp866u, ruscii"
msgstr "1125, ibm1125, cp866u, рос"

msgid "Ukrainian"
msgstr "українська"

msgid "cp1140"
msgstr "cp1140"

msgid "ibm1140"
msgstr "ibm1140"

msgid "cp1250"
msgstr "cp1250"

msgid "windows-1250"
msgstr "вікна-1250"

msgid "cp1251"
msgstr "cp1251"

msgid "windows-1251"
msgstr "вікна-1251"

msgid "cp1252"
msgstr "cp1252"

msgid "windows-1252"
msgstr "вікна-1252"

msgid "cp1253"
msgstr "cp1253"

msgid "windows-1253"
msgstr "вікна-1253"

msgid "cp1254"
msgstr "cp1254"

msgid "windows-1254"
msgstr "windows-1254"

msgid "cp1255"
msgstr "cp1255"

msgid "windows-1255"
msgstr "вікна-1255"

msgid "cp1256"
msgstr "cp1256"

msgid "windows-1256"
msgstr "вікна-1256"

msgid "cp1257"
msgstr "cp1257"

msgid "windows-1257"
msgstr "вікна-1257"

msgid "cp1258"
msgstr "cp1258"

msgid "windows-1258"
msgstr "вікна-1258"

msgid "Vietnamese"
msgstr "в'єтнамська"

msgid "euc_jp"
msgstr "euc_jp"

msgid "eucjp, ujis, u-jis"
msgstr "eucjp, ujis, u-jis"

msgid "euc_jis_2004"
msgstr "euc_jis_2004"

msgid "jisx0213, eucjis2004"
msgstr "jisx0213, eucjis2004"

msgid "euc_jisx0213"
msgstr "euc_jisx0213"

msgid "eucjisx0213"
msgstr "eucjisx0213"

msgid "euc_kr"
msgstr "euc_kr"

msgid "euckr, korean, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"
msgstr ""
"euckr, корейська, ksc5601, ks_c-5601, ks_c-5601-1987, ksx1001, ks_x-1001"

msgid "gb2312"
msgstr "gb2312"

msgid ""
"chinese, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"
msgstr ""
"китайська, csiso58gb231280, euc-cn, euccn, eucgb2312-cn, gb2312-1980, "
"gb2312-80, iso-ir-58"

msgid "Simplified Chinese"
msgstr "Спрощена Китайська"

msgid "gbk"
msgstr "gbk"

msgid "936, cp936, ms936"
msgstr "936, cp936, ms936"

msgid "Unified Chinese"
msgstr "Єдина китайська"

msgid "gb18030"
msgstr "gb18030"

msgid "gb18030-2000"
msgstr "gb18030-2000"

msgid "hz"
msgstr "Гц"

msgid "hzgb, hz-gb, hz-gb-2312"
msgstr "hzgb, hz-gb, hz-gb-2312"

msgid "iso2022_jp"
msgstr "iso2022_jp"

msgid "csiso2022jp, iso2022jp, iso-2022-jp"
msgstr "csiso2022jp, iso2022jp, iso-2022-jp"

msgid "iso2022_jp_1"
msgstr "iso2022_jp_1"

msgid "iso2022jp-1, iso-2022-jp-1"
msgstr "iso2022jp-1, iso-2022-jp-1"

msgid "iso2022_jp_2"
msgstr "iso2022_jp_2"

msgid "iso2022jp-2, iso-2022-jp-2"
msgstr "iso2022jp-2, iso-2022-jp-2"

msgid "Japanese, Korean, Simplified Chinese, Western Europe, Greek"
msgstr "Японська, корейська, спрощена китайська, західноєвропейська, грецька"

msgid "iso2022_jp_2004"
msgstr "iso2022_jp_2004"

msgid "iso2022jp-2004, iso-2022-jp-2004"
msgstr "iso2022jp-2004, iso-2022-jp-2004"

msgid "iso2022_jp_3"
msgstr "iso2022_jp_3"

msgid "iso2022jp-3, iso-2022-jp-3"
msgstr "iso2022jp-3, iso-2022-jp-3"

msgid "iso2022_jp_ext"
msgstr "iso2022_jp_ext"

msgid "iso2022jp-ext, iso-2022-jp-ext"
msgstr "iso2022jp-ext, iso-2022-jp-ext"

msgid "iso2022_kr"
msgstr "iso2022_kr"

msgid "csiso2022kr, iso2022kr, iso-2022-kr"
msgstr "csiso2022kr, iso2022kr, iso-2022-kr"

msgid "latin_1"
msgstr "latin_1"

msgid "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"
msgstr "iso-8859-1, iso8859-1, 8859, cp819, latin, latin1, L1"

msgid "iso8859_2"
msgstr "iso8859_2"

msgid "iso-8859-2, latin2, L2"
msgstr "iso-8859-2, latin2, L2"

msgid "iso8859_3"
msgstr "iso8859_3"

msgid "iso-8859-3, latin3, L3"
msgstr "iso-8859-3, latin3, L3"

msgid "Esperanto, Maltese"
msgstr "Есперанто, мальтійська"

msgid "iso8859_4"
msgstr "iso8859_4"

msgid "iso-8859-4, latin4, L4"
msgstr "iso-8859-4, latin4, L4"

msgid "iso8859_5"
msgstr "iso8859_5"

msgid "iso-8859-5, cyrillic"
msgstr "iso-8859-5, кирил"

msgid "iso8859_6"
msgstr "iso8859_6"

msgid "iso-8859-6, arabic"
msgstr "iso-8859-6, араб"

msgid "iso8859_7"
msgstr "iso8859_7"

msgid "iso-8859-7, greek, greek8"
msgstr "iso-8859-7, грецький, грецький8"

msgid "iso8859_8"
msgstr "iso8859_8"

msgid "iso-8859-8, hebrew"
msgstr "iso-8859-8, іврит"

msgid "iso8859_9"
msgstr "iso8859_9"

msgid "iso-8859-9, latin5, L5"
msgstr "iso-8859-9, latin5, L5"

msgid "iso8859_10"
msgstr "iso8859_10"

msgid "iso-8859-10, latin6, L6"
msgstr "iso-8859-10, latin6, L6"

msgid "Nordic languages"
msgstr "Скандинавські мови"

msgid "iso8859_11"
msgstr "iso8859_11"

msgid "iso-8859-11, thai"
msgstr "iso-8859-11, тай"

msgid "Thai languages"
msgstr "тайські мови"

msgid "iso8859_13"
msgstr "iso8859_13"

msgid "iso-8859-13, latin7, L7"
msgstr "iso-8859-13, latin7, L7"

msgid "iso8859_14"
msgstr "iso8859_14"

msgid "iso-8859-14, latin8, L8"
msgstr "iso-8859-14, latin8, L8"

msgid "Celtic languages"
msgstr "кельтські мови"

msgid "iso8859_15"
msgstr "iso8859_15"

msgid "iso-8859-15, latin9, L9"
msgstr "iso-8859-15, latin9, L9"

msgid "iso8859_16"
msgstr "iso8859_16"

msgid "iso-8859-16, latin10, L10"
msgstr "iso-8859-16, latin10, L10"

msgid "South-Eastern Europe"
msgstr "Південно-Східна Європа"

msgid "johab"
msgstr "Йохаб"

msgid "cp1361, ms1361"
msgstr "cp1361, ms1361"

msgid "koi8_r"
msgstr "koi8_r"

msgid "koi8_t"
msgstr "koi8_t"

msgid "Tajik"
msgstr "таджицька"

msgid "koi8_u"
msgstr "koi8_u"

msgid "kz1048"
msgstr "kz1048"

msgid "kz_1048, strk1048_2002, rk1048"
msgstr "kz_1048, strk1048_2002, rk1048"

msgid "Kazakh"
msgstr "казахська"

msgid "mac_cyrillic"
msgstr "mac_cyrillic"

msgid "maccyrillic"
msgstr "макирилицею"

msgid "mac_greek"
msgstr "mac_greek"

msgid "macgreek"
msgstr "макгрік"

msgid "mac_iceland"
msgstr "mac_iceland"

msgid "maciceland"
msgstr "maciceland"

msgid "mac_latin2"
msgstr "mac_latin2"

msgid "maclatin2, maccentraleurope, mac_centeuro"
msgstr "maclatin2, maccentraleurope, mac_centeuro"

msgid "mac_roman"
msgstr "mac_roman"

msgid "macroman, macintosh"
msgstr "макромен, макінтош"

msgid "mac_turkish"
msgstr "mac_turkish"

msgid "macturkish"
msgstr "macturkish"

msgid "ptcp154"
msgstr "ptcp154"

msgid "csptcp154, pt154, cp154, cyrillic-asian"
msgstr "csptcp154, pt154, cp154, кирилиця-азійська"

msgid "shift_jis"
msgstr "shift_jis"

msgid "csshiftjis, shiftjis, sjis, s_jis"
msgstr "csshiftjis, shiftjis, sjis, s_jis"

msgid "shift_jis_2004"
msgstr "shift_jis_2004"

msgid "shiftjis2004, sjis_2004, sjis2004"
msgstr "shiftjis2004, sjis_2004, sjis2004"

msgid "shift_jisx0213"
msgstr "shift_jisx0213"

msgid "shiftjisx0213, sjisx0213, s_jisx0213"
msgstr "shiftjisx0213, sjisx0213, s_jisx0213"

msgid "utf_32"
msgstr "utf_32"

msgid "U32, utf32"
msgstr "U32, utf32"

msgid "all languages"
msgstr "всі мови"

msgid "utf_32_be"
msgstr "utf_32_be"

msgid "UTF-32BE"
msgstr "UTF-32BE"

msgid "utf_32_le"
msgstr "utf_32_le"

msgid "UTF-32LE"
msgstr "UTF-32LE"

msgid "utf_16"
msgstr "utf_16"

msgid "U16, utf16"
msgstr "U16, utf16"

msgid "utf_16_be"
msgstr "utf_16_be"

msgid "UTF-16BE"
msgstr "UTF-16BE"

msgid "utf_16_le"
msgstr "utf_16_le"

msgid "UTF-16LE"
msgstr "UTF-16LE"

msgid "utf_7"
msgstr "utf_7"

msgid "U7, unicode-1-1-utf-7"
msgstr "U7, unicode-1-1-utf-7"

msgid "utf_8"
msgstr "utf_8"

msgid "U8, UTF, utf8, cp65001"
msgstr "U8, UTF, utf8, cp65001"

msgid "utf_8_sig"
msgstr "utf_8_sig"

msgid ""
"The utf-16\\* and utf-32\\* encoders no longer allow surrogate code points "
"(``U+D800``--``U+DFFF``) to be encoded. The utf-32\\* decoders no longer "
"decode byte sequences that correspond to surrogate code points."
msgstr ""
"Кодери utf-16\\* і utf-32\\* більше не дозволяють кодувати сурогатні кодові "
"точки (``U+D800``--``U+DFFF``). Декодери utf-32\\* більше не декодують "
"послідовності байтів, які відповідають сурогатним кодовим точкам."

msgid "``cp65001`` is now an alias to ``utf_8``."
msgstr "``cp65001`` тепер є псевдонімом ``utf_8``."

msgid "Python Specific Encodings"
msgstr "Спеціальні кодування Python"

msgid ""
"A number of predefined codecs are specific to Python, so their codec names "
"have no meaning outside Python. These are listed in the tables below based "
"on the expected input and output types (note that while text encodings are "
"the most common use case for codecs, the underlying codec infrastructure "
"supports arbitrary data transforms rather than just text encodings). For "
"asymmetric codecs, the stated meaning describes the encoding direction."
msgstr ""
"Деякі попередньо визначені кодеки є специфічними для Python, тому їхні назви "
"кодеків не мають значення поза Python. Вони перераховані в таблицях нижче на "
"основі очікуваних типів введення та виведення (зауважте, що хоча кодування "
"тексту є найпоширенішим випадком використання кодеків, базова інфраструктура "
"кодеків підтримує довільні перетворення даних, а не лише кодування тексту). "
"Для асиметричних кодеків вказане значення описує напрямок кодування."

msgid "Text Encodings"
msgstr "Кодування тексту"

msgid ""
"The following codecs provide :class:`str` to :class:`bytes` encoding and :"
"term:`bytes-like object` to :class:`str` decoding, similar to the Unicode "
"text encodings."
msgstr ""
"Наступні кодеки забезпечують кодування :class:`str` до :class:`bytes` і "
"декодування :term:`bytes-like object` до :class:`str`, подібне до кодування "
"тексту Unicode."

msgid "idna"
msgstr "idna"

msgid ""
"Implement :rfc:`3490`, see also :mod:`encodings.idna`. Only "
"``errors='strict'`` is supported."
msgstr ""
"Реалізація :rfc:`3490`, див. також :mod:`encodings.idna`. Підтримується лише "
"``errors='strict'``."

msgid "mbcs"
msgstr "mbcs"

msgid "ansi, dbcs"
msgstr "ansi, dbcs"

msgid ""
"Windows only: Encode the operand according to the ANSI codepage (CP_ACP)."
msgstr ""
"Лише для Windows: кодуйте операнд відповідно до кодової сторінки ANSI "
"(CP_ACP)."

msgid "oem"
msgstr "oem"

msgid ""
"Windows only: Encode the operand according to the OEM codepage (CP_OEMCP)."
msgstr ""
"Лише для Windows: кодуйте операнд відповідно до кодової сторінки OEM "
"(CP_OEMCP)."

msgid "palmos"
msgstr "palmos"

msgid "Encoding of PalmOS 3.5."
msgstr "Кодування PalmOS 3.5."

msgid "punycode"
msgstr "punycode"

msgid "Implement :rfc:`3492`. Stateful codecs are not supported."
msgstr "Впровадити :rfc:`3492`. Кодеки з підтримкою стану не підтримуються."

msgid "raw_unicode_escape"
msgstr "raw_unicode_escape"

msgid ""
"Latin-1 encoding with ``\\uXXXX`` and ``\\UXXXXXXXX`` for other code points. "
"Existing backslashes are not escaped in any way. It is used in the Python "
"pickle protocol."
msgstr ""
"Кодування Latin-1 з ``\\uXXXX`` і ``\\UXXXXXXXX`` для інших кодових точок. "
"Існуючі зворотні косі риски жодним чином не захищені. Він використовується в "
"протоколі pickle Python."

msgid "undefined"
msgstr "невизначений"

msgid ""
"Raise an exception for all conversions, even empty strings. The error "
"handler is ignored."
msgstr ""
"Викликати виняток для всіх перетворень, навіть для порожніх рядків. Обробник "
"помилок ігнорується."

msgid "unicode_escape"
msgstr "unicode_escape"

msgid ""
"Encoding suitable as the contents of a Unicode literal in ASCII-encoded "
"Python source code, except that quotes are not escaped. Decode from Latin-1 "
"source code. Beware that Python source code actually uses UTF-8 by default."
msgstr ""
"Кодування, придатне як вміст літералу Юнікод у вихідному коді Python із "
"кодуванням ASCII, за винятком того, що лапки не екрануються. Декодувати з "
"вихідного коду Latin-1. Майте на увазі, що вихідний код Python насправді "
"використовує UTF-8 за замовчуванням."

msgid "\"unicode_internal\" codec is removed."
msgstr "Кодек \"unicode_internal\" видалено."

msgid "Binary Transforms"
msgstr "Двійкові перетворення"

msgid ""
"The following codecs provide binary transforms: :term:`bytes-like object` "
"to :class:`bytes` mappings. They are not supported by :meth:`bytes.decode` "
"(which only produces :class:`str` output)."
msgstr ""
"Наступні кодеки забезпечують двійкові перетворення: :term:`bytes-like "
"object` у :class:`bytes` зіставлення. Вони не підтримуються :meth:`bytes."
"decode` (який виводить лише :class:`str`)."

msgid "Encoder / decoder"
msgstr "Кодер / декодер"

msgid "base64_codec [#b64]_"
msgstr "base64_codec [#b64]_"

msgid "base64, base_64"
msgstr "base64, base_64"

msgid ""
"Convert the operand to multiline MIME base64 (the result always includes a "
"trailing ``'\\n'``)."
msgstr ""
"Перетворіть операнд на багаторядковий MIME base64 (результат завжди включає "
"``'\\n'``)."

msgid ""
"accepts any :term:`bytes-like object` as input for encoding and decoding"
msgstr ""
"приймає будь-який :term:`bytes-like object` як вхідні дані для кодування та "
"декодування"

msgid ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"
msgstr ":meth:`base64.encodebytes` / :meth:`base64.decodebytes`"

msgid "bz2_codec"
msgstr "bz2_codec"

msgid "bz2"
msgstr "bz2"

msgid "Compress the operand using bz2."
msgstr "Стисніть операнд за допомогою bz2."

msgid ":meth:`bz2.compress` / :meth:`bz2.decompress`"
msgstr ":meth:`bz2.compress` / :meth:`bz2.decompress`"

msgid "hex_codec"
msgstr "hex_codec"

msgid "hex"
msgstr "шістнадцятковий"

msgid ""
"Convert the operand to hexadecimal representation, with two digits per byte."
msgstr "Перетворіть операнд у шістнадцяткове подання з двома цифрами на байт."

msgid ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"
msgstr ":meth:`binascii.b2a_hex` / :meth:`binascii.a2b_hex`"

msgid "quopri_codec"
msgstr "quopri_codec"

msgid "quopri, quotedprintable, quoted_printable"
msgstr "quopri, quotedprintable, quoted_printable"

msgid "Convert the operand to MIME quoted printable."
msgstr "Перетворіть операнд на MIME-цитований для друку."

msgid ":meth:`quopri.encode` with ``quotetabs=True`` / :meth:`quopri.decode`"
msgstr ":meth:`quopri.encode` з ``quotetabs=True`` / :meth:`quopri.decode`"

msgid "uu_codec"
msgstr "uu_codec"

msgid "uu"
msgstr "uu"

msgid "Convert the operand using uuencode."
msgstr "Перетворіть операнд за допомогою uuencode."

msgid ":meth:`uu.encode` / :meth:`uu.decode`"
msgstr ":meth:`uu.encode` / :meth:`uu.decode`"

msgid "zlib_codec"
msgstr "zlib_codec"

msgid "zip, zlib"
msgstr "zip, zlib"

msgid "Compress the operand using gzip."
msgstr "Стисніть операнд за допомогою gzip."

msgid ":meth:`zlib.compress` / :meth:`zlib.decompress`"
msgstr ":meth:`zlib.compress` / :meth:`zlib.decompress`"

msgid ""
"In addition to :term:`bytes-like objects <bytes-like object>`, "
"``'base64_codec'`` also accepts ASCII-only instances of :class:`str` for "
"decoding"
msgstr ""
"На додаток до :term:`байт-подібних об’єктів <bytes-like object>`, "
"``'base64_codec''`` також приймає лише ASCII-примірники :class:`str` для "
"декодування"

msgid "Restoration of the binary transforms."
msgstr "Відновлення двійкових перетворень."

msgid "Restoration of the aliases for the binary transforms."
msgstr "Відновлення псевдонімів для бінарних перетворень."

msgid "Text Transforms"
msgstr "Перетворення тексту"

msgid ""
"The following codec provides a text transform: a :class:`str` to :class:"
"`str` mapping. It is not supported by :meth:`str.encode` (which only "
"produces :class:`bytes` output)."
msgstr ""
"Наступний кодек забезпечує перетворення тексту: відображення :class:`str` у :"
"class:`str`. Він не підтримується :meth:`str.encode` (який виводить лише :"
"class:`bytes`)."

msgid "rot_13"
msgstr "rot_13"

msgid "rot13"
msgstr "гниль13"

msgid "Return the Caesar-cypher encryption of the operand."
msgstr "Повернути шифрування операнда за допомогою шифру Цезаря."

msgid "Restoration of the ``rot_13`` text transform."
msgstr "Відновлення текстового перетворення ``rot_13``."

msgid "Restoration of the ``rot13`` alias."
msgstr "Відновлення псевдоніма ``rot13``."

msgid ""
":mod:`encodings.idna` --- Internationalized Domain Names in Applications"
msgstr ""
":mod:`encodings.idna` --- Інтернаціоналізовані доменні імена в програмах"

msgid ""
"This module implements :rfc:`3490` (Internationalized Domain Names in "
"Applications) and :rfc:`3492` (Nameprep: A Stringprep Profile for "
"Internationalized Domain Names (IDN)). It builds upon the ``punycode`` "
"encoding and :mod:`stringprep`."
msgstr ""
"Цей модуль реалізує :rfc:`3490` (інтернаціоналізовані доменні імена в "
"програмах) і :rfc:`3492` (nameprep: профіль Stringprep для "
"інтернаціоналізованих доменних імен (IDN)). Він побудований на основі "
"кодування ``punycode`` і :mod:`stringprep`."

msgid ""
"If you need the IDNA 2008 standard from :rfc:`5891` and :rfc:`5895`, use the "
"third-party `idna module <https://pypi.org/project/idna/>`_."
msgstr ""
"Якщо вам потрібен стандарт IDNA 2008 від :rfc:`5891` і :rfc:`5895`, "
"використовуйте сторонній `idna module <https://pypi.org/project/idna/>`_."

msgid ""
"These RFCs together define a protocol to support non-ASCII characters in "
"domain names. A domain name containing non-ASCII characters (such as ``www."
"Alliancefrançaise.nu``) is converted into an ASCII-compatible encoding (ACE, "
"such as ``www.xn--alliancefranaise-npb.nu``). The ACE form of the domain "
"name is then used in all places where arbitrary characters are not allowed "
"by the protocol, such as DNS queries, HTTP :mailheader:`Host` fields, and so "
"on. This conversion is carried out in the application; if possible invisible "
"to the user: The application should transparently convert Unicode domain "
"labels to IDNA on the wire, and convert back ACE labels to Unicode before "
"presenting them to the user."
msgstr ""
"Ці RFC разом визначають протокол для підтримки символів, відмінних від "
"ASCII, у доменних іменах. Доменне ім’я, що містить символи, відмінні від "
"ASCII (наприклад, ``www.Alliancefrançaise.nu``), перетворюється на ASCII-"
"сумісне кодування (ACE, наприклад ``www.xn--alliancefranaise-npb.nu``). "
"Форма ACE імені домену потім використовується в усіх місцях, де довільні "
"символи не дозволені протоколом, наприклад у запитах DNS, HTTP :mailheader:"
"`Host` тощо. Це перетворення здійснюється в додатку; якщо можливо, невидимі "
"для користувача: програма повинна прозоро перетворювати мітки домену Unicode "
"на IDNA на дроті та перетворювати мітки ACE назад у Unicode перед тим, як "
"представляти їх користувачеві."

msgid ""
"Python supports this conversion in several ways:  the ``idna`` codec "
"performs conversion between Unicode and ACE, separating an input string into "
"labels based on the separator characters defined in :rfc:`section 3.1 of RFC "
"3490 <3490#section-3.1>` and converting each label to ACE as required, and "
"conversely separating an input byte string into labels based on the ``.`` "
"separator and converting any ACE labels found into unicode. Furthermore, "
"the :mod:`socket` module transparently converts Unicode host names to ACE, "
"so that applications need not be concerned about converting host names "
"themselves when they pass them to the socket module. On top of that, modules "
"that have host names as function parameters, such as :mod:`http.client` and :"
"mod:`ftplib`, accept Unicode host names (:mod:`http.client` then also "
"transparently sends an IDNA hostname in the :mailheader:`Host` field if it "
"sends that field at all)."
msgstr ""
"Python підтримує це перетворення декількома способами: кодек ``idna`` "
"виконує перетворення між Юнікодом і ACE, розділяючи вхідний рядок на мітки "
"на основі символів-роздільників, визначених у :rfc:`розділі 3.1 RFC 3490 "
"<3490#section-3.1>`, і перетворюючи кожну мітку до ACE за потреби, і "
"навпаки, розділяючи вхідний байтовий рядок на мітки на основі роздільника ``."
"`` і перетворюючи будь-які знайдені мітки ACE в Юнікод. Крім того, модуль :"
"mod:`socket` прозоро перетворює імена хостів Unicode на ACE, тому програмам "
"не потрібно турбуватися про перетворення самих імен хостів, коли вони "
"передають їх модулю сокетів. Крім того, модулі, які мають імена хостів як "
"параметри функцій, наприклад :mod:`http.client` і :mod:`ftplib`, приймають "
"імена хостів Unicode (:mod:`http.client` потім також прозоро надсилає IDNA "
"ім’я хоста в полі :mailheader:`Host`, якщо воно взагалі надсилає це поле)."

msgid ""
"When receiving host names from the wire (such as in reverse name lookup), no "
"automatic conversion to Unicode is performed: applications wishing to "
"present such host names to the user should decode them to Unicode."
msgstr ""
"Під час отримання імен хостів із проводу (наприклад, під час зворотного "
"пошуку імен) автоматичне перетворення в Unicode не виконується: програми, "
"які бажають надати такі імена хостів користувачеві, повинні декодувати їх у "
"Unicode."

msgid ""
"The module :mod:`encodings.idna` also implements the nameprep procedure, "
"which performs certain normalizations on host names, to achieve case-"
"insensitivity of international domain names, and to unify similar "
"characters. The nameprep functions can be used directly if desired."
msgstr ""
"Модуль :mod:`encodings.idna` також реалізує процедуру nameprep, яка виконує "
"певні нормалізації імен хостів, щоб досягти нечутливості до регістру "
"міжнародних доменних імен і уніфікувати схожі символи. За бажанням можна "
"безпосередньо використовувати функції nameprep."

msgid ""
"Return the nameprepped version of *label*. The implementation currently "
"assumes query strings, so ``AllowUnassigned`` is true."
msgstr ""
"Повертає запрограмовану версію *мітки*. Реалізація наразі передбачає рядки "
"запиту, тому ``AllowUnassigned`` є істинним."

msgid ""
"Convert a label to ASCII, as specified in :rfc:`3490`. ``UseSTD3ASCIIRules`` "
"is assumed to be false."
msgstr ""
"Перетворіть мітку на ASCII, як зазначено в :rfc:`3490`. "
"``UseSTD3ASCIIRules`` вважається false."

msgid "Convert a label to Unicode, as specified in :rfc:`3490`."
msgstr "Перетворіть мітку в Unicode, як зазначено в :rfc:`3490`."

msgid ":mod:`encodings.mbcs` --- Windows ANSI codepage"
msgstr ":mod:`encodings.mbcs` --- кодова сторінка Windows ANSI"

msgid "This module implements the ANSI codepage (CP_ACP)."
msgstr "Цей модуль реалізує кодову сторінку ANSI (CP_ACP)."

msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Наявність <availability>`: Windows."

msgid "Support any error handler."
msgstr "Підтримка будь-якого засобу обробки помилок."

msgid ""
"Before 3.2, the *errors* argument was ignored; ``'replace'`` was always used "
"to encode, and ``'ignore'`` to decode."
msgstr ""
"До версії 3.2 аргумент *errors* ігнорувався; ``'replace'`` завжди "
"використовувався для кодування, а ``'ignore''`` для декодування."

msgid ":mod:`encodings.utf_8_sig` --- UTF-8 codec with BOM signature"
msgstr ":mod:`encodings.utf_8_sig` --- кодек UTF-8 із підписом BOM"

msgid ""
"This module implements a variant of the UTF-8 codec. On encoding, a UTF-8 "
"encoded BOM will be prepended to the UTF-8 encoded bytes. For the stateful "
"encoder this is only done once (on the first write to the byte stream). On "
"decoding, an optional UTF-8 encoded BOM at the start of the data will be "
"skipped."
msgstr ""
"Цей модуль реалізує варіант кодека UTF-8. Під час кодування BOM у кодуванні "
"UTF-8 буде додано до байтів у кодуванні UTF-8. Для кодувальника зі "
"збереженням стану це робиться лише один раз (під час першого запису в потік "
"байтів). Під час декодування додаткова специфікація даних у кодуванні UTF-8 "
"на початку даних буде пропущена."
