# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`__main__` --- Top-level code environment"
msgstr ":mod:`__main__` --- Кодове середовище верхнього рівня"

msgid ""
"In Python, the special name ``__main__`` is used for two important "
"constructs:"
msgstr ""
"У Python спеціальна назва ``__main__`` використовується для двох важливих "
"конструкцій:"

msgid ""
"the name of the top-level environment of the program, which can be checked "
"using the ``__name__ == '__main__'`` expression; and"
msgstr ""
"ім'я середовища верхнього рівня програми, яке можна перевірити за допомогою "
"виразу ``__name__ == '__main__'``; і"

msgid "the ``__main__.py`` file in Python packages."
msgstr "файл ``__main__.py`` в пакетах Python."

msgid ""
"Both of these mechanisms are related to Python modules; how users interact "
"with them and how they interact with each other.  They are explained in "
"detail below.  If you're new to Python modules, see the tutorial section :"
"ref:`tut-modules` for an introduction."
msgstr ""
"Обидва ці механізми пов’язані з модулями Python; як користувачі взаємодіють "
"з ними та як вони взаємодіють один з одним. Вони детально пояснюються нижче. "
"Якщо ви новачок у роботі з модулями Python, ознайомтеся з розділом "
"посібника :ref:`tut-modules`."

msgid "``__name__ == '__main__'``"
msgstr "``__name__ == '__main__''``"

msgid ""
"When a Python module or package is imported, ``__name__`` is set to the "
"module's name.  Usually, this is the name of the Python file itself without "
"the ``.py`` extension::"
msgstr ""
"Коли імпортується модуль або пакет Python, ``__name__`` встановлюється на "
"ім’я модуля. Зазвичай це назва самого файлу Python без розширення ``.py``::"

msgid ""
"If the file is part of a package, ``__name__`` will also include the parent "
"package's path::"
msgstr ""
"Якщо файл є частиною пакета, ``__name__`` також включатиме шлях до "
"батьківського пакета::"

msgid ""
"However, if the module is executed in the top-level code environment, its "
"``__name__`` is set to the string ``'__main__'``."
msgstr ""
"Однак, якщо модуль виконується в кодовому середовищі верхнього рівня, його "
"``__name__`` встановлюється на рядок ``'__main__'``."

msgid "What is the \"top-level code environment\"?"
msgstr "Що таке \"середовище коду верхнього рівня\"?"

msgid ""
"``__main__`` is the name of the environment where top-level code is run. "
"\"Top-level code\" is the first user-specified Python module that starts "
"running. It's \"top-level\" because it imports all other modules that the "
"program needs. Sometimes \"top-level code\" is called an *entry point* to "
"the application."
msgstr ""
"``__main__`` — це назва середовища, де виконується код верхнього рівня. "
"\"Код верхнього рівня\" — це перший зазначений користувачем модуль Python, "
"який запускається. Це \"верхній рівень\", тому що він імпортує всі інші "
"модулі, які потрібні програмі. Іноді \"код верхнього рівня\" називають "
"*точкою входу* до програми."

msgid "The top-level code environment can be:"
msgstr "Кодове середовище верхнього рівня може бути:"

msgid "the scope of an interactive prompt::"
msgstr "область дії інтерактивної підказки:"

msgid "the Python module passed to the Python interpreter as a file argument:"
msgstr "модуль Python передається інтерпретатору Python як аргумент файлу:"

msgid ""
"the Python module or package passed to the Python interpreter with the :"
"option:`-m` argument:"
msgstr ""
"модуль або пакет Python передається інтерпретатору Python з аргументом :"
"option:`-m`:"

msgid "Python code read by the Python interpreter from standard input:"
msgstr ""
"Код Python, який читається інтерпретатором Python зі стандартного введення:"

msgid ""
"Python code passed to the Python interpreter with the :option:`-c` argument:"
msgstr ""
"Код Python передається інтерпретатору Python з аргументом :option:`-c`:"

msgid ""
"In each of these situations, the top-level module's ``__name__`` is set to "
"``'__main__'``."
msgstr ""
"У кожній із цих ситуацій ``__name__`` модуля верхнього рівня встановлено на "
"``'__main__'``."

msgid ""
"As a result, a module can discover whether or not it is running in the top-"
"level environment by checking its own ``__name__``, which allows a common "
"idiom for conditionally executing code when the module is not initialized "
"from an import statement::"
msgstr ""
"Як наслідок, модуль може виявити, чи працює він у середовищі верхнього "
"рівня, перевіряючи власне ``__name__``, що дозволяє загальну ідіому для "
"умовного виконання коду, коли модуль не ініціалізовано оператором імпорту: :"

msgid ""
"For a more detailed look at how ``__name__`` is set in all situations, see "
"the tutorial section :ref:`tut-modules`."
msgstr ""
"Для більш детального ознайомлення з тим, як ``__name__`` встановлюється в "
"усіх ситуаціях, перегляньте розділ підручника :ref:`tut-modules`."

msgid "Idiomatic Usage"
msgstr "Ідіоматичне використання"

msgid ""
"Some modules contain code that is intended for script use only, like parsing "
"command-line arguments or fetching data from standard input.  If a module "
"like this was imported from a different module, for example to unit test it, "
"the script code would unintentionally execute as well."
msgstr ""
"Деякі модулі містять код, призначений лише для використання сценарієм, як-от "
"аналіз аргументів командного рядка або отримання даних зі стандартного "
"введення. Якщо подібний модуль було імпортовано з іншого модуля, наприклад, "
"для модульного тестування, код сценарію також буде ненавмисно виконано."

msgid ""
"This is where using the ``if __name__ == '__main__'`` code block comes in "
"handy. Code within this block won't run unless the module is executed in the "
"top-level environment."
msgstr ""
"Тут стане в нагоді використання блоку коду ``if __name__ == '__main__''``. "
"Код у цьому блоці не працюватиме, якщо модуль не буде виконано в середовищі "
"верхнього рівня."

msgid ""
"Putting as few statements as possible in the block below ``if __name___ == "
"'__main__'`` can improve code clarity and correctness. Most often, a "
"function named ``main`` encapsulates the program's primary behavior::"
msgstr ""
"Розміщення якомога меншої кількості операторів у блоці нижче ``if __name___ "
"== '__main__'`` може покращити ясність і правильність коду. Найчастіше "
"функція з назвою ``main`` інкапсулює основну поведінку програми:"

msgid ""
"Note that if the module didn't encapsulate code inside the ``main`` function "
"but instead put it directly within the ``if __name__ == '__main__'`` block, "
"the ``phrase`` variable would be global to the entire module.  This is error-"
"prone as other functions within the module could be unintentionally using "
"the global variable instead of a local name.  A ``main`` function solves "
"this problem."
msgstr ""
"Зауважте, що якби модуль не інкапсулював код у функцію ``main``, а поміщав "
"його безпосередньо в блок ``if __name__ == '__main__'``, змінна ``phrase`` "
"буде глобальною для весь модуль. Це загрожує помилками, оскільки інші "
"функції в модулі можуть ненавмисно використовувати глобальну змінну замість "
"локального імені. Функція ``main`` вирішує цю проблему."

msgid ""
"Using a ``main`` function has the added benefit of the ``echo`` function "
"itself being isolated and importable elsewhere. When ``echo.py`` is "
"imported, the ``echo`` and ``main`` functions will be defined, but neither "
"of them will be called, because ``__name__ != '__main__'``."
msgstr ""
"Використання функції ``main`` має додаткову перевагу в тому, що сама функція "
"``echo`` є ізольованою та її можна імпортувати в інше місце. Коли "
"імпортується ``echo.py``, функції ``echo`` і ``main`` будуть визначені, але "
"жодна з них не буде викликана, оскільки ``__name__ != '__main__'``."

msgid "Packaging Considerations"
msgstr "Зауваження щодо упаковки"

msgid ""
"``main`` functions are often used to create command-line tools by specifying "
"them as entry points for console scripts.  When this is done, `pip <https://"
"pip.pypa.io/>`_ inserts the function call into a template script, where the "
"return value of ``main`` is passed into :func:`sys.exit`. For example::"
msgstr ""
"Функції ``main`` часто використовуються для створення інструментів "
"командного рядка, вказуючи їх як точки входу для сценаріїв консолі. Коли це "
"зроблено, `pip <https://pip.pypa.io/>`_ вставляє виклик функції в сценарій "
"шаблону, де повернуте значення ``main`` передається в :func:`sys.exit`. "
"Наприклад::"

msgid ""
"Since the call to ``main`` is wrapped in :func:`sys.exit`, the expectation "
"is that your function will return some value acceptable as an input to :func:"
"`sys.exit`; typically, an integer or ``None`` (which is implicitly returned "
"if your function does not have a return statement)."
msgstr ""
"Оскільки виклик ``main`` загорнутий у :func:`sys.exit`, очікується, що ваша "
"функція поверне деяке значення, прийнятне як вхідні дані для :func:`sys."
"exit`; як правило, ціле число або ``None`` (що неявно повертається, якщо "
"ваша функція не має оператора return)."

msgid ""
"By proactively following this convention ourselves, our module will have the "
"same behavior when run directly (i.e. ``python3 echo.py``) as it will have "
"if we later package it as a console script entry-point in a pip-installable "
"package."
msgstr ""
"Завчасно дотримуючись цієї угоди, наш модуль матиме таку саму поведінку під "
"час безпосереднього запуску (тобто ``python3 echo.py``), як і якщо ми "
"пізніше запакуємо його як точку входу сценарію консолі в пакунок, який можна "
"встановити за допомогою pip ."

msgid ""
"In particular, be careful about returning strings from your ``main`` "
"function. :func:`sys.exit` will interpret a string argument as a failure "
"message, so your program will have an exit code of ``1``, indicating "
"failure, and the string will be written to :data:`sys.stderr`.  The ``echo."
"py`` example from earlier exemplifies using the ``sys.exit(main())`` "
"convention."
msgstr ""
"Зокрема, будьте обережні щодо повернення рядків з вашої функції ``main``. :"
"func:`sys.exit` інтерпретує рядковий аргумент як повідомлення про помилку, "
"тому ваша програма матиме код виходу ``1``, що вказує на помилку, і рядок "
"буде записано в :data:`sys.stderr`. Приклад ``echo.py`` з попереднього "
"прикладу використання угоди ``sys.exit(main())``."

msgid ""
"`Python Packaging User Guide <https://packaging.python.org/>`_ contains a "
"collection of tutorials and references on how to distribute and install "
"Python packages with modern tools."
msgstr ""
"`Посібник користувача з пакування Python <https://packaging.python.org/>`_ "
"містить колекцію посібників і довідок про те, як розповсюджувати та "
"встановлювати пакунки Python за допомогою сучасних інструментів."

msgid "``__main__.py`` in Python Packages"
msgstr "``__main__.py`` в пакетах Python"

msgid ""
"If you are not familiar with Python packages, see section :ref:`tut-"
"packages` of the tutorial.  Most commonly, the ``__main__.py`` file is used "
"to provide a command-line interface for a package. Consider the following "
"hypothetical package, \"bandclass\":"
msgstr ""
"Якщо ви не знайомі з пакетами Python, перегляньте розділ :ref:`tut-packages` "
"підручника. Найчастіше файл ``__main__.py`` використовується для "
"забезпечення інтерфейсу командного рядка для пакета. Розглянемо наступний "
"гіпотетичний пакет, \"bandclass\":"

msgid ""
"``__main__.py`` will be executed when the package itself is invoked directly "
"from the command line using the :option:`-m` flag. For example:"
msgstr ""
"``__main__.py`` буде виконано, коли сам пакет викликається безпосередньо з "
"командного рядка за допомогою прапорця :option:`-m`. Наприклад:"

msgid ""
"This command will cause ``__main__.py`` to run. How you utilize this "
"mechanism will depend on the nature of the package you are writing, but in "
"this hypothetical case, it might make sense to allow the teacher to search "
"for students::"
msgstr ""
"Ця команда призведе до запуску ``__main__.py``. Те, як ви використовуєте цей "
"механізм, залежатиме від характеру пакету, який ви пишете, але в цьому "
"гіпотетичному випадку може мати сенс дозволити вчителю шукати учнів:"

msgid ""
"Note that ``from .student import search_students`` is an example of a "
"relative import.  This import style can be used when referencing modules "
"within a package.  For more details, see :ref:`intra-package-references` in "
"the :ref:`tut-modules` section of the tutorial."
msgstr ""
"Зауважте, що ``from .student import search_students`` є прикладом відносного "
"імпорту. Цей стиль імпорту можна використовувати під час посилань на модулі "
"в пакеті. Для отримання додаткової інформації перегляньте :ref:`intra-"
"package-references` у розділі :ref:`tut-modules` підручника."

msgid ""
"The contents of ``__main__.py`` typically isn't fenced with ``if __name__ == "
"'__main__'`` blocks.  Instead, those files are kept short, functions to "
"execute from other modules.  Those other modules can then be easily unit-"
"tested and are properly reusable."
msgstr ""
"Вміст ``__main__.py`` зазвичай не обмежується блоками ``if __name__ == "
"'__main__''``. Натомість ці файли зберігаються короткими, функції "
"виконуються з інших модулів. Ці інші модулі потім можна легко протестувати "
"на модулі та належним чином повторно використовувати."

msgid ""
"If used, an ``if __name__ == '__main__'`` block will still work as expected "
"for a ``__main__.py`` file within a package, because its ``__name__`` "
"attribute will include the package's path if imported::"
msgstr ""
"Якщо використовується, блок ``if __name__ == '__main__'`` все одно "
"працюватиме належним чином для файлу ``__main__.py`` у пакеті, тому що його "
"атрибут ``__name__`` включатиме шлях до пакета, якщо імпортовано ::"

msgid ""
"This won't work for ``__main__.py`` files in the root directory of a .zip "
"file though.  Hence, for consistency, minimal ``__main__.py`` like the :mod:"
"`venv` one mentioned below are preferred."
msgstr ""
"Однак це не працюватиме для файлів ``__main__.py`` у кореневому каталозі "
"файлу .zip. Тому для узгодженості бажано використовувати мінімальний "
"``__main__.py``, наприклад :mod:`venv`, згаданий нижче."

msgid ""
"See :mod:`venv` for an example of a package with a minimal ``__main__.py`` "
"in the standard library. It doesn't contain a ``if __name__ == '__main__'`` "
"block. You can invoke it with ``python3 -m venv [directory]``."
msgstr ""
"Перегляньте :mod:`venv` для прикладу пакета з мінімальним ``__main__.py`` у "
"стандартній бібліотеці. Він не містить блоку ``if __name__ == '__main__''``. "
"Ви можете викликати його за допомогою ``python3 -m venv [каталог]``."

msgid ""
"See :mod:`runpy` for more details on the :option:`-m` flag to the "
"interpreter executable."
msgstr ""
"Перегляньте :mod:`runpy` для отримання додаткової інформації про прапорець :"
"option:`-m` для виконуваного файлу інтерпретатора."

msgid ""
"See :mod:`zipapp` for how to run applications packaged as *.zip* files. In "
"this case Python looks for a ``__main__.py`` file in the root directory of "
"the archive."
msgstr ""
"Перегляньте :mod:`zipapp`, щоб дізнатися, як запускати програми, упаковані у "
"файли *.zip*. У цьому випадку Python шукає файл ``__main__.py`` в кореневому "
"каталозі архіву."

msgid "``import __main__``"
msgstr "``імпорт __main__``"

msgid ""
"Regardless of which module a Python program was started with, other modules "
"running within that same program can import the top-level environment's "
"scope (:term:`namespace`) by importing the ``__main__`` module.  This "
"doesn't import a ``__main__.py`` file but rather whichever module that "
"received the special name ``'__main__'``."
msgstr ""
"Незалежно від того, з якого модуля була запущена програма Python, інші "
"модулі, що працюють у цій же програмі, можуть імпортувати область верхнього "
"рівня середовища (:term:`namespace`), імпортуючи модуль ``__main__``. Це "
"імпортує не файл ``__main__.py``, а будь-який модуль, який отримав "
"спеціальну назву ``'__main__'``."

msgid "Here is an example module that consumes the ``__main__`` namespace::"
msgstr "Ось приклад модуля, який використовує простір імен ``__main__``::"

msgid "Example usage of this module could be as follows::"
msgstr "Приклад використання цього модуля може бути наступним:"

msgid "Now, if we started our program, the result would look like this:"
msgstr "Тепер, якби ми запустили нашу програму, результат виглядав би так:"

msgid ""
"The exit code of the program would be 1, indicating an error. Uncommenting "
"the line with ``my_name = \"Dinsdale\"`` fixes the program and now it exits "
"with status code 0, indicating success:"
msgstr ""
"Код виходу програми буде 1, що вказуватиме на помилку. Розкоментування рядка "
"``my_name = \"Dinsdale\"`` виправляє програму, і тепер вона завершує роботу "
"з кодом статусу 0, що вказує на успіх:"

msgid ""
"Note that importing ``__main__`` doesn't cause any issues with "
"unintentionally running top-level code meant for script use which is put in "
"the ``if __name__ == \"__main__\"`` block of the ``start`` module. Why does "
"this work?"
msgstr ""
"Зауважте, що імпорт ``__main__`` не викликає жодних проблем із ненавмисним "
"запуском коду верхнього рівня, призначеного для використання сценарію, який "
"розміщено в ``if __name__ == \"__main__\"`` блоку ``start`` модуля . Чому це "
"працює?"

msgid ""
"Python inserts an empty ``__main__`` module in :attr:`sys.modules` at "
"interpreter startup, and populates it by running top-level code. In our "
"example this is the ``start`` module which runs line by line and imports "
"``namely``. In turn, ``namely`` imports ``__main__`` (which is really "
"``start``). That's an import cycle! Fortunately, since the partially "
"populated ``__main__`` module is present in :attr:`sys.modules`, Python "
"passes that to ``namely``. See :ref:`Special considerations for __main__ "
"<import-dunder-main>` in the import system's reference for details on how "
"this works."
msgstr ""
"Python вставляє порожній модуль ``__main__`` в :attr:`sys.modules` під час "
"запуску інтерпретатора та заповнює його, запускаючи код верхнього рівня. У "
"нашому прикладі це модуль ``start``, який виконується рядок за рядком і "
"імпортує ``namely``. У свою чергу, ``namely`` імпортує ``__main__`` (що "
"насправді є ``початком``). Це цикл імпорту! На щастя, оскільки частково "
"заповнений модуль ``__main__`` присутній у :attr:`sys.modules`, Python "
"передає його в ``namely``. Перегляньте :ref:`Особливі зауваження для "
"__main__ <import-dunder-main>` у довіднику системи імпорту, щоб дізнатися "
"більше про те, як це працює."

msgid ""
"The Python REPL is another example of a \"top-level environment\", so "
"anything defined in the REPL becomes part of the ``__main__`` scope::"
msgstr ""
"Python REPL є ще одним прикладом \"середовища верхнього рівня\", тому все, "
"що визначено в REPL, стає частиною області ``__main__``::"

msgid ""
"Note that in this case the ``__main__`` scope doesn't contain a ``__file__`` "
"attribute as it's interactive."
msgstr ""
"Зауважте, що в цьому випадку область ``__main__`` не містить атрибут "
"``__file__``, оскільки вона інтерактивна."

msgid ""
"The ``__main__`` scope is used in the implementation of :mod:`pdb` and :mod:"
"`rlcompleter`."
msgstr ""
"Область ``__main__`` використовується в реалізації :mod:`pdb` і :mod:"
"`rlcompleter`."
