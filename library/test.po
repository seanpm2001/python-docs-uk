# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:14+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`test` --- Regression tests package for Python"
msgstr ":mod:`test` --- Пакет регресійних тестів для Python"

msgid ""
"The :mod:`test` package is meant for internal use by Python only. It is "
"documented for the benefit of the core developers of Python. Any use of this "
"package outside of Python's standard library is discouraged as code "
"mentioned here can change or be removed without notice between releases of "
"Python."
msgstr ""
"Пакет :mod:`test` призначений лише для внутрішнього використання Python. Це "
"задокументовано на користь основних розробників Python. Будь-яке "
"використання цього пакета поза стандартною бібліотекою Python не "
"рекомендується, оскільки код, згаданий тут, може змінюватися або бути "
"видалений без попередження між випусками Python."

msgid ""
"The :mod:`test` package contains all regression tests for Python as well as "
"the modules :mod:`test.support` and :mod:`test.regrtest`. :mod:`test."
"support` is used to enhance your tests while :mod:`test.regrtest` drives the "
"testing suite."
msgstr ""
"Пакет :mod:`test` містить усі регресійні тести для Python, а також модулі :"
"mod:`test.support` і :mod:`test.regrtest`. :mod:`test.support` "
"використовується для вдосконалення ваших тестів, а :mod:`test.regrtest` "
"керує набором тестів."

msgid ""
"Each module in the :mod:`test` package whose name starts with ``test_`` is a "
"testing suite for a specific module or feature. All new tests should be "
"written using the :mod:`unittest` or :mod:`doctest` module.  Some older "
"tests are written using a \"traditional\" testing style that compares output "
"printed to ``sys.stdout``; this style of test is considered deprecated."
msgstr ""
"Кожен модуль у пакеті :mod:`test`, назва якого починається з ``test_``, є "
"набором тестів для певного модуля або функції. Усі нові тести слід писати за "
"допомогою модуля :mod:`unittest` або :mod:`doctest`. Деякі старіші тести "
"написані з використанням \"традиційного\" стилю тестування, який порівнює "
"виведені дані з ``sys.stdout``; цей стиль тесту вважається застарілим."

msgid "Module :mod:`unittest`"
msgstr "Модуль :mod:`unittest`"

msgid "Writing PyUnit regression tests."
msgstr "Написання регресійних тестів PyUnit."

msgid "Module :mod:`doctest`"
msgstr "Модуль :mod:`doctest`"

msgid "Tests embedded in documentation strings."
msgstr "Тести, вбудовані в рядки документації."

msgid "Writing Unit Tests for the :mod:`test` package"
msgstr "Написання модульних тестів для пакета :mod:`test`"

msgid ""
"It is preferred that tests that use the :mod:`unittest` module follow a few "
"guidelines. One is to name the test module by starting it with ``test_`` and "
"end it with the name of the module being tested. The test methods in the "
"test module should start with ``test_`` and end with a description of what "
"the method is testing. This is needed so that the methods are recognized by "
"the test driver as test methods. Also, no documentation string for the "
"method should be included. A comment (such as ``# Tests function returns "
"only True or False``) should be used to provide documentation for test "
"methods. This is done because documentation strings get printed out if they "
"exist and thus what test is being run is not stated."
msgstr ""
"Бажано, щоб тести, які використовують модуль :mod:`unittest`, дотримувалися "
"кількох вказівок. Один із них – назвати тестовий модуль, починаючи його з "
"``test_`` і закінчуючи назвою модуля, що тестується. Методи тестування в "
"модулі тестування мають починатися з ``test_`` і закінчуватися описом того, "
"що метод тестує. Це потрібно для того, щоб методи розпізнавались тестовим "
"драйвером як методи тестування. Також не слід включати рядок документації "
"для методу. Коментар (наприклад, ``# Функція тестів повертає лише True або "
"False``) слід використовувати для надання документації щодо методів "
"тестування. Це робиться тому, що рядки документації роздруковуються, якщо "
"вони існують, і тому не вказується, який тест виконується."

msgid "A basic boilerplate is often used::"
msgstr "Часто використовується базовий шаблон:"

msgid ""
"This code pattern allows the testing suite to be run by :mod:`test."
"regrtest`, on its own as a script that supports the :mod:`unittest` CLI, or "
"via the ``python -m unittest`` CLI."
msgstr ""
"Цей шаблон коду дозволяє запускати набір тестів за допомогою :mod:`test."
"regrtest` окремо як сценарій, який підтримує :mod:`unittest` CLI, або через "
"``python -m unittest`` CLI."

msgid ""
"The goal for regression testing is to try to break code. This leads to a few "
"guidelines to be followed:"
msgstr ""
"Мета регресійного тестування — спробувати зламати код. Це призводить до "
"кількох вказівок, яких слід дотримуватися:"

msgid ""
"The testing suite should exercise all classes, functions, and constants. "
"This includes not just the external API that is to be presented to the "
"outside world but also \"private\" code."
msgstr ""
"Набір для тестування повинен використовувати всі класи, функції та "
"константи. Це включає не лише зовнішній API, який має бути представлений "
"зовнішньому світу, а й \"приватний\" код."

msgid ""
"Whitebox testing (examining the code being tested when the tests are being "
"written) is preferred. Blackbox testing (testing only the published user "
"interface) is not complete enough to make sure all boundary and edge cases "
"are tested."
msgstr ""
"Тестування Whitebox (вивчення коду, що тестується під час написання тестів) "
"є кращим. Тестування Blackbox (тестування лише опублікованого інтерфейсу "
"користувача) недостатньо повне, щоб перевірити всі граничні та крайові "
"випадки."

msgid ""
"Make sure all possible values are tested including invalid ones. This makes "
"sure that not only all valid values are acceptable but also that improper "
"values are handled correctly."
msgstr ""
"Переконайтеся, що перевірено всі можливі значення, включно з недійсними. Це "
"гарантує, що не тільки всі дійсні значення є прийнятними, але й неправильні "
"значення обробляються правильно."

msgid ""
"Exhaust as many code paths as possible. Test where branching occurs and thus "
"tailor input to make sure as many different paths through the code are taken."
msgstr ""
"Вичерпайте якомога більше шляхів коду. Перевірте, де відбувається "
"розгалуження, і таким чином адаптуйте вхідні дані, щоб переконатися, що в "
"коді використовується якомога більше різних шляхів."

msgid ""
"Add an explicit test for any bugs discovered for the tested code. This will "
"make sure that the error does not crop up again if the code is changed in "
"the future."
msgstr ""
"Додайте явний тест для будь-яких помилок, виявлених у перевіреному коді. Це "
"гарантує, що помилка не виникне знову, якщо код буде змінено в майбутньому."

msgid ""
"Make sure to clean up after your tests (such as close and remove all "
"temporary files)."
msgstr ""
"Обов’язково очистіть після тестів (наприклад, закрийте та видаліть усі "
"тимчасові файли)."

msgid ""
"If a test is dependent on a specific condition of the operating system then "
"verify the condition already exists before attempting the test."
msgstr ""
"Якщо тест залежить від конкретного стану операційної системи, то перед "
"спробою перевірки переконайтеся, що умова вже існує."

msgid ""
"Import as few modules as possible and do it as soon as possible. This "
"minimizes external dependencies of tests and also minimizes possible "
"anomalous behavior from side-effects of importing a module."
msgstr ""
"Імпортуйте якомога менше модулів і робіть це якомога швидше. Це мінімізує "
"зовнішні залежності тестів, а також мінімізує можливу аномальну поведінку "
"через побічні ефекти імпортування модуля."

msgid ""
"Try to maximize code reuse. On occasion, tests will vary by something as "
"small as what type of input is used. Minimize code duplication by "
"subclassing a basic test class with a class that specifies the input::"
msgstr ""
"Спробуйте максимізувати повторне використання коду. Інколи тести "
"відрізнятимуться дещо настільки незначним, як тип введення, що "
"використовується. Мінімізуйте дублювання коду шляхом створення підкласу "
"базового тестового класу з класом, який визначає вхідні дані:"

msgid ""
"When using this pattern, remember that all classes that inherit from :class:"
"`unittest.TestCase` are run as tests.  The :class:`Mixin` class in the "
"example above does not have any data and so can't be run by itself, thus it "
"does not inherit from :class:`unittest.TestCase`."
msgstr ""
"Використовуючи цей шаблон, пам’ятайте, що всі класи, які успадковують :class:"
"`unittest.TestCase`, виконуються як тести. Клас :class:`Mixin` у наведеному "
"вище прикладі не має жодних даних і тому не може запускатися сам по собі, "
"тому він не успадковує :class:`unittest.TestCase`."

msgid "Test Driven Development"
msgstr "Розробка, орієнтована на тестування"

msgid "A book by Kent Beck on writing tests before code."
msgstr "Книга Кента Бека про написання тестів перед кодом."

msgid "Running tests using the command-line interface"
msgstr "Виконання тестів за допомогою інтерфейсу командного рядка"

msgid ""
"The :mod:`test` package can be run as a script to drive Python's regression "
"test suite, thanks to the :option:`-m` option: :program:`python -m test`. "
"Under the hood, it uses :mod:`test.regrtest`; the call :program:`python -m "
"test.regrtest` used in previous Python versions still works.  Running the "
"script by itself automatically starts running all regression tests in the :"
"mod:`test` package. It does this by finding all modules in the package whose "
"name starts with ``test_``, importing them, and executing the function :func:"
"`test_main` if present or loading the tests via unittest.TestLoader."
"loadTestsFromModule if ``test_main`` does not exist.  The names of tests to "
"execute may also be passed to the script. Specifying a single regression "
"test (:program:`python -m test test_spam`) will minimize output and only "
"print whether the test passed or failed."
msgstr ""
"Пакет :mod:`test` можна запустити як сценарій для запуску набору регресійних "
"тестів Python завдяки параметру :option:`-m`: :program:`python -m test`. Під "
"капотом він використовує :mod:`test.regrtest`; виклик :program:`python -m "
"test.regrtest`, який використовувався в попередніх версіях Python, все ще "
"працює. Запуск сценарію сам по собі автоматично запускає всі регресійні "
"тести в пакеті :mod:`test`. Він робить це, знаходячи всі модулі в пакеті, "
"ім’я яких починається з ``test_``, імпортує їх і виконує функцію :func:"
"`test_main`, якщо вона присутня, або завантажує тести через unittest."
"TestLoader.loadTestsFromModule, якщо ``test_main`` не існує. Назви тестів "
"для виконання також можуть бути передані в сценарій. Якщо вказати єдиний "
"регресійний тест (:program:`python -m test test_spam`), буде мінімізовано "
"вихідні дані та виведено лише те, чи пройдено тест чи не пройдено."

msgid ""
"Running :mod:`test` directly allows what resources are available for tests "
"to use to be set. You do this by using the ``-u`` command-line option. "
"Specifying ``all`` as the value for the ``-u`` option enables all possible "
"resources: :program:`python -m test -uall`. If all but one resource is "
"desired (a more common case), a comma-separated list of resources that are "
"not desired may be listed after ``all``. The command :program:`python -m "
"test -uall,-audio,-largefile` will run :mod:`test` with all resources except "
"the ``audio`` and ``largefile`` resources. For a list of all resources and "
"more command-line options, run :program:`python -m test -h`."
msgstr ""
"Запуск :mod:`test` безпосередньо дозволяє встановити, які ресурси доступні "
"для використання тестами. Це можна зробити за допомогою параметра командного "
"рядка ``-u``. Якщо вказати ``all`` як значення параметра ``-u``, усі можливі "
"ресурси будуть активовані: :program:`python -m test -uall`. Якщо потрібні "
"всі ресурси, окрім одного (частіший випадок), список непотрібних ресурсів, "
"розділених комами, може бути перераховано після ``всі``. Команда :program:"
"`python -m test -uall,-audio,-largefile` запустить :mod:`test` з усіма "
"ресурсами, крім ресурсів ``audio`` і ``largefile``. Щоб отримати список усіх "
"ресурсів і більше параметрів командного рядка, запустіть :program:`python -m "
"test -h`."

msgid ""
"Some other ways to execute the regression tests depend on what platform the "
"tests are being executed on. On Unix, you can run :program:`make test` at "
"the top-level directory where Python was built. On Windows, executing :"
"program:`rt.bat` from your :file:`PCbuild` directory will run all regression "
"tests."
msgstr ""
"Деякі інші способи виконання регресійних тестів залежать від того, на якій "
"платформі виконуються тести. В Unix ви можете запустити :program:`make test` "
"у каталозі верхнього рівня, де було зібрано Python. У Windows виконання :"
"program:`rt.bat` з вашого каталогу :file:`PCbuild` запустить усі регресійні "
"тести."

msgid ":mod:`test.support` --- Utilities for the Python test suite"
msgstr ":mod:`test.support` --- Утиліти для набору тестів Python"

msgid ""
"The :mod:`test.support` module provides support for Python's regression test "
"suite."
msgstr ""
"Модуль :mod:`test.support` забезпечує підтримку набору регресійних тестів "
"Python."

msgid ""
":mod:`test.support` is not a public module.  It is documented here to help "
"Python developers write tests.  The API of this module is subject to change "
"without backwards compatibility concerns between releases."
msgstr ""
":mod:`test.support` не є публічним модулем. Це задокументовано тут, щоб "
"допомогти розробникам Python писати тести. API цього модуля може бути "
"змінений без проблем із зворотною сумісністю між випусками."

msgid "This module defines the following exceptions:"
msgstr "Цей модуль визначає такі винятки:"

msgid ""
"Exception to be raised when a test fails. This is deprecated in favor of :"
"mod:`unittest`\\ -based tests and :class:`unittest.TestCase`'s assertion "
"methods."
msgstr ""
"Виняток, який виникає, коли тест проходить невдало. Це застаріло на користь "
"тестів на основі :mod:`unittest`\\ і методів підтвердження :class:`unittest."
"TestCase`."

msgid ""
"Subclass of :exc:`unittest.SkipTest`. Raised when a resource (such as a "
"network connection) is not available. Raised by the :func:`requires` "
"function."
msgstr ""
"Підклас :exc:`unittest.SkipTest`. Викликається, коли ресурс (наприклад, "
"підключення до мережі) недоступний. Викликається функцією :func:`requires`."

msgid "The :mod:`test.support` module defines the following constants:"
msgstr "Модуль :mod:`test.support` визначає такі константи:"

msgid ""
"``True`` when verbose output is enabled. Should be checked when more "
"detailed information is desired about a running test. *verbose* is set by :"
"mod:`test.regrtest`."
msgstr ""
"``True``, коли ввімкнено докладний вивід. Слід перевірити, якщо потрібна "
"більш детальна інформація про поточний тест. *verbose* встановлюється :mod:"
"`test.regrtest`."

msgid "``True`` if the running interpreter is Jython."
msgstr "``True``, якщо запущеним інтерпретатором є Jython."

msgid "``True`` if the system is Android."
msgstr "``True``, якщо системою є Android."

msgid "Path for shell if not on Windows; otherwise ``None``."
msgstr "Шлях для оболонки, якщо не в Windows; інакше ``Жодного``."

msgid ""
"Timeout in seconds for tests using a network server listening on the network "
"local loopback interface like ``127.0.0.1``."
msgstr ""
"Тайм-аут у секундах для тестів із використанням мережевого сервера, який "
"прослуховує інтерфейс локальної петлі, як-от ``127.0.0.1``."

msgid ""
"The timeout is long enough to prevent test failure: it takes into account "
"that the client and the server can run in different threads or even "
"different processes."
msgstr ""
"Час очікування достатньо довгий, щоб запобігти помилці тесту: він враховує, "
"що клієнт і сервер можуть працювати в різних потоках або навіть різних "
"процесах."

msgid ""
"The timeout should be long enough for :meth:`~socket.socket.connect`, :meth:"
"`~socket.socket.recv` and :meth:`~socket.socket.send` methods of :class:"
"`socket.socket`."
msgstr ""
"Час очікування має бути достатнім для методів :meth:`~socket.socket."
"connect`, :meth:`~socket.socket.recv` і :meth:`~socket.socket.send` :class:"
"`socket. розетка`."

msgid "Its default value is 5 seconds."
msgstr "Його значення за замовчуванням становить 5 секунд."

msgid "See also :data:`INTERNET_TIMEOUT`."
msgstr "Дивіться також :data:`INTERNET_TIMEOUT`."

msgid "Timeout in seconds for network requests going to the internet."
msgstr "Тайм-аут у секундах для мережевих запитів, що надходять до Інтернету."

msgid ""
"The timeout is short enough to prevent a test to wait for too long if the "
"internet request is blocked for whatever reason."
msgstr ""
"Тайм-аут досить короткий, щоб запобігти надто довгому очікуванню тесту, якщо "
"інтернет-запит заблоковано з будь-якої причини."

msgid ""
"Usually, a timeout using :data:`INTERNET_TIMEOUT` should not mark a test as "
"failed, but skip the test instead: see :func:`~test.support.socket_helper."
"transient_internet`."
msgstr ""
"Зазвичай тайм-аут за допомогою :data:`INTERNET_TIMEOUT` не повинен позначати "
"тест як невдалий, а натомість пропускати тест: див. :func:`~test.support."
"socket_helper.transient_internet`."

msgid "Its default value is 1 minute."
msgstr "Його значення за умовчанням становить 1 хвилину."

msgid "See also :data:`LOOPBACK_TIMEOUT`."
msgstr "Дивіться також :data:`LOOPBACK_TIMEOUT`."

msgid ""
"Timeout in seconds to mark a test as failed if the test takes \"too long\"."
msgstr ""
"Тайм-аут у секундах для позначення тесту як невдалого, якщо тест триває "
"\"занадто довго\"."

msgid ""
"The timeout value depends on the regrtest ``--timeout`` command line option."
msgstr ""
"Значення часу очікування залежить від параметра командного рядка regrtest "
"``--timeout``."

msgid ""
"If a test using :data:`SHORT_TIMEOUT` starts to fail randomly on slow "
"buildbots, use :data:`LONG_TIMEOUT` instead."
msgstr ""
"Якщо тест із використанням :data:`SHORT_TIMEOUT` починає випадково зазнавати "
"помилок на повільних роботах для збірки, використовуйте натомість :data:"
"`LONG_TIMEOUT`."

msgid "Its default value is 30 seconds."
msgstr "Його значення за замовчуванням становить 30 секунд."

msgid "Timeout in seconds to detect when a test hangs."
msgstr "Час очікування в секундах для виявлення зависання тесту."

msgid ""
"It is long enough to reduce the risk of test failure on the slowest Python "
"buildbots. It should not be used to mark a test as failed if the test takes "
"\"too long\".  The timeout value depends on the regrtest ``--timeout`` "
"command line option."
msgstr ""
"Його достатньо, щоб зменшити ризик невдачі тесту на найповільніших роботах "
"для збірки Python. Його не слід використовувати для позначення тесту як "
"невдалого, якщо тест триває \"занадто довго\". Значення часу очікування "
"залежить від параметра командного рядка regrtest ``--timeout``."

msgid "Its default value is 5 minutes."
msgstr "Його значення за замовчуванням становить 5 хвилин."

msgid ""
"See also :data:`LOOPBACK_TIMEOUT`, :data:`INTERNET_TIMEOUT` and :data:"
"`SHORT_TIMEOUT`."
msgstr ""
"Дивіться також :data:`LOOPBACK_TIMEOUT`, :data:`INTERNET_TIMEOUT` і :data:"
"`SHORT_TIMEOUT`."

msgid "Set when tests can be skipped when they are not useful for PGO."
msgstr "Встановіть, коли тести можна пропускати, якщо вони не корисні для PGO."

msgid ""
"A constant that is likely larger than the underlying OS pipe buffer size, to "
"make writes blocking."
msgstr ""
"Константа, яка, ймовірно, більша за розмір основного буфера каналу ОС, щоб "
"блокувати запис."

msgid ""
"A constant that is likely larger than the underlying OS socket buffer size, "
"to make writes blocking."
msgstr ""
"Константа, яка, імовірно, більша за розмір буфера основного сокета ОС, щоб "
"блокувати запис."

msgid "Set to the top level directory that contains :mod:`test.support`."
msgstr "Встановіть каталог верхнього рівня, який містить :mod:`test.support`."

msgid "Set to the top level directory for the test package."
msgstr "Встановіть каталог верхнього рівня для тестового пакета."

msgid "Set to the ``data`` directory within the test package."
msgstr "Встановіть каталог ``data`` в тестовому пакеті."

msgid "Set to :data:`sys.maxsize` for big memory tests."
msgstr "Встановіть значення :data:`sys.maxsize` для великих тестів пам’яті."

msgid ""
"Set by :func:`set_memlimit` as the memory limit for big memory tests. "
"Limited by :data:`MAX_Py_ssize_t`."
msgstr ""
"Встановлено :func:`set_memlimit` як обмеження пам’яті для великих тестів "
"пам’яті. Обмежено :data:`MAX_Py_ssize_t`."

msgid ""
"Set by :func:`set_memlimit` as the memory limit for big memory tests.  Not "
"limited by :data:`MAX_Py_ssize_t`."
msgstr ""
"Встановлено :func:`set_memlimit` як обмеження пам’яті для великих тестів "
"пам’яті. Не обмежено :data:`MAX_Py_ssize_t`."

msgid ""
"Set to ``True`` if Python is built without docstrings (the :c:macro:"
"`WITH_DOC_STRINGS` macro is not defined). See the :option:`configure --"
"without-doc-strings <--without-doc-strings>` option."
msgstr ""
"Установіть значення ``True``, якщо Python створено без рядків документації "
"(макрос :c:macro:`WITH_DOC_STRINGS` не визначено). Перегляньте параметр :"
"option:`configure --without-doc-strings <--without-doc-strings>`."

msgid "See also the :data:`HAVE_DOCSTRINGS` variable."
msgstr "Перегляньте також змінну :data:`HAVE_DOCSTRINGS`."

msgid ""
"Set to ``True`` if function docstrings are available. See the :option:"
"`python -OO <-O>` option, which strips docstrings of functions implemented "
"in Python."
msgstr ""
"Установіть значення ``True``, якщо доступні рядки документації функцій. "
"Перегляньте параметр :option:`python -OO <-O>`, який видаляє рядки "
"документів функцій, реалізованих у Python."

msgid "See also the :data:`MISSING_C_DOCSTRINGS` variable."
msgstr "Перегляньте також змінну :data:`MISSING_C_DOCSTRINGS`."

msgid "Define the URL of a dedicated HTTP server for the network tests."
msgstr "Визначте URL-адресу виділеного HTTP-сервера для мережевих тестів."

msgid "Object that is equal to anything.  Used to test mixed type comparison."
msgstr ""
"Об'єкт, який дорівнює будь-чому. Використовується для перевірки порівняння "
"змішаного типу."

msgid ""
"Object that is not equal to anything (even to :data:`ALWAYS_EQ`). Used to "
"test mixed type comparison."
msgstr ""
"Об’єкт, який нічому не дорівнює (навіть :data:`ALWAYS_EQ`). Використовується "
"для перевірки порівняння змішаного типу."

msgid ""
"Object that is greater than anything (except itself). Used to test mixed "
"type comparison."
msgstr ""
"Об'єкт, який є більшим за все (крім самого себе). Використовується для "
"перевірки порівняння змішаного типу."

msgid ""
"Object that is less than anything (except itself). Used to test mixed type "
"comparison."
msgstr ""
"Об'єкт, який є меншим за все (крім себе). Використовується для перевірки "
"порівняння змішаного типу."

msgid "The :mod:`test.support` module defines the following functions:"
msgstr "Модуль :mod:`test.support` визначає такі функції:"

msgid ""
"Return ``True`` if *resource* is enabled and available. The list of "
"available resources is only set when :mod:`test.regrtest` is executing the "
"tests."
msgstr ""
"Повертає ``True``, якщо *ресурс* увімкнено та доступний. Список доступних "
"ресурсів встановлюється лише тоді, коли :mod:`test.regrtest` виконує тести."

msgid "Return ``True`` if Python was not built with ``-O0`` or ``-Og``."
msgstr "Повертає ``True``, якщо Python не було зібрано з ``-O0`` або ``-Og``."

msgid "Return :data:`_testcapi.WITH_PYMALLOC`."
msgstr "Повернути :data:`_testcapi.WITH_PYMALLOC`."

msgid ""
"Raise :exc:`ResourceDenied` if *resource* is not available. *msg* is the "
"argument to :exc:`ResourceDenied` if it is raised. Always returns ``True`` "
"if called by a function whose ``__name__`` is ``'__main__'``. Used when "
"tests are executed by :mod:`test.regrtest`."
msgstr ""
"Підніміть :exc:`ResourceDenied`, якщо *ресурс* недоступний. *msg* є "
"аргументом для :exc:`ResourceDenied`, якщо він викликаний. Завжди повертає "
"``True``, якщо викликається функцією, ``__name__`` якої є ``'__main__''``. "
"Використовується, коли тести виконуються :mod:`test.regrtest`."

msgid "Return a repr of *dict* with keys sorted."
msgstr "Повертає повтор *dict* із відсортованими ключами."

msgid ""
"Return the path to the file named *filename*. If no match is found "
"*filename* is returned. This does not equal a failure since it could be the "
"path to the file."
msgstr ""
"Поверніть шлях до файлу з назвою *filename*. Якщо збігів не знайдено, "
"повертається *ім’я файлу*. Це не означає помилку, оскільки це може бути шлях "
"до файлу."

msgid ""
"Setting *subdir* indicates a relative path to use to find the file rather "
"than looking directly in the path directories."
msgstr ""
"Параметр *subdir* вказує на відносний шлях для пошуку файлу, а не шукати "
"безпосередньо в каталогах шляхів."

msgid ""
"Determine whether *test* matches the patterns set in :func:`set_match_tests`."
msgstr ""
"Визначте, чи *test* відповідає шаблонам, встановленим у :func:"
"`set_match_tests`."

msgid ""
"Define match patterns on test filenames and test method names for filtering "
"tests."
msgstr ""
"Визначте шаблони відповідності для імен тестових файлів і імен тестових "
"методів для фільтрації тестів."

msgid ""
"Execute :class:`unittest.TestCase` subclasses passed to the function. The "
"function scans the classes for methods starting with the prefix ``test_`` "
"and executes the tests individually."
msgstr ""
"Виконати підкласи :class:`unittest.TestCase`, передані функції. Функція "
"сканує класи на наявність методів, що починаються з префікса ``test_``, і "
"виконує тести окремо."

msgid ""
"It is also legal to pass strings as parameters; these should be keys in "
"``sys.modules``. Each associated module will be scanned by ``unittest."
"TestLoader.loadTestsFromModule()``. This is usually seen in the following :"
"func:`test_main` function::"
msgstr ""
"Також допустимо передавати рядки як параметри; це мають бути ключі в ``sys."
"modules``. Кожен пов’язаний модуль буде скановано за допомогою ``unittest."
"TestLoader.loadTestsFromModule()``. Зазвичай це видно у такій функції :func:"
"`test_main`::"

msgid "This will run all tests defined in the named module."
msgstr "Це запустить усі тести, визначені у названому модулі."

msgid ""
"Run :func:`doctest.testmod` on the given *module*.  Return ``(failure_count, "
"test_count)``."
msgstr ""
"Запустіть :func:`doctest.testmod` на заданому *модулі*. Повернення "
"``(failure_count, test_count)``."

msgid ""
"If *verbosity* is ``None``, :func:`doctest.testmod` is run with verbosity "
"set to :data:`verbose`.  Otherwise, it is run with verbosity set to "
"``None``.  *optionflags* is passed as ``optionflags`` to :func:`doctest."
"testmod`."
msgstr ""
"Якщо *detality* має значення ``None``, :func:`doctest.testmod` запускається "
"з детальністю, встановленою на :data:`verbose`. В іншому випадку він "
"запускається з параметром детальності, встановленим на ``None``. "
"*optionflags* передається як ``optionflags`` до :func:`doctest.testmod`."

msgid ""
"Set the :func:`sys.setswitchinterval` to the given *interval*.  Defines a "
"minimum interval for Android systems to prevent the system from hanging."
msgstr ""
"Установіть :func:`sys.setswitchinterval` на заданий *інтервал*. Визначає "
"мінімальний інтервал для систем Android, щоб запобігти зависанню системи."

msgid ""
"Use this check to guard CPython's implementation-specific tests or to run "
"them only on the implementations guarded by the arguments.  This function "
"returns ``True`` or ``False`` depending on the host platform. Example usage::"
msgstr ""
"Використовуйте цю перевірку, щоб захистити специфічні для реалізації тести "
"CPython або запустити їх лише на реалізаціях, які захищені аргументами. Ця "
"функція повертає ``True`` або ``False`` залежно від хост-платформи. Приклад "
"використання::"

msgid ""
"Set the values for :data:`max_memuse` and :data:`real_max_memuse` for big "
"memory tests."
msgstr ""
"Установіть значення для :data:`max_memuse` і :data:`real_max_memuse` для "
"великих тестів пам’яті."

msgid ""
"Store the value from *stdout*.  It is meant to hold the stdout at the time "
"the regrtest began."
msgstr ""
"Збережіть значення з *stdout*. Він призначений для утримання стандартного "
"виводу під час початку перевірки."

msgid ""
"Return the original stdout set by :func:`record_original_stdout` or ``sys."
"stdout`` if it's not set."
msgstr ""
"Повертає оригінальний stdout, встановлений :func:`record_original_stdout` "
"або ``sys.stdout``, якщо він не встановлений."

msgid ""
"Return a list of command line arguments reproducing the current settings in "
"``sys.flags`` and ``sys.warnoptions``."
msgstr ""
"Повертає список аргументів командного рядка, що відтворюють поточні "
"параметри в ``sys.flags`` і ``sys.warnoptions``."

msgid ""
"Return a list of command line arguments reproducing the current optimization "
"settings in ``sys.flags``."
msgstr ""
"Повертає список аргументів командного рядка, що відтворюють поточні "
"параметри оптимізації в ``sys.flags``."

msgid ""
"A context managers that temporarily replaces the named stream with :class:"
"`io.StringIO` object."
msgstr ""
"Менеджер контексту, який тимчасово замінює названий потік на об’єкт :class:"
"`io.StringIO`."

msgid "Example use with output streams::"
msgstr "Приклад використання з вихідними потоками::"

msgid "Example use with input stream::"
msgstr "Приклад використання з вхідним потоком::"

msgid "A context manager that temporary disables :mod:`faulthandler`."
msgstr "Контекстний менеджер, який тимчасово вимикає :mod:`faulthandler`."

msgid ""
"Force as many objects as possible to be collected.  This is needed because "
"timely deallocation is not guaranteed by the garbage collector.  This means "
"that ``__del__`` methods may be called later than expected and weakrefs may "
"remain alive for longer than expected."
msgstr ""
"Змусьте зібрати якомога більше предметів. Це необхідно, тому що своєчасне "
"звільнення не гарантується збирачем сміття. Це означає, що методи "
"``__del__`` можуть викликатися пізніше, ніж очікувалося, а слабкі посилання "
"можуть залишатися активними довше, ніж очікувалося."

msgid ""
"A context manager that disables the garbage collector on entry. On exit, the "
"garbage collector is restored to its prior state."
msgstr ""
"Менеджер контексту, який вимикає збирач сміття під час входу. Після виходу "
"збирач сміття відновлюється до попереднього стану."

msgid "Context manager to swap out an attribute with a new object."
msgstr "Менеджер контексту для заміни атрибута на новий об’єкт."

msgid "Usage::"
msgstr "Використання::"

msgid ""
"This will set ``obj.attr`` to 5 for the duration of the ``with`` block, "
"restoring the old value at the end of the block.  If ``attr`` doesn't exist "
"on ``obj``, it will be created and then deleted at the end of the block."
msgstr ""
"Це встановить для ``obj.attr`` значення 5 протягом блоку ``with``, "
"відновлюючи старе значення в кінці блоку. Якщо ``attr`` не існує в ``obj``, "
"його буде створено, а потім видалено в кінці блоку."

msgid ""
"The old value (or ``None`` if it doesn't exist) will be assigned to the "
"target of the \"as\" clause, if there is one."
msgstr ""
"Старе значення (або ``None``, якщо воно не існує) буде призначено цільовому "
"об’єкту \"as\", якщо воно є."

msgid "Context manager to swap out an item with a new object."
msgstr "Менеджер контексту для заміни елемента новим об’єктом."

msgid ""
"This will set ``obj[\"item\"]`` to 5 for the duration of the ``with`` block, "
"restoring the old value at the end of the block. If ``item`` doesn't exist "
"on ``obj``, it will be created and then deleted at the end of the block."
msgstr ""
"Це встановить для ``obj[\"item\"]`` значення 5 протягом блоку ``with``, "
"відновлюючи старе значення в кінці блоку. Якщо ``item`` не існує в ``obj``, "
"його буде створено, а потім видалено в кінці блоку."

msgid ""
"Call the ``flush()`` method on :data:`sys.stdout` and then on :data:`sys."
"stderr`. It can be used to make sure that the logs order is consistent "
"before writing into stderr."
msgstr ""

msgid ""
"Print a warning into :data:`sys.__stderr__`. Format the message as: "
"``f\"Warning -- {msg}\"``. If *msg* is made of multiple lines, add "
"``\"Warning -- \"`` prefix to each line."
msgstr ""
"Надрукуйте попередження в :data:`sys.__stderr__`. Відформатуйте повідомлення "
"так: ``f\"Попередження -- {msg}\"``. Якщо *повідомлення* складається з "
"кількох рядків, додайте до кожного рядка префікс \"Попередження --\"."

msgid ""
"Wait until process *pid* completes and check that the process exit code is "
"*exitcode*."
msgstr ""
"Зачекайте, поки процес *pid* завершиться, і переконайтеся, що код виходу "
"процесу *exitcode*."

msgid ""
"Raise an :exc:`AssertionError` if the process exit code is not equal to "
"*exitcode*."
msgstr ""
"Викликати :exc:`AssertionError`, якщо код виходу процесу не дорівнює "
"*exitcode*."

msgid ""
"If the process runs longer than *timeout* seconds (:data:`SHORT_TIMEOUT` by "
"default), kill the process and raise an :exc:`AssertionError`. The timeout "
"feature is not available on Windows."
msgstr ""
"Якщо процес виконується довше *timeout* секунд (:data:`SHORT_TIMEOUT` за "
"замовчуванням), завершіть процес і викликайте :exc:`AssertionError`. Функція "
"тайм-ауту недоступна в Windows."

msgid ""
"Return the size of the :c:type:`PyObject` whose structure members are "
"defined by *fmt*. The returned value includes the size of the Python object "
"header and alignment."
msgstr ""
"Повертає розмір :c:type:`PyObject`, члени структури якого визначені *fmt*. "
"Повернене значення включає розмір заголовка об’єкта Python і вирівнювання."

msgid ""
"Return the size of the :c:type:`PyVarObject` whose structure members are "
"defined by *fmt*. The returned value includes the size of the Python object "
"header and alignment."
msgstr ""
"Повертає розмір :c:type:`PyVarObject`, члени структури якого визначено "
"*fmt*. Повернене значення включає розмір заголовка об’єкта Python і "
"вирівнювання."

msgid ""
"For testcase *test*, assert that the ``sys.getsizeof`` for *o* plus the GC "
"header size equals *size*."
msgstr ""
"Для тестового випадку *test* переконайтеся, що ``sys.getsizeof`` для *o* "
"плюс розмір заголовка GC дорівнює *size*."

msgid ""
"A decorator to conditionally mark tests with :func:`unittest."
"expectedFailure`. Any use of this decorator should have an associated "
"comment identifying the relevant tracker issue."
msgstr ""
"Декоратор для умовного позначення тестів :func:`unittest.expectedFailure`. "
"Будь-яке використання цього декоратора повинно мати відповідний коментар, що "
"визначає відповідну проблему трекера."

msgid ""
"A decorator that skips the decorated test on TLS certification validation "
"failures."
msgstr ""
"Декоратор, який пропускає декорований тест на помилки перевірки сертифікації "
"TLS."

msgid ""
"A decorator for running a function in a different locale, correctly "
"resetting it after it has finished.  *catstr* is the locale category as a "
"string (for example ``\"LC_ALL\"``).  The *locales* passed will be tried "
"sequentially, and the first valid locale will be used."
msgstr ""
"Декоратор для запуску функції в іншій локалі, правильно скидаючи її після "
"завершення. *catstr* — це категорія локалі у вигляді рядка (наприклад, "
"``\"LC_ALL\"``). Передані *локалі* перевірятимуться послідовно, і "
"використовуватиметься перша дійсна локаль."

msgid ""
"A decorator for running a function in a specific timezone, correctly "
"resetting it after it has finished."
msgstr ""
"Декоратор для запуску функції в певному часовому поясі, правильно скидаючи "
"її після завершення."

msgid ""
"Decorator for the minimum version when running test on FreeBSD.  If the "
"FreeBSD version is less than the minimum, the test is skipped."
msgstr ""
"Декоратор для мінімальної версії під час виконання тесту на FreeBSD. Якщо "
"версія FreeBSD нижча за мінімальну, тест пропускається."

msgid ""
"Decorator for the minimum version when running test on Linux.  If the Linux "
"version is less than the minimum, the test is skipped."
msgstr ""
"Декоратор для мінімальної версії під час виконання тесту в Linux. Якщо "
"версія Linux нижча за мінімальну, тест пропускається."

msgid ""
"Decorator for the minimum version when running test on macOS.  If the macOS "
"version is less than the minimum, the test is skipped."
msgstr ""
"Декоратор для мінімальної версії під час виконання тесту на macOS. Якщо "
"версія macOS нижча за мінімальну, тест пропускається."

msgid "Decorator for skipping tests on non-IEEE 754 platforms."
msgstr "Декоратор для пропуску тестів на платформах не IEEE 754."

msgid "Decorator for skipping tests if :mod:`zlib` doesn't exist."
msgstr "Декоратор для пропуску тестів, якщо :mod:`zlib` не існує."

msgid "Decorator for skipping tests if :mod:`gzip` doesn't exist."
msgstr "Декоратор для пропуску тестів, якщо :mod:`gzip` не існує."

msgid "Decorator for skipping tests if :mod:`bz2` doesn't exist."
msgstr "Декоратор для пропуску тестів, якщо :mod:`bz2` не існує."

msgid "Decorator for skipping tests if :mod:`lzma` doesn't exist."
msgstr "Декоратор для пропуску тестів, якщо :mod:`lzma` не існує."

msgid "Decorator for skipping tests if *resource* is not available."
msgstr "Декоратор для пропуску тестів, якщо *ресурс* недоступний."

msgid "Decorator for only running the test if :data:`HAVE_DOCSTRINGS`."
msgstr "Декоратор лише для запуску тесту, якщо :data:`HAVE_DOCSTRINGS`."

msgid "Decorator for tests only applicable to CPython."
msgstr "Декоратор для тестів, застосовний лише до CPython."

msgid ""
"Decorator for invoking :func:`check_impl_detail` on *guards*.  If that "
"returns ``False``, then uses *msg* as the reason for skipping the test."
msgstr ""
"Декоратор для виклику :func:`check_impl_detail` на *guards*. Якщо це "
"повертає ``False``, тоді використовується *msg* як причина для пропуску "
"тесту."

msgid "Decorator to temporarily turn off tracing for the duration of the test."
msgstr "Декоратор тимчасово вимикає трасування на час тесту."

msgid ""
"Decorator for tests which involve reference counting.  The decorator does "
"not run the test if it is not run by CPython.  Any trace function is unset "
"for the duration of the test to prevent unexpected refcounts caused by the "
"trace function."
msgstr ""
"Декоратор для тестів, які включають підрахунок посилань. Декоратор не "
"запускає тест, якщо його не запускає CPython. Будь-яка функція трасування не "
"налаштована на час тесту, щоб запобігти неочікуваним повторним підрахункам, "
"викликаним функцією трасування."

msgid "Decorator for bigmem tests."
msgstr "Декоратор для тестів bigmem."

msgid ""
"*size* is a requested size for the test (in arbitrary, test-interpreted "
"units.)  *memuse* is the number of bytes per unit for the test, or a good "
"estimate of it.  For example, a test that needs two byte buffers, of 4 GiB "
"each, could be decorated with ``@bigmemtest(size=_4G, memuse=2)``."
msgstr ""
"*size* — це запитуваний розмір для тесту (у довільних, інтерпретованих "
"тестом одиницях). *memuse* — це кількість байтів на одиницю для тесту або її "
"хороша оцінка. Наприклад, тест, який потребує двох байтових буферів, по 4 "
"ГіБ кожен, можна прикрасити ``@bigmemtest(size=_4G, memuse=2)``."

msgid ""
"The *size* argument is normally passed to the decorated test method as an "
"extra argument.  If *dry_run* is ``True``, the value passed to the test "
"method may be less than the requested value.  If *dry_run* is ``False``, it "
"means the test doesn't support dummy runs when ``-M`` is not specified."
msgstr ""
"Аргумент *size* зазвичай передається декорованому тестовому методу як "
"додатковий аргумент. Якщо *dry_run* має значення ``True``, значення, "
"передане в метод тестування, може бути меншим за запитуване значення. Якщо "
"*dry_run* має значення ``False``, це означає, що тест не підтримує фіктивні "
"запуски, якщо ``-M`` не вказано."

msgid "Decorator for tests that fill the address space."
msgstr "Декоратор для тестів, які заповнюють адресний простір."

msgid ""
"Test for syntax errors in *statement* by attempting to compile *statement*. "
"*testcase* is the :mod:`unittest` instance for the test.  *errtext* is the "
"regular expression which should match the string representation of the "
"raised :exc:`SyntaxError`.  If *lineno* is not ``None``, compares to the "
"line of the exception.  If *offset* is not ``None``, compares to the offset "
"of the exception."
msgstr ""
"Перевірте синтаксичні помилки в *операторі*, спробувавши скомпілювати "
"*оператор*. *testcase* — це екземпляр :mod:`unittest` для тесту. *errtext* — "
"це регулярний вираз, який має відповідати рядковому представленню "
"викликаної :exc:`SyntaxError`. Якщо *lineno* не є ``None``, порівнюється з "
"рядком винятку. Якщо *offset* не є ``None``, порівнюється зі зміщенням "
"винятку."

msgid "Open *url*.  If open fails, raises :exc:`TestFailed`."
msgstr ""
"Відкрийте *url*. Якщо відкрити не вдається, викликає :exc:`TestFailed`."

msgid ""
"Use this at the end of ``test_main`` whenever sub-processes are started. "
"This will help ensure that no extra children (zombies) stick around to hog "
"resources and create problems when looking for refleaks."
msgstr ""
"Використовуйте це в кінці ``test_main`` кожного разу, коли запускаються "
"підпроцеси. Це допоможе гарантувати, що жодні зайві діти (зомбі) не "
"залишаться, щоб витягнути ресурси та створювати проблеми під час пошуку "
"рефлексів."

msgid ""
"Get an attribute, raising :exc:`unittest.SkipTest` if :exc:`AttributeError` "
"is raised."
msgstr ""
"Отримати атрибут, викликаючи :exc:`unittest.SkipTest`, якщо виникає :exc:"
"`AttributeError`."

msgid ""
"Context manager catching unraisable exception using :func:`sys."
"unraisablehook`."
msgstr ""
"Менеджер контексту перехоплює виняток, який неможливо викликати, "
"використовуючи :func:`sys.unraisablehook`."

msgid ""
"Storing the exception value (``cm.unraisable.exc_value``) creates a "
"reference cycle. The reference cycle is broken explicitly when the context "
"manager exits."
msgstr ""
"Зберігання значення винятку (``cm.unraisable.exc_value``) створює еталонний "
"цикл. Посилальний цикл явно розривається, коли контекстний менеджер виходить."

msgid ""
"Storing the object (``cm.unraisable.object``) can resurrect it if it is set "
"to an object which is being finalized. Exiting the context manager clears "
"the stored object."
msgstr ""
"Зберігання об’єкта (``cm.unraisable.object``) може воскресити його, якщо для "
"нього встановлено об’єкт, який завершується. Вихід із менеджера контексту "
"очищає збережений об’єкт."

msgid ""
"Generic implementation of the :mod:`unittest` ``load_tests`` protocol for "
"use in test packages.  *pkg_dir* is the root directory of the package; "
"*loader*, *standard_tests*, and *pattern* are the arguments expected by "
"``load_tests``.  In simple cases, the test package's ``__init__.py`` can be "
"the following::"
msgstr ""
"Загальна реалізація протоколу :mod:`unittest` ``load_tests`` для "
"використання в тестових пакетах. *pkg_dir* — кореневий каталог пакета; "
"*loader*, *standard_tests* і *pattern* є аргументами, які очікуються для "
"``load_tests``. У простих випадках тестовий пакет ``__init__.py`` може бути "
"наступним:"

msgid ""
"Returns the set of attributes, functions or methods of *ref_api* not found "
"on *other_api*, except for a defined list of items to be ignored in this "
"check specified in *ignore*."
msgstr ""
"Повертає набір атрибутів, функцій або методів *ref_api*, яких немає в "
"*other_api*, за винятком визначеного списку елементів, які слід ігнорувати в "
"цій перевірці, указаній у *ignore*."

msgid ""
"By default this skips private attributes beginning with '_' but includes all "
"magic methods, i.e. those starting and ending in '__'."
msgstr ""
"За замовчуванням це пропускає приватні атрибути, що починаються з \"_\", але "
"включає всі магічні методи, тобто ті, що починаються та закінчуються на "
"\"__\"."

msgid ""
"Override *object_to_patch.attr_name* with *new_value*.  Also add cleanup "
"procedure to *test_instance* to restore *object_to_patch* for *attr_name*.  "
"The *attr_name* should be a valid attribute for *object_to_patch*."
msgstr ""
"Замініть *object_to_patch.attr_name* на *new_value*. Також додайте процедуру "
"очищення до *test_instance*, щоб відновити *object_to_patch* для "
"*attr_name*. *attr_name* має бути дійсним атрибутом для *object_to_patch*."

msgid ""
"Run *code* in subinterpreter.  Raise :exc:`unittest.SkipTest` if :mod:"
"`tracemalloc` is enabled."
msgstr ""
"Запустіть *код* у субінтерпретаторі. Підніміть :exc:`unittest.SkipTest`, "
"якщо :mod:`tracemalloc` увімкнено."

msgid "Assert instances of *cls* are deallocated after iterating."
msgstr "Екземпляри Assert *cls* звільняються після ітерації."

msgid ""
"Check for the existence of the compiler executables whose names are listed "
"in *cmd_names* or all the compiler executables when *cmd_names* is empty and "
"return the first missing executable or ``None`` when none is found missing."
msgstr ""
"Перевірте наявність виконуваних файлів компілятора, імена яких указано в "
"*cmd_names*, або всіх виконуваних файлів компілятора, якщо *cmd_names* "
"порожній, і поверніть перший відсутній виконуваний файл або ``None``, якщо "
"жоден відсутній."

msgid ""
"Assert that the ``__all__`` variable of *module* contains all public names."
msgstr ""
"Переконайтеся, що змінна ``__all__`` *module* містить усі публічні імена."

msgid ""
"The module's public names (its API) are detected automatically based on "
"whether they match the public name convention and were defined in *module*."
msgstr ""
"Загальнодоступні імена модуля (його API) визначаються автоматично залежно "
"від того, чи відповідають вони загальнодоступним іменам і чи були визначені "
"в *module*."

msgid ""
"The *name_of_module* argument can specify (as a string or tuple thereof) "
"what module(s) an API could be defined in order to be detected as a public "
"API. One case for this is when *module* imports part of its public API from "
"other modules, possibly a C backend (like ``csv`` and its ``_csv``)."
msgstr ""
"Аргумент *name_of_module* може вказувати (як рядок або його кортеж), який(і) "
"модуль(и) API може бути визначений, щоб бути визначеним як публічний API. "
"Одним із випадків цього є те, що *module* імпортує частину свого "
"загальнодоступного API з інших модулів, можливо, серверної частини C "
"(наприклад, ``csv`` і його ``_csv``)."

msgid ""
"The *extra* argument can be a set of names that wouldn't otherwise be "
"automatically detected as \"public\", like objects without a proper "
"``__module__`` attribute. If provided, it will be added to the automatically "
"detected ones."
msgstr ""
"Аргументом *extra* може бути набір імен, які інакше не були б автоматично "
"визначені як \"загальнодоступні\", як об’єкти без належного атрибута "
"``__module__``. Якщо вказано, його буде додано до автоматично виявлених."

msgid ""
"The *not_exported* argument can be a set of names that must not be treated "
"as part of the public API even though their names indicate otherwise."
msgstr ""
"Аргумент *not_exported* може бути набором імен, які не можна розглядати як "
"частину загальнодоступного API, навіть якщо їхні імена вказують на інше."

msgid "Example use::"
msgstr "Приклад використання::"

msgid ""
"Skip tests if the :mod:`multiprocessing.synchronize` module is missing, if "
"there is no available semaphore implementation, or if creating a lock raises "
"an :exc:`OSError`."
msgstr ""
"Пропустіть тести, якщо модуль :mod:`multiprocessing.synchronize` відсутній, "
"якщо немає доступної реалізації семафора або якщо створення блокування "
"викликає :exc:`OSError`."

msgid "Assert that type *tp* cannot be instantiated using *args* and *kwds*."
msgstr ""
"Стверджуйте, що тип *tp* не може бути створений за допомогою *args* і *kwds*."

msgid ""
"This function returns a context manager that will change the global :func:"
"`sys.set_int_max_str_digits` setting for the duration of the context to "
"allow execution of test code that needs a different limit on the number of "
"digits when converting between an integer and string."
msgstr ""

msgid "The :mod:`test.support` module defines the following classes:"
msgstr "Модуль :mod:`test.support` визначає такі класи:"

msgid ""
"A context manager used to try to prevent crash dialog popups on tests that "
"are expected to crash a subprocess."
msgstr ""
"Менеджер контексту, який використовується для запобігання діалоговим вікнам "
"збою під час тестів, які, як очікується, призведуть до збою підпроцесу."

msgid ""
"On Windows, it disables Windows Error Reporting dialogs using `SetErrorMode "
"<https://msdn.microsoft.com/en-us/library/windows/desktop/ms680621.aspx>`_."
msgstr ""
"У Windows він вимикає діалогові вікна звітів про помилки Windows за "
"допомогою `SetErrorMode <https://msdn.microsoft.com/en-us/library/windows/"
"desktop/ms680621.aspx>`_."

msgid ""
"On UNIX, :func:`resource.setrlimit` is used to set :attr:`resource."
"RLIMIT_CORE`'s soft limit to 0 to prevent coredump file creation."
msgstr ""
"В UNIX :func:`resource.setrlimit` використовується для встановлення м’якого "
"обмеження :attr:`resource.RLIMIT_CORE` на 0, щоб запобігти створенню файлу "
"coredump."

msgid "On both platforms, the old value is restored by :meth:`__exit__`."
msgstr ""
"На обох платформах старе значення відновлюється за допомогою :meth:"
"`__exit__`."

msgid ""
"Class to save and restore signal handlers registered by the Python signal "
"handler."
msgstr ""
"Клас для збереження та відновлення обробників сигналів, зареєстрованих "
"обробником сигналів Python."

msgid ""
"Save the signal handlers to a dictionary mapping signal numbers to the "
"current signal handler."
msgstr ""
"Збережіть обробники сигналів у словнику, зіставляючи номери сигналів із "
"поточним обробником сигналів."

msgid ""
"Set the signal numbers from the :meth:`save` dictionary to the saved handler."
msgstr ""
"Установіть номери сигналів зі словника :meth:`save` для збереженого "
"обробника."

msgid "Try to match a single dict with the supplied arguments."
msgstr "Спробуйте зіставити один диктовок із наданими аргументами."

msgid "Try to match a single stored value (*dv*) with a supplied value (*v*)."
msgstr ""
"Спробуйте зіставити одне збережене значення (*dv*) із наданим значенням "
"(*v*)."

msgid "Run *test* and return the result."
msgstr "Запустіть *test* і поверніть результат."

msgid ":mod:`test.support.socket_helper` --- Utilities for socket tests"
msgstr ":mod:`test.support.socket_helper` --- Утиліти для тестування сокетів"

msgid ""
"The :mod:`test.support.socket_helper` module provides support for socket "
"tests."
msgstr ""
"Модуль :mod:`test.support.socket_helper` забезпечує підтримку тестів сокетів."

msgid "Set to ``True`` if IPv6 is enabled on this host, ``False`` otherwise."
msgstr ""
"Встановіть ``True``, якщо IPv6 увімкнено на цьому хості, ``False`` інакше."

msgid ""
"Returns an unused port that should be suitable for binding.  This is "
"achieved by creating a temporary socket with the same family and type as the "
"``sock`` parameter (default is :const:`~socket.AF_INET`, :const:`~socket."
"SOCK_STREAM`), and binding it to the specified host address (defaults to "
"``0.0.0.0``) with the port set to 0, eliciting an unused ephemeral port from "
"the OS. The temporary socket is then closed and deleted, and the ephemeral "
"port is returned."
msgstr ""
"Повертає невикористаний порт, який має бути придатним для зв’язування. Це "
"досягається шляхом створення тимчасового сокета з тим самим сімейством і "
"типом, що й параметр ``sock`` (за замовчуванням: :const:`~socket.AF_INET`, :"
"const:`~socket.SOCK_STREAM`), і прив’язування його до указана адреса хоста "
"(за замовчуванням ``0.0.0.0``) з портом, встановленим на 0, виявляючи "
"невикористаний тимчасовий порт з ОС. Потім тимчасовий сокет закривається та "
"видаляється, а тимчасовий порт повертається."

msgid ""
"Either this method or :func:`bind_port` should be used for any tests where a "
"server socket needs to be bound to a particular port for the duration of the "
"test. Which one to use depends on whether the calling code is creating a "
"Python socket, or if an unused port needs to be provided in a constructor or "
"passed to an external program (i.e. the ``-accept`` argument to openssl's "
"s_server mode).  Always prefer :func:`bind_port` over :func:"
"`find_unused_port` where possible.  Using a hard coded port is discouraged "
"since it can make multiple instances of the test impossible to run "
"simultaneously, which is a problem for buildbots."
msgstr ""
"Або цей метод, або :func:`bind_port` слід використовувати для будь-яких "
"тестів, де серверний сокет потрібно прив’язати до певного порту на час "
"тесту. Який з них використовувати залежить від того, чи код виклику створює "
"сокет Python, чи потрібно надати невикористаний порт у конструкторі чи "
"передати зовнішній програмі (тобто аргумент ``-accept`` для режиму s_server "
"openssl). Завжди віддавайте перевагу :func:`bind_port` над :func:"
"`find_unused_port`, де це можливо. Не рекомендується використовувати жорстко "
"закодований порт, оскільки це може зробити неможливим одночасний запуск "
"кількох екземплярів тесту, що є проблемою для buildbots."

msgid ""
"Bind the socket to a free port and return the port number.  Relies on "
"ephemeral ports in order to ensure we are using an unbound port.  This is "
"important as many tests may be running simultaneously, especially in a "
"buildbot environment.  This method raises an exception if the ``sock."
"family`` is :const:`~socket.AF_INET` and ``sock.type`` is :const:`~socket."
"SOCK_STREAM`, and the socket has :const:`~socket.SO_REUSEADDR` or :const:"
"`~socket.SO_REUSEPORT` set on it. Tests should never set these socket "
"options for TCP/IP sockets. The only case for setting these options is "
"testing multicasting via multiple UDP sockets."
msgstr ""
"Прив’яжіть сокет до вільного порту та поверніть номер порту. Покладається на "
"тимчасові порти, щоб переконатися, що ми використовуємо незв’язаний порт. Це "
"важливо, оскільки багато тестів можуть виконуватися одночасно, особливо в "
"середовищі buildbot. Цей метод викликає виняток, якщо ``sock.family`` має "
"значення :const:`~socket.AF_INET` і ``sock.type`` має значення :const:"
"`~socket.SOCK_STREAM`, і сокет має На ньому встановлено :const:`~socket."
"SO_REUSEADDR` або :const:`~socket.SO_REUSEPORT`. Тести ніколи не повинні "
"встановлювати ці параметри сокетів для сокетів TCP/IP. Єдиним випадком "
"встановлення цих параметрів є тестування багатоадресної розсилки через "
"кілька сокетів UDP."

msgid ""
"Additionally, if the :const:`~socket.SO_EXCLUSIVEADDRUSE` socket option is "
"available (i.e. on Windows), it will be set on the socket.  This will "
"prevent anyone else from binding to our host/port for the duration of the "
"test."
msgstr ""
"Крім того, якщо опція сокета :const:`~socket.SO_EXCLUSIVEADDRUSE` доступна "
"(тобто у Windows), вона буде встановлена на сокеті. Це не дозволить будь-"
"кому іншому підключитися до нашого хосту/порту на час тестування."

msgid ""
"Bind a Unix socket, raising :exc:`unittest.SkipTest` if :exc:"
"`PermissionError` is raised."
msgstr ""

msgid ""
"A decorator for running tests that require a functional ``bind()`` for Unix "
"sockets."
msgstr ""
"Декоратор для запуску тестів, які потребують функціонального ``bind()`` для "
"сокетів Unix."

msgid ""
"A context manager that raises :exc:`~test.support.ResourceDenied` when "
"various issues with the internet connection manifest themselves as "
"exceptions."
msgstr ""
"Контекстний менеджер, який викликає :exc:`~test.support.ResourceDenied`, "
"коли різні проблеми з підключенням до Інтернету проявляються як винятки."

msgid ""
":mod:`test.support.script_helper` --- Utilities for the Python execution "
"tests"
msgstr ""
":mod:`test.support.script_helper` --- Утиліти для тестів виконання Python"

msgid ""
"The :mod:`test.support.script_helper` module provides support for Python's "
"script execution tests."
msgstr ""
"Модуль :mod:`test.support.script_helper` забезпечує підтримку тестів "
"виконання сценаріїв Python."

msgid ""
"Return ``True`` if ``sys.executable interpreter`` requires environment "
"variables in order to be able to run at all."
msgstr ""
"Повертає ``True``, якщо ``sys.executable інтерпретатор`` вимагає змінних "
"середовища, щоб взагалі мати можливість працювати."

msgid ""
"This is designed to be used with ``@unittest.skipIf()`` to annotate tests "
"that need to use an ``assert_python*()`` function to launch an isolated mode "
"(``-I``) or no environment mode (``-E``) sub-interpreter process."
msgstr ""
"Це призначено для використання з ``@unittest.skipIf()`` для анотування "
"тестів, які потребують використання функції ``assert_python*()`` для запуску "
"ізольованого режиму (``-I``) або без середовища процес підінтерпретатора "
"режиму (``-E``)."

msgid ""
"A normal build & test does not run into this situation but it can happen "
"when trying to run the standard library test suite from an interpreter that "
"doesn't have an obvious home with Python's current home finding logic."
msgstr ""
"Звичайна збірка та тестування не стикаються з такою ситуацією, але це може "
"трапитися під час спроби запустити набір тестів стандартної бібліотеки з "
"інтерпретатора, який не має очевидної початкової точки з поточною логікою "
"пошуку початкової точки Python."

msgid ""
"Setting :envvar:`PYTHONHOME` is one way to get most of the testsuite to run "
"in that situation.  :envvar:`PYTHONPATH` or :envvar:`PYTHONUSERSITE` are "
"other common environment variables that might impact whether or not the "
"interpreter can start."
msgstr ""
"Налаштування :envvar:`PYTHONHOME` є одним із способів запустити більшу "
"частину набору тестів у цій ситуації. :envvar:`PYTHONPATH` або :envvar:"
"`PYTHONUSERSITE` — це інші загальні змінні середовища, які можуть впливати "
"на те, чи може запускатися інтерпретатор."

msgid ""
"Set up the environment based on *env_vars* for running the interpreter in a "
"subprocess.  The values can include ``__isolated``, ``__cleanenv``, "
"``__cwd``, and ``TERM``."
msgstr ""
"Налаштуйте середовище на основі *env_vars* для запуску інтерпретатора в "
"підпроцесі. Значення можуть включати ``__isolated``, ``__cleanenv``, "
"``__cwd`` і ``TERM``."

msgid "The function no longer strips whitespaces from *stderr*."
msgstr "Ця функція більше не видаляє пробіли з *stderr*."

msgid ""
"Assert that running the interpreter with *args* and optional environment "
"variables *env_vars* succeeds (``rc == 0``) and return a ``(return code, "
"stdout, stderr)`` tuple."
msgstr ""
"Стверджуйте, що запуск інтерпретатора з *args* і необов’язковими змінними "
"середовища *env_vars* успішний (``rc == 0``) і повертає кортеж ``(код "
"повернення, stdout, stderr)``."

msgid ""
"If the *__cleanenv* keyword-only parameter is set, *env_vars* is used as a "
"fresh environment."
msgstr ""
"Якщо встановлено параметр лише для ключового слова *__cleanenv*, *env_vars* "
"використовується як нове середовище."

msgid ""
"Python is started in isolated mode (command line option ``-I``), except if "
"the *__isolated* keyword-only parameter is set to ``False``."
msgstr ""
"Python запускається в ізольованому режимі (параметр командного рядка ``-"
"I``), за винятком випадків, коли для параметра *__isolated* тільки ключове "
"слово встановлено значення ``False``."

msgid ""
"Assert that running the interpreter with *args* and optional environment "
"variables *env_vars* fails (``rc != 0``) and return a ``(return code, "
"stdout, stderr)`` tuple."
msgstr ""
"Стверджуйте, що запуск інтерпретатора з *args* і необов’язковими змінними "
"середовища *env_vars* не вдається (``rc != 0``), і повертайте кортеж ``(код "
"повернення, stdout, stderr)``."

msgid "See :func:`assert_python_ok` for more options."
msgstr ""
"Перегляньте :func:`assert_python_ok` для отримання додаткових параметрів."

msgid "Run a Python subprocess with the given arguments."
msgstr "Запустіть підпроцес Python із заданими аргументами."

msgid ""
"*kw* is extra keyword args to pass to :func:`subprocess.Popen`. Returns a :"
"class:`subprocess.Popen` object."
msgstr ""
"*kw* — додаткові аргументи ключового слова, які потрібно передати в :func:"
"`subprocess.Popen`. Повертає об’єкт :class:`subprocess.Popen`."

msgid ""
"Run the given :class:`subprocess.Popen` process until completion and return "
"stdout."
msgstr ""
"Запустіть заданий процес :class:`subprocess.Popen` до завершення та "
"поверніть stdout."

msgid ""
"Create script containing *source* in path *script_dir* and "
"*script_basename*. If *omit_suffix* is ``False``, append ``.py`` to the "
"name.  Return the full script path."
msgstr ""
"Створіть сценарій, що містить *source* у шляху *script_dir* і "
"*script_basename*. Якщо *omit_suffix* має значення ``False``, додайте ``."
"py`` до імені. Повернути повний шлях до сценарію."

msgid ""
"Create zip file at *zip_dir* and *zip_basename* with extension ``zip`` which "
"contains the files in *script_name*. *name_in_zip* is the archive name. "
"Return a tuple containing ``(full path, full path of archive name)``."
msgstr ""
"Створіть файл zip за адресами *zip_dir* і *zip_basename* із розширенням "
"``zip``, який містить файли в *script_name*. *name_in_zip* — назва архіву. "
"Повертає кортеж, що містить ``(повний шлях, повний шлях до імені архіву)``."

msgid ""
"Create a directory named *pkg_dir* containing an ``__init__`` file with "
"*init_source* as its contents."
msgstr ""
"Створіть каталог з назвою *pkg_dir*, що містить файл ``__init__`` із вмістом "
"*init_source*."

msgid ""
"Create a zip package directory with a path of *zip_dir* and *zip_basename* "
"containing an empty ``__init__`` file and a file *script_basename* "
"containing the *source*.  If *compiled* is ``True``, both source files will "
"be compiled and added to the zip package.  Return a tuple of the full zip "
"path and the archive name for the zip file."
msgstr ""
"Створіть каталог пакетів zip із шляхом *zip_dir* і *zip_basename*, що "
"містить порожній файл ``__init__`` і файл *script_basename*, що містить "
"*джерело*. Якщо *compiled* має значення ``True``, обидва вихідні файли буде "
"скомпільовано та додано до пакета zip. Повертає кортеж повного шляху до "
"архіву та ім’я архіву для файлу."

msgid ""
":mod:`test.support.bytecode_helper` --- Support tools for testing correct "
"bytecode generation"
msgstr ""
":mod:`test.support.bytecode_helper` --- Інструменти підтримки для тестування "
"правильної генерації байт-коду"

msgid ""
"The :mod:`test.support.bytecode_helper` module provides support for testing "
"and inspecting bytecode generation."
msgstr ""
"Модуль :mod:`test.support.bytecode_helper` забезпечує підтримку для "
"тестування та перевірки генерації байт-коду."

msgid "The module defines the following class:"
msgstr "Модуль визначає наступний клас:"

msgid "This class has custom assertion methods for inspecting bytecode."
msgstr "У цьому класі є власні методи твердження для перевірки байт-коду."

msgid "Return the disassembly of *co* as string."
msgstr "Повернути розбирання *co* як рядок."

msgid ""
"Return instr if *opname* is found, otherwise throws :exc:`AssertionError`."
msgstr ""
"Повертає instr, якщо *opname* знайдено, інакше видає :exc:`AssertionError`."

msgid "Throws :exc:`AssertionError` if *opname* is found."
msgstr "Видає :exc:`AssertionError`, якщо знайдено *opname*."

msgid ":mod:`test.support.threading_helper` --- Utilities for threading tests"
msgstr ":mod:`test.support.threading_helper` --- Утиліти для потокових тестів"

msgid ""
"The :mod:`test.support.threading_helper` module provides support for "
"threading tests."
msgstr ""
"Модуль :mod:`test.support.threading_helper` забезпечує підтримку потокових "
"тестів."

msgid ""
"Join a *thread* within *timeout*.  Raise an :exc:`AssertionError` if thread "
"is still alive after *timeout* seconds."
msgstr ""
"Приєднайтеся до *ланцюжка* протягом *часу очікування*. Викликати :exc:"
"`AssertionError`, якщо потік все ще активний після *часу очікування* секунд."

msgid "Decorator to ensure the threads are cleaned up even if the test fails."
msgstr ""
"Декоратор, щоб переконатися, що нитки очищені, навіть якщо тест провалиться."

msgid ""
"Context manager to start *threads*, which is a sequence of threads. *unlock* "
"is a function called after the threads are started, even if an exception was "
"raised; an example would be :meth:`threading.Event.set`. ``start_threads`` "
"will attempt to join the started threads upon exit."
msgstr ""
"Менеджер контексту для запуску *потоків*, який є послідовністю потоків. "
"*unlock* — це функція, яка викликається після запуску потоків, навіть якщо "
"було викликано виняткову ситуацію; прикладом може бути :meth:`threading."
"Event.set`. ``start_threads`` спробує приєднатися до розпочатих потоків "
"після виходу."

msgid ""
"Cleanup up threads not specified in *original_values*.  Designed to emit a "
"warning if a test leaves running threads in the background."
msgstr ""
"Очистити потоки, не вказані в *original_values*. Призначений для видачі "
"попередження, якщо тест залишає запущені потоки у фоновому режимі."

msgid "Return current thread count and copy of dangling threads."
msgstr "Повертає поточну кількість потоків і копію завислих потоків."

msgid ""
"Context manager to wait until all threads created in the ``with`` statement "
"exit."
msgstr ""
"Менеджер контексту для очікування завершення роботи всіх потоків, створених "
"у операторі ``with``."

msgid ""
"Context manager catching :class:`threading.Thread` exception using :func:"
"`threading.excepthook`."
msgstr ""
"Менеджер контексту перехоплює виняток :class:`threading.Thread` за "
"допомогою :func:`threading.excepthook`."

msgid "Attributes set when an exception is caught:"
msgstr "Атрибути, які встановлюються, коли виявляється виняток:"

msgid "``exc_type``"
msgstr "``exc_type``"

msgid "``exc_value``"
msgstr "``exc_value``"

msgid "``exc_traceback``"
msgstr "``exc_traceback``"

msgid "``thread``"
msgstr "``потік``"

msgid "See :func:`threading.excepthook` documentation."
msgstr "Перегляньте документацію :func:`threading.excepthook`."

msgid "These attributes are deleted at the context manager exit."
msgstr "Ці атрибути видаляються при виході з контекстного менеджера."

msgid ":mod:`test.support.os_helper` --- Utilities for os tests"
msgstr ":mod:`test.support.os_helper` --- Утиліти для тестування ОС"

msgid "The :mod:`test.support.os_helper` module provides support for os tests."
msgstr "Модуль :mod:`test.support.os_helper` забезпечує підтримку тестів ОС."

msgid "A non-ASCII character encodable by :func:`os.fsencode`."
msgstr "Символ не-ASCII, який можна кодувати за допомогою :func:`os.fsencode`."

msgid "Set to :func:`os.getcwd`."
msgstr "Установіть значення :func:`os.getcwd`."

msgid ""
"Set to a name that is safe to use as the name of a temporary file.  Any "
"temporary file that is created should be closed and unlinked (removed)."
msgstr ""
"Встановіть назву, яку можна безпечно використовувати як назву тимчасового "
"файлу. Будь-який створений тимчасовий файл має бути закритий і від’єднаний "
"(видалений)."

msgid ""
"Set to a filename containing the :data:`FS_NONASCII` character, if it "
"exists. This guarantees that if the filename exists, it can be encoded and "
"decoded with the default filesystem encoding. This allows tests that require "
"a non-ASCII filename to be easily skipped on platforms where they can't work."
msgstr ""
"Встановіть назву файлу, яка містить символ :data:`FS_NONASCII`, якщо він "
"існує. Це гарантує, що якщо ім’я файлу існує, його можна закодувати та "
"декодувати за допомогою стандартного кодування файлової системи. Це дозволяє "
"легко пропускати тести, які вимагають імені файлу, відмінного від ASCII, на "
"платформах, де вони не можуть працювати."

msgid ""
"Set to a filename (str type) that should not be able to be encoded by file "
"system encoding in strict mode.  It may be ``None`` if it's not possible to "
"generate such a filename."
msgstr ""
"Встановіть ім’я файлу (тип str), яке не можна закодувати за допомогою "
"кодування файлової системи в строгому режимі. Це може бути ``None``, якщо "
"неможливо згенерувати таку назву файлу."

msgid ""
"Set to a filename (bytes type) that should not be able to be decoded by file "
"system encoding in strict mode.  It may be ``None`` if it's not possible to "
"generate such a filename."
msgstr ""
"Встановіть назву файлу (тип байтів), яку не можна буде розшифрувати за "
"допомогою кодування файлової системи в строгому режимі. Це може бути "
"``None``, якщо неможливо згенерувати таку назву файлу."

msgid "Set to a non-ASCII name for a temporary file."
msgstr "Встановіть назву, відмінну від ASCII, для тимчасового файлу."

msgid ""
"Class used to temporarily set or unset environment variables.  Instances can "
"be used as a context manager and have a complete dictionary interface for "
"querying/modifying the underlying ``os.environ``. After exit from the "
"context manager all changes to environment variables done through this "
"instance will be rolled back."
msgstr ""
"Клас, який використовується для тимчасового встановлення або вимкнення "
"змінних середовища. Екземпляри можна використовувати як контекстний менеджер "
"і мати повний інтерфейс словника для запитів/модифікації основного ``os."
"environ``. Після виходу з диспетчера контексту всі зміни змінних середовища, "
"внесені через цей екземпляр, буде відкочено."

msgid "Added dictionary interface."
msgstr "Додано інтерфейс словника."

msgid ""
"Simple :term:`path-like object`.  It implements the :meth:`__fspath__` "
"method which just returns the *path* argument.  If *path* is an exception, "
"it will be raised in :meth:`!__fspath__`."
msgstr ""
"Простий :term:`path-like object`. Він реалізує метод :meth:`__fspath__`, "
"який просто повертає аргумент *path*. Якщо *path* є винятком, він буде "
"викликаний у :meth:`!__fspath__`."

msgid ""
"Temporarily set the environment variable ``envvar`` to the value of "
"``value``."
msgstr ""
"Тимчасово встановіть для змінної середовища ``envvar`` значення ``value``."

msgid "Temporarily unset the environment variable ``envvar``."
msgstr "Тимчасово вимкнути змінну середовища ``envvar``."

msgid "Return ``True`` if the OS supports symbolic links, ``False`` otherwise."
msgstr ""
"Повертає ``True``, якщо ОС підтримує символічні посилання, ``False`` інакше."

msgid "Return ``True`` if the OS supports xattr, ``False`` otherwise."
msgstr "Повертає ``True``, якщо ОС підтримує xattr, ``False`` інакше."

msgid ""
"A context manager that temporarily changes the current working directory to "
"*path* and yields the directory."
msgstr ""
"Менеджер контексту, який тимчасово змінює поточний робочий каталог на *шлях* "
"і повертає каталог."

msgid ""
"If *quiet* is ``False``, the context manager raises an exception on error.  "
"Otherwise, it issues only a warning and keeps the current working directory "
"the same."
msgstr ""
"Якщо *quiet* має значення ``False``, менеджер контексту створює виняток у "
"разі помилки. В іншому випадку він видає лише попередження та зберігає "
"поточний робочий каталог незмінним."

msgid ""
"Create an empty file with *filename*.  If it already exists, truncate it."
msgstr "Створіть порожній файл із *ім’ям*. Якщо він уже існує, обріжте його."

msgid "Count the number of open file descriptors."
msgstr "Підрахуйте кількість відкритих файлових дескрипторів."

msgid "Return ``True`` if the file system for *directory* is case-insensitive."
msgstr ""
"Повертає ``True``, якщо файлова система для *каталогу* нечутлива до регістру."

msgid ""
"Create an invalid file descriptor by opening and closing a temporary file, "
"and returning its descriptor."
msgstr ""
"Створіть недійсний дескриптор файлу, відкривши та закриваючи тимчасовий файл "
"і повертаючи його дескриптор."

msgid ""
"Call :func:`os.rmdir` on *filename*.  On Windows platforms, this is wrapped "
"with a wait loop that checks for the existence of the file, which is needed "
"due to antivirus programs that can hold files open and prevent deletion."
msgstr ""
"Викличте :func:`os.rmdir` на *назві файлу*. На платформах Windows це "
"обернено циклом очікування, який перевіряє існування файлу, що необхідно "
"через антивірусні програми, які можуть утримувати файли відкритими та "
"запобігати видаленню."

msgid ""
"Call :func:`shutil.rmtree` on *path* or call :func:`os.lstat` and :func:`os."
"rmdir` to remove a path and its contents.  As with :func:`rmdir`, on Windows "
"platforms this is wrapped with a wait loop that checks for the existence of "
"the files."
msgstr ""
"Викличте :func:`shutil.rmtree` на *path* або викличте :func:`os.lstat` і :"
"func:`os.rmdir`, щоб видалити шлях і його вміст. Як і у випадку з :func:"
"`rmdir`, на платформах Windows це обертається циклом очікування, який "
"перевіряє існування файлів."

msgid "A decorator for running tests that require support for symbolic links."
msgstr ""
"Декоратор для запуску тестів, які потребують підтримки символьних посилань."

msgid "A decorator for running tests that require support for xattr."
msgstr "Декоратор для запуску тестів, які потребують підтримки xattr."

msgid ""
"A context manager that temporarily creates a new directory and changes the "
"current working directory (CWD)."
msgstr ""
"Менеджер контексту, який тимчасово створює новий каталог і змінює поточний "
"робочий каталог (CWD)."

msgid ""
"The context manager creates a temporary directory in the current directory "
"with name *name* before temporarily changing the current working directory.  "
"If *name* is ``None``, the temporary directory is created using :func:"
"`tempfile.mkdtemp`."
msgstr ""
"Менеджер контексту створює тимчасовий каталог у поточному каталозі з назвою "
"*name* перед тим, як тимчасово змінити поточний робочий каталог. Якщо *name* "
"має значення ``None``, тимчасовий каталог створюється за допомогою :func:"
"`tempfile.mkdtemp`."

msgid ""
"If *quiet* is ``False`` and it is not possible to create or change the CWD, "
"an error is raised.  Otherwise, only a warning is raised and the original "
"CWD is used."
msgstr ""
"Якщо *quiet* має значення ``False`` і неможливо створити або змінити CWD, "
"виникає помилка. В іншому випадку виводиться лише попередження та "
"використовується оригінальний CWD."

msgid ""
"A context manager that creates a temporary directory at *path* and yields "
"the directory."
msgstr ""
"Менеджер контексту, який створює тимчасовий каталог за *шляхом* і дає "
"каталог."

msgid ""
"If *path* is ``None``, the temporary directory is created using :func:"
"`tempfile.mkdtemp`.  If *quiet* is ``False``, the context manager raises an "
"exception on error.  Otherwise, if *path* is specified and cannot be "
"created, only a warning is issued."
msgstr ""
"Якщо *path* має значення ``None``, тимчасовий каталог створюється за "
"допомогою :func:`tempfile.mkdtemp`. Якщо *quiet* має значення ``False``, "
"менеджер контексту створює виняток у разі помилки. В іншому випадку, якщо "
"вказано *шлях* і його неможливо створити, видається лише попередження."

msgid "A context manager that temporarily sets the process umask."
msgstr "Менеджер контексту, який тимчасово встановлює umask процесу."

msgid ""
"Call :func:`os.unlink` on *filename*.  As with :func:`rmdir`, on Windows "
"platforms, this is wrapped with a wait loop that checks for the existence of "
"the file."
msgstr ""
"Виклик :func:`os.unlink` на *назві файлу*. Як і у випадку з :func:`rmdir`, "
"на платформах Windows це обернуто циклом очікування, який перевіряє "
"існування файлу."

msgid ":mod:`test.support.import_helper` --- Utilities for import tests"
msgstr ":mod:`test.support.import_helper` --- Утиліти для імпортування тестів"

msgid ""
"The :mod:`test.support.import_helper` module provides support for import "
"tests."
msgstr ""
"Модуль :mod:`test.support.import_helper` забезпечує підтримку тестів імпорту."

msgid ""
"Remove the module named *module_name* from ``sys.modules`` and delete any "
"byte-compiled files of the module."
msgstr ""
"Видаліть модуль із назвою *module_name* із ``sys.modules`` і видаліть усі "
"скомпільовані файли модуля."

msgid ""
"This function imports and returns a fresh copy of the named Python module by "
"removing the named module from ``sys.modules`` before doing the import. Note "
"that unlike :func:`reload`, the original module is not affected by this "
"operation."
msgstr ""
"Ця функція імпортує та повертає нову копію названого модуля Python, "
"видаливши названий модуль із ``sys.modules`` перед виконанням імпорту. "
"Зауважте, що на відміну від :func:`reload`, ця операція не впливає на "
"вихідний модуль."

msgid ""
"*fresh* is an iterable of additional module names that are also removed from "
"the ``sys.modules`` cache before doing the import."
msgstr ""
"*fresh* — це ітерація додаткових назв модулів, які також видаляються з кешу "
"``sys.modules`` перед виконанням імпорту."

msgid ""
"*blocked* is an iterable of module names that are replaced with ``None`` in "
"the module cache during the import to ensure that attempts to import them "
"raise :exc:`ImportError`."
msgstr ""
"*blocked* — це ітерація імен модулів, які замінюються на ``None`` у кеші "
"модуля під час імпорту, щоб гарантувати, що спроби їх імпортувати "
"викликають :exc:`ImportError`."

msgid ""
"The named module and any modules named in the *fresh* and *blocked* "
"parameters are saved before starting the import and then reinserted into "
"``sys.modules`` when the fresh import is complete."
msgstr ""
"Названий модуль і будь-які модулі, названі в параметрах *fresh* і *blocked*, "
"зберігаються перед початком імпорту, а потім знову вставляються в ``sys."
"modules``, коли новий імпорт буде завершено."

msgid ""
"Module and package deprecation messages are suppressed during this import if "
"*deprecated* is ``True``."
msgstr ""
"Повідомлення про застарілі модулі та пакети пригнічуються під час цього "
"імпорту, якщо *deprecated* має значення ``True``."

msgid ""
"This function will raise :exc:`ImportError` if the named module cannot be "
"imported."
msgstr ""
"Ця функція викличе :exc:`ImportError`, якщо вказаний модуль неможливо "
"імпортувати."

msgid ""
"This function imports and returns the named module. Unlike a normal import, "
"this function raises :exc:`unittest.SkipTest` if the module cannot be "
"imported."
msgstr ""
"Ця функція імпортує та повертає названий модуль. На відміну від звичайного "
"імпорту, ця функція викликає :exc:`unittest.SkipTest`, якщо модуль неможливо "
"імпортувати."

msgid ""
"Module and package deprecation messages are suppressed during this import if "
"*deprecated* is ``True``.  If a module is required on a platform but "
"optional for others, set *required_on* to an iterable of platform prefixes "
"which will be compared against :data:`sys.platform`."
msgstr ""
"Повідомлення про застарілі модулі та пакети пригнічуються під час цього "
"імпорту, якщо *deprecated* має значення ``True``. Якщо модуль потрібен на "
"платформі, але необов’язковий для інших, установіть *required_on* на "
"ітерацію префіксів платформи, які порівнюватимуться з :data:`sys.platform`."

msgid "Return a copy of :data:`sys.modules`."
msgstr "Повернути копію :data:`sys.modules`."

msgid ""
"Remove modules except for *oldmodules* and ``encodings`` in order to "
"preserve internal cache."
msgstr ""
"Видаліть модулі, за винятком *oldmodules* і ``encoding``, щоб зберегти "
"внутрішній кеш."

msgid "Delete *name* from ``sys.modules``."
msgstr "Видалити *name* з ``sys.modules``."

msgid ""
"Move a :pep:`3147`/:pep:`488` pyc file to its legacy pyc location and return "
"the file system path to the legacy pyc file.  The *source* value is the file "
"system path to the source file.  It does not need to exist, however the PEP "
"3147/488 pyc file must exist."
msgstr ""
"Перемістіть :pep:`3147`/:pep:`488` файл pyc до його застарілого розташування "
"pyc і поверніть шлях файлової системи до застарілого pyc-файлу. Значення "
"*source* — це шлях файлової системи до вихідного файлу. Він не обов’язково "
"існує, однак файл PEP 3147/488 pyc має існувати."

msgid ""
"A context manager to force import to return a new module reference.  This is "
"useful for testing module-level behaviors, such as the emission of a :exc:"
"`DeprecationWarning` on import.  Example usage::"
msgstr ""
"Менеджер контексту для примусового імпортування для повернення нового "
"посилання на модуль. Це корисно для тестування поведінки на рівні модуля, "
"наприклад виведення :exc:`DeprecationWarning` під час імпорту. Приклад "
"використання::"

msgid "A context manager to temporarily add directories to :data:`sys.path`."
msgstr ""
"Менеджер контексту для тимчасового додавання каталогів до :data:`sys.path`."

msgid ""
"This makes a copy of :data:`sys.path`, appends any directories given as "
"positional arguments, then reverts :data:`sys.path` to the copied settings "
"when the context ends."
msgstr ""
"Це створює копію :data:`sys.path`, додає будь-які каталоги, надані як "
"позиційні аргументи, а потім повертає :data:`sys.path` скопійовані "
"налаштування, коли контекст закінчується."

msgid ""
"Note that *all* :data:`sys.path` modifications in the body of the context "
"manager, including replacement of the object, will be reverted at the end of "
"the block."
msgstr ""
"Зауважте, що *всі* :data:`sys.path` зміни в тілі контекстного менеджера, "
"включаючи заміну об’єкта, буде скасовано в кінці блоку."

msgid ":mod:`test.support.warnings_helper` --- Utilities for warnings tests"
msgstr ""
":mod:`test.support.warnings_helper` --- Утиліти для перевірки попереджень"

msgid ""
"The :mod:`test.support.warnings_helper` module provides support for warnings "
"tests."
msgstr ""
"Модуль :mod:`test.support.warnings_helper` забезпечує підтримку тестів "
"попереджень."

msgid ""
"Context manager to check that no :exc:`ResourceWarning` was raised.  You "
"must remove the object which may emit :exc:`ResourceWarning` before the end "
"of the context manager."
msgstr ""
"Менеджер контексту для перевірки відсутності :exc:`ResourceWarning`. Ви "
"повинні видалити об’єкт, який може видати :exc:`ResourceWarning` перед "
"завершенням контекстного менеджера."

msgid ""
"Test for syntax warning in *statement* by attempting to compile *statement*. "
"Test also that the :exc:`SyntaxWarning` is emitted only once, and that it "
"will be converted to a :exc:`SyntaxError` when turned into error. *testcase* "
"is the :mod:`unittest` instance for the test.  *errtext* is the regular "
"expression which should match the string representation of the emitted :exc:"
"`SyntaxWarning` and raised :exc:`SyntaxError`.  If *lineno* is not ``None``, "
"compares to the line of the warning and exception. If *offset* is not "
"``None``, compares to the offset of the exception."
msgstr ""
"Перевірте синтаксичне попередження в *операторі*, спробувавши скомпілювати "
"*оператор*. Перевірте також, що :exc:`SyntaxWarning` видається лише один "
"раз, і що воно буде перетворено на :exc:`SyntaxError`, коли перетвориться на "
"помилку. *testcase* — це екземпляр :mod:`unittest` для тесту. *errtext* — це "
"регулярний вираз, який має відповідати рядковому представленню випущеного :"
"exc:`SyntaxWarning` і викликаного :exc:`SyntaxError`. Якщо *lineno* не є "
"``None``, порівнюється з рядком попередження та винятку. Якщо *offset* не є "
"``None``, порівнюється зі зміщенням винятку."

msgid ""
"A convenience wrapper for :func:`warnings.catch_warnings()` that makes it "
"easier to test that a warning was correctly raised.  It is approximately "
"equivalent to calling ``warnings.catch_warnings(record=True)`` with :meth:"
"`warnings.simplefilter` set to ``always`` and with the option to "
"automatically validate the results that are recorded."
msgstr ""
"Зручна оболонка для :func:`warnings.catch_warnings()`, яка полегшує "
"перевірку правильності виклику попередження. Це приблизно еквівалентно "
"виклику ``warnings.catch_warnings(record=True)`` з :meth:`warnings."
"simplefilter`, встановленим на ``always`` і з опцією автоматичної перевірки "
"результатів, які записуються."

msgid ""
"``check_warnings`` accepts 2-tuples of the form ``(\"message regexp\", "
"WarningCategory)`` as positional arguments. If one or more *filters* are "
"provided, or if the optional keyword argument *quiet* is ``False``, it "
"checks to make sure the warnings are as expected:  each specified filter "
"must match at least one of the warnings raised by the enclosed code or the "
"test fails, and if any warnings are raised that do not match any of the "
"specified filters the test fails.  To disable the first of these checks, set "
"*quiet* to ``True``."
msgstr ""
"``check_warnings`` приймає 2-кортежі форми ``(\"message regexp\", "
"WarningCategory)`` як позиційні аргументи. Якщо надано один або більше "
"*фільтрів*, або якщо необов’язковий аргумент ключового слова *quiet* має "
"значення ``False``, він перевіряє, щоб переконатися, що попередження "
"відповідають очікуванням: кожен вказаний фільтр повинен відповідати "
"принаймні одному з попереджень, викликаних вкладений код або тест не "
"вдається, і якщо виникають попередження, які не відповідають жодному з "
"указаних фільтрів, тест не вдається. Щоб вимкнути першу з цих перевірок, "
"установіть *quiet* на ``True``."

msgid "If no arguments are specified, it defaults to::"
msgstr "Якщо аргументи не вказано, за замовчуванням::"

msgid "In this case all warnings are caught and no errors are raised."
msgstr "У цьому випадку всі попередження вловлюються, а помилки не виникають."

msgid ""
"On entry to the context manager, a :class:`WarningRecorder` instance is "
"returned. The underlying warnings list from :func:`~warnings.catch_warnings` "
"is available via the recorder object's :attr:`warnings` attribute.  As a "
"convenience, the attributes of the object representing the most recent "
"warning can also be accessed directly through the recorder object (see "
"example below).  If no warning has been raised, then any of the attributes "
"that would otherwise be expected on an object representing a warning will "
"return ``None``."
msgstr ""
"Після входу в контекстний менеджер повертається екземпляр :class:"
"`WarningRecorder`. Базовий список попереджень із :func:`~warnings."
"catch_warnings` доступний через атрибут :attr:`warnings` об’єкта запису. Для "
"зручності атрибути об’єкта, що представляє останнє попередження, також можна "
"отримати безпосередньо через об’єкт запису (див. приклад нижче). Якщо "
"попередження не було викликано, тоді будь-який з атрибутів, які в іншому "
"випадку очікувалися б для об’єкта, що представляє попередження, поверне "
"``None``."

msgid ""
"The recorder object also has a :meth:`reset` method, which clears the "
"warnings list."
msgstr ""
"Об’єкт recorder також має метод :meth:`reset`, який очищає список "
"попереджень."

msgid "The context manager is designed to be used like this::"
msgstr "Контекстний менеджер призначений для використання таким чином:"

msgid ""
"In this case if either warning was not raised, or some other warning was "
"raised, :func:`check_warnings` would raise an error."
msgstr ""
"У цьому випадку, якщо попередження не було викликано, або якесь інше "
"попередження було викликано, :func:`check_warnings` викличе помилку."

msgid ""
"When a test needs to look more deeply into the warnings, rather than just "
"checking whether or not they occurred, code like this can be used::"
msgstr ""
"Коли під час тестування потрібно глибше вивчити попередження, а не просто "
"перевірити, чи вони виникли чи ні, можна використати такий код:"

msgid ""
"Here all warnings will be caught, and the test code tests the captured "
"warnings directly."
msgstr ""
"Тут будуть перехоплені всі попередження, а тестовий код безпосередньо "
"перевірить захоплені попередження."

msgid "New optional arguments *filters* and *quiet*."
msgstr "Нові необов'язкові аргументи *фільтри* та *тихий*."

msgid ""
"Class used to record warnings for unit tests. See documentation of :func:"
"`check_warnings` above for more details."
msgstr ""
"Клас, який використовується для запису попереджень для модульних тестів. "
"Перегляньте документацію :func:`check_warnings` вище, щоб дізнатися більше."
