# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:55+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Synchronization Primitives"
msgstr "Примітиви синхронізації"

msgid "**Source code:** :source:`Lib/asyncio/locks.py`"
msgstr "**Вихідний код:** :source:`Lib/asyncio/locks.py`"

msgid ""
"asyncio synchronization primitives are designed to be similar to those of "
"the :mod:`threading` module with two important caveats:"
msgstr ""
"Примітиви синхронізації asyncio розроблені таким чином, щоб бути подібними "
"до модулів :mod:`threading` з двома важливими застереженнями:"

msgid ""
"asyncio primitives are not thread-safe, therefore they should not be used "
"for OS thread synchronization (use :mod:`threading` for that);"
msgstr ""
"примітиви asyncio не є потокобезпечними, тому їх не слід використовувати для "
"синхронізації потоків ОС (для цього використовуйте :mod:`threading`);"

msgid ""
"methods of these synchronization primitives do not accept the *timeout* "
"argument; use the :func:`asyncio.wait_for` function to perform operations "
"with timeouts."
msgstr ""
"методи цих примітивів синхронізації не приймають аргумент *timeout*; "
"використовуйте функцію :func:`asyncio.wait_for` для виконання операцій із "
"тайм-аутами."

msgid "asyncio has the following basic synchronization primitives:"
msgstr "asyncio має такі базові примітиви синхронізації:"

msgid ":class:`Lock`"
msgstr ":class:`Lock`"

msgid ":class:`Event`"
msgstr ":class:`Event`"

msgid ":class:`Condition`"
msgstr ":class:`Condition`"

msgid ":class:`Semaphore`"
msgstr ":class:`Semaphore`"

msgid ":class:`BoundedSemaphore`"
msgstr ":class:`BoundedSemaphore`"

msgid ":class:`Barrier`"
msgstr ""

msgid "Lock"
msgstr "Замок"

msgid "Implements a mutex lock for asyncio tasks.  Not thread-safe."
msgstr ""
"Реалізує блокування м'ютексу для асинхронних завдань. Небезпечно для потоків."

msgid ""
"An asyncio lock can be used to guarantee exclusive access to a shared "
"resource."
msgstr ""
"Асинхронне блокування можна використовувати, щоб гарантувати ексклюзивний "
"доступ до спільного ресурсу."

msgid "The preferred way to use a Lock is an :keyword:`async with` statement::"
msgstr ""
"Найкращим способом використання Lock є оператор :keyword:`async with`::"

msgid "which is equivalent to::"
msgstr "що еквівалентно::"

msgid "Removed the *loop* parameter."
msgstr "Видалено параметр *loop*."

msgid "Acquire the lock."
msgstr "Придбайте замок."

msgid ""
"This method waits until the lock is *unlocked*, sets it to *locked* and "
"returns ``True``."
msgstr ""
"Цей метод очікує, поки блокування буде *розблоковано*, встановлює його на "
"*заблоковано* та повертає ``True``."

msgid ""
"When more than one coroutine is blocked in :meth:`acquire` waiting for the "
"lock to be unlocked, only one coroutine eventually proceeds."
msgstr ""
"Якщо в :meth:`acquire` заблоковано більше ніж одну співпрограму, яка очікує "
"розблокування блокування, зрештою виконується лише одна співпрограма."

msgid ""
"Acquiring a lock is *fair*: the coroutine that proceeds will be the first "
"coroutine that started waiting on the lock."
msgstr ""
"Отримання блокування є *чесним*: співпрограма, яка продовжується, буде "
"першою співпрограмою, яка почала очікувати на блокування."

msgid "Release the lock."
msgstr "Відпустіть замок."

msgid "When the lock is *locked*, reset it to *unlocked* and return."
msgstr ""
"Коли замок *заблоковано*, скиньте його на *розблоковано* та поверніться."

msgid "If the lock is *unlocked*, a :exc:`RuntimeError` is raised."
msgstr "Якщо блокування *розблоковано*, виникає :exc:`RuntimeError`."

msgid "Return ``True`` if the lock is *locked*."
msgstr "Повертає ``True``, якщо блокування *заблоковано*."

msgid "Event"
msgstr "Подія"

msgid "An event object.  Not thread-safe."
msgstr "Об'єкт події. Небезпечно для потоків."

msgid ""
"An asyncio event can be used to notify multiple asyncio tasks that some "
"event has happened."
msgstr ""
"Асинхронну подію можна використовувати для сповіщення кількох асинхронних "
"завдань про те, що сталася якась подія."

msgid ""
"An Event object manages an internal flag that can be set to *true* with the :"
"meth:`~Event.set` method and reset to *false* with the :meth:`clear` "
"method.  The :meth:`~Event.wait` method blocks until the flag is set to "
"*true*.  The flag is set to *false* initially."
msgstr ""
"Об’єкт Event керує внутрішнім прапором, який можна встановити на *true* за "
"допомогою методу :meth:`~Event.set` і скинути на *false* за допомогою "
"методу :meth:`clear`. Метод :meth:`~Event.wait` блокується, доки прапор не "
"буде встановлено на *true*. Спочатку для прапора встановлено значення "
"*false*."

msgid "Example::"
msgstr "Приклад::"

msgid "Wait until the event is set."
msgstr "Дочекайтеся встановлення події."

msgid ""
"If the event is set, return ``True`` immediately. Otherwise block until "
"another task calls :meth:`~Event.set`."
msgstr ""
"Якщо подія встановлена, негайно поверніть ``True``. Інакше заблокуйте, доки "
"інше завдання не викличе :meth:`~Event.set`."

msgid "Set the event."
msgstr "Встановити подію."

msgid "All tasks waiting for event to be set will be immediately awakened."
msgstr ""
"Усі завдання, які очікують встановлення події, будуть негайно активовані."

msgid "Clear (unset) the event."
msgstr "Очистити (скасувати) подію."

msgid ""
"Tasks awaiting on :meth:`~Event.wait` will now block until the :meth:`~Event."
"set` method is called again."
msgstr ""
"Завдання, що очікують на :meth:`~Event.wait`, тепер блокуватимуться, доки "
"метод :meth:`~Event.set` не буде викликано знову."

msgid "Return ``True`` if the event is set."
msgstr "Повертає ``True``, якщо подія встановлена."

msgid "Condition"
msgstr "Хвороба"

msgid "A Condition object.  Not thread-safe."
msgstr "Об’єкт Condition. Небезпечно для потоків."

msgid ""
"An asyncio condition primitive can be used by a task to wait for some event "
"to happen and then get exclusive access to a shared resource."
msgstr ""
"Примітив асинхронної умови може використовуватися завданням для очікування "
"настання певної події та отримання ексклюзивного доступу до спільного "
"ресурсу."

msgid ""
"In essence, a Condition object combines the functionality of an :class:"
"`Event` and a :class:`Lock`.  It is possible to have multiple Condition "
"objects share one Lock, which allows coordinating exclusive access to a "
"shared resource between different tasks interested in particular states of "
"that shared resource."
msgstr ""
"По суті, об’єкт Condition поєднує функціональні можливості :class:`Event` і :"
"class:`Lock`. Кілька об’єктів Condition можуть використовувати один Lock, що "
"дозволяє координувати ексклюзивний доступ до спільного ресурсу між різними "
"завданнями, зацікавленими в певних станах цього спільного ресурсу."

msgid ""
"The optional *lock* argument must be a :class:`Lock` object or ``None``.  In "
"the latter case a new Lock object is created automatically."
msgstr ""
"Додатковий аргумент *lock* має бути об’єктом :class:`Lock` або ``None``. В "
"останньому випадку новий об’єкт Lock створюється автоматично."

msgid ""
"The preferred way to use a Condition is an :keyword:`async with` statement::"
msgstr ""
"Найкращим способом використання умови є оператор :keyword:`async with`::"

msgid "Acquire the underlying lock."
msgstr "Отримайте основний замок."

msgid ""
"This method waits until the underlying lock is *unlocked*, sets it to "
"*locked* and returns ``True``."
msgstr ""
"Цей метод чекає, доки базове блокування *розблокується*, встановлює його на "
"*locked* і повертає ``True``."

msgid ""
"Wake up at most *n* tasks (1 by default) waiting on this condition.  The "
"method is no-op if no tasks are waiting."
msgstr ""
"Виводити щонайбільше *n* завдань (1 за замовчуванням), що очікують за цієї "
"умови. Метод безопераційний, якщо немає завдань, що очікують."

msgid ""
"The lock must be acquired before this method is called and released shortly "
"after.  If called with an *unlocked* lock a :exc:`RuntimeError` error is "
"raised."
msgstr ""
"Блокування має бути отримано перед викликом цього методу та звільнено "
"незабаром після цього. У разі виклику з *розблокованим* блокуванням виникає "
"помилка :exc:`RuntimeError`."

msgid "Return ``True`` if the underlying lock is acquired."
msgstr "Повертає ``True``, якщо основне блокування отримано."

msgid "Wake up all tasks waiting on this condition."
msgstr "Розбудіть усі завдання, що очікують за цієї умови."

msgid "This method acts like :meth:`notify`, but wakes up all waiting tasks."
msgstr ""
"Цей метод діє як :meth:`notify`, але активує всі завдання, що очікують."

msgid "Release the underlying lock."
msgstr "Звільніть базовий замок."

msgid "When invoked on an unlocked lock, a :exc:`RuntimeError` is raised."
msgstr ""
"Під час виклику для розблокованого блокування виникає :exc:`RuntimeError`."

msgid "Wait until notified."
msgstr "Дочекайтеся повідомлення."

msgid ""
"If the calling task has not acquired the lock when this method is called, a :"
"exc:`RuntimeError` is raised."
msgstr ""
"Якщо завдання, що викликає, не отримало блокування під час виклику цього "
"методу, виникає :exc:`RuntimeError`."

msgid ""
"This method releases the underlying lock, and then blocks until it is "
"awakened by a :meth:`notify` or :meth:`notify_all` call. Once awakened, the "
"Condition re-acquires its lock and this method returns ``True``."
msgstr ""
"Цей метод знімає основне блокування, а потім блокує, доки його не розбудить "
"виклик :meth:`notify` або :meth:`notify_all`. Після пробудження умова знову "
"блокується, і цей метод повертає ``True``."

msgid "Wait until a predicate becomes *true*."
msgstr "Зачекайте, поки предикат стане *true*."

msgid ""
"The predicate must be a callable which result will be interpreted as a "
"boolean value.  The final value is the return value."
msgstr ""
"Предикат має бути викликаним, результат якого буде інтерпретуватися як "
"логічне значення. Кінцеве значення є значенням, що повертається."

msgid "Semaphore"
msgstr "Семафор"

msgid "A Semaphore object.  Not thread-safe."
msgstr "Об'єкт Semaphore. Небезпечно для потоків."

msgid ""
"A semaphore manages an internal counter which is decremented by each :meth:"
"`acquire` call and incremented by each :meth:`release` call. The counter can "
"never go below zero; when :meth:`acquire` finds that it is zero, it blocks, "
"waiting until some task calls :meth:`release`."
msgstr ""
"Семафор керує внутрішнім лічильником, який зменшується при кожному виклику :"
"meth:`acquire` і збільшується при кожному виклику :meth:`release`. Лічильник "
"ніколи не може опускатися нижче нуля; коли :meth:`acquire` виявляє, що він "
"дорівнює нулю, він блокується, чекаючи, поки якесь завдання викличе :meth:"
"`release`."

msgid ""
"The optional *value* argument gives the initial value for the internal "
"counter (``1`` by default). If the given value is less than ``0`` a :exc:"
"`ValueError` is raised."
msgstr ""
"Необов’язковий аргумент *value* дає початкове значення для внутрішнього "
"лічильника (``1`` за замовчуванням). Якщо вказане значення менше ніж ``0``, "
"виникає :exc:`ValueError`."

msgid ""
"The preferred way to use a Semaphore is an :keyword:`async with` statement::"
msgstr ""
"Кращим способом використання семафора є оператор :keyword:`async with`::"

msgid "Acquire a semaphore."
msgstr "Придбайте семафор."

msgid ""
"If the internal counter is greater than zero, decrement it by one and return "
"``True`` immediately.  If it is zero, wait until a :meth:`release` is called "
"and return ``True``."
msgstr ""
"Якщо внутрішній лічильник більший за нуль, зменште його на одиницю та "
"негайно поверніть ``True``. Якщо він дорівнює нулю, дочекайтеся виклику :"
"meth:`release` і поверніть ``True``."

msgid "Returns ``True`` if semaphore can not be acquired immediately."
msgstr "Повертає ``True``, якщо семафор не може бути отриманий негайно."

msgid ""
"Release a semaphore, incrementing the internal counter by one. Can wake up a "
"task waiting to acquire the semaphore."
msgstr ""
"Відпустіть семафор, збільшивши внутрішній лічильник на одиницю. Може "
"розбудити завдання, яке очікує отримання семафора."

msgid ""
"Unlike :class:`BoundedSemaphore`, :class:`Semaphore` allows making more "
"``release()`` calls than ``acquire()`` calls."
msgstr ""
"На відміну від :class:`BoundedSemaphore`, :class:`Semaphore` дозволяє робити "
"більше викликів ``release()``, ніж викликів ``acquire()``."

msgid "BoundedSemaphore"
msgstr "Обмежений семафор"

msgid "A bounded semaphore object.  Not thread-safe."
msgstr "Обмежений семафорний об’єкт. Небезпечно для потоків."

msgid ""
"Bounded Semaphore is a version of :class:`Semaphore` that raises a :exc:"
"`ValueError` in :meth:`~Semaphore.release` if it increases the internal "
"counter above the initial *value*."
msgstr ""
"Обмежений семафор — це версія :class:`Semaphore`, яка викликає :exc:"
"`ValueError` у :meth:`~Semaphore.release`, якщо він збільшує внутрішній "
"лічильник вище початкового *значення*."

msgid "Barrier"
msgstr ""

msgid "A barrier object.  Not thread-safe."
msgstr ""

msgid ""
"A barrier is a simple synchronization primitive that allows to block until "
"*parties* number of tasks are waiting on it. Tasks can wait on the :meth:"
"`~Barrier.wait` method and would be blocked until the specified number of "
"tasks end up waiting on :meth:`~Barrier.wait`. At that point all of the "
"waiting tasks would unblock simultaneously."
msgstr ""

msgid ""
":keyword:`async with` can be used as an alternative to awaiting on :meth:"
"`~Barrier.wait`."
msgstr ""

msgid "The barrier can be reused any number of times."
msgstr ""

msgid "Result of this example is::"
msgstr ""

msgid ""
"Pass the barrier. When all the tasks party to the barrier have called this "
"function, they are all unblocked simultaneously."
msgstr ""

msgid ""
"When a waiting or blocked task in the barrier is cancelled, this task exits "
"the barrier which stays in the same state. If the state of the barrier is "
"\"filling\", the number of waiting task decreases by 1."
msgstr ""

msgid ""
"The return value is an integer in the range of 0 to ``parties-1``, different "
"for each task. This can be used to select a task to do some special "
"housekeeping, e.g.::"
msgstr ""

msgid ""
"This method may raise a :class:`BrokenBarrierError` exception if the barrier "
"is broken or reset while a task is waiting. It could raise a :exc:"
"`CancelledError` if a task is cancelled."
msgstr ""

msgid ""
"Return the barrier to the default, empty state.  Any tasks waiting on it "
"will receive the :class:`BrokenBarrierError` exception."
msgstr ""

msgid ""
"If a barrier is broken it may be better to just leave it and create a new "
"one."
msgstr ""

msgid ""
"Put the barrier into a broken state.  This causes any active or future calls "
"to :meth:`wait` to fail with the :class:`BrokenBarrierError`. Use this for "
"example if one of the tasks needs to abort, to avoid infinite waiting tasks."
msgstr ""

msgid "The number of tasks required to pass the barrier."
msgstr ""

msgid "The number of tasks currently waiting in the barrier while filling."
msgstr ""

msgid "A boolean that is ``True`` if the barrier is in the broken state."
msgstr ""
"Логічне значення, яке має значення ``True``, якщо бар’єр знаходиться в "
"зламаному стані."

msgid ""
"This exception, a subclass of :exc:`RuntimeError`, is raised when the :class:"
"`Barrier` object is reset or broken."
msgstr ""
"Цей виняток, підклас :exc:`RuntimeError`, виникає, коли об’єкт :class:"
"`Barrier` скидається або зламано."

msgid ""
"Acquiring a lock using ``await lock`` or ``yield from lock`` and/or :keyword:"
"`with` statement (``with await lock``, ``with (yield from lock)``) was "
"removed.  Use ``async with lock`` instead."
msgstr ""
"Отримання блокування за допомогою оператора ``await lock`` або ``yield from "
"lock`` та/або :keyword:`with` (``with await lock``, ``with (yield from "
"lock)``) було видалено . Натомість використовуйте ``async with lock``."
