# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-29 17:18+0300\n"
"PO-Revision-Date: 2022-07-05 15:38+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`http.client` --- HTTP protocol client"
msgstr ":mod:`http.client` --- клієнт протоколу HTTP"

msgid "**Source code:** :source:`Lib/http/client.py`"
msgstr "**Вихідний код:** :source:`Lib/http/client.py`"

msgid ""
"This module defines classes which implement the client side of the HTTP and "
"HTTPS protocols.  It is normally not used directly --- the module :mod:"
"`urllib.request` uses it to handle URLs that use HTTP and HTTPS."
msgstr ""
"Цей модуль визначає класи, які реалізують клієнтську сторону протоколів HTTP "
"і HTTPS. Зазвичай він не використовується безпосередньо --- модуль :mod:"
"`urllib.request` використовує його для обробки URL-адрес, які використовують "
"HTTP і HTTPS."

msgid ""
"The `Requests package <https://requests.readthedocs.io/en/master/>`_ is "
"recommended for a higher-level HTTP client interface."
msgstr ""
"`Пакет запитів <https://requests.readthedocs.io/en/master/>`_ рекомендовано "
"для клієнтського інтерфейсу HTTP вищого рівня."

msgid ""
"HTTPS support is only available if Python was compiled with SSL support "
"(through the :mod:`ssl` module)."
msgstr ""
"Підтримка HTTPS доступна, лише якщо Python було скомпільовано з підтримкою "
"SSL (через модуль :mod:`ssl`)."

msgid "The module provides the following classes:"
msgstr "Модуль надає такі класи:"

msgid ""
"An :class:`HTTPConnection` instance represents one transaction with an HTTP "
"server.  It should be instantiated passing it a host and optional port "
"number.  If no port number is passed, the port is extracted from the host "
"string if it has the form ``host:port``, else the default HTTP port (80) is "
"used.  If the optional *timeout* parameter is given, blocking operations "
"(like connection attempts) will timeout after that many seconds (if it is "
"not given, the global default timeout setting is used). The optional "
"*source_address* parameter may be a tuple of a (host, port) to use as the "
"source address the HTTP connection is made from. The optional *blocksize* "
"parameter sets the buffer size in bytes for sending a file-like message body."
msgstr ""
"Екземпляр :class:`HTTPConnection` представляє одну транзакцію з сервером "
"HTTP. Його слід створити, передавши йому хост і необов’язковий номер порту. "
"Якщо номер порту не передано, порт витягується з рядка хоста, якщо він має "
"форму ``host:port``, інакше використовується стандартний порт HTTP (80). "
"Якщо вказано необов’язковий параметр *timeout*, операції блокування "
"(наприклад, спроби підключення) закінчаться через стільки секунд (якщо його "
"не вказано, використовується глобальне налаштування часу очікування за "
"замовчуванням). Додатковий параметр *source_address* може бути кортежем "
"(хост, порт) для використання як адреси джерела, з якого створюється HTTP-"
"з’єднання. Додатковий параметр *blocksize* встановлює розмір буфера в байтах "
"для надсилання тіла повідомлення, схожого на файл."

msgid ""
"For example, the following calls all create instances that connect to the "
"server at the same host and port::"
msgstr ""
"Наприклад, усі наведені нижче виклики створюють екземпляри, які "
"підключаються до сервера на одному хості та порту:"

msgid "*source_address* was added."
msgstr "*вихідна_адреса* була додана."

msgid ""
"The  *strict* parameter was removed. HTTP 0.9-style \"Simple Responses\" are "
"not longer supported."
msgstr ""
"Параметр *strict* видалено. \"Прості відповіді\" у стилі HTTP 0.9 більше не "
"підтримуються."

msgid "*blocksize* parameter was added."
msgstr "Додано параметр *blocksize*."

msgid ""
"A subclass of :class:`HTTPConnection` that uses SSL for communication with "
"secure servers.  Default port is ``443``.  If *context* is specified, it "
"must be a :class:`ssl.SSLContext` instance describing the various SSL "
"options."
msgstr ""
"Підклас :class:`HTTPConnection`, який використовує SSL для зв’язку із "
"захищеними серверами. Стандартний порт ``443``. Якщо вказано *контекст*, це "
"має бути екземпляр :class:`ssl.SSLContext`, який описує різні параметри SSL."

msgid "Please read :ref:`ssl-security` for more information on best practices."
msgstr ""
"Будь ласка, прочитайте :ref:`ssl-security`, щоб дізнатися більше про "
"найкращі практики."

msgid "*source_address*, *context* and *check_hostname* were added."
msgstr "Додано *source_address*, *context* і *check_hostname*."

msgid ""
"This class now supports HTTPS virtual hosts if possible (that is, if :data:"
"`ssl.HAS_SNI` is true)."
msgstr ""
"Цей клас тепер підтримує віртуальні хости HTTPS, якщо це можливо (тобто, "
"якщо :data:`ssl.HAS_SNI` має значення true)."

msgid ""
"The *strict* parameter was removed. HTTP 0.9-style \"Simple Responses\" are "
"no longer supported."
msgstr ""
"Параметр *strict* видалено. \"Прості відповіді\" у стилі HTTP 0.9 більше не "
"підтримуються."

msgid ""
"This class now performs all the necessary certificate and hostname checks by "
"default. To revert to the previous, unverified, behavior :func:`ssl."
"_create_unverified_context` can be passed to the *context* parameter."
msgstr ""
"Тепер цей клас за замовчуванням виконує всі необхідні перевірки сертифікатів "
"і імен хостів. Щоб повернутися до попередньої, неперевіреної поведінки, :"
"func:`ssl._create_unverified_context` можна передати в параметр *context*."

msgid ""
"This class now enables TLS 1.3 :attr:`ssl.SSLContext.post_handshake_auth` "
"for the default *context* or when *cert_file* is passed with a custom "
"*context*."
msgstr ""
"Цей клас тепер увімкне TLS 1.3 :attr:`ssl.SSLContext.post_handshake_auth` "
"для *контексту* за замовчуванням або коли *cert_file* передається з "
"настроюваним *контекстом*."

msgid ""
"This class now sends an ALPN extension with protocol indicator ``http/1.1`` "
"when no *context* is given. Custom *context* should set ALPN protocols with :"
"meth:`~ssl.SSLContext.set_alpn_protocol`."
msgstr ""
"Цей клас тепер надсилає розширення ALPN з індикатором протоколу "
"``http/1.1``, якщо не задано *контексту*. Спеціальний *контекст* має "
"встановлювати протоколи ALPN за допомогою :meth:`~ssl.SSSLContext."
"set_alpn_protocol`."

msgid ""
"*key_file* and *cert_file* are deprecated in favor of *context*. Please use :"
"meth:`ssl.SSLContext.load_cert_chain` instead, or let :func:`ssl."
"create_default_context` select the system's trusted CA certificates for you."
msgstr ""
"*key_file* і *cert_file* застаріли на користь *context*. Натомість "
"використовуйте :meth:`ssl.SSLContext.load_cert_chain` або дозвольте :func:"
"`ssl.create_default_context` вибрати для вас надійні сертифікати ЦС системи."

msgid ""
"The *check_hostname* parameter is also deprecated; the :attr:`ssl.SSLContext."
"check_hostname` attribute of *context* should be used instead."
msgstr ""
"Параметр *check_hostname* також застарів; замість нього слід використовувати "
"атрибут :attr:`ssl.SSLContext.check_hostname` *context*."

msgid ""
"Class whose instances are returned upon successful connection.  Not "
"instantiated directly by user."
msgstr ""
"Клас, екземпляри якого повертаються після успішного підключення. Не "
"створюється безпосередньо користувачем."

msgid ""
"The *strict* parameter was removed. HTTP 0.9 style \"Simple Responses\" are "
"no longer supported."
msgstr ""
"Параметр *strict* видалено. Стиль HTTP 0.9 \"Прості відповіді\" більше не "
"підтримується."

msgid "This module provides the following function:"
msgstr "Цей модуль забезпечує наступні функції:"

msgid ""
"Parse the headers from a file pointer *fp* representing a HTTP request/"
"response. The file has to be a :class:`BufferedIOBase` reader (i.e. not "
"text) and must provide a valid :rfc:`2822` style header."
msgstr ""
"Проаналізуйте заголовки з покажчика файлу *fp*, що представляє запит/"
"відповідь HTTP. Файл має бути :class:`BufferedIOBase` читачем (тобто не "
"текстовим) і має містити дійсний заголовок стилю :rfc:`2822`."

msgid ""
"This function returns an instance of :class:`http.client.HTTPMessage` that "
"holds the header fields, but no payload (the same as :attr:`HTTPResponse."
"msg` and :attr:`http.server.BaseHTTPRequestHandler.headers`). After "
"returning, the file pointer *fp* is ready to read the HTTP body."
msgstr ""
"Ця функція повертає екземпляр :class:`http.client.HTTPMessage`, який містить "
"поля заголовка, але не містить корисного навантаження (те саме, що :attr:"
"`HTTPResponse.msg` і :attr:`http.server.BaseHTTPRequestHandler.headers` ). "
"Після повернення покажчик файлу *fp* готовий читати тіло HTTP."

msgid ""
":meth:`parse_headers` does not parse the start-line of a HTTP message; it "
"only parses the ``Name: value`` lines. The file has to be ready to read "
"these field lines, so the first line should already be consumed before "
"calling the function."
msgstr ""
":meth:`parse_headers` не аналізує початковий рядок HTTP-повідомлення; він "
"аналізує лише рядки ``Назва: значення``. Файл має бути готовий до читання "
"цих рядків полів, тому перший рядок уже має бути використано перед викликом "
"функції."

msgid "The following exceptions are raised as appropriate:"
msgstr "Наступні винятки підняті відповідно до:"

msgid ""
"The base class of the other exceptions in this module.  It is a subclass of :"
"exc:`Exception`."
msgstr ""
"Базовий клас інших винятків у цьому модулі. Це підклас :exc:`Exception`."

msgid "A subclass of :exc:`HTTPException`."
msgstr "Підклас :exc:`HTTPException`."

msgid ""
"A subclass of :exc:`HTTPException`, raised if a port is given and is either "
"non-numeric or empty."
msgstr ""
"Підклас :exc:`HTTPException`, викликаний, якщо задано порт, який є "
"нечисловим або порожнім."

msgid "A subclass of :exc:`ImproperConnectionState`."
msgstr "Підклас :exc:`ImproperConnectionState`."

msgid ""
"A subclass of :exc:`HTTPException`.  Raised if a server responds with a HTTP "
"status code that we don't understand."
msgstr ""
"Підклас :exc:`HTTPException`. Викликається, якщо сервер відповідає кодом "
"статусу HTTP, який ми не розуміємо."

msgid ""
"A subclass of :exc:`HTTPException`.  Raised if an excessively long line is "
"received in the HTTP protocol from the server."
msgstr ""
"Підклас :exc:`HTTPException`. Викликається, якщо в протоколі HTTP від "
"сервера отримано надто довгий рядок."

msgid ""
"A subclass of :exc:`ConnectionResetError` and :exc:`BadStatusLine`.  Raised "
"by :meth:`HTTPConnection.getresponse` when the attempt to read the response "
"results in no data read from the connection, indicating that the remote end "
"has closed the connection."
msgstr ""
"Підклас :exc:`ConnectionResetError` і :exc:`BadStatusLine`. Викликається :"
"meth:`HTTPConnection.getresponse`, коли спроба прочитати відповідь не "
"призводить до зчитування даних із з’єднання, що вказує на те, що віддалена "
"сторона закрила з’єднання."

msgid "Previously, :exc:`BadStatusLine`\\ ``('')`` was raised."
msgstr "Раніше було піднято :exc:`BadStatusLine`\\ ``('')``."

msgid "The constants defined in this module are:"
msgstr "Константи, визначені в цьому модулі:"

msgid "The default port for the HTTP protocol (always ``80``)."
msgstr "Порт за замовчуванням для протоколу HTTP (завжди ``80``)."

msgid "The default port for the HTTPS protocol (always ``443``)."
msgstr "Порт за замовчуванням для протоколу HTTPS (завжди ``443``)."

msgid "This dictionary maps the HTTP 1.1 status codes to the W3C names."
msgstr "Цей словник відображає коди статусу HTTP 1.1 на імена W3C."

msgid ""
"Example: ``http.client.responses[http.client.NOT_FOUND]`` is ``'Not Found'``."
msgstr ""
"Приклад: ``http.client.responses[http.client.NOT_FOUND]`` означає ``'Не "
"знайдено'``."

msgid ""
"See :ref:`http-status-codes` for a list of HTTP status codes that are "
"available in this module as constants."
msgstr ""
"Перегляньте :ref:`http-status-codes` список кодів стану HTTP, які доступні в "
"цьому модулі як константи."

msgid "HTTPConnection Objects"
msgstr "Об'єкти HTTPConnection"

msgid ":class:`HTTPConnection` instances have the following methods:"
msgstr "Екземпляри :class:`HTTPConnection` мають такі методи:"

msgid ""
"This will send a request to the server using the HTTP request method "
"*method* and the selector *url*."
msgstr ""
"Це надішле запит на сервер за допомогою методу запиту HTTP *method* і "
"селектора *url*."

msgid ""
"If *body* is specified, the specified data is sent after the headers are "
"finished.  It may be a :class:`str`, a :term:`bytes-like object`, an open :"
"term:`file object`, or an iterable of :class:`bytes`.  If *body* is a "
"string, it is encoded as ISO-8859-1, the default for HTTP.  If it is a bytes-"
"like object, the bytes are sent as is.  If it is a :term:`file object`, the "
"contents of the file is sent; this file object should support at least the "
"``read()`` method.  If the file object is an instance of :class:`io."
"TextIOBase`, the data returned by the ``read()`` method will be encoded as "
"ISO-8859-1, otherwise the data returned by ``read()`` is sent as is.  If "
"*body* is an iterable, the elements of the iterable are sent as is until the "
"iterable is exhausted."
msgstr ""
"Якщо вказано *body*, зазначені дані надсилаються після завершення "
"заголовків. Це може бути :class:`str`, :term:`bytes-like object`, відкритий :"
"term:`file object` або ітерація :class:`bytes`. Якщо *body* є рядком, він "
"кодується як ISO-8859-1, стандартний для HTTP. Якщо це байтоподібний об’єкт, "
"байти надсилаються як є. Якщо це :term:`file object`, вміст файлу "
"надсилається; цей файловий об’єкт має підтримувати принаймні метод "
"``read()``. Якщо об’єкт файлу є екземпляром :class:`io.TextIOBase`, дані, "
"повернуті методом ``read()``, будуть закодовані як ISO-8859-1, інакше дані, "
"повернуті ``read()`` надсилається як є. Якщо *body* є iterable, елементи "
"iterable надсилаються як є, доки iterable не буде вичерпано."

msgid ""
"The *headers* argument should be a mapping of extra HTTP headers to send "
"with the request."
msgstr ""
"Аргумент *headers* має бути відображенням додаткових HTTP-заголовків, які "
"надсилаються із запитом."

msgid ""
"If *headers* contains neither Content-Length nor Transfer-Encoding, but "
"there is a request body, one of those header fields will be added "
"automatically.  If *body* is ``None``, the Content-Length header is set to "
"``0`` for methods that expect a body (``PUT``, ``POST``, and ``PATCH``).  If "
"*body* is a string or a bytes-like object that is not also a :term:`file "
"<file object>`, the Content-Length header is set to its length.  Any other "
"type of *body* (files and iterables in general) will be chunk-encoded, and "
"the Transfer-Encoding header will automatically be set instead of Content-"
"Length."
msgstr ""
"Якщо *headers* не містить ані Content-Length, ані Transfer-Encoding, але є "
"тіло запиту, одне з цих полів заголовка буде додано автоматично. Якщо *body* "
"має значення ``None``, заголовок Content-Length встановлюється на ``0`` для "
"методів, які очікують тіла (``PUT``, ``POST`` і ``PATCH``). . Якщо *body* є "
"рядком або байтоподібним об’єктом, який також не є :term:`файлом <file "
"object>`, заголовок Content-Length встановлюється на його довжину. Будь-який "
"інший тип *body* (файли та ітерації загалом) буде закодовано фрагментами, а "
"заголовок Transfer-Encoding буде автоматично встановлено замість Content-"
"Length."

msgid ""
"The *encode_chunked* argument is only relevant if Transfer-Encoding is "
"specified in *headers*.  If *encode_chunked* is ``False``, the "
"HTTPConnection object assumes that all encoding is handled by the calling "
"code.  If it is ``True``, the body will be chunk-encoded."
msgstr ""
"Аргумент *encode_chunked* доречний, лише якщо Transfer-Encoding указано в "
"*headers*. Якщо *encode_chunked* має значення ``False``, об’єкт "
"HTTPConnection припускає, що все кодування обробляється кодом виклику. Якщо "
"значення ``True``, тіло буде закодовано фрагментами."

msgid ""
"Chunked transfer encoding has been added to the HTTP protocol version 1.1.  "
"Unless the HTTP server is known to handle HTTP 1.1, the caller must either "
"specify the Content-Length, or must pass a :class:`str` or bytes-like object "
"that is not also a file as the body representation."
msgstr ""
"До протоколу HTTP версії 1.1 додано кодування передачі фрагментами. Якщо не "
"відомо, що HTTP-сервер обробляє HTTP 1.1, абонент повинен або вказати "
"Content-Length, або повинен передати :class:`str` або байт-подібний об’єкт, "
"який також не є файлом, як представлення тіла."

msgid "*body* can now be an iterable."
msgstr "*body* тепер може бути ітерованим."

msgid ""
"If neither Content-Length nor Transfer-Encoding are set in *headers*, file "
"and iterable *body* objects are now chunk-encoded. The *encode_chunked* "
"argument was added. No attempt is made to determine the Content-Length for "
"file objects."
msgstr ""
"Якщо ані Content-Length, ані Transfer-Encoding не встановлено в *headers*, "
"файл і ітераційні *body* об’єкти тепер закодовані фрагментами. Додано "
"аргумент *encode_chunked*. Не робиться жодних спроб визначити довжину вмісту "
"для файлових об’єктів."

msgid ""
"Should be called after a request is sent to get the response from the "
"server. Returns an :class:`HTTPResponse` instance."
msgstr ""
"Має викликатися після надсилання запиту, щоб отримати відповідь від сервера. "
"Повертає екземпляр :class:`HTTPResponse`."

msgid ""
"Note that you must have read the whole response before you can send a new "
"request to the server."
msgstr ""
"Зверніть увагу, що ви повинні прочитати всю відповідь, перш ніж ви зможете "
"надіслати новий запит на сервер."

msgid ""
"If a :exc:`ConnectionError` or subclass is raised, the :class:"
"`HTTPConnection` object will be ready to reconnect when a new request is "
"sent."
msgstr ""
"Якщо виникає :exc:`ConnectionError` або підклас, об’єкт :class:"
"`HTTPConnection` буде готовий до повторного підключення, коли буде надіслано "
"новий запит."

msgid ""
"Set the debugging level.  The default debug level is ``0``, meaning no "
"debugging output is printed.  Any value greater than ``0`` will cause all "
"currently defined debug output to be printed to stdout.  The ``debuglevel`` "
"is passed to any new :class:`HTTPResponse` objects that are created."
msgstr ""
"Встановіть рівень налагодження. Рівень налагодження за замовчуванням ``0``, "
"тобто вихідні дані налагодження не друкуються. Будь-яке значення, яке "
"перевищує ``0``, призведе до того, що весь поточний визначений вихід "
"налагодження буде надруковано в stdout. ``debuglevel`` передається будь-яким "
"новим об’єктам :class:`HTTPResponse`, які створюються."

msgid ""
"Set the host and the port for HTTP Connect Tunnelling. This allows running "
"the connection through a proxy server."
msgstr ""
"Встановіть хост і порт для тунелювання підключення HTTP. Це дозволяє "
"запускати підключення через проксі-сервер."

msgid ""
"The host and port arguments specify the endpoint of the tunneled connection "
"(i.e. the address included in the CONNECT request, *not* the address of the "
"proxy server)."
msgstr ""
"Аргументи host і port визначають кінцеву точку тунельованого з’єднання "
"(тобто адресу, включену в запит CONNECT, *не* адресу проксі-сервера)."

msgid ""
"The headers argument should be a mapping of extra HTTP headers to send with "
"the CONNECT request."
msgstr ""
"Аргумент заголовків має бути відображенням додаткових заголовків HTTP для "
"надсилання із запитом CONNECT."

msgid ""
"For example, to tunnel through a HTTPS proxy server running locally on port "
"8080, we would pass the address of the proxy to the :class:`HTTPSConnection` "
"constructor, and the address of the host that we eventually want to reach to "
"the :meth:`~HTTPConnection.set_tunnel` method::"
msgstr ""
"Наприклад, щоб тунелювати через проксі-сервер HTTPS, який працює локально на "
"порту 8080, ми повинні передати адресу проксі-сервера до конструктора :class:"
"`HTTPSConnection`, а адресу хоста, до якого ми хочемо отримати доступ, до :"
"meth:`~HTTPConnection.set_tunnel` метод::"

msgid ""
"Connect to the server specified when the object was created.  By default, "
"this is called automatically when making a request if the client does not "
"already have a connection."
msgstr ""
"Підключіться до сервера, указаного під час створення об’єкта. За "
"замовчуванням це викликається автоматично під час надсилання запиту, якщо "
"клієнт ще не має підключення."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``http.client.connect`` with "
"arguments ``self``, ``host``, ``port``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``http.client.connect`` з "
"аргументами ``self``, ``host``, ``port``."

msgid "Close the connection to the server."
msgstr "Закрийте підключення до сервера."

msgid "Buffer size in bytes for sending a file-like message body."
msgstr ""
"Розмір буфера в байтах для надсилання тіла повідомлення, схожого на файл."

msgid ""
"As an alternative to using the :meth:`request` method described above, you "
"can also send your request step by step, by using the four functions below."
msgstr ""
"Як альтернативу використанню методу :meth:`request`, описаного вище, ви "
"також можете надіслати свій запит крок за кроком, використовуючи чотири "
"функції нижче."

msgid ""
"This should be the first call after the connection to the server has been "
"made. It sends a line to the server consisting of the *method* string, the "
"*url* string, and the HTTP version (``HTTP/1.1``).  To disable automatic "
"sending of ``Host:`` or ``Accept-Encoding:`` headers (for example to accept "
"additional content encodings), specify *skip_host* or *skip_accept_encoding* "
"with non-False values."
msgstr ""
"Це має бути перший виклик після підключення до сервера. Він надсилає на "
"сервер рядок, що складається з рядка *method*, рядка *url* і версії HTTP "
"(``HTTP/1.1``). Щоб вимкнути автоматичне надсилання заголовків ``Host:`` або "
"``Accept-Encoding:`` (наприклад, щоб прийняти додаткове кодування вмісту), "
"укажіть *skip_host* або *skip_accept_encoding* зі значеннями, відмінними від "
"False."

msgid ""
"Send an :rfc:`822`\\ -style header to the server.  It sends a line to the "
"server consisting of the header, a colon and a space, and the first "
"argument.  If more arguments are given, continuation lines are sent, each "
"consisting of a tab and an argument."
msgstr ""
"Надішліть на сервер заголовок у стилі :rfc:`822`\\. Він надсилає на сервер "
"рядок, що складається із заголовка, двокрапки, пробілу та першого аргументу. "
"Якщо задано більше аргументів, надсилаються рядки продовження, кожен з яких "
"складається з табуляції та аргументу."

msgid ""
"Send a blank line to the server, signalling the end of the headers. The "
"optional *message_body* argument can be used to pass a message body "
"associated with the request."
msgstr ""
"Надішліть порожній рядок на сервер, сигналізуючи про кінець заголовків. "
"Додатковий аргумент *message_body* можна використовувати для передачі тіла "
"повідомлення, пов’язаного із запитом."

msgid ""
"If *encode_chunked* is ``True``, the result of each iteration of "
"*message_body* will be chunk-encoded as specified in :rfc:`7230`, Section "
"3.3.1.  How the data is encoded is dependent on the type of *message_body*.  "
"If *message_body* implements the :ref:`buffer interface <bufferobjects>` the "
"encoding will result in a single chunk. If *message_body* is a :class:"
"`collections.abc.Iterable`, each iteration of *message_body* will result in "
"a chunk.  If *message_body* is a :term:`file object`, each call to ``."
"read()`` will result in a chunk. The method automatically signals the end of "
"the chunk-encoded data immediately after *message_body*."
msgstr ""
"Якщо *encode_chunked* має значення ``True``, результат кожної ітерації "
"*message_body* буде закодовано фрагментами, як зазначено в :rfc:`7230`, "
"розділ 3.3.1. Спосіб кодування даних залежить від типу *message_body*. Якщо "
"*message_body* реалізує :ref:`інтерфейс буфера <bufferobjects>`, кодування "
"призведе до єдиного блоку. Якщо *message_body* є :class:`collections.abc."
"Iterable`, кожна ітерація *message_body* призведе до блоку. Якщо "
"*message_body* є об’єктом :term:`file object`, кожен виклик ``.read()`` "
"призведе до блоку. Метод автоматично сигналізує про кінець даних, "
"закодованих фрагментами, відразу після *message_body*."

msgid ""
"Due to the chunked encoding specification, empty chunks yielded by an "
"iterator body will be ignored by the chunk-encoder. This is to avoid "
"premature termination of the read of the request by the target server due to "
"malformed encoding."
msgstr ""
"Через специфікацію фрагментованого кодування порожні фрагменти, отримані "
"тілом ітератора, ігноруватимуться кодувальником фрагментів. Це робиться для "
"того, щоб уникнути передчасного припинення читання запиту цільовим сервером "
"через неправильне кодування."

msgid "Chunked encoding support.  The *encode_chunked* parameter was added."
msgstr "Підтримка фрагментованого кодування. Додано параметр *encode_chunked*."

msgid ""
"Send data to the server.  This should be used directly only after the :meth:"
"`endheaders` method has been called and before :meth:`getresponse` is called."
msgstr ""
"Надіслати дані на сервер. Це слід використовувати безпосередньо лише після "
"виклику методу :meth:`endheaders` і до виклику :meth:`getresponse`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``http.client.send`` with "
"arguments ``self``, ``data``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``http.client.send`` з аргументами "
"``self``, ``data``."

msgid "HTTPResponse Objects"
msgstr "Об'єкти HTTPResponse"

msgid ""
"An :class:`HTTPResponse` instance wraps the HTTP response from the server.  "
"It provides access to the request headers and the entity body.  The response "
"is an iterable object and can be used in a with statement."
msgstr ""
"Екземпляр :class:`HTTPResponse` обгортає відповідь HTTP від сервера. Він "
"забезпечує доступ до заголовків запиту та тіла сутності. Відповідь є "
"повторюваним об’єктом і може використовуватися в операторі with."

msgid ""
"The :class:`io.BufferedIOBase` interface is now implemented and all of its "
"reader operations are supported."
msgstr ""
"Інтерфейс :class:`io.BufferedIOBase` тепер реалізовано, і всі його операції "
"читання підтримуються."

msgid "Reads and returns the response body, or up to the next *amt* bytes."
msgstr "Читає та повертає тіло відповіді або до наступних байтів *amt*."

msgid ""
"Reads up to the next len(b) bytes of the response body into the buffer *b*. "
"Returns the number of bytes read."
msgstr ""
"Зчитує до наступного len(b) байт тіла відповіді в буфер *b*. Повертає "
"кількість прочитаних байтів."

msgid ""
"Return the value of the header *name*, or *default* if there is no header "
"matching *name*.  If there is more than one  header with the name *name*, "
"return all of the values joined by ', '.  If 'default' is any iterable other "
"than a single string, its elements are similarly returned joined by commas."
msgstr ""
"Повертає значення заголовка *name* або *default*, якщо заголовок не "
"відповідає *name*. Якщо є більше одного заголовка з іменем *name*, поверніть "
"усі значення, об’єднані \",\". Якщо 'default' є будь-яким ітерованим, крім "
"одного рядка, його елементи так само повертаються, об'єднані комами."

msgid "Return a list of (header, value) tuples."
msgstr "Повертає список кортежів (заголовок, значення)."

msgid "Return the ``fileno`` of the underlying socket."
msgstr "Повертає ``fileno`` основного сокета."

msgid ""
"A :class:`http.client.HTTPMessage` instance containing the response "
"headers.  :class:`http.client.HTTPMessage` is a subclass of :class:`email."
"message.Message`."
msgstr ""
"Екземпляр :class:`http.client.HTTPMessage`, що містить заголовки "
"відповідей. :class:`http.client.HTTPMessage` є підкласом :class:`email."
"message.Message`."

msgid ""
"HTTP protocol version used by server.  10 for HTTP/1.0, 11 for HTTP/1.1."
msgstr ""
"Версія протоколу HTTP, яку використовує сервер. 10 для HTTP/1.0, 11 для "
"HTTP/1.1."

msgid ""
"URL of the resource retrieved, commonly used to determine if a redirect was "
"followed."
msgstr ""
"URL-адреса отриманого ресурсу, яка зазвичай використовується для визначення "
"того, чи було переспрямовано."

msgid ""
"Headers of the response in the form of an :class:`email.message."
"EmailMessage` instance."
msgstr ""
"Заголовки відповіді у формі екземпляра :class:`email.message.EmailMessage`."

msgid "Status code returned by server."
msgstr "Код статусу, повернутий сервером."

msgid "Reason phrase returned by server."
msgstr "Фраза причини, повернута сервером."

msgid ""
"A debugging hook.  If :attr:`debuglevel` is greater than zero, messages will "
"be printed to stdout as the response is read and parsed."
msgstr ""
"Гачок для налагодження. Якщо :attr:`debuglevel` більше нуля, повідомлення "
"буде надруковано в стандартний вихід під час читання та аналізу відповіді."

msgid "Is ``True`` if the stream is closed."
msgstr "Значить ``True``, якщо потік закрито."

msgid "Deprecated in favor of :attr:`~HTTPResponse.url`."
msgstr "Застаріло на користь :attr:`~HTTPResponse.url`."

msgid "Deprecated in favor of :attr:`~HTTPResponse.headers`."
msgstr "Застаріло на користь :attr:`~HTTPResponse.headers`."

msgid "Deprecated in favor of :attr:`~HTTPResponse.status`."
msgstr "Застаріло на користь :attr:`~HTTPResponse.status`."

msgid "Examples"
msgstr "Приклади"

msgid "Here is an example session that uses the ``GET`` method::"
msgstr "Ось приклад сеансу, який використовує метод ``GET``::"

msgid ""
"Here is an example session that uses the ``HEAD`` method.  Note that the "
"``HEAD`` method never returns any data. ::"
msgstr ""
"Ось приклад сеансу, який використовує метод ``HEAD``. Зауважте, що метод "
"``HEAD`` ніколи не повертає жодних даних. ::"

msgid "Here is an example session that shows how to ``POST`` requests::"
msgstr "Ось приклад сеансу, який показує, як ``POST`` запити::"

msgid ""
"Client side ``HTTP PUT`` requests are very similar to ``POST`` requests. The "
"difference lies only the server side where HTTP server will allow resources "
"to be created via ``PUT`` request. It should be noted that custom HTTP "
"methods are also handled in :class:`urllib.request.Request` by setting the "
"appropriate method attribute. Here is an example session that shows how to "
"send a ``PUT`` request using http.client::"
msgstr ""
"Клієнтські запити ``HTTP PUT`` дуже схожі на ``POST`` запити. Різниця "
"полягає лише на стороні сервера, де сервер HTTP дозволить створювати ресурси "
"за допомогою запиту ``PUT``. Слід зазначити, що спеціальні методи HTTP також "
"обробляються в :class:`urllib.request.Request` шляхом встановлення "
"відповідного атрибута методу. Ось приклад сеансу, який показує, як надіслати "
"запит ``PUT`` за допомогою http.client::"

msgid "HTTPMessage Objects"
msgstr "Об’єкти HTTPMessage"

msgid ""
"An :class:`http.client.HTTPMessage` instance holds the headers from an HTTP "
"response.  It is implemented using the :class:`email.message.Message` class."
msgstr ""
"Екземпляр :class:`http.client.HTTPMessage` містить заголовки відповіді HTTP. "
"Це реалізовано за допомогою класу :class:`email.message.Message`."
