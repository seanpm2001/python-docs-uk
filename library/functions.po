# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:06+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Built-in Functions"
msgstr "Вбудовані функції"

msgid ""
"The Python interpreter has a number of functions and types built into it "
"that are always available.  They are listed here in alphabetical order."
msgstr ""
"Інтерпретатор Python має ряд вбудованих функцій і типів, які завжди "
"доступні. Вони перераховані тут в алфавітному порядку."

msgid "**A**"
msgstr "**A**"

msgid ":func:`abs`"
msgstr ":func:`abs`"

msgid ":func:`aiter`"
msgstr ":func:`aiter`"

msgid ":func:`all`"
msgstr ":func:`all`"

msgid ":func:`any`"
msgstr ":func:`any`"

msgid ":func:`anext`"
msgstr ":func:`anext`"

msgid ":func:`ascii`"
msgstr ":func:`ascii`"

msgid "**B**"
msgstr "**B**"

msgid ":func:`bin`"
msgstr ":func:`bin`"

msgid ":func:`bool`"
msgstr ":func:`bool`"

msgid ":func:`breakpoint`"
msgstr ":func:`breakpoint`"

msgid "|func-bytearray|_"
msgstr "|func-bytearray|_"

msgid "|func-bytes|_"
msgstr "|func-bytes|_"

msgid "**C**"
msgstr "**C**"

msgid ":func:`callable`"
msgstr ":func:`callable`"

msgid ":func:`chr`"
msgstr ":func:`chr`"

msgid ":func:`classmethod`"
msgstr ":func:`classmethod`"

msgid ":func:`compile`"
msgstr ":func:`compile`"

msgid ":func:`complex`"
msgstr ":func:`complex`"

msgid "**D**"
msgstr "**D**"

msgid ":func:`delattr`"
msgstr ":func:`delattr`"

msgid "|func-dict|_"
msgstr "|func-dict|_"

msgid ":func:`dir`"
msgstr ":func:`dir`"

msgid ":func:`divmod`"
msgstr ":func:`divmod`"

msgid "**E**"
msgstr "**E**"

msgid ":func:`enumerate`"
msgstr ":func:`enumerate`"

msgid ":func:`eval`"
msgstr ":func:`eval`"

msgid ":func:`exec`"
msgstr ":func:`exec`"

msgid "**F**"
msgstr "**F**"

msgid ":func:`filter`"
msgstr ":func:`filter`"

msgid ":func:`float`"
msgstr ":func:`float`"

msgid ":func:`format`"
msgstr ":func:`format`"

msgid "|func-frozenset|_"
msgstr "|func-frozenset|_"

msgid "**G**"
msgstr "**G**"

msgid ":func:`getattr`"
msgstr ":func:`getattr`"

msgid ":func:`globals`"
msgstr ":func:`globals`"

msgid "**H**"
msgstr "**H**"

msgid ":func:`hasattr`"
msgstr ":func:`hasattr`"

msgid ":func:`hash`"
msgstr ":func:`hash`"

msgid ":func:`help`"
msgstr ":func:`help`"

msgid ":func:`hex`"
msgstr ":func:`hex`"

msgid "**I**"
msgstr "**I**"

msgid ":func:`id`"
msgstr ":func:`id`"

msgid ":func:`input`"
msgstr ":func:`input`"

msgid ":func:`int`"
msgstr ":func:`int`"

msgid ":func:`isinstance`"
msgstr ":func:`isinstance`"

msgid ":func:`issubclass`"
msgstr ":func:`issubclass`"

msgid ":func:`iter`"
msgstr ":func:`iter`"

msgid "**L**"
msgstr "**L**"

msgid ":func:`len`"
msgstr ":func:`len`"

msgid "|func-list|_"
msgstr "|func-list|_"

msgid ":func:`locals`"
msgstr ":func:`locals`"

msgid "**M**"
msgstr "**М**"

msgid ":func:`map`"
msgstr ":func:`map`"

msgid ":func:`max`"
msgstr ":func:`max`"

msgid "|func-memoryview|_"
msgstr "|func-memoryview|_"

msgid ":func:`min`"
msgstr ":func:`min`"

msgid "**N**"
msgstr "**Н**"

msgid ":func:`next`"
msgstr ":func:`anext`"

msgid "**O**"
msgstr "**O**"

msgid ":func:`object`"
msgstr ":func:`object`"

msgid ":func:`oct`"
msgstr ":func:`oct`"

msgid ":func:`open`"
msgstr ":func:`open`"

msgid ":func:`ord`"
msgstr ":func:`ord`"

msgid "**P**"
msgstr "**P**"

msgid ":func:`pow`"
msgstr ":func:`pow`"

msgid ":func:`print`"
msgstr ":func:`print`"

msgid ":func:`property`"
msgstr ":func:`property`"

msgid "**R**"
msgstr "**R**"

msgid "|func-range|_"
msgstr "|func-range|_"

msgid ":func:`repr`"
msgstr ":func:`repr`"

msgid ":func:`reversed`"
msgstr ":func:`reversed`"

msgid ":func:`round`"
msgstr ":func:`round`"

msgid "**S**"
msgstr "**S**"

msgid "|func-set|_"
msgstr "|func-set|_"

msgid ":func:`setattr`"
msgstr ":func:`setattr`"

msgid ":func:`slice`"
msgstr ":func:`slice`"

msgid ":func:`sorted`"
msgstr ":func:`sorted`"

msgid ":func:`staticmethod`"
msgstr ":func:`staticmethod`"

msgid "|func-str|_"
msgstr "|func-str|_"

msgid ":func:`sum`"
msgstr ":func:`sum`"

msgid ":func:`super`"
msgstr ":func:`super`"

msgid "**T**"
msgstr "**T**"

msgid "|func-tuple|_"
msgstr "|func-tuple|_"

msgid ":func:`type`"
msgstr ":func:`type`"

msgid "**V**"
msgstr "**V**"

msgid ":func:`vars`"
msgstr ":func:`vars`"

msgid "**Z**"
msgstr "**Z**"

msgid ":func:`zip`"
msgstr ":func:`zip`"

msgid "**_**"
msgstr "**_**"

msgid ":func:`__import__`"
msgstr ":func:`__import__`"

msgid ""
"Return the absolute value of a number.  The argument may be an integer, a "
"floating point number, or an object implementing :meth:`__abs__`. If the "
"argument is a complex number, its magnitude is returned."
msgstr ""
"Повертає абсолютне значення числа. Аргументом може бути ціле число, число з "
"плаваючою комою або об’єкт, що реалізує метод :meth:`__abs__`. Якщо аргумент "
"є комплексним числом, повертається його абсолютна величина."

msgid ""
"Return an :term:`asynchronous iterator` for an :term:`asynchronous "
"iterable`. Equivalent to calling ``x.__aiter__()``."
msgstr ""
"Повертає :term:`асинхронний ітератор <asynchronous iterator>` для :term:"
"`asynchronous iterable`. Еквівалент виклику ``x.__aiter__()``."

msgid "Note: Unlike :func:`iter`, :func:`aiter` has no 2-argument variant."
msgstr ""
"Примітка. На відміну від :func:`iter`, :func:`aiter` не має 2х-аргументного "
"варіанту."

msgid ""
"Return ``True`` if all elements of the *iterable* are true (or if the "
"iterable is empty).  Equivalent to::"
msgstr ""
"Повертає ``True``, якщо всі елементи *iterable* є істинними (або якщо "
"iterable порожній). Дорівнює::"

msgid ""
"When awaited, return the next item from the given :term:`asynchronous "
"iterator`, or *default* if given and the iterator is exhausted."
msgstr ""
"Коли очікується, повертає наступний елемент із заданого :term:`asynchronous "
"iterator` або *default*, якщо задано, а ітератор вичерпано."

msgid ""
"This is the async variant of the :func:`next` builtin, and behaves similarly."
msgstr ""
"Це асинхронний варіант вбудованої функції :func:`next`, і він поводиться "
"аналогічно."

msgid ""
"This calls the :meth:`~object.__anext__` method of *async_iterator*, "
"returning an :term:`awaitable`. Awaiting this returns the next value of the "
"iterator. If *default* is given, it is returned if the iterator is "
"exhausted, otherwise :exc:`StopAsyncIteration` is raised."
msgstr ""
"Це викликає метод :meth:`~object.__anext__` *async_iterator*, повертаючи :"
"term:`awaitable`. Очікування цього повертає наступне значення ітератора. "
"Якщо вказано *default*, воно повертається, якщо ітератор вичерпано, інакше :"
"exc:`StopAsyncIteration` викликається."

msgid ""
"Return ``True`` if any element of the *iterable* is true.  If the iterable "
"is empty, return ``False``.  Equivalent to::"
msgstr ""
"Повертає ``True``, якщо будь-який елемент *iterable* є істинним. Якщо "
"iterable порожній, поверніть ``False``. Дорівнює::"

msgid ""
"As :func:`repr`, return a string containing a printable representation of an "
"object, but escape the non-ASCII characters in the string returned by :func:"
"`repr` using ``\\x``, ``\\u``, or ``\\U`` escapes.  This generates a string "
"similar to that returned by :func:`repr` in Python 2."
msgstr ""
"Як :func:`repr` повертає рядок, що містить представлення об’єкта для друку, "
"але екранує символи, відмінні від ASCII, у рядку, який повертає :func:"
"`repr`, використовуючи ``\\x``, ``\\u`` або ``\\U`` екранує. Це генерує "
"рядок, подібний до того, який повертає :func:`repr` у Python 2."

msgid ""
"Convert an integer number to a binary string prefixed with \"0b\". The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`__index__` method that returns an "
"integer. Some examples:"
msgstr ""
"Перетворення цілого числа на двійковий рядок із префіксом \"0b\". "
"Результатом є дійсний вираз Python. Якщо *x* не є об’єктом Python :class:"
"`int`, він має визначити метод :meth:`__index__`, який повертає ціле число. "
"Деякі приклади:"

msgid ""
"If the prefix \"0b\" is desired or not, you can use either of the following "
"ways."
msgstr ""
"Якщо префікс \"0b\" потрібний чи ні, ви можете скористатися одним із "
"наведених нижче способів."

msgid "See also :func:`format` for more information."
msgstr "Дивіться також :func:`format` для отримання додаткової інформації."

msgid ""
"Return a Boolean value, i.e. one of ``True`` or ``False``.  *x* is converted "
"using the standard :ref:`truth testing procedure <truth>`.  If *x* is false "
"or omitted, this returns ``False``; otherwise, it returns ``True``.  The :"
"class:`bool` class is a subclass of :class:`int` (see :ref:`typesnumeric`). "
"It cannot be subclassed further.  Its only instances are ``False`` and "
"``True`` (see :ref:`bltin-boolean-values`)."
msgstr ""
"Повертає логічне значення, тобто одне з ``True`` або ``False``. *x* "
"перетворюється за допомогою стандартної :ref:`процедури перевірки істинності "
"<truth>`. Якщо *x* є false або пропущено, це повертає ``False``; інакше він "
"повертає ``True``. Клас :class:`bool` є підкласом :class:`int` (див. :ref:"
"`typesnumeric`). Його не можна далі класифікувати. Єдиними його екземплярами "
"є ``False`` і ``True`` (див. :ref:`bltin-boolean-values`)."

msgid "*x* is now a positional-only parameter."
msgstr "*x* тепер є лише позиційним параметром."

msgid ""
"This function drops you into the debugger at the call site.  Specifically, "
"it calls :func:`sys.breakpointhook`, passing ``args`` and ``kws`` straight "
"through.  By default, ``sys.breakpointhook()`` calls :func:`pdb.set_trace()` "
"expecting no arguments.  In this case, it is purely a convenience function "
"so you don't have to explicitly import :mod:`pdb` or type as much code to "
"enter the debugger.  However, :func:`sys.breakpointhook` can be set to some "
"other function and :func:`breakpoint` will automatically call that, allowing "
"you to drop into the debugger of choice. If :func:`sys.breakpointhook` is "
"not accessible, this function will raise :exc:`RuntimeError`."
msgstr ""

msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.breakpoint`` with "
"argument ``breakpointhook``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``builtins.breakpoint`` з аргументом "
"``breakpointhook``."

msgid ""
"Return a new array of bytes.  The :class:`bytearray` class is a mutable "
"sequence of integers in the range 0 <= x < 256.  It has most of the usual "
"methods of mutable sequences, described in :ref:`typesseq-mutable`, as well "
"as most methods that the :class:`bytes` type has, see :ref:`bytes-methods`."
msgstr ""
"Повертає новий масив байтів. Клас :class:`bytearray` — це змінна "
"послідовність цілих чисел у діапазоні 0 <= x < 256. Він містить більшість "
"звичайних методів змінних послідовностей, описаних у :ref:`typesseq-"
"mutable`, а також більшість методи, які має тип :class:`bytes`, див. :ref:"
"`bytes-methods`."

msgid ""
"The optional *source* parameter can be used to initialize the array in a few "
"different ways:"
msgstr ""
"Додатковий параметр *source* можна використовувати для ініціалізації масиву "
"кількома різними способами:"

msgid ""
"If it is a *string*, you must also give the *encoding* (and optionally, "
"*errors*) parameters; :func:`bytearray` then converts the string to bytes "
"using :meth:`str.encode`."
msgstr ""
"Якщо це *рядок*, ви також повинні надати параметри *encoding* (і, "
"необов’язково, *errors*); Потім :func:`bytearray` перетворює рядок на байти "
"за допомогою :meth:`str.encode`."

msgid ""
"If it is an *integer*, the array will have that size and will be initialized "
"with null bytes."
msgstr ""
"Якщо це *ціле число*, масив матиме такий розмір і буде ініціалізовано "
"нульовими байтами."

msgid ""
"If it is an object conforming to the :ref:`buffer interface "
"<bufferobjects>`, a read-only buffer of the object will be used to "
"initialize the bytes array."
msgstr ""
"Якщо це об’єкт, що відповідає :ref:`інтерфейсу буфера <bufferobjects>`, для "
"ініціалізації масиву байтів буде використано буфер лише для читання об’єкта."

msgid ""
"If it is an *iterable*, it must be an iterable of integers in the range ``0 "
"<= x < 256``, which are used as the initial contents of the array."
msgstr ""
"Якщо це *iterable*, це має бути iterable цілих чисел у діапазоні ``0 <= x < "
"256``, які використовуються як початковий вміст масиву."

msgid "Without an argument, an array of size 0 is created."
msgstr "Без аргументу створюється масив розміром 0."

msgid "See also :ref:`binaryseq` and :ref:`typebytearray`."
msgstr "Дивіться також :ref:`binaryseq` і :ref:`typebytearray`."

msgid ""
"Return a new \"bytes\" object which is an immutable sequence of integers in "
"the range ``0 <= x < 256``.  :class:`bytes` is an immutable version of :"
"class:`bytearray` -- it has the same non-mutating methods and the same "
"indexing and slicing behavior."
msgstr ""
"Повертає новий об’єкт \"bytes\", який є незмінною послідовністю цілих чисел "
"у діапазоні \"0 <= x < 256\". :class:`bytes` є незмінною версією :class:"
"`bytearray` -- вона має ті самі методи без мутації та таку саму поведінку "
"індексування та зрізання."

msgid ""
"Accordingly, constructor arguments are interpreted as for :func:`bytearray`."
msgstr ""
"Відповідно, аргументи конструктора інтерпретуються як для :func:`bytearray`."

msgid "Bytes objects can also be created with literals, see :ref:`strings`."
msgstr ""
"Об’єкти Bytes також можна створювати за допомогою літералів, див. :ref:"
"`strings`."

msgid "See also :ref:`binaryseq`, :ref:`typebytes`, and :ref:`bytes-methods`."
msgstr ""
"Дивіться також :ref:`binaryseq`, :ref:`typebytes` і :ref:`bytes-methods`."

msgid ""
"Return :const:`True` if the *object* argument appears callable, :const:"
"`False` if not.  If this returns ``True``, it is still possible that a call "
"fails, but if it is ``False``, calling *object* will never succeed. Note "
"that classes are callable (calling a class returns a new instance); "
"instances are callable if their class has a :meth:`__call__` method."
msgstr ""
"Повертає :const:`True`, якщо аргумент *object* здається викликаним, :const:"
"`False`, якщо ні. Якщо це повертає ``True``, все ще можливо, що виклик не "
"вдасться, але якщо це ``False``, виклик *object* ніколи не вдасться. "
"Зауважте, що класи можна викликати (виклик класу повертає новий екземпляр); "
"екземпляри можна викликати, якщо їхній клас має метод :meth:`__call__`."

msgid ""
"This function was first removed in Python 3.0 and then brought back in "
"Python 3.2."
msgstr ""
"Цю функцію спочатку було видалено в Python 3.0, а потім повернуто в Python "
"3.2."

msgid ""
"Return the string representing a character whose Unicode code point is the "
"integer *i*.  For example, ``chr(97)`` returns the string ``'a'``, while "
"``chr(8364)`` returns the string ``'€'``. This is the inverse of :func:`ord`."
msgstr ""
"Повертає рядок, що представляє символ, кодовою точкою Unicode якого є ціле "
"число *i*. Наприклад, ``chr(97)`` повертає рядок ``'a''``, а ``chr(8364)`` "
"повертає рядок ``'€'``. Це зворотне до :func:`ord`."

msgid ""
"The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in "
"base 16).  :exc:`ValueError` will be raised if *i* is outside that range."
msgstr ""
"Допустимий діапазон для аргументу – від 0 до 1 114 111 (0x10FFFF за основою "
"16). :exc:`ValueError` буде викликано, якщо *i* знаходиться за межами цього "
"діапазону."

msgid "Transform a method into a class method."
msgstr "Перетворення методу в метод класу."

msgid ""
"A class method receives the class as an implicit first argument, just like "
"an instance method receives the instance. To declare a class method, use "
"this idiom::"
msgstr ""
"Метод класу отримує клас як неявний перший аргумент, так само як метод "
"екземпляра отримує екземпляр. Щоб оголосити метод класу, використовуйте цю "
"ідіому::"

msgid ""
"The ``@classmethod`` form is a function :term:`decorator` -- see :ref:"
"`function` for details."
msgstr ""
"Форма ``@classmethod`` є функцією :term:`decorator` -- подробиці див. :ref:"
"`function`."

msgid ""
"A class method can be called either on the class (such as ``C.f()``) or on "
"an instance (such as ``C().f()``).  The instance is ignored except for its "
"class. If a class method is called for a derived class, the derived class "
"object is passed as the implied first argument."
msgstr ""
"Метод класу можна викликати або в класі (наприклад, ``C.f()``), або в "
"екземплярі (такому як ``C().f()``). Примірник ігнорується, за винятком його "
"класу. Якщо метод класу викликається для похідного класу, об’єкт похідного "
"класу передається як неявний перший аргумент."

msgid ""
"Class methods are different than C++ or Java static methods. If you want "
"those, see :func:`staticmethod` in this section. For more information on "
"class methods, see :ref:`types`."
msgstr ""
"Методи класу відрізняються від статичних методів C++ або Java. Якщо ви "
"хочете їх, перегляньте :func:`staticmethod` у цьому розділі. Для отримання "
"додаткової інформації про методи класу див. :ref:`types`."

msgid ""
"Class methods can now wrap other :term:`descriptors <descriptor>` such as :"
"func:`property`."
msgstr ""
"Методи класу тепер можуть обгортати інші :term:`дескриптори <descriptor>`, "
"такі як :func:`property`."

msgid ""
"Class methods now inherit the method attributes (``__module__``, "
"``__name__``, ``__qualname__``, ``__doc__`` and ``__annotations__``) and "
"have a new ``__wrapped__`` attribute."
msgstr ""
"Методи класу тепер успадковують атрибути методу (``__module__``, "
"``__name__``, ``__qualname__``, ``__doc__`` і ``__annotations__``) і мають "
"новий атрибут ``__wrapped__``."

msgid ""
"Class methods can no longer wrap other :term:`descriptors <descriptor>` such "
"as :func:`property`."
msgstr ""

msgid ""
"Compile the *source* into a code or AST object.  Code objects can be "
"executed by :func:`exec` or :func:`eval`.  *source* can either be a normal "
"string, a byte string, or an AST object.  Refer to the :mod:`ast` module "
"documentation for information on how to work with AST objects."
msgstr ""
"Скомпілюйте *джерело* в код або об’єкт AST. Об’єкти коду можуть бути "
"виконані за допомогою :func:`exec` або :func:`eval`. *джерело* може бути "
"звичайним рядком, рядком байтів або об’єктом AST. Зверніться до документації "
"модуля :mod:`ast`, щоб дізнатися, як працювати з об’єктами AST."

msgid ""
"The *filename* argument should give the file from which the code was read; "
"pass some recognizable value if it wasn't read from a file (``'<string>'`` "
"is commonly used)."
msgstr ""
"Аргумент *ім'я_файлу* повинен давати файл, з якого було прочитано код; "
"передати певне розпізнаване значення, якщо воно не було прочитано з файлу "
"(зазвичай використовується ``' <string>'``)."

msgid ""
"The *mode* argument specifies what kind of code must be compiled; it can be "
"``'exec'`` if *source* consists of a sequence of statements, ``'eval'`` if "
"it consists of a single expression, or ``'single'`` if it consists of a "
"single interactive statement (in the latter case, expression statements that "
"evaluate to something other than ``None`` will be printed)."
msgstr ""
"Аргумент *mode* визначає тип коду, який потрібно скомпілювати; це може бути "
"``'exec'``, якщо *source* складається з послідовності операторів, "
"``'eval'``, якщо воно складається з одного виразу, або ``'single'``, якщо "
"воно складається з одного інтерактивний оператор (в останньому випадку "
"оператори-вирази, які мають значення, відмінне від ``None``, будуть "
"надруковані)."

msgid ""
"The optional arguments *flags* and *dont_inherit* control which :ref:"
"`compiler options <ast-compiler-flags>` should be activated and which :ref:"
"`future features <future>` should be allowed. If neither is present (or both "
"are zero) the code is compiled with the same flags that affect the code that "
"is calling :func:`compile`. If the *flags* argument is given and "
"*dont_inherit* is not (or is zero) then the compiler options and the future "
"statements specified by the *flags* argument are used in addition to those "
"that would be used anyway. If *dont_inherit* is a non-zero integer then the "
"*flags* argument is it -- the flags (future features and compiler options) "
"in the surrounding code are ignored."
msgstr ""
"Необов’язкові аргументи *flags* і *dont_inherit* визначають, які :ref:"
"`параметри компілятора <ast-compiler-flags>` мають бути активовані та які :"
"ref:`майбутні функції <future>` мають бути дозволені. Якщо жоден не "
"присутній (або обидва дорівнюють нулю), код компілюється з тими самими "
"прапорцями, які впливають на код, який викликає :func:`compile`. Якщо надано "
"аргумент *flags*, а *dont_inherit* — ні (або дорівнює нулю), то параметри "
"компілятора та майбутні оператори, визначені аргументом *flags*, "
"використовуються на додаток до тих, які були б використані в будь-якому "
"випадку. Якщо *dont_inherit* є ненульовим цілим числом, то це аргумент "
"*flags* — прапори (майбутні функції та параметри компілятора) у "
"навколишньому коді ігноруються."

msgid ""
"Compiler options and future statements are specified by bits which can be "
"bitwise ORed together to specify multiple options. The bitfield required to "
"specify a given future feature can be found as the :attr:`~__future__."
"_Feature.compiler_flag` attribute on the :class:`~__future__._Feature` "
"instance in the :mod:`__future__` module. :ref:`Compiler flags <ast-compiler-"
"flags>` can be found in :mod:`ast` module, with ``PyCF_`` prefix."
msgstr ""
"Параметри компілятора та майбутні оператори визначаються бітами, які можна "
"об’єднати порозрядним АБО, щоб визначити кілька параметрів. Бітове поле, "
"необхідне для вказівки певної майбутньої функції, можна знайти як атрибут :"
"attr:`~__future__._Feature.compiler_flag` екземпляра :class:`~__future__."
"_Feature` у модулі :mod:`__future__`. :ref:`Прапори компілятора <ast-"
"compiler-flags>` можна знайти в :mod:`ast` модулі з префіксом ``PyCF_``."

msgid ""
"The argument *optimize* specifies the optimization level of the compiler; "
"the default value of ``-1`` selects the optimization level of the "
"interpreter as given by :option:`-O` options.  Explicit levels are ``0`` (no "
"optimization; ``__debug__`` is true), ``1`` (asserts are removed, "
"``__debug__`` is false) or ``2`` (docstrings are removed too)."
msgstr ""
"Аргумент *optimize* визначає рівень оптимізації компілятора; значення за "
"замовчуванням ``-1`` вибирає рівень оптимізації інтерпретатора, як задано "
"параметрами :option:`-O`. Явні рівні: ``0`` (немає оптимізації; "
"``__debug__`` є істинним), ``1`` (затвердження видалено, ``__debug__`` є "
"хибним) або ``2`` (рядки документа також видалено )."

msgid ""
"This function raises :exc:`SyntaxError` if the compiled source is invalid, "
"and :exc:`ValueError` if the source contains null bytes."
msgstr ""
"Ця функція викликає :exc:`SyntaxError`, якщо скомпільоване джерело недійсне, "
"і :exc:`ValueError`, якщо джерело містить нульові байти."

msgid ""
"If you want to parse Python code into its AST representation, see :func:`ast."
"parse`."
msgstr ""
"Якщо ви хочете розібрати код Python у його представлення AST, перегляньте :"
"func:`ast.parse`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``compile`` with arguments "
"``source``, ``filename``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``компіляція`` з аргументами "
"``джерело``, ``назва файлу``."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``compile`` with arguments "
"``source`` and ``filename``. This event may also be raised by implicit "
"compilation."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``компіляція`` з аргументами "
"``джерело`` та ``назва файлу``. Ця подія також може бути викликана неявною "
"компіляцією."

msgid ""
"When compiling a string with multi-line code in ``'single'`` or ``'eval'`` "
"mode, input must be terminated by at least one newline character.  This is "
"to facilitate detection of incomplete and complete statements in the :mod:"
"`code` module."
msgstr ""
"Під час компіляції рядка з багаторядковим кодом у режимі ``'single'`` або "
"``'eval'`` вхідні дані мають завершуватися принаймні одним символом нового "
"рядка. Це робиться для полегшення виявлення неповних і повних операторів у "
"модулі :mod:`code`."

msgid ""
"It is possible to crash the Python interpreter with a sufficiently large/"
"complex string when compiling to an AST object due to stack depth "
"limitations in Python's AST compiler."
msgstr ""
"Можливий збій інтерпретатора Python із досить великим/складним рядком під "
"час компіляції в об’єкт AST через обмеження глибини стеку в компіляторі AST "
"Python."

msgid ""
"Allowed use of Windows and Mac newlines.  Also, input in ``'exec'`` mode "
"does not have to end in a newline anymore.  Added the *optimize* parameter."
msgstr ""
"Дозволено використання нових рядків у Windows і Mac. Крім того, введення в "
"режимі ``'exec''`` більше не повинно закінчуватися символом нового рядка. "
"Додано параметр *optimize*."

msgid ""
"Previously, :exc:`TypeError` was raised when null bytes were encountered in "
"*source*."
msgstr ""
"Раніше :exc:`TypeError` виникало, коли в *source* зустрічалися нульові байти."

msgid ""
"``ast.PyCF_ALLOW_TOP_LEVEL_AWAIT`` can now be passed in flags to enable "
"support for top-level ``await``, ``async for``, and ``async with``."
msgstr ""
"``ast.PyCF_ALLOW_TOP_LEVEL_AWAIT`` тепер можна передавати у прапорах, щоб "
"увімкнути підтримку верхнього рівня ``await``, ``async for`` і ``async "
"with``."

msgid ""
"Return a complex number with the value *real* + *imag*\\*1j or convert a "
"string or number to a complex number.  If the first parameter is a string, "
"it will be interpreted as a complex number and the function must be called "
"without a second parameter.  The second parameter can never be a string. "
"Each argument may be any numeric type (including complex).  If *imag* is "
"omitted, it defaults to zero and the constructor serves as a numeric "
"conversion like :class:`int` and :class:`float`.  If both arguments are "
"omitted, returns ``0j``."
msgstr ""
"Повертає комплексне число зі значенням *real* + *imag*\\*1j або перетворює "
"рядок або число на комплексне число. Якщо перший параметр є рядком, він буде "
"інтерпретуватися як комплексне число, і функція має бути викликана без "
"другого параметра. Другий параметр ніколи не може бути рядком. Кожен "
"аргумент може бути будь-якого числового типу (включаючи комплексний). Якщо "
"*imag* опущено, за замовчуванням він дорівнює нулю, а конструктор служить "
"для числового перетворення, наприклад :class:`int` і :class:`float`. Якщо "
"обидва аргументи опущено, повертає ``0j``."

msgid ""
"For a general Python object ``x``, ``complex(x)`` delegates to ``x."
"__complex__()``.  If ``__complex__()`` is not defined then it falls back to :"
"meth:`__float__`.  If ``__float__()`` is not defined then it falls back to :"
"meth:`__index__`."
msgstr ""
"Для загального об’єкта Python ``x`` ``complex(x)`` делегує ``x."
"__complex__()``. Якщо ``__complex__()`` не визначено, тоді він повертається "
"до :meth:`__float__`. Якщо ``__float__()`` не визначено, він повертається "
"до :meth:`__index__`."

msgid ""
"When converting from a string, the string must not contain whitespace around "
"the central ``+`` or ``-`` operator.  For example, ``complex('1+2j')`` is "
"fine, but ``complex('1 + 2j')`` raises :exc:`ValueError`."
msgstr ""
"Під час перетворення з рядка рядок не повинен містити пробіли навколо "
"центрального оператора ``+`` або ``-``. Наприклад, ``complex('1+2j')`` "
"добре, але ``complex('1 + 2j')`` викликає :exc:`ValueError`."

msgid "The complex type is described in :ref:`typesnumeric`."
msgstr "Складний тип описано в :ref:`typesnumeric`."

msgid "Grouping digits with underscores as in code literals is allowed."
msgstr "Допускається групування цифр із підкресленням, як у кодових літералах."

msgid ""
"Falls back to :meth:`__index__` if :meth:`__complex__` and :meth:`__float__` "
"are not defined."
msgstr ""
"Повертається до :meth:`__index__`, якщо :meth:`__complex__` і :meth:"
"`__float__` не визначено."

msgid ""
"This is a relative of :func:`setattr`.  The arguments are an object and a "
"string.  The string must be the name of one of the object's attributes.  The "
"function deletes the named attribute, provided the object allows it.  For "
"example, ``delattr(x, 'foobar')`` is equivalent to ``del x.foobar``. *name* "
"need not be a Python identifier (see :func:`setattr`)."
msgstr ""

msgid ""
"Create a new dictionary.  The :class:`dict` object is the dictionary class. "
"See :class:`dict` and :ref:`typesmapping` for documentation about this class."
msgstr ""
"Створіть новий словник. Об’єкт :class:`dict` є класом словника. Перегляньте :"
"class:`dict` і :ref:`typesmapping` для документації про цей клас."

msgid ""
"For other containers see the built-in :class:`list`, :class:`set`, and :"
"class:`tuple` classes, as well as the :mod:`collections` module."
msgstr ""
"Для інших контейнерів перегляньте вбудовані класи :class:`list`, :class:"
"`set` і :class:`tuple`, а також модуль :mod:`collections`."

msgid ""
"Without arguments, return the list of names in the current local scope.  "
"With an argument, attempt to return a list of valid attributes for that "
"object."
msgstr ""
"Без аргументів повертає список імен у поточній локальній області. За "
"допомогою аргументу спробуйте повернути список дійсних атрибутів для цього "
"об’єкта."

msgid ""
"If the object has a method named :meth:`__dir__`, this method will be called "
"and must return the list of attributes. This allows objects that implement a "
"custom :func:`__getattr__` or :func:`__getattribute__` function to customize "
"the way :func:`dir` reports their attributes."
msgstr ""
"Якщо об’єкт має метод з назвою :meth:`__dir__`, цей метод буде викликаний і "
"повинен повернути список атрибутів. Це дозволяє об’єктам, які реалізують "
"спеціальну функцію :func:`__getattr__` або :func:`__getattribute__`, "
"налаштувати спосіб, у який :func:`dir` повідомляє свої атрибути."

msgid ""
"If the object does not provide :meth:`__dir__`, the function tries its best "
"to gather information from the object's :attr:`~object.__dict__` attribute, "
"if defined, and from its type object.  The resulting list is not necessarily "
"complete and may be inaccurate when the object has a custom :func:"
"`__getattr__`."
msgstr ""
"Якщо об’єкт не надає :meth:`__dir__`, функція робить усе можливе, щоб "
"зібрати інформацію з атрибута :attr:`~object.__dict__` об’єкта, якщо він "
"визначений, і з його об’єкта типу. Отриманий список не обов’язково є повним "
"і може бути неточним, якщо об’єкт має настроюваний :func:`__getattr__`."

msgid ""
"The default :func:`dir` mechanism behaves differently with different types "
"of objects, as it attempts to produce the most relevant, rather than "
"complete, information:"
msgstr ""
"Механізм за замовчуванням :func:`dir` поводиться по-різному з різними типами "
"об’єктів, оскільки він намагається створити найбільш релевантну, а не повну "
"інформацію:"

msgid ""
"If the object is a module object, the list contains the names of the "
"module's attributes."
msgstr "Якщо об’єкт є об’єктом модуля, список містить назви атрибутів модуля."

msgid ""
"If the object is a type or class object, the list contains the names of its "
"attributes, and recursively of the attributes of its bases."
msgstr ""
"Якщо об’єкт є об’єктом типу або класу, список містить імена його атрибутів і "
"рекурсивно атрибутів його баз."

msgid ""
"Otherwise, the list contains the object's attributes' names, the names of "
"its class's attributes, and recursively of the attributes of its class's "
"base classes."
msgstr ""
"В іншому випадку список містить назви атрибутів об’єкта, назви атрибутів "
"його класу та рекурсивно атрибутів базових класів його класу."

msgid "The resulting list is sorted alphabetically.  For example:"
msgstr "Отриманий список відсортовано за алфавітом. Наприклад:"

msgid ""
"Because :func:`dir` is supplied primarily as a convenience for use at an "
"interactive prompt, it tries to supply an interesting set of names more than "
"it tries to supply a rigorously or consistently defined set of names, and "
"its detailed behavior may change across releases.  For example, metaclass "
"attributes are not in the result list when the argument is a class."
msgstr ""
"Оскільки :func:`dir` надається насамперед для зручності використання в "
"інтерактивному запиті, він намагається надати цікавий набір імен більше, ніж "
"намагається надати чітко або послідовно визначений набір імен, і його "
"детальна поведінка може змінитися через випуски. Наприклад, атрибути "
"метакласу відсутні в списку результатів, якщо аргументом є клас."

msgid ""
"Take two (non-complex) numbers as arguments and return a pair of numbers "
"consisting of their quotient and remainder when using integer division.  "
"With mixed operand types, the rules for binary arithmetic operators apply.  "
"For integers, the result is the same as ``(a // b, a % b)``. For floating "
"point numbers the result is ``(q, a % b)``, where *q* is usually ``math."
"floor(a / b)`` but may be 1 less than that.  In any case ``q * b + a % b`` "
"is very close to *a*, if ``a % b`` is non-zero it has the same sign as *b*, "
"and ``0 <= abs(a % b) < abs(b)``."
msgstr ""
"Візьміть два (некомплексних) числа як аргументи та поверніть пару чисел, що "
"складаються з частки та залишку під час цілочисельного ділення. Для змішаних "
"типів операндів застосовуються правила для двійкових арифметичних "
"операторів. Для цілих чисел результат такий самий, як ``(a // b, a % b)``. "
"Для чисел з плаваючою комою результатом є ``(q, a % b)``, де *q* зазвичай є "
"``math.floor(a / b)``, але може бути на 1 менше за це. У будь-якому випадку "
"``q * b + a % b`` дуже близький до *a*, якщо ``a % b`` відмінний від нуля, "
"він має той самий знак, що і *b*, а ``0 <= abs(a % b) < abs(b)``."

msgid ""
"Return an enumerate object. *iterable* must be a sequence, an :term:"
"`iterator`, or some other object which supports iteration. The :meth:"
"`~iterator.__next__` method of the iterator returned by :func:`enumerate` "
"returns a tuple containing a count (from *start* which defaults to 0) and "
"the values obtained from iterating over *iterable*."
msgstr ""
"Повертає об’єкт перерахування. *iterable* має бути послідовністю, :term:"
"`iterator` або іншим об’єктом, який підтримує ітерацію. Метод :meth:"
"`~iterator.__next__` ітератора, який повертає :func:`enumerate`, повертає "
"кортеж, що містить лічильник (від *start*, який за замовчуванням дорівнює 0) "
"і значення, отримані в результаті ітерації над *iterable*."

msgid "Equivalent to::"
msgstr "Дорівнює::"

msgid ""
"The arguments are a string and optional globals and locals.  If provided, "
"*globals* must be a dictionary.  If provided, *locals* can be any mapping "
"object."
msgstr ""
"Аргументами є рядок і необов’язкові глобальні та локальні значення. Якщо "
"вказано, *globals* має бути словником. Якщо вказано, *locals* може бути будь-"
"яким об’єктом відображення."

msgid ""
"The *expression* argument is parsed and evaluated as a Python expression "
"(technically speaking, a condition list) using the *globals* and *locals* "
"dictionaries as global and local namespace.  If the *globals* dictionary is "
"present and does not contain a value for the key ``__builtins__``, a "
"reference to the dictionary of the built-in module :mod:`builtins` is "
"inserted under that key before *expression* is parsed.  That way you can "
"control what builtins are available to the executed code by inserting your "
"own ``__builtins__`` dictionary into *globals* before passing it to :func:"
"`eval`.  If the *locals* dictionary is omitted it defaults to the *globals* "
"dictionary.  If both dictionaries are omitted, the expression is executed "
"with the *globals* and *locals* in the environment where :func:`eval` is "
"called.  Note, *eval()* does not have access to the :term:`nested scopes "
"<nested scope>` (non-locals) in the enclosing environment."
msgstr ""
"Аргумент *expression* аналізується та оцінюється як вираз Python (технічно "
"кажучи, список умов) за допомогою словників *globals* і *locals* як "
"глобального та локального простору імен. Якщо словник *globals* присутній і "
"не містить значення для ключа ``__builtins__``, посилання на словник "
"вбудованого модуля :mod:`builtins` вставляється під цей ключ перед "
"*expression* розібрати. Таким чином ви можете контролювати, які вбудовані "
"елементи доступні для виконуваного коду, вставивши свій власний словник "
"``__builtins__`` у *globals* перед передачею його в :func:`eval`. Якщо "
"словник *locals* опущено, за замовчуванням буде використовуватися словник "
"*globals*. Якщо обидва словники опущені, вираз виконується з *globals* і "
"*locals* у середовищі, де викликається :func:`eval`. Зауважте, *eval()* не "
"має доступу до :term:`вкладених областей <nested scope>` (нелокальних) в "
"охоплюючому середовищі."

msgid ""
"The return value is the result of the evaluated expression. Syntax errors "
"are reported as exceptions.  Example:"
msgstr ""
"Повернене значення є результатом обчисленого виразу. Синтаксичні помилки "
"повідомляються як винятки. приклад:"

msgid ""
"This function can also be used to execute arbitrary code objects (such as "
"those created by :func:`compile`).  In this case, pass a code object instead "
"of a string.  If the code object has been compiled with ``'exec'`` as the "
"*mode* argument, :func:`eval`\\'s return value will be ``None``."
msgstr ""
"Ця функція також може бути використана для виконання довільних об’єктів коду "
"(наприклад, створених :func:`compile`). У цьому випадку передавайте об’єкт "
"коду замість рядка. Якщо об’єкт коду було скомпільовано з ``'exec'`` як "
"аргументом *mode*, значення, що повертається :func:`eval`\\, буде ``None``."

msgid ""
"Hints: dynamic execution of statements is supported by the :func:`exec` "
"function.  The :func:`globals` and :func:`locals` functions return the "
"current global and local dictionary, respectively, which may be useful to "
"pass around for use by :func:`eval` or :func:`exec`."
msgstr ""
"Підказки: динамічне виконання операторів підтримується функцією :func:"
"`exec`. Функції :func:`globals` і :func:`locals` повертають поточний "
"глобальний і локальний словники відповідно, які можуть бути корисними "
"передати для використання :func:`eval` або :func:`exec`."

msgid ""
"If the given source is a string, then leading and trailing spaces and tabs "
"are stripped."
msgstr ""
"Якщо дане джерело є рядком, то пробіли та табуляції на початку та в кінці "
"видаляються."

msgid ""
"See :func:`ast.literal_eval` for a function that can safely evaluate strings "
"with expressions containing only literals."
msgstr ""
"Перегляньте :func:`ast.literal_eval` для функції, яка може безпечно "
"обчислювати рядки з виразами, що містять лише літерали."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``exec`` with argument "
"``code_object``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``exec`` з аргументом "
"``code_object``."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``exec`` with the code object as "
"the argument. Code compilation events may also be raised."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``exec`` з об’єктом коду як "
"аргументом. Також можуть виникати події компіляції коду."

msgid ""
"This function supports dynamic execution of Python code. *object* must be "
"either a string or a code object.  If it is a string, the string is parsed "
"as a suite of Python statements which is then executed (unless a syntax "
"error occurs). [#]_ If it is a code object, it is simply executed.  In all "
"cases, the code that's executed is expected to be valid as file input (see "
"the section :ref:`file-input` in the Reference Manual). Be aware that the :"
"keyword:`nonlocal`, :keyword:`yield`,  and :keyword:`return` statements may "
"not be used outside of function definitions even within the context of code "
"passed to the :func:`exec` function. The return value is ``None``."
msgstr ""
"Ця функція підтримує динамічне виконання коду Python. *object* має бути або "
"рядком, або об’єктом коду. Якщо це рядок, цей рядок аналізується як набір "
"операторів Python, який потім виконується (якщо не виникає синтаксична "
"помилка). [#]_ Якщо це об’єкт коду, він просто виконується. У всіх випадках "
"очікується, що код, який виконується, буде дійсним як вхідний файл (див. "
"розділ :ref:`file-input` у Довідковому посібнику). Майте на увазі, що "
"оператори :keyword:`nonlocal`, :keyword:`yield` і :keyword:`return` не можна "
"використовувати поза визначеннями функцій навіть у контексті коду, "
"переданого у функцію :func:`exec` . Повернуте значення ``None``."

msgid ""
"In all cases, if the optional parts are omitted, the code is executed in the "
"current scope.  If only *globals* is provided, it must be a dictionary (and "
"not a subclass of dictionary), which will be used for both the global and "
"the local variables.  If *globals* and *locals* are given, they are used for "
"the global and local variables, respectively.  If provided, *locals* can be "
"any mapping object.  Remember that at the module level, globals and locals "
"are the same dictionary. If exec gets two separate objects as *globals* and "
"*locals*, the code will be executed as if it were embedded in a class "
"definition."
msgstr ""
"У всіх випадках, якщо необов’язкові частини опущені, код виконується в "
"поточній області. Якщо вказано лише *globals*, це має бути словник (а не "
"підклас словника), який використовуватиметься як для глобальних, так і для "
"локальних змінних. Якщо вказано *globals* і *locals*, вони використовуються "
"для глобальних і локальних змінних відповідно. Якщо вказано, *locals* може "
"бути будь-яким об’єктом відображення. Пам’ятайте, що на рівні модуля "
"глобальні та локальні є одним і тим же словником. Якщо exec отримує два "
"окремих об’єкти як *globals* і *locals*, код буде виконано так, ніби він був "
"вбудований у визначення класу."

msgid ""
"If the *globals* dictionary does not contain a value for the key "
"``__builtins__``, a reference to the dictionary of the built-in module :mod:"
"`builtins` is inserted under that key.  That way you can control what "
"builtins are available to the executed code by inserting your own "
"``__builtins__`` dictionary into *globals* before passing it to :func:`exec`."
msgstr ""
"Якщо словник *globals* не містить значення для ключа ``__builtins__``, під "
"цим ключем вставляється посилання на словник вбудованого модуля :mod:"
"`builtins`. Таким чином ви можете контролювати, які вбудовані елементи "
"доступні для виконуваного коду, вставивши свій власний словник "
"``__builtins__`` у *globals* перед передачею його в :func:`exec`."

msgid ""
"The *closure* argument specifies a closure--a tuple of cellvars. It's only "
"valid when the *object* is a code object containing free variables. The "
"length of the tuple must exactly match the number of free variables "
"referenced by the code object."
msgstr ""

msgid ""
"The built-in functions :func:`globals` and :func:`locals` return the current "
"global and local dictionary, respectively, which may be useful to pass "
"around for use as the second and third argument to :func:`exec`."
msgstr ""
"Вбудовані функції :func:`globals` і :func:`locals` повертають поточний "
"глобальний і локальний словники відповідно, які може бути корисно передати "
"для використання як другий і третій аргумент :func:`exec` ."

msgid ""
"The default *locals* act as described for function :func:`locals` below: "
"modifications to the default *locals* dictionary should not be attempted. "
"Pass an explicit *locals* dictionary if you need to see effects of the code "
"on *locals* after function :func:`exec` returns."
msgstr ""
"*Locals* за замовчуванням діє, як описано для функції :func:`locals` нижче: "
"не слід намагатися змінити словник *locals* за замовчуванням. Передайте "
"явний словник *locals*, якщо вам потрібно побачити вплив коду на *locals* "
"після повернення функції :func:`exec`."

msgid "Added the *closure* parameter."
msgstr ""

msgid ""
"Construct an iterator from those elements of *iterable* for which *function* "
"returns true.  *iterable* may be either a sequence, a container which "
"supports iteration, or an iterator.  If *function* is ``None``, the identity "
"function is assumed, that is, all elements of *iterable* that are false are "
"removed."
msgstr ""
"Побудуйте ітератор з тих елементів *iterable*, для яких *функція* повертає "
"true. *iterable* може бути або послідовністю, контейнером, який підтримує "
"ітерацію, або ітератором. Якщо *function* має значення ``None``, "
"передбачається функція ідентифікації, тобто всі елементи *iterable*, які є "
"false, видаляються."

msgid ""
"Note that ``filter(function, iterable)`` is equivalent to the generator "
"expression ``(item for item in iterable if function(item))`` if function is "
"not ``None`` and ``(item for item in iterable if item)`` if function is "
"``None``."
msgstr ""
"Зауважте, що ``filter(function, iterable)`` еквівалентний виразу генератора "
"``(item for item в iterable if function(item))``, якщо функція не є ``None`` "
"і ``(item for item в iterable if item)`` якщо функція ``None``."

msgid ""
"See :func:`itertools.filterfalse` for the complementary function that "
"returns elements of *iterable* for which *function* returns false."
msgstr ""
"Перегляньте :func:`itertools.filterfalse` для додаткової функції, яка "
"повертає елементи *iterable*, для яких *функція* повертає false."

msgid "Return a floating point number constructed from a number or string *x*."
msgstr "Повертає число з плаваючою комою, створене з числа або рядка *x*."

msgid ""
"If the argument is a string, it should contain a decimal number, optionally "
"preceded by a sign, and optionally embedded in whitespace.  The optional "
"sign may be ``'+'`` or ``'-'``; a ``'+'`` sign has no effect on the value "
"produced.  The argument may also be a string representing a NaN (not-a-"
"number), or positive or negative infinity.  More precisely, the input must "
"conform to the following grammar after leading and trailing whitespace "
"characters are removed:"
msgstr ""
"Якщо аргумент є рядком, він має містити десяткове число, якому необов’язково "
"передує знак, і необов’язково вбудоване в пробіл. Додатковим знаком може "
"бути ``'+'`` або ``'-'``; знак ``'+'`` не впливає на отримане значення. "
"Аргумент також може бути рядком, що представляє NaN (не число), або "
"позитивну чи негативну нескінченність. Точніше, введення має відповідати "
"наведеній нижче граматиці після видалення початкових і кінцевих пробілів:"

msgid ""
"Here ``floatnumber`` is the form of a Python floating-point literal, "
"described in :ref:`floating`.  Case is not significant, so, for example, "
"\"inf\", \"Inf\", \"INFINITY\", and \"iNfINity\" are all acceptable "
"spellings for positive infinity."
msgstr ""
"Тут ``floatnumber`` є формою літералу з плаваючою комою Python, описаного в :"
"ref:`floating`. Регістр не має значення, тому, наприклад, \"inf\", \"Inf\", "
"\"INFINITY\" та \"iNfINity\" є прийнятними варіантами написання позитивної "
"нескінченності."

msgid ""
"Otherwise, if the argument is an integer or a floating point number, a "
"floating point number with the same value (within Python's floating point "
"precision) is returned.  If the argument is outside the range of a Python "
"float, an :exc:`OverflowError` will be raised."
msgstr ""
"В іншому випадку, якщо аргумент є цілим числом або числом з плаваючою комою, "
"повертається число з плаваючою комою з тим самим значенням (у межах точності "
"Python до плаваючої коми). Якщо аргумент виходить за межі діапазону числа з "
"плаваючою точкою Python, буде викликано :exc:`OverflowError`."

msgid ""
"For a general Python object ``x``, ``float(x)`` delegates to ``x."
"__float__()``.  If ``__float__()`` is not defined then it falls back to :"
"meth:`__index__`."
msgstr ""
"Для загального об’єкта Python ``x`` ``float(x)`` делегує ``x.__float__()``. "
"Якщо ``__float__()`` не визначено, він повертається до :meth:`__index__`."

msgid "If no argument is given, ``0.0`` is returned."
msgstr "Якщо аргумент не вказано, повертається ``0.0``."

msgid "Examples::"
msgstr "Приклади::"

msgid "The float type is described in :ref:`typesnumeric`."
msgstr "Тип float описано в :ref:`typesnumeric`."

msgid "Falls back to :meth:`__index__` if :meth:`__float__` is not defined."
msgstr ""
"Повертається до :meth:`__index__`, якщо :meth:`__float__` не визначено."

msgid ""
"Convert a *value* to a \"formatted\" representation, as controlled by "
"*format_spec*.  The interpretation of *format_spec* will depend on the type "
"of the *value* argument; however, there is a standard formatting syntax that "
"is used by most built-in types: :ref:`formatspec`."
msgstr ""
"Перетворення *значення* на \"форматований\" представлення, як керується "
"*format_spec*. Інтерпретація *format_spec* залежатиме від типу аргументу "
"*value*; проте існує стандартний синтаксис форматування, який "
"використовується більшістю вбудованих типів: :ref:`formatspec`."

msgid ""
"The default *format_spec* is an empty string which usually gives the same "
"effect as calling :func:`str(value) <str>`."
msgstr ""
"За замовчуванням *format_spec* є порожнім рядком, який зазвичай дає той "
"самий ефект, що й виклик :func:`str(value) <str>`."

msgid ""
"A call to ``format(value, format_spec)`` is translated to ``type(value)."
"__format__(value, format_spec)`` which bypasses the instance dictionary when "
"searching for the value's :meth:`__format__` method.  A :exc:`TypeError` "
"exception is raised if the method search reaches :mod:`object` and the "
"*format_spec* is non-empty, or if either the *format_spec* or the return "
"value are not strings."
msgstr ""
"Виклик ``format(value, format_spec)`` перекладається на ``type(value)."
"__format__(value, format_spec)``, який обходить словник екземпляра під час "
"пошуку методу значення :meth:`__format__`. Виняток :exc:`TypeError` виникає, "
"якщо метод пошуку досягає :mod:`object` і *format_spec* не є порожнім, або "
"якщо *format_spec* або значення, що повертається, не є рядками."

msgid ""
"``object().__format__(format_spec)`` raises :exc:`TypeError` if "
"*format_spec* is not an empty string."
msgstr ""
"``object().__format__(format_spec)`` викликає :exc:`TypeError`, якщо "
"*format_spec* не є порожнім рядком."

msgid ""
"Return a new :class:`frozenset` object, optionally with elements taken from "
"*iterable*.  ``frozenset`` is a built-in class.  See :class:`frozenset` and :"
"ref:`types-set` for documentation about this class."
msgstr ""
"Повертає новий об’єкт :class:`frozenset`, необов’язково з елементами, "
"взятими з *iterable*. ``frozenset`` є вбудованим класом. Перегляньте :class:"
"`frozenset` і :ref:`types-set` для документації про цей клас."

msgid ""
"For other containers see the built-in :class:`set`, :class:`list`, :class:"
"`tuple`, and :class:`dict` classes, as well as the :mod:`collections` module."
msgstr ""
"Для інших контейнерів перегляньте вбудовані класи :class:`set`, :class:"
"`list`, :class:`tuple` і :class:`dict`, а також модуль :mod:`collections`."

msgid ""
"Return the value of the named attribute of *object*.  *name* must be a "
"string. If the string is the name of one of the object's attributes, the "
"result is the value of that attribute.  For example, ``getattr(x, "
"'foobar')`` is equivalent to ``x.foobar``.  If the named attribute does not "
"exist, *default* is returned if provided, otherwise :exc:`AttributeError` is "
"raised. *name* need not be a Python identifier (see :func:`setattr`)."
msgstr ""

msgid ""
"Since :ref:`private name mangling <private-name-mangling>` happens at "
"compilation time, one must manually mangle a private attribute's (attributes "
"with two leading underscores) name in order to retrieve it with :func:"
"`getattr`."
msgstr ""
"Оскільки :ref:`викривлення приватного імені <private-name-mangling>` "
"відбувається під час компіляції, потрібно вручну спотворити ім’я приватного "
"атрибута (атрибути з двома символами підкреслення на початку), щоб отримати "
"його за допомогою :func:`getattr`."

msgid ""
"Return the dictionary implementing the current module namespace. For code "
"within functions, this is set when the function is defined and remains the "
"same regardless of where the function is called."
msgstr ""
"Повертає словник, що реалізує поточний простір імен модуля. Для коду "
"всередині функцій це значення встановлюється під час визначення функції та "
"залишається незмінним незалежно від місця виклику функції."

msgid ""
"The arguments are an object and a string.  The result is ``True`` if the "
"string is the name of one of the object's attributes, ``False`` if not. "
"(This is implemented by calling ``getattr(object, name)`` and seeing whether "
"it raises an :exc:`AttributeError` or not.)"
msgstr ""
"Аргументами є об’єкт і рядок. Результатом є ``True``, якщо рядок є назвою "
"одного з атрибутів об’єкта, ``False``, якщо ні. (Це реалізується шляхом "
"виклику ``getattr(object, name)`` і перевірки, чи викликає це :exc:"
"`AttributeError` чи ні.)"

msgid ""
"Return the hash value of the object (if it has one).  Hash values are "
"integers.  They are used to quickly compare dictionary keys during a "
"dictionary lookup.  Numeric values that compare equal have the same hash "
"value (even if they are of different types, as is the case for 1 and 1.0)."
msgstr ""
"Повертає хеш-значення об’єкта (якщо воно є). Хеш-значення є цілими числами. "
"Вони використовуються для швидкого порівняння ключів словника під час пошуку "
"в словнику. Числові значення, які порівнюються, мають однакове хеш-значення "
"(навіть якщо вони мають різні типи, як у випадку 1 і 1.0)."

msgid ""
"For objects with custom :meth:`__hash__` methods, note that :func:`hash` "
"truncates the return value based on the bit width of the host machine. See :"
"meth:`__hash__` for details."
msgstr ""
"Для об’єктів із спеціальними методами :meth:`__hash__` зауважте, що :func:"
"`hash` скорочує значення, що повертається, на основі розрядності хост-"
"машини. Перегляньте :meth:`__hash__` для деталей."

msgid ""
"Invoke the built-in help system.  (This function is intended for interactive "
"use.)  If no argument is given, the interactive help system starts on the "
"interpreter console.  If the argument is a string, then the string is looked "
"up as the name of a module, function, class, method, keyword, or "
"documentation topic, and a help page is printed on the console.  If the "
"argument is any other kind of object, a help page on the object is generated."
msgstr ""
"Виклик вбудованої довідкової системи. (Ця функція призначена для "
"інтерактивного використання.) Якщо аргумент не задано, інтерактивна "
"довідкова система запускається на консолі інтерпретатора. Якщо аргументом є "
"рядок, то цей рядок шукається як ім’я модуля, функції, класу, методу, "
"ключового слова чи розділу документації, а на консолі друкується довідкова "
"сторінка. Якщо аргументом є об’єкт будь-якого іншого типу, для цього об’єкта "
"буде створено сторінку довідки."

msgid ""
"Note that if a slash(/) appears in the parameter list of a function when "
"invoking :func:`help`, it means that the parameters prior to the slash are "
"positional-only. For more info, see :ref:`the FAQ entry on positional-only "
"parameters <faq-positional-only-arguments>`."
msgstr ""
"Зауважте, що якщо скісна риска (/) з’являється у списку параметрів функції "
"під час виклику :func:`help`, це означає, що параметри перед скісною рискою "
"є лише позиційними. Для отримання додаткової інформації див. :ref:`запис у "
"поширених питаннях щодо позиційних параметрів <faq-positional-only-"
"arguments>`."

msgid ""
"This function is added to the built-in namespace by the :mod:`site` module."
msgstr "Ця функція додається до вбудованого простору імен модулем :mod:`site`."

msgid ""
"Changes to :mod:`pydoc` and :mod:`inspect` mean that the reported signatures "
"for callables are now more comprehensive and consistent."
msgstr ""
"Зміни в :mod:`pydoc` і :mod:`inspect` означають, що звітні підписи для "
"викликів тепер більш повні та узгоджені."

msgid ""
"Convert an integer number to a lowercase hexadecimal string prefixed with "
"\"0x\". If *x* is not a Python :class:`int` object, it has to define an :"
"meth:`__index__` method that returns an integer. Some examples:"
msgstr ""
"Перетворення цілого числа на шістнадцятковий рядок у нижньому регістрі з "
"префіксом \"0x\". Якщо *x* не є об’єктом Python :class:`int`, він має "
"визначити метод :meth:`__index__`, який повертає ціле число. Деякі приклади:"

msgid ""
"If you want to convert an integer number to an uppercase or lower "
"hexadecimal string with prefix or not, you can use either of the following "
"ways:"
msgstr ""
"Якщо ви хочете перетворити ціле число у верхній або нижній шістнадцятковий "
"рядок із префіксом або без нього, ви можете скористатися одним із наведених "
"нижче способів:"

msgid ""
"See also :func:`int` for converting a hexadecimal string to an integer using "
"a base of 16."
msgstr ""
"Дивіться також :func:`int` для перетворення шістнадцяткового рядка в ціле "
"число за основою 16."

msgid ""
"To obtain a hexadecimal string representation for a float, use the :meth:"
"`float.hex` method."
msgstr ""
"Щоб отримати шістнадцяткове представлення рядка для float, використовуйте "
"метод :meth:`float.hex`."

msgid ""
"Return the \"identity\" of an object.  This is an integer which is "
"guaranteed to be unique and constant for this object during its lifetime. "
"Two objects with non-overlapping lifetimes may have the same :func:`id` "
"value."
msgstr ""
"Повернути \"ідентичність\" об'єкта. Це ціле число, яке гарантовано буде "
"унікальним і постійним для цього об’єкта протягом усього його існування. Два "
"об’єкти з що існують у різні проміжки часу можуть мати однакові значення :"
"func:`id`."

msgid "This is the address of the object in memory."
msgstr ""

msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.id`` with argument "
"``id``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``builtins.id`` з аргументом ``id``."

msgid ""
"If the *prompt* argument is present, it is written to standard output "
"without a trailing newline.  The function then reads a line from input, "
"converts it to a string (stripping a trailing newline), and returns that.  "
"When EOF is read, :exc:`EOFError` is raised.  Example::"
msgstr ""
"Якщо присутній аргумент *prompt*, він записується в стандартний вивід без "
"символу нового рядка. Потім функція зчитує рядок із вхідних даних, "
"перетворює його на рядок (вилучаючи кінцевий новий рядок) і повертає його. "
"Під час читання EOF виникає :exc:`EOFError`. Приклад::"

msgid ""
"If the :mod:`readline` module was loaded, then :func:`input` will use it to "
"provide elaborate line editing and history features."
msgstr ""
"Якщо модуль :mod:`readline` було завантажено, то :func:`input` "
"використовуватиме його для забезпечення складних функцій редагування рядка "
"та історії."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input`` with argument "
"``prompt``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``builtins.input`` з аргументом "
"``prompt``."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input`` with argument "
"``prompt`` before reading input"
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``builtins.input`` з аргументом "
"``prompt`` перед читанням введення"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input/result`` with "
"argument ``result``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``builtins.input/result`` з "
"аргументом ``result``."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``builtins.input/result`` with "
"the result after successfully reading input."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``builtins.input/result`` з "
"результатом після успішного читання введення."

msgid ""
"Return an integer object constructed from a number or string *x*, or return "
"``0`` if no arguments are given.  If *x* defines :meth:`__int__`, ``int(x)`` "
"returns ``x.__int__()``.  If *x* defines :meth:`__index__`, it returns ``x."
"__index__()``.  If *x* defines :meth:`__trunc__`, it returns ``x."
"__trunc__()``. For floating point numbers, this truncates towards zero."
msgstr ""
"Повертає цілочисельний об’єкт, створений з числа або рядка *x*, або повертає "
"``0``, якщо не надано аргументів. Якщо *x* визначає :meth:`__int__`, "
"``int(x)`` повертає ``x.__int__()``. Якщо *x* визначає :meth:`__index__`, "
"він повертає ``x.__index__()``. Якщо *x* визначає :meth:`__trunc__`, він "
"повертає ``x.__trunc__()``. Для чисел з плаваючою комою це скорочується до "
"нуля."

msgid ""
"If *x* is not a number or if *base* is given, then *x* must be a string, :"
"class:`bytes`, or :class:`bytearray` instance representing an :ref:`integer "
"literal <integers>` in radix *base*.  Optionally, the literal can be "
"preceded by ``+`` or ``-`` (with no space in between) and surrounded by "
"whitespace.  A base-n literal consists of the digits 0 to n-1, with ``a`` to "
"``z`` (or ``A`` to ``Z``) having values 10 to 35.  The default *base* is 10. "
"The allowed values are 0 and 2--36. Base-2, -8, and -16 literals can be "
"optionally prefixed with ``0b``/``0B``, ``0o``/``0O``, or ``0x``/``0X``, as "
"with integer literals in code.  Base 0 means to interpret exactly as a code "
"literal, so that the actual base is 2, 8, 10, or 16, and so that "
"``int('010', 0)`` is not legal, while ``int('010')`` is, as well as "
"``int('010', 8)``."
msgstr ""
"Якщо *x* не є числом або задано *base*, тоді *x* має бути рядком, :class:"
"`bytes` або екземпляром :class:`bytearray`, який представляє :ref:"
"`цілочисельний літерал <integers>` в корені *основа*. За бажанням перед "
"літералом може стояти ``+`` або ``-`` (без пробілу між ними) і оточений "
"пробілом. Літерал base-n складається з цифр від 0 до n-1, причому від ``a`` "
"до ``z`` (або ``A`` до ``Z``) мають значення від 10 до 35. За замовчуванням "
"*base* дорівнює 10. Дозволені значення 0 і 2-36. Літерали Base-2, -8 і -16 "
"можуть мати префікс ``0b``/``0B``, ``0o``/``0O`` або ``0x``/``0X``, як і з "
"цілими літералами в коді. База 0 означає інтерпретувати точно як кодовий "
"літерал, так що фактична база дорівнює 2, 8, 10 або 16, і тому ``int('010', "
"0)`` є недопустимим, тоді як ``int( '010')`` є, а також ``int('010', 8)``."

msgid "The integer type is described in :ref:`typesnumeric`."
msgstr "Цілочисельний тип описано в :ref:`typesnumeric`."

msgid ""
"If *base* is not an instance of :class:`int` and the *base* object has a :"
"meth:`base.__index__ <object.__index__>` method, that method is called to "
"obtain an integer for the base.  Previous versions used :meth:`base.__int__ "
"<object.__int__>` instead of :meth:`base.__index__ <object.__index__>`."
msgstr ""
"Якщо *base* не є екземпляром :class:`int` і об’єкт *base* має метод :meth:"
"`base.__index__ <object.__index__>`, цей метод викликається для отримання "
"цілого числа для бази. У попередніх версіях використовувався :meth:`base."
"__int__ <object.__int__>` замість :meth:`base.__index__ <object.__index__>`."

msgid "Falls back to :meth:`__index__` if :meth:`__int__` is not defined."
msgstr "Повертається до :meth:`__index__`, якщо :meth:`__int__` не визначено."

msgid "The delegation to :meth:`__trunc__` is deprecated."
msgstr ""

msgid ""
":class:`int` string inputs and string representations can be limited to help "
"avoid denial of service attacks. A :exc:`ValueError` is raised when the "
"limit is exceeded while converting a string *x* to an :class:`int` or when "
"converting an :class:`int` into a string would exceed the limit. See the :"
"ref:`integer string conversion length limitation <int_max_str_digits>` "
"documentation."
msgstr ""

msgid ""
"Return ``True`` if the *object* argument is an instance of the *classinfo* "
"argument, or of a (direct, indirect, or :term:`virtual <abstract base "
"class>`) subclass thereof.  If *object* is not an object of the given type, "
"the function always returns ``False``. If *classinfo* is a tuple of type "
"objects (or recursively, other such tuples) or a :ref:`types-union` of "
"multiple types, return ``True`` if *object* is an instance of any of the "
"types. If *classinfo* is not a type or tuple of types and such tuples, a :"
"exc:`TypeError` exception is raised. :exc:`TypeError` may not be raised for "
"an invalid type if an earlier check succeeds."
msgstr ""

msgid "*classinfo* can be a :ref:`types-union`."
msgstr "*classinfo* може бути :ref:`types-union`."

msgid ""
"Return ``True`` if *class* is a subclass (direct, indirect, or :term:"
"`virtual <abstract base class>`) of *classinfo*.  A class is considered a "
"subclass of itself. *classinfo* may be a tuple of class objects (or "
"recursively, other such tuples) or a :ref:`types-union`, in which case "
"return ``True`` if *class* is a subclass of any entry in *classinfo*.  In "
"any other case, a :exc:`TypeError` exception is raised."
msgstr ""
"Повертає ``True``, якщо *class* є підкласом (прямим, непрямим або :term:"
"`віртуальним <abstract base class>`) *classinfo*. Клас вважається підкласом "
"самого себе. *classinfo* може бути кортежем об’єктів класу (або рекурсивно "
"іншими подібними кортежами) або :ref:`types-union`, у цьому випадку повертає "
"``True``, якщо *class* є підкласом будь-якого запису в *інформація про "
"клас*. У будь-якому іншому випадку виникає виняток :exc:`TypeError`."

msgid ""
"Return an :term:`iterator` object.  The first argument is interpreted very "
"differently depending on the presence of the second argument. Without a "
"second argument, *object* must be a collection object which supports the :"
"term:`iterable` protocol (the :meth:`__iter__` method), or it must support "
"the sequence protocol (the :meth:`__getitem__` method with integer arguments "
"starting at ``0``).  If it does not support either of those protocols, :exc:"
"`TypeError` is raised. If the second argument, *sentinel*, is given, then "
"*object* must be a callable object.  The iterator created in this case will "
"call *object* with no arguments for each call to its :meth:`~iterator."
"__next__` method; if the value returned is equal to *sentinel*, :exc:"
"`StopIteration` will be raised, otherwise the value will be returned."
msgstr ""
"Повертає об’єкт :term:`iterator`. Перший аргумент інтерпретується дуже по-"
"різному в залежності від наявності другого аргументу. Без другого аргументу "
"*object* має бути об’єктом колекції, який підтримує протокол :term:"
"`iterable` (метод :meth:`__iter__`), або він має підтримувати протокол "
"послідовності (метод :meth:`__getitem__` з цілими аргументами, починаючи з "
"``0``). Якщо він не підтримує жодного з цих протоколів, виникає :exc:"
"`TypeError`. Якщо задано другий аргумент, *sentinel*, то *object* має бути "
"викликаним об’єктом. Ітератор, створений у цьому випадку, буде викликати "
"*object* без аргументів для кожного виклику його методу :meth:`~iterator."
"__next__`; якщо повернуте значення дорівнює *sentinel*, :exc:`StopIteration` "
"буде піднято, інакше буде повернено значення."

msgid "See also :ref:`typeiter`."
msgstr "Дивіться також :ref:`typeiter`."

msgid ""
"One useful application of the second form of :func:`iter` is to build a "
"block-reader. For example, reading fixed-width blocks from a binary database "
"file until the end of file is reached::"
msgstr ""
"Одним із корисних застосувань другої форми :func:`iter` є створення програми "
"для читання блоків. Наприклад, читання блоків фіксованої ширини з бінарного "
"файлу бази даних до досягнення кінця файлу::"

msgid ""
"Return the length (the number of items) of an object.  The argument may be a "
"sequence (such as a string, bytes, tuple, list, or range) or a collection "
"(such as a dictionary, set, or frozen set)."
msgstr ""
"Повертає довжину (кількість елементів) об’єкта. Аргументом може бути "
"послідовність (наприклад, рядок, байти, кортеж, список або діапазон) або "
"колекція (наприклад, словник, набір або заморожений набір)."

msgid ""
"``len`` raises :exc:`OverflowError` on lengths larger than :data:`sys."
"maxsize`, such as :class:`range(2 ** 100) <range>`."
msgstr ""
"``len`` викликає :exc:`OverflowError` для довжин, більших за :data:`sys."
"maxsize`, наприклад :class:`range(2 ** 100) <range>`."

msgid ""
"Rather than being a function, :class:`list` is actually a mutable sequence "
"type, as documented in :ref:`typesseq-list` and :ref:`typesseq`."
msgstr ""
"Замість того, щоб бути функцією, :class:`list` насправді є змінним типом "
"послідовності, як описано в :ref:`typesseq-list` і :ref:`typesseq`."

msgid ""
"Update and return a dictionary representing the current local symbol table. "
"Free variables are returned by :func:`locals` when it is called in function "
"blocks, but not in class blocks. Note that at the module level, :func:"
"`locals` and :func:`globals` are the same dictionary."
msgstr ""
"Оновити та повернути словник, що представляє поточну локальну таблицю "
"символів. Вільні змінні повертає :func:`locals`, коли він викликається у "
"функціональних блоках, але не в блоках класів. Зауважте, що на рівні модуля :"
"func:`locals` і :func:`globals` є одним і тим же словником."

msgid ""
"The contents of this dictionary should not be modified; changes may not "
"affect the values of local and free variables used by the interpreter."
msgstr ""
"Вміст цього словника не можна змінювати; зміни не можуть впливати на "
"значення локальних і вільних змінних, що використовуються інтерпретатором."

msgid ""
"Return an iterator that applies *function* to every item of *iterable*, "
"yielding the results.  If additional *iterables* arguments are passed, "
"*function* must take that many arguments and is applied to the items from "
"all iterables in parallel.  With multiple iterables, the iterator stops when "
"the shortest iterable is exhausted.  For cases where the function inputs are "
"already arranged into argument tuples, see :func:`itertools.starmap`\\."
msgstr ""

msgid ""
"Return the largest item in an iterable or the largest of two or more "
"arguments."
msgstr ""
"Повертає найбільший елемент у ітерації або найбільший з двох чи більше "
"аргументів."

msgid ""
"If one positional argument is provided, it should be an :term:`iterable`. "
"The largest item in the iterable is returned.  If two or more positional "
"arguments are provided, the largest of the positional arguments is returned."
msgstr ""
"Якщо надається один позиційний аргумент, це має бути :term:`iterable`. "
"Повертається найбільший елемент ітерації. Якщо надано два або більше "
"позиційних аргументів, повертається найбільший із позиційних аргументів."

msgid ""
"There are two optional keyword-only arguments. The *key* argument specifies "
"a one-argument ordering function like that used for :meth:`list.sort`. The "
"*default* argument specifies an object to return if the provided iterable is "
"empty. If the iterable is empty and *default* is not provided, a :exc:"
"`ValueError` is raised."
msgstr ""
"Є два необов’язкові аргументи лише для ключових слів. Аргумент *key* "
"визначає функцію впорядкування з одним аргументом, подібну до тієї, яка "
"використовується для :meth:`list.sort`. Аргумент *default* визначає об’єкт, "
"який повертається, якщо наданий ітераційний елемент порожній. Якщо iterable "
"порожній і *default* не вказано, виникає :exc:`ValueError`."

msgid ""
"If multiple items are maximal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving tools "
"such as ``sorted(iterable, key=keyfunc, reverse=True)[0]`` and ``heapq."
"nlargest(1, iterable, key=keyfunc)``."
msgstr ""
"Якщо кілька елементів є максимальними, функція повертає перший знайдений. Це "
"узгоджується з іншими інструментами збереження стабільності сортування, "
"такими як ``sorted(iterable, key=keyfunc, reverse=True)[0]`` і ``heapq."
"nlargest(1, iterable, key=keyfunc)``."

msgid "The *default* keyword-only argument."
msgstr "Аргумент *default* лише для ключового слова."

msgid "The *key* can be ``None``."
msgstr "*Ключ* може бути ``None``."

msgid ""
"Return a \"memory view\" object created from the given argument.  See :ref:"
"`typememoryview` for more information."
msgstr ""
"Повертає об’єкт \"перегляд пам’яті\", створений із заданого аргументу. "
"Перегляньте :ref:`typememoryview` для отримання додаткової інформації."

msgid ""
"Return the smallest item in an iterable or the smallest of two or more "
"arguments."
msgstr ""
"Повертає найменший елемент у ітерації або найменший з двох чи більше "
"аргументів."

msgid ""
"If one positional argument is provided, it should be an :term:`iterable`. "
"The smallest item in the iterable is returned.  If two or more positional "
"arguments are provided, the smallest of the positional arguments is returned."
msgstr ""
"Якщо надається один позиційний аргумент, це має бути :term:`iterable`. "
"Повертається найменший елемент ітерації. Якщо надано два або більше "
"позиційних аргументів, повертається найменший із позиційних аргументів."

msgid ""
"If multiple items are minimal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving tools "
"such as ``sorted(iterable, key=keyfunc)[0]`` and ``heapq.nsmallest(1, "
"iterable, key=keyfunc)``."
msgstr ""
"Якщо декілька елементів є мінімальними, функція повертає перший знайдений. "
"Це узгоджується з іншими інструментами збереження стабільності сортування, "
"такими як ``sorted(iterable, key=keyfunc)[0]`` і ``heapq.nsmallest(1, "
"iterable, key=keyfunc)``."

msgid ""
"Retrieve the next item from the :term:`iterator` by calling its :meth:"
"`~iterator.__next__` method.  If *default* is given, it is returned if the "
"iterator is exhausted, otherwise :exc:`StopIteration` is raised."
msgstr ""
"Отримайте наступний елемент із :term:`iterator`, викликавши його метод :meth:"
"`~iterator.__next__`. Якщо задано *default*, воно повертається, якщо "
"ітератор вичерпано, інакше :exc:`StopIteration` викликається."

msgid ""
"Return a new featureless object.  :class:`object` is a base for all classes. "
"It has methods that are common to all instances of Python classes.  This "
"function does not accept any arguments."
msgstr ""
"Повернути новий безособливий об’єкт. :class:`object` є основою для всіх "
"класів. Він має методи, які є спільними для всіх екземплярів класів Python. "
"Ця функція не приймає жодних аргументів."

msgid ""
":class:`object` does *not* have a :attr:`~object.__dict__`, so you can't "
"assign arbitrary attributes to an instance of the :class:`object` class."
msgstr ""
":class:`object` *не* має :attr:`~object.__dict__`, тому ви не можете "
"призначити довільні атрибути екземпляру класу :class:`object`."

msgid ""
"Convert an integer number to an octal string prefixed with \"0o\".  The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`__index__` method that returns an "
"integer. For example:"
msgstr ""
"Перетворення цілого числа на вісімковий рядок із префіксом \"0o\". "
"Результатом є дійсний вираз Python. Якщо *x* не є об’єктом Python :class:"
"`int`, він має визначити метод :meth:`__index__`, який повертає ціле число. "
"Наприклад:"

msgid ""
"If you want to convert an integer number to an octal string either with the "
"prefix \"0o\" or not, you can use either of the following ways."
msgstr ""
"Якщо ви хочете перетворити ціле число на вісімковий рядок із префіксом "
"\"0o\" чи ні, ви можете скористатися одним із наведених нижче способів."

msgid ""
"Open *file* and return a corresponding :term:`file object`.  If the file "
"cannot be opened, an :exc:`OSError` is raised. See :ref:`tut-files` for more "
"examples of how to use this function."
msgstr ""
"Відкрийте *файл* і поверніть відповідний :term:`file object`. Якщо файл "
"неможливо відкрити, виникає :exc:`OSError`. Перегляньте :ref:`tut-files` для "
"отримання додаткових прикладів використання цієї функції."

msgid ""
"*file* is a :term:`path-like object` giving the pathname (absolute or "
"relative to the current working directory) of the file to be opened or an "
"integer file descriptor of the file to be wrapped.  (If a file descriptor is "
"given, it is closed when the returned I/O object is closed unless *closefd* "
"is set to ``False``.)"
msgstr ""
"*file* — це :term:`path-like object`, що надає шлях (абсолютний або "
"відносний до поточного робочого каталогу) до файлу, який потрібно відкрити, "
"або цілочисельний файловий дескриптор файлу, який потрібно обернути. (Якщо "
"задано дескриптор файлу, він закривається, коли повертається об’єкт вводу/"
"виводу, якщо *closefd* не має значення ``False``.)"

msgid ""
"*mode* is an optional string that specifies the mode in which the file is "
"opened.  It defaults to ``'r'`` which means open for reading in text mode. "
"Other common values are ``'w'`` for writing (truncating the file if it "
"already exists), ``'x'`` for exclusive creation, and ``'a'`` for appending "
"(which on *some* Unix systems, means that *all* writes append to the end of "
"the file regardless of the current seek position).  In text mode, if "
"*encoding* is not specified the encoding used is platform-dependent: :func:"
"`locale.getencoding()` is called to get the current locale encoding. (For "
"reading and writing raw bytes use binary mode and leave *encoding* "
"unspecified.)  The available modes are:"
msgstr ""

msgid "Character"
msgstr "характер"

msgid "Meaning"
msgstr "Значення"

msgid "``'r'``"
msgstr "``'r''``"

msgid "open for reading (default)"
msgstr "відкритий для читання (за замовчуванням)"

msgid "``'w'``"
msgstr "``'w'``"

msgid "open for writing, truncating the file first"
msgstr "відкрити для запису, спочатку скоротивши файл"

msgid "``'x'``"
msgstr "``'x''``"

msgid "open for exclusive creation, failing if the file already exists"
msgstr "відкрити для ексклюзивного створення, якщо файл уже існує"

msgid "``'a'``"
msgstr "``'a'``"

msgid "open for writing, appending to the end of file if it exists"
msgstr "відкрито для запису, додаючи в кінець файлу, якщо він існує"

msgid "``'b'``"
msgstr "``'b''``"

msgid "binary mode"
msgstr "двійковий режим"

msgid "``'t'``"
msgstr "``'t''``"

msgid "text mode (default)"
msgstr "текстовий режим (за замовчуванням)"

msgid "``'+'``"
msgstr "``'+'``"

msgid "open for updating (reading and writing)"
msgstr "відкритий для оновлення (читання та запис)"

msgid ""
"The default mode is ``'r'`` (open for reading text, a synonym of ``'rt'``). "
"Modes ``'w+'`` and ``'w+b'`` open and truncate the file.  Modes ``'r+'`` and "
"``'r+b'`` open the file with no truncation."
msgstr ""
"Типовим режимом є ``'r'`` (відкритий для читання тексту, синонім ``'rt'``). "
"Режими ``'w+'`` і ``'w+b'`` відкривають і скорочують файл. Режими ``'r+'`` і "
"``'r+b'`` відкривають файл без скорочення."

msgid ""
"As mentioned in the :ref:`io-overview`, Python distinguishes between binary "
"and text I/O.  Files opened in binary mode (including ``'b'`` in the *mode* "
"argument) return contents as :class:`bytes` objects without any decoding.  "
"In text mode (the default, or when ``'t'`` is included in the *mode* "
"argument), the contents of the file are returned as :class:`str`, the bytes "
"having been first decoded using a platform-dependent encoding or using the "
"specified *encoding* if given."
msgstr ""
"Як згадувалося в :ref:`io-overview`, Python розрізняє двійковий і текстовий "
"ввід-вивід. Файли, відкриті в двійковому режимі (включаючи ``'b'`` в "
"аргументі *mode*) повертають вміст як об’єкти :class:`bytes` без будь-якого "
"декодування. У текстовому режимі (за замовчуванням або коли ``'t'`` включено "
"в аргумент *mode*) вміст файлу повертається як :class:`str`, байти, які "
"спочатку були декодовані за допомогою платформи -залежне кодування або "
"використання зазначеного *кодування*, якщо воно вказано."

msgid ""
"Python doesn't depend on the underlying operating system's notion of text "
"files; all the processing is done by Python itself, and is therefore "
"platform-independent."
msgstr ""
"Python не залежить від поняття текстових файлів базової операційної системи; "
"вся обробка виконується самим Python, і тому вона не залежить від платформи."

msgid ""
"*buffering* is an optional integer used to set the buffering policy.  Pass 0 "
"to switch buffering off (only allowed in binary mode), 1 to select line "
"buffering (only usable in text mode), and an integer > 1 to indicate the "
"size in bytes of a fixed-size chunk buffer. Note that specifying a buffer "
"size this way applies for binary buffered I/O, but ``TextIOWrapper`` (i.e., "
"files opened with ``mode='r+'``) would have another buffering. To disable "
"buffering in ``TextIOWrapper``, consider using the ``write_through`` flag "
"for :func:`io.TextIOWrapper.reconfigure`. When no *buffering* argument is "
"given, the default buffering policy works as follows:"
msgstr ""
"*buffering* — необов’язкове ціле число, яке використовується для "
"встановлення політики буферизації. Передайте 0, щоб вимкнути буферизацію "
"(дозволено лише в двійковому режимі), 1, щоб вибрати буферизацію рядка "
"(використовується лише в текстовому режимі), і ціле число > 1, щоб вказати "
"розмір у байтах буфера фрагментів фіксованого розміру. Зауважте, що "
"визначення розміру буфера таким чином стосується бінарного буферизації вводу-"
"виводу, але ``TextIOWrapper`` (тобто файли, відкриті за допомогою "
"``mode='r+'``) матиме іншу буферизацію. Щоб вимкнути буферизацію в "
"``TextIOWrapper``, розгляньте можливість використання прапора "
"``write_through`` для :func:`io.TextIOWrapper.reconfigure`. Якщо аргумент "
"*buffering* не вказано, політика буферизації за замовчуванням працює таким "
"чином:"

msgid ""
"Binary files are buffered in fixed-size chunks; the size of the buffer is "
"chosen using a heuristic trying to determine the underlying device's \"block "
"size\" and falling back on :attr:`io.DEFAULT_BUFFER_SIZE`.  On many systems, "
"the buffer will typically be 4096 or 8192 bytes long."
msgstr ""
"Бінарні файли буферизуються в блоках фіксованого розміру; розмір буфера "
"вибирається за допомогою евристики, яка намагається визначити \"розмір "
"блоку\" основного пристрою та повертається до :attr:`io."
"DEFAULT_BUFFER_SIZE`. У багатьох системах буфер зазвичай має довжину 4096 "
"або 8192 байтів."

msgid ""
"\"Interactive\" text files (files for which :meth:`~io.IOBase.isatty` "
"returns ``True``) use line buffering.  Other text files use the policy "
"described above for binary files."
msgstr ""
"\"Інтерактивні\" текстові файли (файли, для яких :meth:`~io.IOBase.isatty` "
"повертає ``True``) використовують буферизацію рядка. Інші текстові файли "
"використовують політику, описану вище для двійкових файлів."

msgid ""
"*encoding* is the name of the encoding used to decode or encode the file. "
"This should only be used in text mode.  The default encoding is platform "
"dependent (whatever :func:`locale.getencoding` returns), but any :term:`text "
"encoding` supported by Python can be used. See the :mod:`codecs` module for "
"the list of supported encodings."
msgstr ""

msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled—this cannot be used in binary mode. A variety of "
"standard error handlers are available (listed under :ref:`error-handlers`), "
"though any error handling name that has been registered with :func:`codecs."
"register_error` is also valid.  The standard names include:"
msgstr ""
"*errors* — це необов’язковий рядок, який визначає, як мають оброблятися "
"помилки кодування та декодування — це не можна використовувати в двійковому "
"режимі. Доступні різноманітні стандартні обробники помилок (перераховані в :"
"ref:`error-handlers`), хоча будь-яка назва обробки помилок, зареєстрована в :"
"func:`codecs.register_error`, також дійсна. Стандартні назви включають:"

msgid ""
"``'strict'`` to raise a :exc:`ValueError` exception if there is an encoding "
"error.  The default value of ``None`` has the same effect."
msgstr ""
"``'strict'``, щоб викликати виключення :exc:`ValueError`, якщо є помилка "
"кодування. Значення за замовчуванням \"Немає\" має той самий ефект."

msgid ""
"``'ignore'`` ignores errors.  Note that ignoring encoding errors can lead to "
"data loss."
msgstr ""
"``'ignore''`` ігнорує помилки. Зауважте, що ігнорування помилок кодування "
"може призвести до втрати даних."

msgid ""
"``'replace'`` causes a replacement marker (such as ``'?'``) to be inserted "
"where there is malformed data."
msgstr ""
"``'replace'`` вставляє маркер заміни (наприклад, ``'?'``), де є неправильно "
"сформовані дані."

msgid ""
"``'surrogateescape'`` will represent any incorrect bytes as low surrogate "
"code units ranging from U+DC80 to U+DCFF. These surrogate code units will "
"then be turned back into the same bytes when the ``surrogateescape`` error "
"handler is used when writing data.  This is useful for processing files in "
"an unknown encoding."
msgstr ""
"``'surrogateescape'`` представлятиме будь-які неправильні байти як одиниці "
"нижнього сурогатного коду в діапазоні від U+DC80 до U+DCFF. Ці одиниці "
"сурогатного коду потім будуть перетворені назад у ті самі байти, коли під "
"час запису даних використовується обробник помилок ``surrogateescape``. Це "
"корисно для обробки файлів у невідомому кодуванні."

msgid ""
"``'xmlcharrefreplace'`` is only supported when writing to a file. Characters "
"not supported by the encoding are replaced with the appropriate XML "
"character reference ``&#nnn;``."
msgstr ""
"``'xmlcharrefreplace'`` підтримується лише під час запису у файл. Символи, "
"які не підтримуються кодуванням, замінюються відповідним посиланням на "
"символ XML ``&#nnn;``."

msgid ""
"``'backslashreplace'`` replaces malformed data by Python's backslashed "
"escape sequences."
msgstr ""
"``'backslashreplace'`` замінює некоректні дані керуючими послідовностями "
"Python зі зворотною похилою рискою."

msgid ""
"``'namereplace'`` (also only supported when writing) replaces unsupported "
"characters with ``\\N{...}`` escape sequences."
msgstr ""
"``'namereplace'`` (також підтримується лише під час запису) замінює "
"непідтримувані символи ``\\N{...}`` керуючими послідовностями."

msgid ""
"*newline* determines how to parse newline characters from the stream. It can "
"be ``None``, ``''``, ``'\\n'``, ``'\\r'``, and ``'\\r\\n'``.  It works as "
"follows:"
msgstr ""

msgid ""
"When reading input from the stream, if *newline* is ``None``, universal "
"newlines mode is enabled.  Lines in the input can end in ``'\\n'``, "
"``'\\r'``, or ``'\\r\\n'``, and these are translated into ``'\\n'`` before "
"being returned to the caller.  If it is ``''``, universal newlines mode is "
"enabled, but line endings are returned to the caller untranslated.  If it "
"has any of the other legal values, input lines are only terminated by the "
"given string, and the line ending is returned to the caller untranslated."
msgstr ""
"Під час читання вхідних даних із потоку, якщо *новий рядок* має значення "
"``None``, увімкнено універсальний режим нових рядків. Рядки у вхідних даних "
"можуть закінчуватися на ``'\\n'``, ``'\\r'`` або ``'\\r\\n'``, і вони "
"перекладаються на ``'\\n'`` перед поверненням до абонента. Якщо це ``''``, "
"універсальний режим нових рядків увімкнено, але закінчення рядків "
"повертаються абоненту без перекладу. Якщо він має будь-яке з інших "
"дозволених значень, рядки введення завершуються лише заданим рядком, а "
"закінчення рядка повертається до викликаючого без перекладу."

msgid ""
"When writing output to the stream, if *newline* is ``None``, any ``'\\n'`` "
"characters written are translated to the system default line separator, :"
"data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no translation "
"takes place.  If *newline* is any of the other legal values, any ``'\\n'`` "
"characters written are translated to the given string."
msgstr ""
"Під час запису вихідних даних у потік, якщо *новий рядок* має значення "
"``None``, будь-які записані символи ``'\\n'`` переводяться в системний "
"роздільник рядків за умовчанням, :data:`os.linesep`. Якщо *новий рядок* є "
"``''`` або ``'\\n'``, переклад не відбувається. Якщо *новий рядок* є будь-"
"яким іншим допустимим значенням, будь-які написані символи ``'\\n'`` "
"переводяться в заданий рядок."

msgid ""
"If *closefd* is ``False`` and a file descriptor rather than a filename was "
"given, the underlying file descriptor will be kept open when the file is "
"closed.  If a filename is given *closefd* must be ``True`` (the default); "
"otherwise, an error will be raised."
msgstr ""
"Якщо *closefd* має значення ``False`` і вказано дескриптор файлу, а не ім’я "
"файлу, базовий дескриптор файлу залишатиметься відкритим, коли файл буде "
"закрито. Якщо вказано ім’я файлу *closefd* має бути ``True`` (за "
"замовчуванням); інакше виникне помилка."

msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by calling "
"*opener* with (*file*, *flags*). *opener* must return an open file "
"descriptor (passing :mod:`os.open` as *opener* results in functionality "
"similar to passing ``None``)."
msgstr ""
"Спеціальний відкривач можна використовувати, передавши виклик як *opener*. "
"Базовий файловий дескриптор для об’єкта файлу потім отримується шляхом "
"виклику *opener* за допомогою (*file*, *flags*). *opener* має повертати "
"дескриптор відкритого файлу (передача :mod:`os.open` як *opener* призводить "
"до функціональності, подібної до передачі ``None``)."

msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "Щойно створений файл :ref:`не успадковується <fd_inheritance>`."

msgid ""
"The following example uses the :ref:`dir_fd <dir_fd>` parameter of the :func:"
"`os.open` function to open a file relative to a given directory::"
msgstr ""
"У наступному прикладі використовується параметр :ref:`dir_fd <dir_fd>` "
"функції :func:`os.open` для відкриття файлу відносно заданого каталогу::"

msgid ""
"The type of :term:`file object` returned by the :func:`open` function "
"depends on the mode.  When :func:`open` is used to open a file in a text "
"mode (``'w'``, ``'r'``, ``'wt'``, ``'rt'``, etc.), it returns a subclass of :"
"class:`io.TextIOBase` (specifically :class:`io.TextIOWrapper`).  When used "
"to open a file in a binary mode with buffering, the returned class is a "
"subclass of :class:`io.BufferedIOBase`.  The exact class varies: in read "
"binary mode, it returns an :class:`io.BufferedReader`; in write binary and "
"append binary modes, it returns an :class:`io.BufferedWriter`, and in read/"
"write mode, it returns an :class:`io.BufferedRandom`.  When buffering is "
"disabled, the raw stream, a subclass of :class:`io.RawIOBase`, :class:`io."
"FileIO`, is returned."
msgstr ""
"Тип об’єкта :term:`file object`, який повертає функція :func:`open`, "
"залежить від режиму. Коли :func:`open` використовується для відкриття файлу "
"в текстовому режимі (``'w'``, ``'r'``, ``'wt'``, ``'rt'``, тощо), він "
"повертає підклас :class:`io.TextIOBase` (зокрема :class:`io.TextIOWrapper`). "
"Коли файл використовується для відкриття файлу в бінарному режимі з "
"буферизацією, повертається клас є підкласом :class:`io.BufferedIOBase`. "
"Точний клас різниться: у бінарному режимі читання він повертає :class:`io."
"BufferedReader`; у двійкових режимах запису та додавання повертає :class:`io."
"BufferedWriter`, а в режимі читання/запису повертає :class:`io."
"BufferedRandom`. Коли буферизацію вимкнено, повертається необроблений потік, "
"підклас :class:`io.RawIOBase`, :class:`io.FileIO`."

msgid ""
"See also the file handling modules, such as :mod:`fileinput`, :mod:`io` "
"(where :func:`open` is declared), :mod:`os`, :mod:`os.path`, :mod:"
"`tempfile`, and :mod:`shutil`."
msgstr ""
"Перегляньте також модулі обробки файлів, такі як :mod:`fileinput`, :mod:`io` "
"(де оголошено :func:`open`), :mod:`os`, :mod:`os.path`, :mod:`tempfile` і :"
"mod:`shutil`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``open`` with arguments ``file``, "
"``mode``, ``flags``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``open`` з аргументами ``file``, "
"``mode``, ``flags``."

msgid ""
"The ``mode`` and ``flags`` arguments may have been modified or inferred from "
"the original call."
msgstr ""
"Аргументи ``mode`` і ``flags`` могли бути змінені або виведені з початкового "
"виклику."

msgid "The *opener* parameter was added."
msgstr "Додано параметр *opener*."

msgid "The ``'x'`` mode was added."
msgstr "Додано режим ``'x``."

msgid ":exc:`IOError` used to be raised, it is now an alias of :exc:`OSError`."
msgstr ":exc:`IOError` раніше викликався, тепер це псевдонім :exc:`OSError`."

msgid ""
":exc:`FileExistsError` is now raised if the file opened in exclusive "
"creation mode (``'x'``) already exists."
msgstr ""
":exc:`FileExistsError` тепер викликається, якщо файл, відкритий у "
"монопольному режимі створення (``'x'``), уже існує."

msgid "The file is now non-inheritable."
msgstr "Тепер файл не успадковується."

msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the function now retries the system call instead of raising an :"
"exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"Якщо системний виклик перервано, а обробник сигналу не викликає виключення, "
"функція тепер повторює системний виклик замість того, щоб викликати виняток :"
"exc:`InterruptedError` (перегляньте :pep:`475` для обґрунтування)."

msgid "The ``'namereplace'`` error handler was added."
msgstr "Додано обробник помилок ``'namereplace'``."

msgid "Support added to accept objects implementing :class:`os.PathLike`."
msgstr ""
"Додано підтримку прийняття об’єктів, що реалізують :class:`os.PathLike`."

msgid ""
"On Windows, opening a console buffer may return a subclass of :class:`io."
"RawIOBase` other than :class:`io.FileIO`."
msgstr ""
"У Windows відкриття буфера консолі може повернути підклас :class:`io."
"RawIOBase`, відмінний від :class:`io.FileIO`."

msgid "The ``'U'`` mode has been removed."
msgstr ""

msgid ""
"Given a string representing one Unicode character, return an integer "
"representing the Unicode code point of that character.  For example, "
"``ord('a')`` returns the integer ``97`` and ``ord('€')`` (Euro sign) returns "
"``8364``.  This is the inverse of :func:`chr`."
msgstr ""
"Дано рядок, що представляє один символ Unicode, повертає ціле число, що "
"представляє код Unicode цього символу. Наприклад, ``ord('a')`` повертає ціле "
"число ``97``, ``ord('€')`` (знак євро) повертає ``8364``. Це зворотне до :"
"func:`chr`."

msgid ""
"Return *base* to the power *exp*; if *mod* is present, return *base* to the "
"power *exp*, modulo *mod* (computed more efficiently than ``pow(base, exp) % "
"mod``). The two-argument form ``pow(base, exp)`` is equivalent to using the "
"power operator: ``base**exp``."
msgstr ""
"Повернути *base* до потужності *exp*; якщо присутній *mod*, повертає *base* "
"до ступеня *exp*, за модулем *mod* (обчислюється ефективніше, ніж "
"``pow(base, exp) % mod``). Форма з двома аргументами ``pow(base, exp)`` "
"еквівалентна використанню оператора ступеня: ``base**exp``."

msgid ""
"The arguments must have numeric types.  With mixed operand types, the "
"coercion rules for binary arithmetic operators apply.  For :class:`int` "
"operands, the result has the same type as the operands (after coercion) "
"unless the second argument is negative; in that case, all arguments are "
"converted to float and a float result is delivered.  For example, ``pow(10, "
"2)`` returns ``100``, but ``pow(10, -2)`` returns ``0.01``.  For a negative "
"base of type :class:`int` or :class:`float` and a non-integral exponent, a "
"complex result is delivered.  For example, ``pow(-9, 0.5)`` returns a value "
"close to ``3j``."
msgstr ""
"Аргументи повинні мати числові типи. Для змішаних типів операндів "
"застосовуються правила приведення для двійкових арифметичних операторів. Для "
"операндів :class:`int` результат має той самий тип, що й операнди (після "
"приведення), якщо другий аргумент не є від’ємним; у цьому випадку всі "
"аргументи перетворюються на значення float і видає результат float. "
"Наприклад, ``pow(10, 2)`` повертає ``100``, а ``pow(10, -2)`` повертає "
"``0,01``. Для від’ємної основи типу :class:`int` або :class:`float` і "
"нецілісного показника видається комплексний результат. Наприклад, ``pow(-9, "
"0.5)`` повертає значення, близьке до ``3j``."

msgid ""
"For :class:`int` operands *base* and *exp*, if *mod* is present, *mod* must "
"also be of integer type and *mod* must be nonzero. If *mod* is present and "
"*exp* is negative, *base* must be relatively prime to *mod*. In that case, "
"``pow(inv_base, -exp, mod)`` is returned, where *inv_base* is an inverse to "
"*base* modulo *mod*."
msgstr ""
"Для :class:`int` операндів *base* і *exp*, якщо присутній *mod*, *mod* також "
"має бути цілого типу, а *mod* має бути ненульовим. Якщо *mod* присутній і "
"*exp* від’ємний, *base* має бути відносно простим до *mod*. У цьому випадку "
"повертається ``pow(inv_base, -exp, mod)``, де *inv_base* є оберненим до "
"*base* за модулем *mod*."

msgid "Here's an example of computing an inverse for ``38`` modulo ``97``::"
msgstr "Ось приклад обчислення оберненого числа для ``38`` за модулем ``97``::"

msgid ""
"For :class:`int` operands, the three-argument form of ``pow`` now allows the "
"second argument to be negative, permitting computation of modular inverses."
msgstr ""
"Для операндів :class:`int` форма з трьома аргументами ``pow`` тепер дозволяє "
"другому аргументу бути від’ємним, що дозволяє обчислювати модульні обернені."

msgid ""
"Allow keyword arguments.  Formerly, only positional arguments were supported."
msgstr ""
"Дозволити аргументи ключових слів. Раніше підтримувалися лише позиційні "
"аргументи."

msgid ""
"Print *objects* to the text stream *file*, separated by *sep* and followed "
"by *end*.  *sep*, *end*, *file*, and *flush*, if present, must be given as "
"keyword arguments."
msgstr ""
"Вивести *об’єкти* в *файл* текстового потоку, розділивши *sep* і "
"супроводжуючи *end*. *sep*, *end*, *file* і *flush*, якщо вони присутні, "
"потрібно надати як аргументи ключового слова."

msgid ""
"All non-keyword arguments are converted to strings like :func:`str` does and "
"written to the stream, separated by *sep* and followed by *end*.  Both *sep* "
"and *end* must be strings; they can also be ``None``, which means to use the "
"default values.  If no *objects* are given, :func:`print` will just write "
"*end*."
msgstr ""
"Усі аргументи, не пов’язані з ключовими словами, перетворюються на рядки, як "
"це робить :func:`str`, і записуються в потік, розділені символом *sep* і "
"після нього *end*. І *sep*, і *end* повинні бути рядками; вони також можуть "
"бути ``None``, що означає використання стандартних значень. Якщо *об’єктів* "
"не надано, :func:`print` просто напише *end*."

msgid ""
"The *file* argument must be an object with a ``write(string)`` method; if it "
"is not present or ``None``, :data:`sys.stdout` will be used.  Since printed "
"arguments are converted to text strings, :func:`print` cannot be used with "
"binary mode file objects.  For these, use ``file.write(...)`` instead."
msgstr ""
"Аргумент *file* має бути об’єктом із методом ``write(string)``; якщо його "
"немає або ``None``, буде використано :data:`sys.stdout`. Оскільки "
"надруковані аргументи перетворюються на текстові рядки, :func:`print` не "
"можна використовувати з об’єктами файлу двійкового режиму. Для цього замість "
"цього використовуйте ``file.write(...)``."

msgid ""
"Whether the output is buffered is usually determined by *file*, but if the "
"*flush* keyword argument is true, the stream is forcibly flushed."
msgstr ""
"Чи буферизований вихід зазвичай визначається *файлом*, але якщо аргумент "
"ключового слова *flush* має значення true, потік примусово очищується."

msgid "Added the *flush* keyword argument."
msgstr "Додано аргумент ключового слова *flush*."

msgid "Return a property attribute."
msgstr "Повертає атрибут властивості."

msgid ""
"*fget* is a function for getting an attribute value.  *fset* is a function "
"for setting an attribute value. *fdel* is a function for deleting an "
"attribute value.  And *doc* creates a docstring for the attribute."
msgstr ""
"*fget* — це функція для отримання значення атрибута. *fset* — це функція для "
"встановлення значення атрибута. *fdel* — це функція для видалення значення "
"атрибута. А *doc* створює рядок документації для атрибута."

msgid "A typical use is to define a managed attribute ``x``::"
msgstr "Типовим використанням є визначення керованого атрибута ``x``::"

msgid ""
"If *c* is an instance of *C*, ``c.x`` will invoke the getter, ``c.x = "
"value`` will invoke the setter, and ``del c.x`` the deleter."
msgstr ""
"Якщо *c* є екземпляром *C*, ``c.x`` викличе засіб отримання, ``c.x = value`` "
"викличе установник, а ``del c.x`` засіб видалення."

msgid ""
"If given, *doc* will be the docstring of the property attribute. Otherwise, "
"the property will copy *fget*'s docstring (if it exists).  This makes it "
"possible to create read-only properties easily using :func:`property` as a :"
"term:`decorator`::"
msgstr ""
"Якщо вказано, *doc* буде рядком документації атрибута властивості. В іншому "
"випадку властивість скопіює рядок документа *fget* (якщо він існує). Це дає "
"змогу легко створювати властивості лише для читання, використовуючи :func:"
"`property` як :term:`decorator`::"

msgid ""
"The ``@property`` decorator turns the :meth:`voltage` method into a "
"\"getter\" for a read-only attribute with the same name, and it sets the "
"docstring for *voltage* to \"Get the current voltage.\""
msgstr ""
"Декоратор ``@property`` перетворює метод :meth:`voltage` на \"отримувач\" "
"для атрибута лише для читання з такою самою назвою, і встановлює рядок "
"документації для *voltage* на \"Отримати поточну напругу\"."

msgid ""
"A property object has :attr:`~property.getter`, :attr:`~property.setter`, "
"and :attr:`~property.deleter` methods usable as decorators that create a "
"copy of the property with the corresponding accessor function set to the "
"decorated function.  This is best explained with an example::"
msgstr ""
"Об’єкт властивості має методи :attr:`~property.getter`, :attr:`~property."
"setter` і :attr:`~property.deleter`, які можна використовувати як "
"декоратори, які створюють копію властивості з відповідною функцією доступу "
"встановлено на декоровану функцію. Це найкраще пояснити на прикладі::"

msgid ""
"This code is exactly equivalent to the first example.  Be sure to give the "
"additional functions the same name as the original property (``x`` in this "
"case.)"
msgstr ""
"Цей код точно еквівалентний першому прикладу. Обов’язково дайте додатковим "
"функціям те саме ім’я, що й початкова властивість (у цьому випадку ``x``)."

msgid ""
"The returned property object also has the attributes ``fget``, ``fset``, and "
"``fdel`` corresponding to the constructor arguments."
msgstr ""
"Повернений об’єкт властивості також має атрибути ``fget``, ``fset`` і "
"``fdel``, що відповідають аргументам конструктора."

msgid "The docstrings of property objects are now writeable."
msgstr "Рядки документації об’єктів властивості тепер доступні для запису."

msgid ""
"Rather than being a function, :class:`range` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-range` and :ref:`typesseq`."
msgstr ""
"Замість того, щоб бути функцією, :class:`range` насправді є незмінним типом "
"послідовності, як описано в :ref:`typesseq-range` і :ref:`typesseq`."

msgid ""
"Return a string containing a printable representation of an object.  For "
"many types, this function makes an attempt to return a string that would "
"yield an object with the same value when passed to :func:`eval`; otherwise, "
"the representation is a string enclosed in angle brackets that contains the "
"name of the type of the object together with additional information often "
"including the name and address of the object.  A class can control what this "
"function returns for its instances by defining a :meth:`__repr__` method. "
"If :func:`sys.displayhook` is not accessible, this function will raise :exc:"
"`RuntimeError`."
msgstr ""

msgid ""
"Return a reverse :term:`iterator`.  *seq* must be an object which has a :"
"meth:`__reversed__` method or supports the sequence protocol (the :meth:"
"`__len__` method and the :meth:`__getitem__` method with integer arguments "
"starting at ``0``)."
msgstr ""
"Повертає зворотний :term:`iterator`. *seq* має бути об’єктом, який має "
"метод :meth:`__reversed__` або підтримує протокол послідовності (метод :meth:"
"`__len__` і метод :meth:`__getitem__` з цілими аргументами, починаючи з "
"``0`` )."

msgid ""
"Return *number* rounded to *ndigits* precision after the decimal point.  If "
"*ndigits* is omitted or is ``None``, it returns the nearest integer to its "
"input."
msgstr ""
"Повертає *число*, округлене до *nцифр* з точністю після коми. Якщо *ndigits* "
"опущено або має значення ``None``, він повертає найближче ціле число до "
"вхідних даних."

msgid ""
"For the built-in types supporting :func:`round`, values are rounded to the "
"closest multiple of 10 to the power minus *ndigits*; if two multiples are "
"equally close, rounding is done toward the even choice (so, for example, "
"both ``round(0.5)`` and ``round(-0.5)`` are ``0``, and ``round(1.5)`` is "
"``2``).  Any integer value is valid for *ndigits* (positive, zero, or "
"negative).  The return value is an integer if *ndigits* is omitted or "
"``None``. Otherwise, the return value has the same type as *number*."
msgstr ""
"Для вбудованих типів, які підтримують :func:`round`, значення округлюються "
"до найближчого кратного 10 у степені мінус *ndigits*; якщо два кратні "
"однаково близькі, округлення виконується в бік парного вибору (тому, "
"наприклад, як``round(0.5)``, так і ``round(-0.5)`` є ``0``, а ``round(1.5)`` "
"є ``2``). Будь-яке ціле значення є дійсним для *nцифр* (додатне, нульове або "
"від’ємне). Повернене значення є цілим числом, якщо *ndigits* пропущено або "
"``None``. В іншому випадку значення, що повертається, має той самий тип, що "
"й *число*."

msgid ""
"For a general Python object ``number``, ``round`` delegates to ``number."
"__round__``."
msgstr ""
"Для загального об’єкта Python ``number`` ``round`` делегує ``number."
"__round__``."

msgid ""
"The behavior of :func:`round` for floats can be surprising: for example, "
"``round(2.675, 2)`` gives ``2.67`` instead of the expected ``2.68``. This is "
"not a bug: it's a result of the fact that most decimal fractions can't be "
"represented exactly as a float.  See :ref:`tut-fp-issues` for more "
"information."
msgstr ""
"Поведінка :func:`round` для числа з плаваючою точкою може бути несподіваною: "
"наприклад, ``round(2.675, 2)`` дає ``2.67`` замість очікуваного ``2.68``. Це "
"не помилка: це результат того факту, що більшість десяткових дробів не можна "
"представити точно як число з плаваючою точкою. Перегляньте :ref:`tut-fp-"
"issues` для отримання додаткової інформації."

msgid ""
"Return a new :class:`set` object, optionally with elements taken from "
"*iterable*.  ``set`` is a built-in class.  See :class:`set` and :ref:`types-"
"set` for documentation about this class."
msgstr ""
"Повертає новий об’єкт :class:`set`, необов’язково з елементами, взятими з "
"*iterable*. ``набір`` є вбудованим класом. Перегляньте :class:`set` і :ref:"
"`types-set` для документації про цей клас."

msgid ""
"For other containers see the built-in :class:`frozenset`, :class:`list`, :"
"class:`tuple`, and :class:`dict` classes, as well as the :mod:`collections` "
"module."
msgstr ""
"Для інших контейнерів перегляньте вбудовані класи :class:`frozenset`, :class:"
"`list`, :class:`tuple` і :class:`dict`, а також модуль :mod:`collections`."

msgid ""
"This is the counterpart of :func:`getattr`.  The arguments are an object, a "
"string, and an arbitrary value.  The string may name an existing attribute "
"or a new attribute.  The function assigns the value to the attribute, "
"provided the object allows it.  For example, ``setattr(x, 'foobar', 123)`` "
"is equivalent to ``x.foobar = 123``."
msgstr ""
"Це відповідник :func:`getattr`. Аргументами є об’єкт, рядок і довільне "
"значення. Рядок може називати існуючий атрибут або новий атрибут. Функція "
"присвоює значення атрибуту, якщо це дозволяє об’єкт. Наприклад, ``setattr(x, "
"'foobar', 123)`` еквівалентно ``x.foobar = 123``."

msgid ""
"*name* need not be a Python identifier as defined in :ref:`identifiers` "
"unless the object chooses to enforce that, for example in a custom :meth:"
"`~object.__getattribute__` or via :attr:`~object.__slots__`. An attribute "
"whose name is not an identifier will not be accessible using the dot "
"notation, but is accessible through :func:`getattr` etc.."
msgstr ""

msgid ""
"Since :ref:`private name mangling <private-name-mangling>` happens at "
"compilation time, one must manually mangle a private attribute's (attributes "
"with two leading underscores) name in order to set it with :func:`setattr`."
msgstr ""
"Оскільки :ref:`викривлення приватного імені <private-name-mangling>` "
"відбувається під час компіляції, потрібно вручну спотворити ім’я приватного "
"атрибута (атрибути з двома символами підкреслення на початку), щоб "
"встановити його за допомогою :func:`setattr`."

msgid ""
"Return a :term:`slice` object representing the set of indices specified by "
"``range(start, stop, step)``.  The *start* and *step* arguments default to "
"``None``.  Slice objects have read-only data attributes :attr:`~slice."
"start`, :attr:`~slice.stop`, and :attr:`~slice.step` which merely return the "
"argument values (or their default).  They have no other explicit "
"functionality; however, they are used by NumPy and other third-party "
"packages. Slice objects are also generated when extended indexing syntax is "
"used.  For example: ``a[start:stop:step]`` or ``a[start:stop, i]``.  See :"
"func:`itertools.islice` for an alternate version that returns an iterator."
msgstr ""
"Повертає об’єкт :term:`slice`, що представляє набір індексів, визначених "
"``діапазоном (початок, зупинка, крок)``. Аргументи *start* і *step* за "
"умовчанням мають значення ``None``. Об’єкти фрагментів мають атрибути даних "
"лише для читання :attr:`~slice.start`, :attr:`~slice.stop` і :attr:`~slice."
"step`, які просто повертають значення аргументів (або їхнє значення за "
"замовчуванням). Вони не мають інших явних функцій; однак вони "
"використовуються NumPy та іншими пакетами сторонніх виробників. Об’єкти "
"фрагментів також генеруються, коли використовується розширений синтаксис "
"індексування. Наприклад: ``a[start:stop:step]`` або ``a[start:stop, i]``. "
"Перегляньте :func:`itertools.islice` альтернативну версію, яка повертає "
"ітератор."

msgid "Return a new sorted list from the items in *iterable*."
msgstr "Повертає новий відсортований список з елементів у *iterable*."

msgid ""
"Has two optional arguments which must be specified as keyword arguments."
msgstr ""
"Має два необов’язкові аргументи, які необхідно вказати як аргументи "
"ключового слова."

msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each element in *iterable* (for example, ``key=str."
"lower``).  The default value is ``None`` (compare the elements directly)."
msgstr ""
"*key* визначає функцію одного аргументу, яка використовується для отримання "
"ключа порівняння з кожного елемента в *iterable* (наприклад, ``key=str."
"lower``). Значення за замовчуванням – ``None`` (пряме порівняння елементів)."

msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* — це логічне значення. Якщо встановлено значення ``True``, "
"елементи списку сортуються так, ніби кожне порівняння було зворотним."

msgid ""
"Use :func:`functools.cmp_to_key` to convert an old-style *cmp* function to a "
"*key* function."
msgstr ""
"Використовуйте :func:`functools.cmp_to_key`, щоб перетворити функцію *cmp* "
"старого стилю на функцію *key*."

msgid ""
"The built-in :func:`sorted` function is guaranteed to be stable. A sort is "
"stable if it guarantees not to change the relative order of elements that "
"compare equal --- this is helpful for sorting in multiple passes (for "
"example, sort by department, then by salary grade)."
msgstr ""
"Вбудована функція :func:`sorted` гарантовано буде стабільною. Сортування є "
"стабільним, якщо воно гарантує відсутність зміни відносного порядку "
"порівнюваних рівних елементів --- це корисно для сортування за кілька "
"проходів (наприклад, сортування за відділом, а потім за ступенем заробітної "
"плати)."

msgid ""
"The sort algorithm uses only ``<`` comparisons between items.  While "
"defining an :meth:`~object.__lt__` method will suffice for sorting, :PEP:`8` "
"recommends that all six :ref:`rich comparisons <comparisons>` be "
"implemented.  This will help avoid bugs when using the same data with other "
"ordering tools such as :func:`max` that rely on a different underlying "
"method.  Implementing all six comparisons also helps avoid confusion for "
"mixed type comparisons which can call reflected the :meth:`~object.__gt__` "
"method."
msgstr ""
"Алгоритм сортування використовує лише ``<`` comparisons between items.  "
"While defining an :meth:`~object.__lt__` method will suffice for sorting, :"
"PEP:`8` recommends that all six :ref:`rich comparisons <comparisons>`. Це "
"допоможе уникнути помилок під час використання тих самих даних з іншими "
"інструментами впорядкування, такими як :func:`max`, які покладаються на "
"інший базовий метод. Реалізація всіх шести порівнянь також допомагає "
"уникнути плутанини для порівнянь змішаного типу, які можуть викликати "
"відображений метод :meth:`~object.__gt__`."

msgid ""
"For sorting examples and a brief sorting tutorial, see :ref:`sortinghowto`."
msgstr ""
"Приклади сортування та короткий посібник із сортування див. :ref:"
"`sortinghowto`."

msgid "Transform a method into a static method."
msgstr "Перетворення методу в статичний метод."

msgid ""
"A static method does not receive an implicit first argument. To declare a "
"static method, use this idiom::"
msgstr ""
"Статичний метод не отримує неявний перший аргумент. Щоб оголосити статичний "
"метод, використовуйте цю ідіому::"

msgid ""
"The ``@staticmethod`` form is a function :term:`decorator` -- see :ref:"
"`function` for details."
msgstr ""
"Форма ``@staticmethod`` є функцією :term:`decorator` -- подробиці див. :ref:"
"`function`."

msgid ""
"A static method can be called either on the class (such as ``C.f()``) or on "
"an instance (such as ``C().f()``). Moreover, they can be called as regular "
"functions (such as ``f()``)."
msgstr ""
"Статичний метод можна викликати або в класі (наприклад, ``C.f()``), або в "
"екземплярі (такому як ``C().f()``). Крім того, їх можна викликати як "
"звичайні функції (наприклад, ``f()``)."

msgid ""
"Static methods in Python are similar to those found in Java or C++. Also, "
"see :func:`classmethod` for a variant that is useful for creating alternate "
"class constructors."
msgstr ""
"Статичні методи в Python подібні до методів Java або C++. Також перегляньте :"
"func:`classmethod` варіант, який корисний для створення альтернативних "
"конструкторів класів."

msgid ""
"Like all decorators, it is also possible to call ``staticmethod`` as a "
"regular function and do something with its result.  This is needed in some "
"cases where you need a reference to a function from a class body and you "
"want to avoid the automatic transformation to instance method.  For these "
"cases, use this idiom::"
msgstr ""
"Як і в усіх декораторах, також можна викликати ``staticmethod`` як звичайну "
"функцію та щось робити з його результатом. Це необхідно в деяких випадках, "
"коли вам потрібно посилання на функцію з тіла класу, і ви хочете уникнути "
"автоматичного перетворення в метод екземпляра. Для цих випадків "
"використовуйте цю ідіому::"

msgid "For more information on static methods, see :ref:`types`."
msgstr ""
"Для отримання додаткової інформації про статичні методи див. :ref:`types`."

msgid ""
"Static methods now inherit the method attributes (``__module__``, "
"``__name__``, ``__qualname__``, ``__doc__`` and ``__annotations__``), have a "
"new ``__wrapped__`` attribute, and are now callable as regular functions."
msgstr ""
"Статичні методи тепер успадковують атрибути методу (``__module__``, "
"``__name__``, ``__qualname__``, ``__doc__`` і ``__annotations__``), мають "
"новий атрибут ``__wrapped__`` і тепер викликаються як звичайні функції."

msgid ""
"Return a :class:`str` version of *object*.  See :func:`str` for details."
msgstr ""
"Повертає :class:`str` версію *object*. Дивіться :func:`str` для деталей."

msgid ""
"``str`` is the built-in string :term:`class`.  For general information about "
"strings, see :ref:`textseq`."
msgstr ""
"``str`` — це вбудований рядок :term:`class`. Щоб отримати загальну "
"інформацію про рядки, перегляньте :ref:`textseq`."

msgid ""
"Sums *start* and the items of an *iterable* from left to right and returns "
"the total.  The *iterable*'s items are normally numbers, and the start value "
"is not allowed to be a string."
msgstr ""
"Сумує *start* і елементи *iterable* зліва направо та повертає підсумок. "
"Елементи *iterable* зазвичай є числами, а початкове значення не може бути "
"рядком."

msgid ""
"For some use cases, there are good alternatives to :func:`sum`. The "
"preferred, fast way to concatenate a sequence of strings is by calling ``''."
"join(sequence)``.  To add floating point values with extended precision, "
"see :func:`math.fsum`\\.  To concatenate a series of iterables, consider "
"using :func:`itertools.chain`."
msgstr ""
"Для деяких випадків використання є хороші альтернативи :func:`sum`. Кращим "
"швидким способом об’єднання послідовності рядків є виклик ``''."
"join(sequence)``. Щоб додати значення з плаваючою комою з розширеною "
"точністю, перегляньте :func:`math.fsum`\\. Щоб об’єднати ряд ітерацій, "
"розгляньте можливість використання :func:`itertools.chain`."

msgid "The *start* parameter can be specified as a keyword argument."
msgstr "Параметр *start* можна вказати як аргумент ключового слова."

msgid ""
"Return a proxy object that delegates method calls to a parent or sibling "
"class of *type*.  This is useful for accessing inherited methods that have "
"been overridden in a class."
msgstr ""
"Повертає проксі-об’єкт, який делегує виклики методу батьківському або "
"рідному класу *типу*. Це корисно для доступу до успадкованих методів, які "
"були перевизначені в класі."

msgid ""
"The *object_or_type* determines the :term:`method resolution order` to be "
"searched.  The search starts from the class right after the *type*."
msgstr ""

msgid ""
"For example, if :attr:`~class.__mro__` of *object_or_type* is ``D -> B -> C -"
"> A -> object`` and the value of *type* is ``B``, then :func:`super` "
"searches ``C -> A -> object``."
msgstr ""

msgid ""
"The :attr:`~class.__mro__` attribute of the *object_or_type* lists the "
"method resolution search order used by both :func:`getattr` and :func:"
"`super`.  The attribute is dynamic and can change whenever the inheritance "
"hierarchy is updated."
msgstr ""

msgid ""
"If the second argument is omitted, the super object returned is unbound.  If "
"the second argument is an object, ``isinstance(obj, type)`` must be true.  "
"If the second argument is a type, ``issubclass(type2, type)`` must be true "
"(this is useful for classmethods)."
msgstr ""
"Якщо другий аргумент опущено, повернутий супероб’єкт не зв’язаний. Якщо "
"другий аргумент є об’єктом, ``isinstance(obj, type)`` має бути істинним. "
"Якщо другий аргумент є типом, ``issubclass(type2, type)`` має бути істинним "
"(це корисно для методів класу)."

msgid ""
"There are two typical use cases for *super*.  In a class hierarchy with "
"single inheritance, *super* can be used to refer to parent classes without "
"naming them explicitly, thus making the code more maintainable.  This use "
"closely parallels the use of *super* in other programming languages."
msgstr ""
"Є два типових випадки використання *super*. В ієрархії класів з єдиним "
"успадкуванням *super* можна використовувати для посилання на батьківські "
"класи, не вказуючи їх явно, що робить код більш придатним для "
"обслуговування. Це використання дуже схоже на використання *super* в інших "
"мовах програмування."

msgid ""
"The second use case is to support cooperative multiple inheritance in a "
"dynamic execution environment.  This use case is unique to Python and is not "
"found in statically compiled languages or languages that only support single "
"inheritance.  This makes it possible to implement \"diamond diagrams\" where "
"multiple base classes implement the same method.  Good design dictates that "
"such implementations have the same calling signature in every case (because "
"the order of calls is determined at runtime, because that order adapts to "
"changes in the class hierarchy, and because that order can include sibling "
"classes that are unknown prior to runtime)."
msgstr ""
"Другий варіант використання — це підтримка кооперативного множинного "
"успадкування в динамічному середовищі виконання. Цей варіант використання "
"унікальний для Python і не зустрічається в статично скомпільованих мовах або "
"мовах, які підтримують лише одне успадкування. Це дає змогу реалізувати "
"\"діамантові діаграми\", де кілька базових класів реалізують один і той же "
"метод. Хороший дизайн вимагає, щоб такі реалізації мали однакову сигнатуру "
"виклику в кожному випадку (оскільки порядок викликів визначається під час "
"виконання, оскільки цей порядок адаптується до змін в ієрархії класів, і "
"оскільки цей порядок може включати однотипні класи, які невідомі до "
"виконання )."

msgid "For both use cases, a typical superclass call looks like this::"
msgstr "Для обох випадків типовий виклик суперкласу виглядає так:"

msgid ""
"In addition to method lookups, :func:`super` also works for attribute "
"lookups.  One possible use case for this is calling :term:`descriptors "
"<descriptor>` in a parent or sibling class."
msgstr ""
"Окрім пошуку методів, :func:`super` також працює для пошуку атрибутів. Одним "
"із можливих варіантів використання цього є виклик :term:`дескрипторів "
"<descriptor>` у батьківському або рідному класі."

msgid ""
"Note that :func:`super` is implemented as part of the binding process for "
"explicit dotted attribute lookups such as ``super().__getitem__(name)``. It "
"does so by implementing its own :meth:`__getattribute__` method for "
"searching classes in a predictable order that supports cooperative multiple "
"inheritance. Accordingly, :func:`super` is undefined for implicit lookups "
"using statements or operators such as ``super()[name]``."
msgstr ""
"Зауважте, що :func:`super` реалізовано як частину процесу зв’язування для "
"явного пошуку атрибутів із пунктирною точкою, наприклад ``super()."
"__getitem__(name)``. Це робиться шляхом реалізації власного методу :meth:"
"`__getattribute__` для пошуку класів у передбачуваному порядку, який "
"підтримує кооперативне множинне успадкування. Відповідно, :func:`super` не "
"визначено для неявних пошуків за допомогою операторів або операторів, таких "
"як ``super()[name]``."

msgid ""
"Also note that, aside from the zero argument form, :func:`super` is not "
"limited to use inside methods.  The two argument form specifies the "
"arguments exactly and makes the appropriate references.  The zero argument "
"form only works inside a class definition, as the compiler fills in the "
"necessary details to correctly retrieve the class being defined, as well as "
"accessing the current instance for ordinary methods."
msgstr ""
"Також зауважте, що, окрім форми нульового аргументу, :func:`super` не "
"обмежується використанням внутрішніх методів. Форма з двома аргументами "
"точно визначає аргументи та робить відповідні посилання. Форма нульового "
"аргументу працює лише всередині визначення класу, оскільки компілятор "
"заповнює необхідні деталі для правильного отримання визначеного класу, а "
"також для доступу до поточного екземпляра для звичайних методів."

msgid ""
"For practical suggestions on how to design cooperative classes using :func:"
"`super`, see `guide to using super() <https://rhettinger.wordpress."
"com/2011/05/26/super-considered-super/>`_."
msgstr ""
"Щоб отримати практичні поради щодо створення кооперативних класів за "
"допомогою :func:`super`, перегляньте `посібник із використання super() "
"<https://rhettinger.wordpress.com/2011/05/26/super-considered-super/>`_."

msgid ""
"Rather than being a function, :class:`tuple` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-tuple` and :ref:`typesseq`."
msgstr ""
"Замість того, щоб бути функцією, :class:`tuple` насправді є незмінним типом "
"послідовності, як описано в :ref:`typesseq-tuple` і :ref:`typesseq`."

msgid ""
"With one argument, return the type of an *object*.  The return value is a "
"type object and generally the same object as returned by :attr:`object."
"__class__ <instance.__class__>`."
msgstr ""
"З одним аргументом повертає тип *об’єкта*. Значення, що повертається, є "
"об’єктом типу та, як правило, таким самим об’єктом, який повертає :attr:"
"`object.__class__ <instance.__class__>`."

msgid ""
"The :func:`isinstance` built-in function is recommended for testing the type "
"of an object, because it takes subclasses into account."
msgstr ""
"Для перевірки типу об’єкта рекомендується використовувати вбудовану функцію :"
"func:`isinstance`, оскільки вона враховує підкласи."

msgid ""
"With three arguments, return a new type object.  This is essentially a "
"dynamic form of the :keyword:`class` statement. The *name* string is the "
"class name and becomes the :attr:`~definition.__name__` attribute. The "
"*bases* tuple contains the base classes and becomes the :attr:`~class."
"__bases__` attribute; if empty, :class:`object`, the ultimate base of all "
"classes, is added.  The *dict* dictionary contains attribute and method "
"definitions for the class body; it may be copied or wrapped before becoming "
"the :attr:`~object.__dict__` attribute. The following two statements create "
"identical :class:`type` objects:"
msgstr ""
"З трьома аргументами повертає об’єкт нового типу. По суті, це динамічна "
"форма оператора :keyword:`class`. Рядок *name* є назвою класу і стає "
"атрибутом :attr:`~definition.__name__`. Кортеж *bases* містить базові класи "
"та стає атрибутом :attr:`~class.__bases__`; якщо порожній, додається :class:"
"`object`, кінцева база всіх класів. Словник *dict* містить визначення "
"атрибутів і методів для тіла класу; його можна скопіювати або обернути перед "
"тим, як стати атрибутом :attr:`~object.__dict__`. Наступні два оператори "
"створюють ідентичні об’єкти :class:`type`:"

msgid "See also :ref:`bltin-type-objects`."
msgstr "Дивіться також :ref:`bltin-type-objects`."

msgid ""
"Keyword arguments provided to the three argument form are passed to the "
"appropriate metaclass machinery (usually :meth:`~object.__init_subclass__`) "
"in the same way that keywords in a class definition (besides *metaclass*) "
"would."
msgstr ""
"Аргументи ключових слів, надані у формі з трьома аргументами, передаються у "
"відповідний механізм метакласу (зазвичай :meth:`~object.__init_subclass__`) "
"так само, як ключові слова у визначенні класу (крім *metaclass*)."

msgid "See also :ref:`class-customization`."
msgstr "Дивіться також :ref:`class-customization`."

msgid ""
"Subclasses of :class:`type` which don't override ``type.__new__`` may no "
"longer use the one-argument form to get the type of an object."
msgstr ""
"Підкласи :class:`type`, які не перевизначають ``type.__new__``, більше не "
"можуть використовувати форму з одним аргументом для отримання типу об’єкта."

msgid ""
"Return the :attr:`~object.__dict__` attribute for a module, class, instance, "
"or any other object with a :attr:`~object.__dict__` attribute."
msgstr ""
"Повертає атрибут :attr:`~object.__dict__` для модуля, класу, екземпляра або "
"будь-якого іншого об’єкта з атрибутом :attr:`~object.__dict__`."

msgid ""
"Objects such as modules and instances have an updateable :attr:`~object."
"__dict__` attribute; however, other objects may have write restrictions on "
"their :attr:`~object.__dict__` attributes (for example, classes use a :class:"
"`types.MappingProxyType` to prevent direct dictionary updates)."
msgstr ""
"Такі об’єкти, як модулі та екземпляри, мають оновлюваний атрибут :attr:"
"`~object.__dict__`; однак інші об’єкти можуть мати обмеження на запис своїх "
"атрибутів :attr:`~object.__dict__` (наприклад, класи використовують :class:"
"`types.MappingProxyType`, щоб запобігти прямим оновленням словника)."

msgid ""
"Without an argument, :func:`vars` acts like :func:`locals`.  Note, the "
"locals dictionary is only useful for reads since updates to the locals "
"dictionary are ignored."
msgstr ""
"Без аргументу :func:`vars` діє як :func:`locals`. Зауважте, що словник "
"місцевих користувачів корисний лише для читання, оскільки оновлення словника "
"локальних користувачів ігноруються."

msgid ""
"A :exc:`TypeError` exception is raised if an object is specified but it "
"doesn't have a :attr:`~object.__dict__` attribute (for example, if its class "
"defines the :attr:`~object.__slots__` attribute)."
msgstr ""
"Виняток :exc:`TypeError` виникає, якщо об’єкт указано, але він не має "
"атрибута :attr:`~object.__dict__` (наприклад, якщо його клас визначає :attr:"
"`~object.__slots__` атрибут)."

msgid ""
"Iterate over several iterables in parallel, producing tuples with an item "
"from each one."
msgstr ""
"Виконайте ітерацію кількох ітерацій паралельно, створюючи кортежі з "
"елементом з кожного."

msgid "Example::"
msgstr "Приклад::"

msgid ""
"More formally: :func:`zip` returns an iterator of tuples, where the *i*-th "
"tuple contains the *i*-th element from each of the argument iterables."
msgstr ""
"Більш формально: :func:`zip` повертає ітератор кортежів, де *i*-й кортеж "
"містить *i*-й елемент з кожного з ітерованих аргументів."

msgid ""
"Another way to think of :func:`zip` is that it turns rows into columns, and "
"columns into rows.  This is similar to `transposing a matrix <https://en."
"wikipedia.org/wiki/Transpose>`_."
msgstr ""
"Інший спосіб уявлення про :func:`zip` полягає в тому, що він перетворює "
"рядки на стовпці, а стовпці — на рядки. Це схоже на `транспонування матриці "
"<https://en.wikipedia.org/wiki/Transpose>`_."

msgid ""
":func:`zip` is lazy: The elements won't be processed until the iterable is "
"iterated on, e.g. by a :keyword:`!for` loop or by wrapping in a :class:"
"`list`."
msgstr ""
":func:`zip` ледачий: елементи не будуть оброблені, доки не буде виконано "
"ітерацію, напр. за допомогою циклу :keyword:`!for` або загортання в :class:"
"`list`."

msgid ""
"One thing to consider is that the iterables passed to :func:`zip` could have "
"different lengths; sometimes by design, and sometimes because of a bug in "
"the code that prepared these iterables.  Python offers three different "
"approaches to dealing with this issue:"
msgstr ""
"Варто взяти до уваги те, що ітератори, передані :func:`zip`, можуть мати "
"різну довжину; іноді задумом, а іноді через помилку в коді, який підготував "
"ці ітерації. Python пропонує три різні підходи до вирішення цієї проблеми:"

msgid ""
"By default, :func:`zip` stops when the shortest iterable is exhausted. It "
"will ignore the remaining items in the longer iterables, cutting off the "
"result to the length of the shortest iterable::"
msgstr ""
"За замовчуванням :func:`zip` зупиняється, коли вичерпується найкоротша "
"ітерація. Він ігноруватиме решта елементів у довших ітераціях, відрізаючи "
"результат до довжини найкоротшої ітерації::"

msgid ""
":func:`zip` is often used in cases where the iterables are assumed to be of "
"equal length.  In such cases, it's recommended to use the ``strict=True`` "
"option. Its output is the same as regular :func:`zip`::"
msgstr ""
":func:`zip` часто використовується у випадках, коли передбачається, що "
"ітератори мають однакову довжину. У таких випадках рекомендується "
"використовувати параметр ``strict=True``. Його вихід такий самий, як і "
"звичайний :func:`zip`::"

msgid ""
"Unlike the default behavior, it checks that the lengths of iterables are "
"identical, raising a :exc:`ValueError` if they aren't:"
msgstr ""
"На відміну від поведінки за замовчуванням, він перевіряє, що довжини "
"ітерованих елементів ідентичні, викликаючи :exc:`ValueError`, якщо вони не є:"

msgid ""
"Without the ``strict=True`` argument, any bug that results in iterables of "
"different lengths will be silenced, possibly manifesting as a hard-to-find "
"bug in another part of the program."
msgstr ""
"Без аргументу ``strict=True`` будь-яка помилка, яка призводить до ітерацій "
"різної довжини, буде замовчена, можливо, проявляючись як помилка, яку важко "
"знайти в іншій частині програми."

msgid ""
"Shorter iterables can be padded with a constant value to make all the "
"iterables have the same length.  This is done by :func:`itertools."
"zip_longest`."
msgstr ""
"Коротші ітератори можна доповнити постійним значенням, щоб усі ітератори "
"мали однакову довжину. Це робить :func:`itertools.zip_longest`."

msgid ""
"Edge cases: With a single iterable argument, :func:`zip` returns an iterator "
"of 1-tuples.  With no arguments, it returns an empty iterator."
msgstr ""
"Граничні випадки: з одним ітерованим аргументом :func:`zip` повертає "
"ітератор 1-кортежів. Без аргументів він повертає порожній ітератор."

msgid "Tips and tricks:"
msgstr "Поради та підказки:"

msgid ""
"The left-to-right evaluation order of the iterables is guaranteed. This "
"makes possible an idiom for clustering a data series into n-length groups "
"using ``zip(*[iter(s)]*n, strict=True)``.  This repeats the *same* iterator "
"``n`` times so that each output tuple has the result of ``n`` calls to the "
"iterator. This has the effect of dividing the input into n-length chunks."
msgstr ""
"Порядок оцінки ітерацій зліва направо гарантується. Це робить можливою "
"ідіому для кластеризації рядів даних у групи довжини n за допомогою "
"``zip(*[iter(s)]*n, strict=True)``. Це повторює *той самий* ітератор ``n`` "
"разів, щоб кожен вихідний кортеж мав результат ``n`` викликів ітератора. Це "
"призводить до поділу вхідних даних на фрагменти довжиною n."

msgid ""
":func:`zip` in conjunction with the ``*`` operator can be used to unzip a "
"list::"
msgstr ""
":func:`zip` у поєднанні з оператором ``*`` можна використовувати для "
"розпакування списку::"

msgid "Added the ``strict`` argument."
msgstr "Додано аргумент ``строгий``."

msgid ""
"This is an advanced function that is not needed in everyday Python "
"programming, unlike :func:`importlib.import_module`."
msgstr ""
"Це розширена функція, яка не потрібна в повсякденному програмуванні на "
"Python, на відміну від :func:`importlib.import_module`."

msgid ""
"This function is invoked by the :keyword:`import` statement.  It can be "
"replaced (by importing the :mod:`builtins` module and assigning to "
"``builtins.__import__``) in order to change semantics of the :keyword:`!"
"import` statement, but doing so is **strongly** discouraged as it is usually "
"simpler to use import hooks (see :pep:`302`) to attain the same goals and "
"does not cause issues with code which assumes the default import "
"implementation is in use.  Direct use of :func:`__import__` is also "
"discouraged in favor of :func:`importlib.import_module`."
msgstr ""
"Ця функція викликається оператором :keyword:`import`. Його можна замінити "
"(імпортувавши модуль :mod:`builtins` і призначивши ``builtins.__import__``), "
"щоб змінити семантику оператора :keyword:`!import`, але це **настійно** не "
"рекомендується, оскільки зазвичай простіше використовувати перехоплювачі "
"імпорту (див. :pep:`302`) для досягнення тих самих цілей і не викликає "
"проблем із кодом, який припускає, що використовується реалізація імпорту за "
"замовчуванням. Пряме використання :func:`__import__` також не рекомендується "
"на користь :func:`importlib.import_module`."

msgid ""
"The function imports the module *name*, potentially using the given "
"*globals* and *locals* to determine how to interpret the name in a package "
"context. The *fromlist* gives the names of objects or submodules that should "
"be imported from the module given by *name*.  The standard implementation "
"does not use its *locals* argument at all and uses its *globals* only to "
"determine the package context of the :keyword:`import` statement."
msgstr ""
"Функція імпортує *name* модуля, потенційно використовуючи задані *globals* і "
"*locals*, щоб визначити, як інтерпретувати назву в контексті пакета. Список "
"*fromlist* надає імена об’єктів або підмодулів, які слід імпортувати з "
"модуля, заданого *name*. Стандартна реалізація взагалі не використовує свій "
"аргумент *locals* і використовує його *globals* лише для визначення "
"контексту пакета оператора :keyword:`import`."

msgid ""
"*level* specifies whether to use absolute or relative imports. ``0`` (the "
"default) means only perform absolute imports.  Positive values for *level* "
"indicate the number of parent directories to search relative to the "
"directory of the module calling :func:`__import__` (see :pep:`328` for the "
"details)."
msgstr ""
"*рівень* визначає, чи використовувати абсолютний чи відносний імпорт. ``0`` "
"(за замовчуванням) означає виконання лише абсолютного імпорту. Позитивні "
"значення для *level* вказують на кількість батьківських каталогів для пошуку "
"відносно каталогу модуля, який викликає :func:`__import__` (див. :pep:`328` "
"для деталей)."

msgid ""
"When the *name* variable is of the form ``package.module``, normally, the "
"top-level package (the name up till the first dot) is returned, *not* the "
"module named by *name*.  However, when a non-empty *fromlist* argument is "
"given, the module named by *name* is returned."
msgstr ""
"Якщо змінна *name* має форму ``package.module``, зазвичай повертається пакет "
"верхнього рівня (ім’я до першої крапки), *а не* модуль, названий *name*. "
"Однак, якщо вказано непорожній аргумент *fromlist*, повертається модуль, "
"названий *name*."

msgid ""
"For example, the statement ``import spam`` results in bytecode resembling "
"the following code::"
msgstr ""
"Наприклад, оператор ``import spam`` призводить до байт-коду, схожого на "
"такий код:"

msgid "The statement ``import spam.ham`` results in this call::"
msgstr "Інструкція ``import spam.ham`` призводить до цього виклику::"

msgid ""
"Note how :func:`__import__` returns the toplevel module here because this is "
"the object that is bound to a name by the :keyword:`import` statement."
msgstr ""
"Зверніть увагу, як :func:`__import__` повертає тут модуль верхнього рівня, "
"оскільки це об’єкт, який прив’язаний до імені оператором :keyword:`import`."

msgid ""
"On the other hand, the statement ``from spam.ham import eggs, sausage as "
"saus`` results in ::"
msgstr ""
"З іншого боку, заява ``from spam.ham import eggs, sausage as saus`` "
"призводить до:"

msgid ""
"Here, the ``spam.ham`` module is returned from :func:`__import__`.  From "
"this object, the names to import are retrieved and assigned to their "
"respective names."
msgstr ""
"Тут модуль ``spam.ham`` повертається з :func:`__import__`. З цього об’єкта "
"витягуються імена для імпорту та призначаються їх відповідні імена."

msgid ""
"If you simply want to import a module (potentially within a package) by "
"name, use :func:`importlib.import_module`."
msgstr ""
"Якщо ви просто хочете імпортувати модуль (можливо, у пакеті) за назвою, "
"використовуйте :func:`importlib.import_module`."

msgid ""
"Negative values for *level* are no longer supported (which also changes the "
"default value to 0)."
msgstr ""
"Від’ємні значення для *рівня* більше не підтримуються (що також змінює "
"значення за замовчуванням на 0)."

msgid ""
"When the command line options :option:`-E` or :option:`-I` are being used, "
"the environment variable :envvar:`PYTHONCASEOK` is now ignored."
msgstr ""
"Коли використовуються параметри командного рядка :option:`-E` або :option:`-"
"I`, змінна середовища :envvar:`PYTHONCASEOK` ігнорується."

msgid "Footnotes"
msgstr "Примітки"

msgid ""
"Note that the parser only accepts the Unix-style end of line convention. If "
"you are reading the code from a file, make sure to use newline conversion "
"mode to convert Windows or Mac-style newlines."
msgstr ""
"Зауважте, що синтаксичний аналізатор приймає символ кінця рядка лише в стилі "
"Unix. Якщо ви читаєте код з файлу, обов’язково використовуйте режим "
"перетворення нового рядка для перетворення символів нового рядка з Windows "
"або Mac."
