# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:17+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`weakref` --- Weak references"
msgstr ":mod:`weakref` --- Слабкі посилання"

msgid "**Source code:** :source:`Lib/weakref.py`"
msgstr "**Вихідний код:** :source:`Lib/weakref.py`"

msgid ""
"The :mod:`weakref` module allows the Python programmer to create :dfn:`weak "
"references` to objects."
msgstr ""
"Модуль :mod:`weakref` дозволяє програмісту Python створювати :dfn:`слабкі "
"посилання` на об’єкти."

msgid ""
"In the following, the term :dfn:`referent` means the object which is "
"referred to by a weak reference."
msgstr ""
"Далі термін :dfn:`referent` означає об’єкт, на який посилається слабке "
"посилання."

msgid ""
"A weak reference to an object is not enough to keep the object alive: when "
"the only remaining references to a referent are weak references, :term:"
"`garbage collection` is free to destroy the referent and reuse its memory "
"for something else.  However, until the object is actually destroyed the "
"weak reference may return the object even if there are no strong references "
"to it."
msgstr ""
"Слабкого посилання на об’єкт недостатньо, щоб зберегти об’єкт живим: коли "
"єдині посилання на референт є слабкими посиланнями, :term:`garbage "
"collection` може знищити референт і використовувати його пам’ять для чогось "
"іншого. Однак, поки об’єкт не буде фактично знищено, слабке посилання може "
"повертати об’єкт, навіть якщо на нього немає сильних посилань."

msgid ""
"A primary use for weak references is to implement caches or mappings holding "
"large objects, where it's desired that a large object not be kept alive "
"solely because it appears in a cache or mapping."
msgstr ""
"Основним використанням слабких посилань є реалізація кешів або відображень, "
"що містять великі об’єкти, де бажано, щоб великий об’єкт не зберігався живим "
"лише тому, що він з’являється в кеші чи відображенні."

msgid ""
"For example, if you have a number of large binary image objects, you may "
"wish to associate a name with each.  If you used a Python dictionary to map "
"names to images, or images to names, the image objects would remain alive "
"just because they appeared as values or keys in the dictionaries.  The :"
"class:`WeakKeyDictionary` and :class:`WeakValueDictionary` classes supplied "
"by the :mod:`weakref` module are an alternative, using weak references to "
"construct mappings that don't keep objects alive solely because they appear "
"in the mapping objects.  If, for example, an image object is a value in a :"
"class:`WeakValueDictionary`, then when the last remaining references to that "
"image object are the weak references held by weak mappings, garbage "
"collection can reclaim the object, and its corresponding entries in weak "
"mappings are simply deleted."
msgstr ""
"Наприклад, якщо у вас є кілька великих бінарних об’єктів зображення, ви "
"можете призначити ім’я кожному. Якби ви використовували словник Python для "
"зіставлення імен із зображеннями або зображень з іменами, об’єкти зображення "
"залишалися б живими лише тому, що вони відображалися як значення або ключі в "
"словниках. Класи :class:`WeakKeyDictionary` і :class:`WeakValueDictionary`, "
"що надаються модулем :mod:`weakref`, є альтернативою, використовуючи слабкі "
"посилання для створення відображень, які не зберігають об’єкти лише тому, що "
"вони з’являються в об’єктах відображення . Якщо, наприклад, об’єкт "
"зображення є значенням у :class:`WeakValueDictionary`, тоді, коли останні "
"посилання на цей об’єкт зображення є слабкими посиланнями, утримуваними "
"слабкими відображеннями, збір сміття може відновити об’єкт і його відповідні "
"записи у слабких відображеннях просто видаляються."

msgid ""
":class:`WeakKeyDictionary` and :class:`WeakValueDictionary` use weak "
"references in their implementation, setting up callback functions on the "
"weak references that notify the weak dictionaries when a key or value has "
"been reclaimed by garbage collection.  :class:`WeakSet` implements the :"
"class:`set` interface, but keeps weak references to its elements, just like "
"a :class:`WeakKeyDictionary` does."
msgstr ""
":class:`WeakKeyDictionary` і :class:`WeakValueDictionary` використовують "
"слабкі посилання у своїй реалізації, встановлюючи функції зворотного виклику "
"для слабких посилань, які сповіщають слабкі словники, коли ключ або значення "
"було вилучено під час збирання сміття. :class:`WeakSet` реалізує інтерфейс :"
"class:`set`, але зберігає слабкі посилання на його елементи, як це робить :"
"class:`WeakKeyDictionary`."

msgid ""
":class:`finalize` provides a straight forward way to register a cleanup "
"function to be called when an object is garbage collected. This is simpler "
"to use than setting up a callback function on a raw weak reference, since "
"the module automatically ensures that the finalizer remains alive until the "
"object is collected."
msgstr ""
":class:`finalize` забезпечує прямий спосіб реєстрації функції очищення, яка "
"буде викликатися під час збирання сміття об’єкта. Це простіше у "
"використанні, ніж налаштування функції зворотного виклику для необробленого "
"слабкого посилання, оскільки модуль автоматично гарантує, що фіналізатор "
"залишається активним, доки об’єкт не буде зібрано."

msgid ""
"Most programs should find that using one of these weak container types or :"
"class:`finalize` is all they need -- it's not usually necessary to create "
"your own weak references directly.  The low-level machinery is exposed by "
"the :mod:`weakref` module for the benefit of advanced uses."
msgstr ""
"Більшість програм має виявити, що використання одного з цих слабких типів "
"контейнерів або :class:`finalize` — це все, що їм потрібно - зазвичай не "
"потрібно безпосередньо створювати власні слабкі посилання. Механізм низького "
"рівня розкривається модулем :mod:`weakref` для розширеного використання."

msgid ""
"Not all objects can be weakly referenced. Objects which support weak "
"references include class instances, functions written in Python (but not in "
"C), instance methods, sets, frozensets, some :term:`file objects <file "
"object>`, :term:`generators <generator>`, type objects, sockets, arrays, "
"deques, regular expression pattern objects, and code objects."
msgstr ""

msgid "Added support for thread.lock, threading.Lock, and code objects."
msgstr "Додано підтримку об’єктів thread.lock, threading.Lock і коду."

msgid ""
"Several built-in types such as :class:`list` and :class:`dict` do not "
"directly support weak references but can add support through subclassing::"
msgstr ""
"Кілька вбудованих типів, таких як :class:`list` і :class:`dict`, не "
"підтримують безпосередньо слабкі посилання, але можуть додати підтримку "
"через підкласи::"

msgid ""
"Other built-in types such as :class:`tuple` and :class:`int` do not support "
"weak references even when subclassed."
msgstr ""
"Інші вбудовані типи, такі як :class:`tuple` і :class:`int` не підтримують "
"слабкі посилання, навіть якщо є підкласами."

msgid ""
"Extension types can easily be made to support weak references; see :ref:"
"`weakref-support`."
msgstr ""
"Типи розширень можна легко створити для підтримки слабких посилань; див. :"
"ref:`weakref-support`."

msgid ""
"When ``__slots__`` are defined for a given type, weak reference support is "
"disabled unless a ``'__weakref__'`` string is also present in the sequence "
"of strings in the ``__slots__`` declaration. See :ref:`__slots__ "
"documentation <slots>` for details."
msgstr ""
"Коли для даного типу визначено ``__slots__``, підтримку слабких посилань "
"вимкнено, якщо тільки рядок ``'__weakref__`` також не присутній у "
"послідовності рядків у декларації ``__slots__``. Перегляньте :ref:`__slots__ "
"документацію <slots>` для деталей."

msgid ""
"Return a weak reference to *object*.  The original object can be retrieved "
"by calling the reference object if the referent is still alive; if the "
"referent is no longer alive, calling the reference object will cause :const:"
"`None` to be returned.  If *callback* is provided and not :const:`None`, and "
"the returned weakref object is still alive, the callback will be called when "
"the object is about to be finalized; the weak reference object will be "
"passed as the only parameter to the callback; the referent will no longer be "
"available."
msgstr ""
"Повернути слабке посилання на *об’єкт*. Вихідний об’єкт можна отримати, "
"викликавши еталонний об’єкт, якщо референт ще живий; якщо референт більше не "
"живий, виклик об’єкта посилання призведе до повернення :const:`None`. Якщо "
"надано *callback*, а не :const:`None`, і повернутий об’єкт weakref все ще "
"живий, зворотний виклик буде викликано, коли об’єкт буде завершено; об'єкт "
"слабкого посилання буде передано як єдиний параметр зворотного виклику; "
"референт більше не буде доступний."

msgid ""
"It is allowable for many weak references to be constructed for the same "
"object. Callbacks registered for each weak reference will be called from the "
"most recently registered callback to the oldest registered callback."
msgstr ""
"Для одного об’єкта допускається створення багатьох слабких посилань. "
"Зворотні виклики, зареєстровані для кожного слабкого посилання, "
"викликатимуться від останнього зареєстрованого зворотного виклику до "
"найстарішого зареєстрованого зворотного виклику."

msgid ""
"Exceptions raised by the callback will be noted on the standard error "
"output, but cannot be propagated; they are handled in exactly the same way "
"as exceptions raised from an object's :meth:`__del__` method."
msgstr ""
"Винятки, викликані зворотним викликом, будуть зазначені у стандартному "
"виведенні помилки, але не можуть бути передані; вони обробляються точно так "
"само, як винятки, викликані методом :meth:`__del__` об’єкта."

msgid ""
"Weak references are :term:`hashable` if the *object* is hashable.  They will "
"maintain their hash value even after the *object* was deleted.  If :func:"
"`hash` is called the first time only after the *object* was deleted, the "
"call will raise :exc:`TypeError`."
msgstr ""
"Слабкі посилання є :term:`hashable`, якщо *об’єкт* є хешованим. Вони "
"збережуть своє хеш-значення навіть після видалення *об’єкта*. Якщо :func:"
"`hash` викликається вперше лише після того, як *об’єкт* було видалено, "
"виклик викличе :exc:`TypeError`."

msgid ""
"Weak references support tests for equality, but not ordering.  If the "
"referents are still alive, two references have the same equality "
"relationship as their referents (regardless of the *callback*).  If either "
"referent has been deleted, the references are equal only if the reference "
"objects are the same object."
msgstr ""
"Слабкі посилання підтримують тести на рівність, але не впорядкування. Якщо "
"референти ще живі, два посилання мають таке ж відношення рівності, що й їхні "
"референти (незалежно від *зворотного виклику*). Якщо будь-який референт було "
"видалено, посилання є рівними, лише якщо об’єкти еталонів є одним і тим же "
"об’єктом."

msgid "This is a subclassable type rather than a factory function."
msgstr "Це тип підкласу, а не фабрична функція."

msgid ""
"This read-only attribute returns the callback currently associated to the "
"weakref.  If there is no callback or if the referent of the weakref is no "
"longer alive then this attribute will have value ``None``."
msgstr ""
"Цей атрибут лише для читання повертає зворотний виклик, наразі пов’язаний зі "
"слабким посиланням. Якщо зворотного виклику немає або референт слабкого "
"посилання більше не живий, цей атрибут матиме значення ``None``."

msgid "Added the :attr:`__callback__` attribute."
msgstr "Додано атрибут :attr:`__callback__`."

msgid ""
"Return a proxy to *object* which uses a weak reference.  This supports use "
"of the proxy in most contexts instead of requiring the explicit "
"dereferencing used with weak reference objects.  The returned object will "
"have a type of either ``ProxyType`` or ``CallableProxyType``, depending on "
"whether *object* is callable.  Proxy objects are not :term:`hashable` "
"regardless of the referent; this avoids a number of problems related to "
"their fundamentally mutable nature, and prevent their use as dictionary "
"keys.  *callback* is the same as the parameter of the same name to the :func:"
"`ref` function."
msgstr ""
"Повернути проксі до *об’єкта*, який використовує слабке посилання. Це "
"підтримує використання проксі-сервера в більшості контекстів замість того, "
"щоб вимагати явного розіменування, яке використовується для слабких "
"посилальних об’єктів. Повернений об’єкт матиме тип ``ProxyType`` або "
"``CallableProxyType``, залежно від того, чи можна викликати *об’єкт*. Проксі-"
"об’єкти не :term:`hashable` незалежно від референта; це дозволяє уникнути "
"ряду проблем, пов'язаних з їх фундаментально змінюваною природою, і "
"запобігає їх використанню як ключів словника. *callback* — це те саме, що й "
"однойменний параметр функції :func:`ref`."

msgid ""
"Accessing an attribute of the proxy object after the referent is garbage "
"collected raises :exc:`ReferenceError`."
msgstr ""

msgid ""
"Extended the operator support on proxy objects to include the matrix "
"multiplication operators ``@`` and ``@=``."
msgstr ""
"Розширено підтримку операторів на проксі-об’єктах, щоб включити оператори "
"множення матриці ``@`` і ``@=``."

msgid ""
"Return the number of weak references and proxies which refer to *object*."
msgstr ""
"Повертає кількість слабких посилань і проксі, які посилаються на *об’єкт*."

msgid ""
"Return a list of all weak reference and proxy objects which refer to "
"*object*."
msgstr ""
"Повертає список усіх слабких посилань і проксі-об’єктів, які посилаються на "
"*об’єкт*."

msgid ""
"Mapping class that references keys weakly.  Entries in the dictionary will "
"be discarded when there is no longer a strong reference to the key.  This "
"can be used to associate additional data with an object owned by other parts "
"of an application without adding attributes to those objects.  This can be "
"especially useful with objects that override attribute accesses."
msgstr ""
"Клас зіставлення, який слабко посилається на ключі. Записи в словнику буде "
"відкинуто, коли більше немає сильного посилання на ключ. Це можна "
"використовувати для зв’язування додаткових даних з об’єктом, що належить "
"іншим частинам програми, без додавання атрибутів до цих об’єктів. Це може "
"бути особливо корисним для об’єктів, які перевизначають доступ до атрибутів."

msgid "Added support for ``|`` and ``|=`` operators, specified in :pep:`584`."
msgstr "Додано підтримку операторів ``|`` і ``|=``, указаних у :pep:`584`."

msgid ""
":class:`WeakKeyDictionary` objects have an additional method that exposes "
"the internal references directly.  The references are not guaranteed to be "
"\"live\" at the time they are used, so the result of calling the references "
"needs to be checked before being used.  This can be used to avoid creating "
"references that will cause the garbage collector to keep the keys around "
"longer than needed."
msgstr ""
"Об’єкти :class:`WeakKeyDictionary` мають додатковий метод, який "
"безпосередньо відкриває внутрішні посилання. Не гарантується, що посилання "
"будуть \"живими\" під час їх використання, тому результат виклику посилань "
"потрібно перевірити перед використанням. Це можна використовувати, щоб "
"уникнути створення посилань, через які збирач сміття зберігатиме ключі "
"довше, ніж потрібно."

msgid "Return an iterable of the weak references to the keys."
msgstr "Повертає ітерацію слабких посилань на ключі."

msgid ""
"Mapping class that references values weakly.  Entries in the dictionary will "
"be discarded when no strong reference to the value exists any more."
msgstr ""
"Клас зіставлення, який слабко посилається на значення. Записи в словнику "
"буде відкинуто, якщо більше не існує сильного посилання на значення."

msgid ""
"Added support for ``|`` and ``|=`` operators, as specified in :pep:`584`."
msgstr "Додано підтримку операторів ``|`` і ``|=``, як зазначено в :pep:`584`."

msgid ""
":class:`WeakValueDictionary` objects have an additional method that has the "
"same issues as the :meth:`keyrefs` method of :class:`WeakKeyDictionary` "
"objects."
msgstr ""
"Об’єкти :class:`WeakValueDictionary` мають додатковий метод, який має ті "
"самі проблеми, що й метод :meth:`keyrefs` об’єктів :class:"
"`WeakKeyDictionary`."

msgid "Return an iterable of the weak references to the values."
msgstr "Повертає ітерацію слабких посилань на значення."

msgid ""
"Set class that keeps weak references to its elements.  An element will be "
"discarded when no strong reference to it exists any more."
msgstr ""
"Клас набору, який зберігає слабкі посилання на свої елементи. Елемент буде "
"відкинуто, якщо на нього більше не буде сильних посилань."

msgid ""
"A custom :class:`ref` subclass which simulates a weak reference to a bound "
"method (i.e., a method defined on a class and looked up on an instance). "
"Since a bound method is ephemeral, a standard weak reference cannot keep "
"hold of it.  :class:`WeakMethod` has special code to recreate the bound "
"method until either the object or the original function dies::"
msgstr ""
"Спеціальний підклас :class:`ref`, який імітує слабке посилання на зв’язаний "
"метод (тобто метод, визначений у класі та шуканий у екземплярі). Оскільки "
"зв’язаний метод є ефемерним, стандартне слабке посилання не може втримати "
"його. :class:`WeakMethod` має спеціальний код для відтворення зв’язаного "
"методу, доки об’єкт або вихідна функція не помре::"

msgid ""
"Return a callable finalizer object which will be called when *obj* is "
"garbage collected. Unlike an ordinary weak reference, a finalizer will "
"always survive until the reference object is collected, greatly simplifying "
"lifecycle management."
msgstr ""
"Повертає викликаний об’єкт фіналізатора, який буде викликаний, коли *obj* "
"буде зібрано сміття. На відміну від звичайного слабкого посилання, "
"фіналізатор завжди житиме, доки не буде зібрано еталонний об’єкт, що значно "
"спрощує керування життєвим циклом."

msgid ""
"A finalizer is considered *alive* until it is called (either explicitly or "
"at garbage collection), and after that it is *dead*.  Calling a live "
"finalizer returns the result of evaluating ``func(*arg, **kwargs)``, whereas "
"calling a dead finalizer returns :const:`None`."
msgstr ""
"Фіналізатор вважається *живим*, доки його не викликають (явним чином або під "
"час збирання сміття), а після цього він *мертвий*. Виклик активного "
"фіналізатора повертає результат обчислення ``func(*arg, **kwargs)``, тоді як "
"виклик мертвого фіналізатора повертає :const:`None`."

msgid ""
"Exceptions raised by finalizer callbacks during garbage collection will be "
"shown on the standard error output, but cannot be propagated.  They are "
"handled in the same way as exceptions raised from an object's :meth:"
"`__del__` method or a weak reference's callback."
msgstr ""
"Винятки, викликані зворотними викликами фіналізатора під час збирання "
"сміття, відображатимуться у стандартному виведенні помилок, але не можуть "
"поширюватися. Вони обробляються так само, як винятки, викликані методом :"
"meth:`__del__` об’єкта або зворотним викликом слабкого посилання."

msgid ""
"When the program exits, each remaining live finalizer is called unless its :"
"attr:`atexit` attribute has been set to false.  They are called in reverse "
"order of creation."
msgstr ""
"Коли програма завершує роботу, викликається кожен живий фіналізатор, що "
"залишився, якщо його атрибут :attr:`atexit` не має значення false. Вони "
"називаються у зворотному порядку створення."

msgid ""
"A finalizer will never invoke its callback during the later part of the :"
"term:`interpreter shutdown` when module globals are liable to have been "
"replaced by :const:`None`."
msgstr ""
"Фіналізатор ніколи не викличе свій зворотний виклик протягом наступної "
"частини :term:`interpreter shutdown`, коли глобальні елементи модуля можуть "
"бути замінені на :const:`None`."

msgid ""
"If *self* is alive then mark it as dead and return the result of calling "
"``func(*args, **kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""
"Якщо *self* живе, позначте його як мертве та поверніть результат виклику "
"``func(*args, **kwargs)``. Якщо *self* мертвий, поверніть :const:`None`."

msgid ""
"If *self* is alive then mark it as dead and return the tuple ``(obj, func, "
"args, kwargs)``.  If *self* is dead then return :const:`None`."
msgstr ""
"Якщо *self* живий, позначте його як мертвий і поверніть кортеж ``(obj, func, "
"args, kwargs)``. Якщо *self* мертвий, поверніть :const:`None`."

msgid ""
"If *self* is alive then return the tuple ``(obj, func, args, kwargs)``.  If "
"*self* is dead then return :const:`None`."
msgstr ""
"Якщо *self* живе, повертає кортеж ``(obj, func, args, kwargs)``. Якщо *self* "
"мертвий, поверніть :const:`None`."

msgid "Property which is true if the finalizer is alive, false otherwise."
msgstr ""
"Властивість, яка є істинною, якщо фіналізатор активний, і хибною в іншому "
"випадку."

msgid ""
"A writable boolean property which by default is true.  When the program "
"exits, it calls all remaining live finalizers for which :attr:`.atexit` is "
"true.  They are called in reverse order of creation."
msgstr ""
"Булева властивість, доступна для запису, яка за замовчуванням має значення "
"true. Коли програма завершує роботу, вона викликає всі поточні фіналізатори, "
"для яких :attr:`.atexit` має значення true. Вони називаються у зворотному "
"порядку створення."

msgid ""
"It is important to ensure that *func*, *args* and *kwargs* do not own any "
"references to *obj*, either directly or indirectly, since otherwise *obj* "
"will never be garbage collected.  In particular, *func* should not be a "
"bound method of *obj*."
msgstr ""
"Важливо переконатися, що *func*, *args* і *kwargs* не мають жодних посилань "
"на *obj*, прямо чи опосередковано, оскільки інакше *obj* ніколи не "
"збиратиметься як сміття. Зокрема, *func* не має бути зв’язаним методом *obj*."

msgid "The type object for weak references objects."
msgstr "Об’єкт типу для об’єктів слабких посилань."

msgid "The type object for proxies of objects which are not callable."
msgstr "Об’єкт типу для проксі об’єктів, які не можна викликати."

msgid "The type object for proxies of callable objects."
msgstr "Об’єкт типу для проксі об’єктів, що викликаються."

msgid ""
"Sequence containing all the type objects for proxies.  This can make it "
"simpler to test if an object is a proxy without being dependent on naming "
"both proxy types."
msgstr ""
"Послідовність, що містить усі об’єкти типу для проксі. Це може спростити "
"перевірку того, чи є об’єкт проксі-сервером, не залежачи від іменування обох "
"типів проксі."

msgid ":pep:`205` - Weak References"
msgstr ":pep:`205` - Слабкі посилання"

msgid ""
"The proposal and rationale for this feature, including links to earlier "
"implementations and information about similar features in other languages."
msgstr ""
"Пропозиція та обґрунтування цієї функції, включаючи посилання на попередні "
"реалізації та інформацію про подібні функції іншими мовами."

msgid "Weak Reference Objects"
msgstr "Слабкі довідкові об’єкти"

msgid ""
"Weak reference objects have no methods and no attributes besides :attr:`ref."
"__callback__`. A weak reference object allows the referent to be obtained, "
"if it still exists, by calling it:"
msgstr ""
"Слабкі посилальні об’єкти не мають методів і атрибутів, крім :attr:`ref."
"__callback__`. Слабкий посилальний об’єкт дозволяє отримати референт, якщо "
"він все ще існує, викликаючи його:"

msgid ""
"If the referent no longer exists, calling the reference object returns :"
"const:`None`:"
msgstr ""
"Якщо референт більше не існує, виклик об’єкта посилання повертає :const:"
"`None`:"

msgid ""
"Testing that a weak reference object is still live should be done using the "
"expression ``ref() is not None``.  Normally, application code that needs to "
"use a reference object should follow this pattern::"
msgstr ""
"Перевірку того, що слабкий еталонний об’єкт все ще живий, слід виконувати за "
"допомогою виразу ``ref() is not None``. Зазвичай код програми, який потребує "
"використання еталонного об’єкта, має відповідати такому шаблону:"

msgid ""
"Using a separate test for \"liveness\" creates race conditions in threaded "
"applications; another thread can cause a weak reference to become "
"invalidated before the weak reference is called; the idiom shown above is "
"safe in threaded applications as well as single-threaded applications."
msgstr ""
"Використання окремого тесту на \"жвавість\" створює умови гонки в потокових "
"програмах; інший потік може призвести до того, що слабке посилання стане "
"недійсним до виклику слабкого посилання; ідіома, показана вище, безпечна як "
"у багатопотокових програмах, так і в однопотокових програмах."

msgid ""
"Specialized versions of :class:`ref` objects can be created through "
"subclassing. This is used in the implementation of the :class:"
"`WeakValueDictionary` to reduce the memory overhead for each entry in the "
"mapping.  This may be most useful to associate additional information with a "
"reference, but could also be used to insert additional processing on calls "
"to retrieve the referent."
msgstr ""
"Спеціалізовані версії об’єктів :class:`ref` можна створити за допомогою "
"підкласів. Це використовується в реалізації :class:`WeakValueDictionary`, "
"щоб зменшити витрати пам’яті для кожного запису у відображенні. Це може бути "
"найбільш корисним для пов’язування додаткової інформації з посиланням, але "
"також може використовуватися для вставки додаткової обробки викликів для "
"отримання референту."

msgid ""
"This example shows how a subclass of :class:`ref` can be used to store "
"additional information about an object and affect the value that's returned "
"when the referent is accessed::"
msgstr ""
"У цьому прикладі показано, як підклас :class:`ref` можна використовувати для "
"зберігання додаткової інформації про об’єкт і впливу на значення, яке "
"повертається під час звернення до референта::"

msgid "Example"
msgstr "приклад"

msgid ""
"This simple example shows how an application can use object IDs to retrieve "
"objects that it has seen before.  The IDs of the objects can then be used in "
"other data structures without forcing the objects to remain alive, but the "
"objects can still be retrieved by ID if they do."
msgstr ""
"Цей простий приклад показує, як програма може використовувати ідентифікатори "
"об’єктів для отримання об’єктів, які вона бачила раніше. Потім "
"ідентифікатори об’єктів можна використовувати в інших структурах даних, не "
"змушуючи об’єкти залишатися живими, але об’єкти все одно можна отримати за "
"ідентифікатором, якщо вони це роблять."

msgid "Finalizer Objects"
msgstr "Об’єкти фіналізатора"

msgid ""
"The main benefit of using :class:`finalize` is that it makes it simple to "
"register a callback without needing to preserve the returned finalizer "
"object.  For instance"
msgstr ""
"Основна перевага використання :class:`finalize` полягає в тому, що це "
"спрощує реєстрацію зворотного виклику без необхідності зберігати повернутий "
"об’єкт фіналізатора. Наприклад"

msgid ""
"The finalizer can be called directly as well.  However the finalizer will "
"invoke the callback at most once."
msgstr ""
"Фіналізатор також можна викликати безпосередньо. Однак фіналізатор викличе "
"зворотний виклик щонайбільше один раз."

msgid ""
"You can unregister a finalizer using its :meth:`~finalize.detach` method.  "
"This kills the finalizer and returns the arguments passed to the constructor "
"when it was created."
msgstr ""
"Ви можете скасувати реєстрацію фіналізатора за допомогою його методу :meth:"
"`~finalize.detach`. Це вбиває фіналізатор і повертає аргументи, передані "
"конструктору під час його створення."

msgid ""
"Unless you set the :attr:`~finalize.atexit` attribute to :const:`False`, a "
"finalizer will be called when the program exits if it is still alive.  For "
"instance"
msgstr ""
"Якщо ви не встановили для атрибута :attr:`~finalize.atexit` значення :const:"
"`False`, фіналізатор буде викликаний під час завершення програми, якщо вона "
"все ще жива. Наприклад"

msgid "Comparing finalizers with :meth:`__del__` methods"
msgstr "Порівняння фіналізаторів із методами :meth:`__del__`"

msgid ""
"Suppose we want to create a class whose instances represent temporary "
"directories.  The directories should be deleted with their contents when the "
"first of the following events occurs:"
msgstr ""
"Припустимо, ми хочемо створити клас, екземпляри якого представляють "
"тимчасові каталоги. Каталоги мають бути видалені разом із їхнім вмістом, "
"коли станеться перша з наступних подій:"

msgid "the object is garbage collected,"
msgstr "об'єкт вивезено сміття,"

msgid "the object's :meth:`remove` method is called, or"
msgstr "викликається метод :meth:`remove` об’єкта або"

msgid "the program exits."
msgstr "програма виходить."

msgid ""
"We might try to implement the class using a :meth:`__del__` method as "
"follows::"
msgstr ""
"Ми можемо спробувати реалізувати клас за допомогою методу :meth:`__del__` "
"наступним чином:"

msgid ""
"Starting with Python 3.4, :meth:`__del__` methods no longer prevent "
"reference cycles from being garbage collected, and module globals are no "
"longer forced to :const:`None` during :term:`interpreter shutdown`. So this "
"code should work without any issues on CPython."
msgstr ""
"Починаючи з Python 3.4, методи :meth:`__del__` більше не перешкоджають "
"збиранню сміття для циклів посилань, а глобальні модулі більше не змушені :"
"const:`None` під час відключення інтерпретатора (:term:`interpreter "
"shutdown`). Таким чином, цей код повинен працювати без проблем на CPython."

msgid ""
"However, handling of :meth:`__del__` methods is notoriously implementation "
"specific, since it depends on internal details of the interpreter's garbage "
"collector implementation."
msgstr ""
"Однак обробка методів :meth:`__del__`, як відомо, залежить від реалізації, "
"оскільки залежить від внутрішніх деталей реалізації збирача сміття "
"інтерпретатора."

msgid ""
"A more robust alternative can be to define a finalizer which only references "
"the specific functions and objects that it needs, rather than having access "
"to the full state of the object::"
msgstr ""
"Більш надійною альтернативою може бути визначення фіналізатора, який "
"посилається лише на певні функції та об’єкти, які йому потрібні, а не має "
"доступу до повного стану об’єкта:"

msgid ""
"Defined like this, our finalizer only receives a reference to the details it "
"needs to clean up the directory appropriately. If the object never gets "
"garbage collected the finalizer will still be called at exit."
msgstr ""
"Визначений таким чином, наш фіналізатор отримує лише посилання на деталі, "
"необхідні для належного очищення каталогу. Якщо об’єкт ніколи не отримує "
"сміття, фіналізатор все одно буде викликаний при виході."

msgid ""
"The other advantage of weakref based finalizers is that they can be used to "
"register finalizers for classes where the definition is controlled by a "
"third party, such as running code when a module is unloaded::"
msgstr ""
"Інша перевага фіналізаторів на основі слабких рефлексів полягає в тому, що "
"їх можна використовувати для реєстрації фіналізаторів для класів, де "
"визначення контролює третя сторона, наприклад, запуск коду, коли модуль "
"вивантажується:"

msgid ""
"If you create a finalizer object in a daemonic thread just as the program "
"exits then there is the possibility that the finalizer does not get called "
"at exit.  However, in a daemonic thread :func:`atexit.register`, ``try: ... "
"finally: ...`` and ``with: ...`` do not guarantee that cleanup occurs either."
msgstr ""
"Якщо ви створюєте об’єкт фіналізатора в демонічному потоці саме під час "
"виходу з програми, тоді існує ймовірність того, що фіналізатор не буде "
"викликаний під час виходу. Однак у демонічному потоці :func:`atexit."
"register`, ``try: ... finally: ...`` і ``with: ...`` також не гарантують "
"виконання очищення."
