# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:03+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`dataclasses` --- Data Classes"
msgstr ":mod:`dataclasses` --- Класи даних"

msgid "**Source code:** :source:`Lib/dataclasses.py`"
msgstr "**Вихідний код:** :source:`Lib/dataclasses.py`"

msgid ""
"This module provides a decorator and functions for automatically adding "
"generated :term:`special method`\\s such as :meth:`__init__` and :meth:"
"`__repr__` to user-defined classes.  It was originally described in :pep:"
"`557`."
msgstr ""
"Цей модуль надає декоратор і функції для автоматичного додавання "
"згенерованих :term:`special method`\\, таких як :meth:`__init__` і :meth:"
"`__repr__` до визначених користувачем класів. Спочатку це було описано в :"
"pep:`557`."

msgid ""
"The member variables to use in these generated methods are defined using :"
"pep:`526` type annotations.  For example, this code::"
msgstr ""
"Змінні-члени для використання в цих згенерованих методах визначаються за "
"допомогою анотацій типу :pep:`526`. Наприклад, цей код::"

msgid "will add, among other things, a :meth:`__init__` that looks like::"
msgstr "додасть, серед іншого, :meth:`__init__`, який виглядає так::"

msgid ""
"Note that this method is automatically added to the class: it is not "
"directly specified in the ``InventoryItem`` definition shown above."
msgstr ""
"Зауважте, що цей метод автоматично додається до класу: він не вказано "
"безпосередньо у визначенні ``InventoryItem``, показаному вище."

msgid "Module contents"
msgstr "Зміст модуля"

msgid ""
"This function is a :term:`decorator` that is used to add generated :term:"
"`special method`\\s to classes, as described below."
msgstr ""
"Ця функція є :term:`decorator`, який використовується для додавання "
"згенерованих :term:`special method`\\ до класів, як описано нижче."

msgid ""
"The :func:`dataclass` decorator examines the class to find ``field``\\s.  A "
"``field`` is defined as a class variable that has a :term:`type annotation "
"<variable annotation>`.  With two exceptions described below, nothing in :"
"func:`dataclass` examines the type specified in the variable annotation."
msgstr ""
"Декоратор :func:`dataclass` перевіряє клас, щоб знайти ``поля`` \\s. "
"``Поле`` визначається як змінна класу, яка має :term:`анотацію типу "
"<variable annotation>`. За двома винятками, описаними нижче, нічого в :func:"
"`dataclass` не перевіряє тип, указаний в анотації змінної."

msgid ""
"The order of the fields in all of the generated methods is the order in "
"which they appear in the class definition."
msgstr ""
"Порядок полів у всіх згенерованих методах – це порядок, у якому вони "
"з’являються у визначенні класу."

msgid ""
"The :func:`dataclass` decorator will add various \"dunder\" methods to the "
"class, described below.  If any of the added methods already exist in the "
"class, the behavior depends on the parameter, as documented below. The "
"decorator returns the same class that it is called on; no new class is "
"created."
msgstr ""
"Декоратор :func:`dataclass` додасть різні методи \"dunder\" до класу, "
"описані нижче. Якщо будь-який із доданих методів уже існує в класі, "
"поведінка залежить від параметра, як описано нижче. Декоратор повертає той "
"самий клас, до якого він викликаний; новий клас не створюється."

msgid ""
"If :func:`dataclass` is used just as a simple decorator with no parameters, "
"it acts as if it has the default values documented in this signature.  That "
"is, these three uses of :func:`dataclass` are equivalent::"
msgstr ""
"Якщо :func:`dataclass` використовується просто як простий декоратор без "
"параметрів, він діє так, ніби має значення за замовчуванням, задокументовані "
"в цьому підписі. Тобто ці три способи використання :func:`dataclass` "
"еквівалентні:"

msgid "The parameters to :func:`dataclass` are:"
msgstr "Параметри :func:`dataclass`:"

msgid ""
"``init``: If true (the default), a :meth:`__init__` method will be generated."
msgstr ""
"``init``: Якщо true (за замовчуванням), буде згенеровано метод :meth:"
"`__init__`."

msgid ""
"If the class already defines :meth:`__init__`, this parameter is ignored."
msgstr "Якщо клас уже визначає :meth:`__init__`, цей параметр ігнорується."

msgid ""
"``repr``: If true (the default), a :meth:`__repr__` method will be "
"generated.  The generated repr string will have the class name and the name "
"and repr of each field, in the order they are defined in the class.  Fields "
"that are marked as being excluded from the repr are not included.  For "
"example: ``InventoryItem(name='widget', unit_price=3.0, "
"quantity_on_hand=10)``."
msgstr ""
"``repr``: Якщо true (за замовчуванням), буде згенеровано метод :meth:"
"`__repr__`. Згенерований рядок repr матиме назву класу, а також ім’я та repr "
"кожного поля в тому порядку, у якому вони визначені в класі. Поля, які "
"позначені як такі, що виключаються з відображення, не включені. Наприклад: "
"``InventoryItem(name='widget', unit_price=3.0, quantity_on_hand=10)``."

msgid ""
"If the class already defines :meth:`__repr__`, this parameter is ignored."
msgstr "Якщо клас уже визначає :meth:`__repr__`, цей параметр ігнорується."

msgid ""
"``eq``: If true (the default), an :meth:`__eq__` method will be generated.  "
"This method compares the class as if it were a tuple of its fields, in "
"order.  Both instances in the comparison must be of the identical type."
msgstr ""
"``eq``: Якщо true (за замовчуванням), буде згенеровано метод :meth:`__eq__`. "
"Цей метод порівнює клас так, ніби це кортеж його полів, по порядку. Обидва "
"екземпляри для порівняння мають бути однакового типу."

msgid "If the class already defines :meth:`__eq__`, this parameter is ignored."
msgstr "Якщо клас уже визначає :meth:`__eq__`, цей параметр ігнорується."

msgid ""
"``order``: If true (the default is ``False``), :meth:`__lt__`, :meth:"
"`__le__`, :meth:`__gt__`, and :meth:`__ge__` methods will be generated.  "
"These compare the class as if it were a tuple of its fields, in order.  Both "
"instances in the comparison must be of the identical type.  If ``order`` is "
"true and ``eq`` is false, a :exc:`ValueError` is raised."
msgstr ""
"``order``: якщо істина (за замовчуванням ``False``), методи :meth:`__lt__`, :"
"meth:`__le__`, :meth:`__gt__` і :meth:`__ge__` будуть створений. Вони "
"порівнюють клас так, ніби це кортеж його полів, по порядку. Обидва "
"екземпляри для порівняння мають бути однакового типу. Якщо ``order`` "
"істинне, а ``eq`` хибне, викликається :exc:`ValueError`."

msgid ""
"If the class already defines any of :meth:`__lt__`, :meth:`__le__`, :meth:"
"`__gt__`, or :meth:`__ge__`, then :exc:`TypeError` is raised."
msgstr ""
"Якщо клас уже визначає будь-який із :meth:`__lt__`, :meth:`__le__`, :meth:"
"`__gt__` або :meth:`__ge__`, тоді виникає :exc:`TypeError`."

msgid ""
"``unsafe_hash``: If ``False`` (the default), a :meth:`__hash__` method is "
"generated according to how ``eq`` and ``frozen`` are set."
msgstr ""
"``unsafe_hash``: якщо ``False`` (за замовчуванням), метод :meth:`__hash__` "
"генерується відповідно до того, як встановлено ``eq`` і ``frozen``."

msgid ""
":meth:`__hash__` is used by built-in :meth:`hash()`, and when objects are "
"added to hashed collections such as dictionaries and sets.  Having a :meth:"
"`__hash__` implies that instances of the class are immutable. Mutability is "
"a complicated property that depends on the programmer's intent, the "
"existence and behavior of :meth:`__eq__`, and the values of the ``eq`` and "
"``frozen`` flags in the :func:`dataclass` decorator."
msgstr ""
":meth:`__hash__` використовується вбудованим :meth:`hash()`, а також коли "
"об’єкти додаються до хешованих колекцій, таких як словники та набори. "
"Наявність :meth:`__hash__` означає, що екземпляри класу незмінні. Змінність "
"— це складна властивість, яка залежить від наміру програміста, існування та "
"поведінки :meth:`__eq__`, а також значень прапорів ``eq`` і ``frozen`` у "
"декораторі :func:`dataclass` ."

msgid ""
"By default, :func:`dataclass` will not implicitly add a :meth:`__hash__` "
"method unless it is safe to do so.  Neither will it add or change an "
"existing explicitly defined :meth:`__hash__` method.  Setting the class "
"attribute ``__hash__ = None`` has a specific meaning to Python, as described "
"in the :meth:`__hash__` documentation."
msgstr ""
"За замовчуванням :func:`dataclass` не буде неявно додавати метод :meth:"
"`__hash__`, якщо це безпечно. Він також не буде додавати або змінювати "
"існуючий явно визначений метод :meth:`__hash__`. Налаштування атрибута класу "
"``__hash__ = None`` має певне значення для Python, як описано в "
"документації :meth:`__hash__`."

msgid ""
"If :meth:`__hash__` is not explicitly defined, or if it is set to ``None``, "
"then :func:`dataclass` *may* add an implicit :meth:`__hash__` method. "
"Although not recommended, you can force :func:`dataclass` to create a :meth:"
"`__hash__` method with ``unsafe_hash=True``. This might be the case if your "
"class is logically immutable but can nonetheless be mutated. This is a "
"specialized use case and should be considered carefully."
msgstr ""
"Якщо :meth:`__hash__` не визначено явно або якщо для нього встановлено "
"значення ``None``, тоді :func:`dataclass` *може* додати неявний метод :meth:"
"`__hash__`. Хоча це не рекомендовано, ви можете змусити :func:`dataclass` "
"створити метод :meth:`__hash__` з ``unsafe_hash=True``. Це може бути у "
"випадку, якщо ваш клас є логічно незмінним, але його можна змінити. Це "
"спеціальний випадок використання, і його слід уважно розглянути."

msgid ""
"Here are the rules governing implicit creation of a :meth:`__hash__` "
"method.  Note that you cannot both have an explicit :meth:`__hash__` method "
"in your dataclass and set ``unsafe_hash=True``; this will result in a :exc:"
"`TypeError`."
msgstr ""
"Ось правила, що регулюють неявне створення методу :meth:`__hash__`. "
"Зауважте, що ви не можете одночасно мати явний метод :meth:`__hash__` у "
"своєму класі даних і встановити ``unsafe_hash=True``; це призведе до :exc:"
"`TypeError`."

msgid ""
"If ``eq`` and ``frozen`` are both true, by default :func:`dataclass` will "
"generate a :meth:`__hash__` method for you.  If ``eq`` is true and "
"``frozen`` is false, :meth:`__hash__` will be set to ``None``, marking it "
"unhashable (which it is, since it is mutable).  If ``eq`` is false, :meth:"
"`__hash__` will be left untouched meaning the :meth:`__hash__` method of the "
"superclass will be used (if the superclass is :class:`object`, this means it "
"will fall back to id-based hashing)."
msgstr ""
"Якщо ``eq`` і ``frozen`` обидва істинні, за замовчуванням :func:`dataclass` "
"створить для вас метод :meth:`__hash__`. Якщо ``eq`` має значення true, а "
"``frozen`` — false, :meth:`__hash__` буде встановлено на ``None``, "
"позначаючи його як нехешований (що й є, оскільки він змінний). Якщо ``eq`` "
"має значення false, :meth:`__hash__` залишиться недоторканим, що означає, що "
"буде використано метод :meth:`__hash__` суперкласу (якщо суперкласом є :"
"class:`object`, це означає, що він буде повернутися до хешування на основі "
"ідентифікатора)."

msgid ""
"``frozen``: If true (the default is ``False``), assigning to fields will "
"generate an exception.  This emulates read-only frozen instances.  If :meth:"
"`__setattr__` or :meth:`__delattr__` is defined in the class, then :exc:"
"`TypeError` is raised.  See the discussion below."
msgstr ""
"``frozen``: якщо true (за замовчуванням ``False``), присвоєння полям "
"створить виняток. Це емулює заморожені екземпляри лише для читання. Якщо :"
"meth:`__setattr__` або :meth:`__delattr__` визначено в класі, тоді виникає :"
"exc:`TypeError`. Дивіться обговорення нижче."

msgid ""
"``match_args``: If true (the default is ``True``), the ``__match_args__`` "
"tuple will be created from the list of parameters to the generated :meth:"
"`__init__` method (even if :meth:`__init__` is not generated, see above).  "
"If false, or if ``__match_args__`` is already defined in the class, then "
"``__match_args__`` will not be generated."
msgstr ""
"``match_args``: Якщо значення true (за замовчуванням ``True``), кортеж "
"``__match_args__`` буде створено зі списку параметрів для згенерованого "
"методу :meth:`__init__` (навіть якщо :meth:`__init__` не генерується, див. "
"вище). Якщо false або якщо ``__match_args__`` вже визначено в класі, то "
"``__match_args__`` не буде згенеровано."

msgid ""
"``kw_only``: If true (the default value is ``False``), then all fields will "
"be marked as keyword-only.  If a field is marked as keyword-only, then the "
"only effect is that the :meth:`__init__` parameter generated from a keyword-"
"only field must be specified with a keyword when :meth:`__init__` is "
"called.  There is no effect on any other aspect of dataclasses.  See the :"
"term:`parameter` glossary entry for details.  Also see the :const:`KW_ONLY` "
"section."
msgstr ""

msgid ""
"``slots``: If true (the default is ``False``), :attr:`__slots__` attribute "
"will be generated and new class will be returned instead of the original "
"one. If :attr:`__slots__` is already defined in the class, then :exc:"
"`TypeError` is raised."
msgstr ""
"``slots``: якщо істина (за замовчуванням ``False``), буде згенеровано "
"атрибут :attr:`__slots__` і буде повернено новий клас замість оригінального. "
"Якщо :attr:`__slots__` вже визначено в класі, тоді виникає :exc:`TypeError`."

msgid ""
"If a field name is already included in the ``__slots__`` of a base class, it "
"will not be included in the generated ``__slots__`` to prevent :ref:"
"`overriding them <datamodel-note-slots>`. Therefore, do not use "
"``__slots__`` to retrieve the field names of a dataclass. Use :func:`fields` "
"instead. To be able to determine inherited slots, base class ``__slots__`` "
"may be any iterable, but *not* an iterator."
msgstr ""

msgid ""
"``weakref_slot``: If true (the default is ``False``), add a slot named "
"\"__weakref__\", which is required to make an instance weakref-able.  It is "
"an error to specify ``weakref_slot=True`` without also specifying "
"``slots=True``."
msgstr ""

msgid ""
"``field``\\s may optionally specify a default value, using normal Python "
"syntax::"
msgstr ""
"``field``\\s може додатково вказати значення за замовчуванням, "
"використовуючи звичайний синтаксис Python:"

msgid ""
"In this example, both ``a`` and ``b`` will be included in the added :meth:"
"`__init__` method, which will be defined as::"
msgstr ""
"У цьому прикладі як ``a``, так і ``b`` будуть включені в доданий метод :meth:"
"`__init__`, який буде визначено як::"

msgid ""
":exc:`TypeError` will be raised if a field without a default value follows a "
"field with a default value.  This is true whether this occurs in a single "
"class, or as a result of class inheritance."
msgstr ""
":exc:`TypeError` буде викликано, якщо поле без значення за замовчуванням "
"слідує за полем зі значенням за замовчуванням. Це вірно незалежно від того, "
"чи відбувається це в одному класі, чи в результаті успадкування класу."

msgid ""
"For common and simple use cases, no other functionality is required.  There "
"are, however, some dataclass features that require additional per-field "
"information.  To satisfy this need for additional information, you can "
"replace the default field value with a call to the provided :func:`field` "
"function.  For example::"
msgstr ""
"Для звичайних і простих випадків використання інші функції не потрібні. "
"Однак існують деякі функції класу даних, які потребують додаткової "
"інформації для кожного поля. Щоб задовольнити цю потребу в додатковій "
"інформації, ви можете замінити значення поля за замовчуванням викликом "
"наданої функції :func:`field`. Наприклад::"

msgid ""
"As shown above, the :const:`MISSING` value is a sentinel object used to "
"detect if some parameters are provided by the user. This sentinel is used "
"because ``None`` is a valid value for some parameters with a distinct "
"meaning.  No code should directly use the :const:`MISSING` value."
msgstr ""
"Як показано вище, значення :const:`MISSING` є дозорним об’єктом, який "
"використовується для визначення того, чи деякі параметри надає користувач. "
"Цей контрольний сигнал використовується, оскільки ``None`` є дійсним "
"значенням для деяких параметрів з чітким значенням. Жоден код не повинен "
"безпосередньо використовувати значення :const:`MISSING`."

msgid "The parameters to :func:`field` are:"
msgstr "Параметри :func:`field` такі:"

msgid ""
"``default``: If provided, this will be the default value for this field.  "
"This is needed because the :meth:`field` call itself replaces the normal "
"position of the default value."
msgstr ""
"``default``: якщо вказано, це буде значення за замовчуванням для цього поля. "
"Це необхідно, оскільки сам виклик :meth:`field` замінює звичайну позицію "
"значення за замовчуванням."

msgid ""
"``default_factory``: If provided, it must be a zero-argument callable that "
"will be called when a default value is needed for this field.  Among other "
"purposes, this can be used to specify fields with mutable default values, as "
"discussed below.  It is an error to specify both ``default`` and "
"``default_factory``."
msgstr ""
"``default_factory``: якщо вказано, це має бути функція виклику з нульовим "
"аргументом, яка буде викликана, коли для цього поля потрібне значення за "
"замовчуванням. Серед інших цілей це можна використовувати для визначення "
"полів зі змінними значеннями за замовчуванням, як обговорюється нижче. "
"Помилково вказувати як ``default``, так і ``default_factory``."

msgid ""
"``init``: If true (the default), this field is included as a parameter to "
"the generated :meth:`__init__` method."
msgstr ""
"``init``: Якщо true (за замовчуванням), це поле включено як параметр до "
"створеного методу :meth:`__init__`."

msgid ""
"``repr``: If true (the default), this field is included in the string "
"returned by the generated :meth:`__repr__` method."
msgstr ""
"``repr``: Якщо true (за замовчуванням), це поле включено в рядок, який "
"повертає згенерований метод :meth:`__repr__`."

msgid ""
"``hash``: This can be a bool or ``None``.  If true, this field is included "
"in the generated :meth:`__hash__` method.  If ``None`` (the default), use "
"the value of ``compare``: this would normally be the expected behavior.  A "
"field should be considered in the hash if it's used for comparisons.  "
"Setting this value to anything other than ``None`` is discouraged."
msgstr ""
"``хеш``: Це може бути логічне значення або ``None``. Якщо значення true, це "
"поле буде включено до згенерованого методу :meth:`__hash__`. Якщо ``None`` "
"(за замовчуванням), використовуйте значення ``compare``: зазвичай це буде "
"очікувана поведінка. Поле слід враховувати в хеші, якщо воно "
"використовується для порівнянь. Не рекомендується встановлювати для цього "
"значення будь-яке значення, окрім ``None``."

msgid ""
"One possible reason to set ``hash=False`` but ``compare=True`` would be if a "
"field is expensive to compute a hash value for, that field is needed for "
"equality testing, and there are other fields that contribute to the type's "
"hash value.  Even if a field is excluded from the hash, it will still be "
"used for comparisons."
msgstr ""
"Однією з можливих причин встановити ``hash=False``, але ``compare=True`` "
"було б, якщо поле є дорогим для обчислення хеш-значення, це поле потрібне "
"для перевірки рівності, і є інші поля, які сприяють хеш-значення типу. "
"Навіть якщо поле виключено з хешу, воно все одно використовуватиметься для "
"порівнянь."

msgid ""
"``compare``: If true (the default), this field is included in the generated "
"equality and comparison methods (:meth:`__eq__`, :meth:`__gt__`, et al.)."
msgstr ""
"``compare``: якщо true (за замовчуванням), це поле включено до згенерованих "
"методів рівності та порівняння (:meth:`__eq__`, :meth:`__gt__` та ін.)."

msgid ""
"``metadata``: This can be a mapping or None. None is treated as an empty "
"dict.  This value is wrapped in :func:`~types.MappingProxyType` to make it "
"read-only, and exposed on the :class:`Field` object. It is not used at all "
"by Data Classes, and is provided as a third-party extension mechanism. "
"Multiple third-parties can each have their own key, to use as a namespace in "
"the metadata."
msgstr ""
"``метадані``: це може бути відображення або немає. None не розглядається як "
"порожній dict. Це значення загорнуте в :func:`~types.MappingProxyType`, щоб "
"зробити його доступним лише для читання, і відображатиметься в об’єкті :"
"class:`Field`. Він взагалі не використовується класами даних і надається як "
"сторонній механізм розширення. Кілька сторонніх розробників можуть мати "
"власний ключ, який можна використовувати як простір імен у метаданих."

msgid ""
"``kw_only``: If true, this field will be marked as keyword-only. This is "
"used when the generated :meth:`__init__` method's parameters are computed."
msgstr ""
"``kw_only``: якщо істина, це поле буде позначено як лише ключове слово. Це "
"використовується, коли обчислюються параметри згенерованого методу :meth:"
"`__init__`."

msgid ""
"If the default value of a field is specified by a call to :func:`field()`, "
"then the class attribute for this field will be replaced by the specified "
"``default`` value.  If no ``default`` is provided, then the class attribute "
"will be deleted.  The intent is that after the :func:`dataclass` decorator "
"runs, the class attributes will all contain the default values for the "
"fields, just as if the default value itself were specified.  For example, "
"after::"
msgstr ""
"Якщо значення поля за замовчуванням вказано викликом :func:`field()`, тоді "
"атрибут класу для цього поля буде замінено вказаним значенням ``default``. "
"Якщо ``default`` не вказано, тоді атрибут класу буде видалено. Намір полягає "
"в тому, що після запуску декоратора :func:`dataclass` всі атрибути класу "
"будуть містити значення за замовчуванням для полів, так само, якби було "
"вказано саме значення за замовчуванням. Наприклад, після::"

msgid ""
"The class attribute ``C.z`` will be ``10``, the class attribute ``C.t`` will "
"be ``20``, and the class attributes ``C.x`` and ``C.y`` will not be set."
msgstr ""
"Атрибут класу ``C.z`` буде ``10``, атрибут класу ``C.t`` буде ``20``, а "
"атрибути класу ``C.x`` і ``C.y`` не будуть встановити."

msgid ""
":class:`Field` objects describe each defined field. These objects are "
"created internally, and are returned by the :func:`fields` module-level "
"method (see below).  Users should never instantiate a :class:`Field` object "
"directly.  Its documented attributes are:"
msgstr ""
"Об'єкти :class:`Field` описують кожне визначене поле. Ці об’єкти створюються "
"всередині та повертаються методом рівня модуля :func:`fields` (див. нижче). "
"Користувачі ніколи не повинні створювати об’єкт :class:`Field` "
"безпосередньо. Його задокументовані атрибути:"

msgid "``name``: The name of the field."
msgstr "``name``: назва поля."

msgid "``type``: The type of the field."
msgstr "``type``: тип поля."

msgid ""
"``default``, ``default_factory``, ``init``, ``repr``, ``hash``, ``compare``, "
"``metadata``, and ``kw_only`` have the identical meaning and values as they "
"do in the :func:`field` function."
msgstr ""
"``default``, ``default_factory``, ``init``, ``repr``, ``hash``, ``compare``, "
"``metadata`` і ``kw_only`` мають ідентичне значення та значення, як і у "
"функції :func:`field`."

msgid ""
"Other attributes may exist, but they are private and must not be inspected "
"or relied on."
msgstr ""
"Інші атрибути можуть існувати, але вони є приватними, і їх не можна "
"перевіряти чи покладатися на них."

msgid ""
"Returns a tuple of :class:`Field` objects that define the fields for this "
"dataclass.  Accepts either a dataclass, or an instance of a dataclass. "
"Raises :exc:`TypeError` if not passed a dataclass or instance of one. Does "
"not return pseudo-fields which are ``ClassVar`` or ``InitVar``."
msgstr ""
"Повертає кортеж об’єктів :class:`Field`, які визначають поля для цього класу "
"даних. Приймає або клас даних, або екземпляр класу даних. Викликає :exc:"
"`TypeError`, якщо не передано клас даних або його екземпляр. Не повертає "
"псевдополя, які є ``ClassVar`` або ``InitVar``."

msgid ""
"Converts the dataclass ``obj`` to a dict (by using the factory function "
"``dict_factory``).  Each dataclass is converted to a dict of its fields, as "
"``name: value`` pairs.  dataclasses, dicts, lists, and tuples are recursed "
"into.  Other objects are copied with :func:`copy.deepcopy`."
msgstr ""
"Перетворює клас даних ``obj`` на dict (за допомогою фабричної функції "
"``dict_factory``). Кожен клас даних перетворюється на диктофон своїх полів у "
"вигляді пар \"ім’я: значення\". класи даних, диктофони, списки та кортежі "
"рекурсують. Інші об’єкти копіюються за допомогою :func:`copy.deepcopy`."

msgid "Example of using :func:`asdict` on nested dataclasses::"
msgstr "Приклад використання :func:`asdict` у вкладених класах даних::"

msgid "To create a shallow copy, the following workaround may be used::"
msgstr "Щоб створити дрібну копію, можна використати такий обхідний шлях:"

msgid ""
":func:`asdict` raises :exc:`TypeError` if ``obj`` is not a dataclass "
"instance."
msgstr ""
":func:`asdict` викликає :exc:`TypeError`, якщо ``obj`` не є екземпляром "
"класу даних."

msgid ""
"Converts the dataclass ``obj`` to a tuple (by using the factory function "
"``tuple_factory``).  Each dataclass is converted to a tuple of its field "
"values.  dataclasses, dicts, lists, and tuples are recursed into. Other "
"objects are copied with :func:`copy.deepcopy`."
msgstr ""
"Перетворює клас даних ``obj`` на кортеж (за допомогою фабричної функції "
"``tuple_factory``). Кожен клас даних перетворюється на кортеж значень свого "
"поля. класи даних, диктофони, списки та кортежі рекурсують. Інші об’єкти "
"копіюються за допомогою :func:`copy.deepcopy`."

msgid "Continuing from the previous example::"
msgstr "Продовжуючи попередній приклад:"

msgid ""
":func:`astuple` raises :exc:`TypeError` if ``obj`` is not a dataclass "
"instance."
msgstr ""
":func:`astuple` викликає :exc:`TypeError`, якщо ``obj`` не є екземпляром "
"класу даних."

msgid ""
"Creates a new dataclass with name ``cls_name``, fields as defined in "
"``fields``, base classes as given in ``bases``, and initialized with a "
"namespace as given in ``namespace``.  ``fields`` is an iterable whose "
"elements are each either ``name``, ``(name, type)``, or ``(name, type, "
"Field)``.  If just ``name`` is supplied, ``typing.Any`` is used for "
"``type``.  The values of ``init``, ``repr``, ``eq``, ``order``, "
"``unsafe_hash``, ``frozen``, ``match_args``, ``kw_only``, ``slots``, and "
"``weakref_slot`` have the same meaning as they do in :func:`dataclass`."
msgstr ""

msgid ""
"This function is not strictly required, because any Python mechanism for "
"creating a new class with ``__annotations__`` can then apply the :func:"
"`dataclass` function to convert that class to a dataclass.  This function is "
"provided as a convenience.  For example::"
msgstr ""
"Ця функція не є обов’язковою, оскільки будь-який механізм Python для "
"створення нового класу з ``__annotations__`` може потім застосувати функцію :"
"func:`dataclass` для перетворення цього класу на клас даних. Ця функція "
"передбачена для зручності. Наприклад::"

msgid "Is equivalent to::"
msgstr "Еквівалентно::"

msgid ""
"Creates a new object of the same type as ``obj``, replacing fields with "
"values from ``changes``.  If ``obj`` is not a Data Class, raises :exc:"
"`TypeError`.  If values in ``changes`` do not specify fields, raises :exc:"
"`TypeError`."
msgstr ""
"Створює новий об’єкт того самого типу, що й ``obj``, замінюючи поля "
"значеннями ``changes``. Якщо ``obj`` не є класом даних, викликає :exc:"
"`TypeError`. Якщо значення в ``changes`` не вказують на поля, викликає :exc:"
"`TypeError`."

msgid ""
"The newly returned object is created by calling the :meth:`__init__` method "
"of the dataclass.  This ensures that :meth:`__post_init__`, if present, is "
"also called."
msgstr ""
"Щойно повернутий об’єкт створюється шляхом виклику методу :meth:`__init__` "
"класу даних. Це гарантує, що :meth:`__post_init__`, якщо він присутній, "
"також викликається."

msgid ""
"Init-only variables without default values, if any exist, must be specified "
"on the call to :func:`replace` so that they can be passed to :meth:"
"`__init__` and :meth:`__post_init__`."
msgstr ""
"Змінні лише для ініціалізації без значень за замовчуванням, якщо такі "
"існують, необхідно вказати під час виклику :func:`replace`, щоб їх можна "
"було передати в :meth:`__init__` і :meth:`__post_init__`."

msgid ""
"It is an error for ``changes`` to contain any fields that are defined as "
"having ``init=False``.  A :exc:`ValueError` will be raised in this case."
msgstr ""
"Це помилка, якщо ``changes`` містить будь-які поля, які визначені як такі, "
"що мають ``init=False``. У цьому випадку буде викликано помилку :exc:"
"`ValueError`."

msgid ""
"Be forewarned about how ``init=False`` fields work during a call to :func:"
"`replace`.  They are not copied from the source object, but rather are "
"initialized in :meth:`__post_init__`, if they're initialized at all.  It is "
"expected that ``init=False`` fields will be rarely and judiciously used.  If "
"they are used, it might be wise to have alternate class constructors, or "
"perhaps a custom ``replace()`` (or similarly named) method which handles "
"instance copying."
msgstr ""
"Будьте попереджені про те, як працюють поля ``init=False`` під час виклику :"
"func:`replace`. Вони не копіюються з вихідного об’єкта, а ініціалізуються в :"
"meth:`__post_init__`, якщо вони взагалі ініціалізовані. Очікується, що поля "
"``init=False`` будуть використовуватися рідко та розумно. Якщо вони "
"використовуються, було б доцільно мати альтернативні конструктори класів "
"або, можливо, спеціальний метод ``replace()`` (або з подібною назвою), який "
"обробляє копіювання екземплярів."

msgid ""
"Return ``True`` if its parameter is a dataclass or an instance of one, "
"otherwise return ``False``."
msgstr ""
"Повертає ``True``, якщо його параметр є класом даних або його екземпляром, "
"інакше повертає ``False``."

msgid ""
"If you need to know if a class is an instance of a dataclass (and not a "
"dataclass itself), then add a further check for ``not isinstance(obj, "
"type)``::"
msgstr ""
"Якщо вам потрібно знати, чи є клас екземпляром класу даних (а не самим "
"класом даних), тоді додайте додаткову перевірку для ``not isinstance(obj, "
"type)``::"

msgid "A sentinel value signifying a missing default or default_factory."
msgstr ""
"Дозорне значення, яке вказує на відсутність параметра default або "
"default_factory."

msgid ""
"A sentinel value used as a type annotation.  Any fields after a pseudo-field "
"with the type of :const:`KW_ONLY` are marked as keyword-only fields.  Note "
"that a pseudo-field of type :const:`KW_ONLY` is otherwise completely "
"ignored.  This includes the name of such a field.  By convention, a name of "
"``_`` is used for a :const:`KW_ONLY` field.  Keyword-only fields signify :"
"meth:`__init__` parameters that must be specified as keywords when the class "
"is instantiated."
msgstr ""
"Дозорне значення, яке використовується як анотація типу. Будь-які поля після "
"псевдополя з типом :const:`KW_ONLY` позначаються як поля лише для ключових "
"слів. Зауважте, що псевдополе типу :const:`KW_ONLY` інакше повністю "
"ігнорується. Це включає назву такого поля. Згідно з угодою, ім’я ``_`` "
"використовується для поля :const:`KW_ONLY`. Поля лише для ключових слів "
"означають параметри :meth:`__init__`, які мають бути вказані як ключові "
"слова під час створення екземпляра класу."

msgid ""
"In this example, the fields ``y`` and ``z`` will be marked as keyword-only "
"fields::"
msgstr ""
"У цьому прикладі поля ``y`` і ``z`` будуть позначені як поля лише для "
"ключових слів:"

msgid ""
"In a single dataclass, it is an error to specify more than one field whose "
"type is :const:`KW_ONLY`."
msgstr ""
"В одному класі даних є помилкою вказувати більше ніж одне поле типу :const:"
"`KW_ONLY`."

msgid ""
"Raised when an implicitly defined :meth:`__setattr__` or :meth:`__delattr__` "
"is called on a dataclass which was defined with ``frozen=True``. It is a "
"subclass of :exc:`AttributeError`."
msgstr ""
"Викликається, коли неявно визначений :meth:`__setattr__` або :meth:"
"`__delattr__` викликається в класі даних, який був визначений як "
"``frozen=True``. Це підклас :exc:`AttributeError`."

msgid "Post-init processing"
msgstr "Обробка після ініціалізації"

msgid ""
"The generated :meth:`__init__` code will call a method named :meth:"
"`__post_init__`, if :meth:`__post_init__` is defined on the class.  It will "
"normally be called as ``self.__post_init__()``. However, if any ``InitVar`` "
"fields are defined, they will also be passed to :meth:`__post_init__` in the "
"order they were defined in the class.  If no :meth:`__init__` method is "
"generated, then :meth:`__post_init__` will not automatically be called."
msgstr ""
"Згенерований код :meth:`__init__` викличе метод з назвою :meth:"
"`__post_init__`, якщо :meth:`__post_init__` визначено в класі. Зазвичай він "
"буде називатися ``self.__post_init__()``. Однак, якщо визначено будь-які "
"поля ``InitVar``, вони також будуть передані в :meth:`__post_init__` в тому "
"порядку, в якому вони були визначені в класі. Якщо метод :meth:`__init__` не "
"створено, то :meth:`__post_init__` не буде викликатися автоматично."

msgid ""
"Among other uses, this allows for initializing field values that depend on "
"one or more other fields.  For example::"
msgstr ""
"Серед іншого використання це дозволяє ініціалізувати значення полів, які "
"залежать від одного або кількох інших полів. Наприклад::"

msgid ""
"The :meth:`__init__` method generated by :func:`dataclass` does not call "
"base class :meth:`__init__` methods. If the base class has an :meth:"
"`__init__` method that has to be called, it is common to call this method in "
"a :meth:`__post_init__` method::"
msgstr ""
"Метод :meth:`__init__`, створений :func:`dataclass`, не викликає методів "
"базового класу :meth:`__init__`. Якщо базовий клас має метод :meth:"
"`__init__`, який потрібно викликати, зазвичай цей метод викликається в "
"методі :meth:`__post_init__`::"

msgid ""
"Note, however, that in general the dataclass-generated :meth:`__init__` "
"methods don't need to be called, since the derived dataclass will take care "
"of initializing all fields of any base class that is a dataclass itself."
msgstr ""
"Однак зауважте, що загалом згенеровані класом даних методи :meth:`__init__` "
"не потрібно викликати, оскільки похідний клас даних подбає про ініціалізацію "
"всіх полів будь-якого базового класу, який сам є класом даних."

msgid ""
"See the section below on init-only variables for ways to pass parameters to :"
"meth:`__post_init__`.  Also see the warning about how :func:`replace` "
"handles ``init=False`` fields."
msgstr ""
"Перегляньте розділ нижче про змінні лише для ініціалізації, щоб дізнатися "
"про способи передачі параметрів у :meth:`__post_init__`. Також перегляньте "
"попередження про те, як :func:`replace` обробляє поля ``init=False``."

msgid "Class variables"
msgstr "Змінні класу"

msgid ""
"One of two places where :func:`dataclass` actually inspects the type of a "
"field is to determine if a field is a class variable as defined in :pep:"
"`526`.  It does this by checking if the type of the field is ``typing."
"ClassVar``.  If a field is a ``ClassVar``, it is excluded from consideration "
"as a field and is ignored by the dataclass mechanisms.  Such ``ClassVar`` "
"pseudo-fields are not returned by the module-level :func:`fields` function."
msgstr ""
"Одним із двох місць, де :func:`dataclass` фактично перевіряє тип поля, є "
"визначення того, чи поле є змінною класу, як визначено в :pep:`526`. Він "
"робить це, перевіряючи, чи є тип поля ``typing.ClassVar``. Якщо поле є "
"``ClassVar``, воно виключається з розгляду як поле та ігнорується "
"механізмами класу даних. Такі псевдополя ``ClassVar`` не повертаються "
"функцією :func:`fields` рівня модуля."

msgid "Init-only variables"
msgstr "Змінні лише для ініціалізації"

msgid ""
"The other place where :func:`dataclass` inspects a type annotation is to "
"determine if a field is an init-only variable.  It does this by seeing if "
"the type of a field is of type ``dataclasses.InitVar``.  If a field is an "
"``InitVar``, it is considered a pseudo-field called an init-only field.  As "
"it is not a true field, it is not returned by the module-level :func:"
"`fields` function.  Init-only fields are added as parameters to the "
"generated :meth:`__init__` method, and are passed to the optional :meth:"
"`__post_init__` method.  They are not otherwise used by dataclasses."
msgstr ""
"Інше місце, де :func:`dataclass` перевіряє анотацію типу, — це визначити, чи "
"є поле змінною лише для ініціалізації. Він робить це, переглядаючи, чи тип "
"поля має тип ``dataclasses.InitVar``. Якщо поле є ``InitVar``, воно "
"вважається псевдополем, яке називається полем тільки ініціалізації. Оскільки "
"це не справжнє поле, воно не повертається функцією рівня модуля :func:"
"`fields`. Поля лише для ініціалізації додаються як параметри до створеного "
"методу :meth:`__init__` і передаються до додаткового методу :meth:"
"`__post_init__`. Вони не використовуються класами даних."

msgid ""
"For example, suppose a field will be initialized from a database, if a value "
"is not provided when creating the class::"
msgstr ""
"Наприклад, припустимо, що поле буде ініціалізовано з бази даних, якщо під "
"час створення класу не вказано значення::"

msgid ""
"In this case, :func:`fields` will return :class:`Field` objects for ``i`` "
"and ``j``, but not for ``database``."
msgstr ""
"У цьому випадку :func:`fields` повертатиме об’єкти :class:`Field` для ``i`` "
"та ``j``, але не для ``database``."

msgid "Frozen instances"
msgstr "Заморожені екземпляри"

msgid ""
"It is not possible to create truly immutable Python objects.  However, by "
"passing ``frozen=True`` to the :meth:`dataclass` decorator you can emulate "
"immutability.  In that case, dataclasses will add :meth:`__setattr__` and :"
"meth:`__delattr__` methods to the class.  These methods will raise a :exc:"
"`FrozenInstanceError` when invoked."
msgstr ""
"Неможливо створити справді незмінні об’єкти Python. Однак, передавши "
"``frozen=True`` декоратору :meth:`dataclass`, ви можете емулювати "
"незмінність. У цьому випадку класи даних додадуть до класу методи :meth:"
"`__setattr__` і :meth:`__delattr__`. Ці методи викликають помилку :exc:"
"`FrozenInstanceError` під час виклику."

msgid ""
"There is a tiny performance penalty when using ``frozen=True``: :meth:"
"`__init__` cannot use simple assignment to initialize fields, and must use :"
"meth:`object.__setattr__`."
msgstr ""
"Під час використання ``frozen=True`` є невелике зниження продуктивності: :"
"meth:`__init__` не може використовувати просте призначення для ініціалізації "
"полів і має використовувати :meth:`object.__setattr__`."

msgid "Inheritance"
msgstr "Спадщина"

msgid ""
"When the dataclass is being created by the :meth:`dataclass` decorator, it "
"looks through all of the class's base classes in reverse MRO (that is, "
"starting at :class:`object`) and, for each dataclass that it finds, adds the "
"fields from that base class to an ordered mapping of fields. After all of "
"the base class fields are added, it adds its own fields to the ordered "
"mapping.  All of the generated methods will use this combined, calculated "
"ordered mapping of fields.  Because the fields are in insertion order, "
"derived classes override base classes.  An example::"
msgstr ""
"Коли клас даних створюється декоратором :meth:`dataclass`, він переглядає "
"всі базові класи класу в зворотному MRO (тобто починаючи з :class:`object`) "
"і для кожного класу даних, який він знаходить, додає поля з цього базового "
"класу до впорядкованого відображення полів. Після додавання всіх полів "
"базового класу він додає власні поля до впорядкованого відображення. Усі "
"згенеровані методи використовуватимуть це комбіноване обчислене впорядковане "
"відображення полів. Оскільки поля розташовані в порядку вставки, похідні "
"класи замінюють базові класи. Приклад::"

msgid ""
"The final list of fields is, in order, ``x``, ``y``, ``z``.  The final type "
"of ``x`` is ``int``, as specified in class ``C``."
msgstr ""
"Остаточний список полів у такому порядку: ``x``, ``y``, ``z``. Остаточним "
"типом ``x`` є ``int``, як зазначено в класі ``C``."

msgid "The generated :meth:`__init__` method for ``C`` will look like::"
msgstr "Згенерований метод :meth:`__init__` для ``C`` виглядатиме так:"

msgid "Re-ordering of keyword-only parameters in :meth:`__init__`"
msgstr "Перевпорядкування параметрів лише для ключових слів у :meth:`__init__`"

msgid ""
"After the parameters needed for :meth:`__init__` are computed, any keyword-"
"only parameters are moved to come after all regular (non-keyword-only) "
"parameters.  This is a requirement of how keyword-only parameters are "
"implemented in Python: they must come after non-keyword-only parameters."
msgstr ""
"Після обчислення параметрів, необхідних для :meth:`__init__`, будь-які "
"параметри, які містять лише ключові слова, переміщуються після всіх "
"звичайних параметрів (не лише ключових слів). Це вимога до того, як "
"параметри, що містять лише ключові слова, реалізовані в Python: вони мають "
"бути після параметрів, які не містять лише ключових слів."

msgid ""
"In this example, ``Base.y``, ``Base.w``, and ``D.t`` are keyword-only "
"fields, and ``Base.x`` and ``D.z`` are regular fields::"
msgstr ""
"У цьому прикладі ``Base.y``, ``Base.w`` і ``D.t`` є полями лише для ключових "
"слів, а ``Base.x`` і ``D.z`` є звичайними полями: :"

msgid "The generated :meth:`__init__` method for ``D`` will look like::"
msgstr "Згенерований метод :meth:`__init__` для ``D`` виглядатиме так:"

msgid ""
"Note that the parameters have been re-ordered from how they appear in the "
"list of fields: parameters derived from regular fields are followed by "
"parameters derived from keyword-only fields."
msgstr ""
"Зауважте, що порядок параметрів змінено відповідно до того, як вони "
"відображаються в списку полів: за параметрами, отриманими зі звичайних "
"полів, слідують параметри, отримані з полів лише з ключовими словами."

msgid ""
"The relative ordering of keyword-only parameters is maintained in the re-"
"ordered :meth:`__init__` parameter list."
msgstr ""
"Відносний порядок параметрів лише за ключовими словами зберігається в "
"перевпорядкованому списку параметрів :meth:`__init__`."

msgid "Default factory functions"
msgstr "Стандартні заводські функції"

msgid ""
"If a :func:`field` specifies a ``default_factory``, it is called with zero "
"arguments when a default value for the field is needed.  For example, to "
"create a new instance of a list, use::"
msgstr ""
"Якщо :func:`field` визначає ``default_factory``, воно викликається з "
"нульовими аргументами, коли потрібне значення за замовчуванням для поля. "
"Наприклад, щоб створити новий екземпляр списку, використовуйте::"

msgid ""
"If a field is excluded from :meth:`__init__` (using ``init=False``) and the "
"field also specifies ``default_factory``, then the default factory function "
"will always be called from the generated :meth:`__init__` function.  This "
"happens because there is no other way to give the field an initial value."
msgstr ""
"Якщо поле виключено з :meth:`__init__` (за допомогою ``init=False``) і в "
"полі також зазначено ``default_factory``, тоді фабрична функція за "
"замовчуванням завжди буде викликатися зі згенерованого :meth:`__init__` "
"функція. Це відбувається тому, що немає іншого способу надати полю початкове "
"значення."

msgid "Mutable default values"
msgstr "Змінні значення за замовчуванням"

msgid ""
"Python stores default member variable values in class attributes. Consider "
"this example, not using dataclasses::"
msgstr ""
"Python зберігає значення змінних членів за замовчуванням в атрибутах класу. "
"Розглянемо цей приклад, не використовуючи класи даних::"

msgid ""
"Note that the two instances of class ``C`` share the same class variable "
"``x``, as expected."
msgstr ""
"Зауважте, що два екземпляри класу ``C`` спільно використовують ту саму "
"змінну класу ``x``, як і очікувалося."

msgid "Using dataclasses, *if* this code was valid::"
msgstr "Використання класів даних, *якщо* цей код дійсний::"

msgid "it would generate code similar to::"
msgstr "це створить код, подібний до::"

msgid ""
"This has the same issue as the original example using class ``C``. That is, "
"two instances of class ``D`` that do not specify a value for ``x`` when "
"creating a class instance will share the same copy of ``x``.  Because "
"dataclasses just use normal Python class creation they also share this "
"behavior.  There is no general way for Data Classes to detect this "
"condition.  Instead, the :func:`dataclass` decorator will raise a :exc:"
"`TypeError` if it detects an unhashable default parameter.  The assumption "
"is that if a value is unhashable, it is mutable.  This is a partial "
"solution, but it does protect against many common errors."
msgstr ""

msgid ""
"Using default factory functions is a way to create new instances of mutable "
"types as default values for fields::"
msgstr ""
"Використання заводських функцій за замовчуванням — це спосіб створення нових "
"екземплярів змінних типів як значень за замовчуванням для полів::"

msgid ""
"Instead of looking for and disallowing objects of type ``list``, ``dict``, "
"or ``set``, unhashable objects are now not allowed as default values.  "
"Unhashability is used to approximate mutability."
msgstr ""

msgid "Descriptor-typed fields"
msgstr ""

msgid ""
"Fields that are assigned :ref:`descriptor objects <descriptors>` as their "
"default value have the following special behaviors:"
msgstr ""

msgid ""
"The value for the field passed to the dataclass's ``__init__`` method is "
"passed to the descriptor's ``__set__`` method rather than overwriting the "
"descriptor object."
msgstr ""

msgid ""
"Similarly, when getting or setting the field, the descriptor's ``__get__`` "
"or ``__set__`` method is called rather than returning or overwriting the "
"descriptor object."
msgstr ""

msgid ""
"To determine whether a field contains a default value, ``dataclasses`` will "
"call the descriptor's ``__get__`` method using its class access form (i.e. "
"``descriptor.__get__(obj=None, type=cls)``.  If the descriptor returns a "
"value in this case, it will be used as the field's default. On the other "
"hand, if the descriptor raises :exc:`AttributeError` in this situation, no "
"default value will be provided for the field."
msgstr ""

msgid ""
"Note that if a field is annotated with a descriptor type, but is not "
"assigned a descriptor object as its default value, the field will act like a "
"normal field."
msgstr ""
