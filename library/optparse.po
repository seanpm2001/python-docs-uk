# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:10+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`optparse` --- Parser for command line options"
msgstr ":mod:`optparse` --- Парсер параметрів командного рядка"

msgid "**Source code:** :source:`Lib/optparse.py`"
msgstr "**Вихідний код:** :source:`Lib/optparse.py`"

msgid ""
"The :mod:`optparse` module is deprecated and will not be developed further; "
"development will continue with the :mod:`argparse` module."
msgstr ""
"Модуль :mod:`optparse` застарів і не розроблятиметься надалі; розробка "
"продовжиться з модулем :mod:`argparse`."

msgid ""
":mod:`optparse` is a more convenient, flexible, and powerful library for "
"parsing command-line options than the old :mod:`getopt` module.  :mod:"
"`optparse` uses a more declarative style of command-line parsing: you create "
"an instance of :class:`OptionParser`, populate it with options, and parse "
"the command line. :mod:`optparse` allows users to specify options in the "
"conventional GNU/POSIX syntax, and additionally generates usage and help "
"messages for you."
msgstr ""
":mod:`optparse` — це більш зручна, гнучка та потужна бібліотека для аналізу "
"параметрів командного рядка, ніж старий модуль :mod:`getopt`. :mod:"
"`optparse` використовує більш декларативний стиль аналізу командного рядка: "
"ви створюєте екземпляр :class:`OptionParser`, заповнюєте його параметрами та "
"аналізуєте командний рядок. :mod:`optparse` дозволяє користувачам вказувати "
"параметри у звичайному синтаксисі GNU/POSIX, а також створює для вас "
"повідомлення про використання та довідку."

msgid "Here's an example of using :mod:`optparse` in a simple script::"
msgstr "Ось приклад використання :mod:`optparse` у простому сценарії::"

msgid ""
"With these few lines of code, users of your script can now do the \"usual "
"thing\" on the command-line, for example::"
msgstr ""
"За допомогою цих кількох рядків коду користувачі вашого сценарію тепер "
"можуть виконувати \"звичайні дії\" в командному рядку, наприклад:"

msgid ""
"As it parses the command line, :mod:`optparse` sets attributes of the "
"``options`` object returned by :meth:`parse_args` based on user-supplied "
"command-line values.  When :meth:`parse_args` returns from parsing this "
"command line, ``options.filename`` will be ``\"outfile\"`` and ``options."
"verbose`` will be ``False``.  :mod:`optparse` supports both long and short "
"options, allows short options to be merged together, and allows options to "
"be associated with their arguments in a variety of ways.  Thus, the "
"following command lines are all equivalent to the above example::"
msgstr ""
"Під час аналізу командного рядка :mod:`optparse` встановлює атрибути об’єкта "
"``options``, які повертає :meth:`parse_args`, на основі значень командного "
"рядка, наданих користувачем. Коли :meth:`parse_args` повертається після "
"аналізу цього командного рядка, ``options.filename`` буде ``\"outfile``, а "
"``options.verbose`` буде ``False``. :mod:`optparse` підтримує як довгі, так "
"і короткі параметри, дозволяє об’єднувати короткі параметри разом і дозволяє "
"пов’язувати параметри з їхніми аргументами різними способами. Таким чином, "
"усі наступні командні рядки еквівалентні наведеному вище прикладу:"

msgid "Additionally, users can run one of the following ::"
msgstr "Крім того, користувачі можуть запустити одну з таких команд:"

msgid ""
"and :mod:`optparse` will print out a brief summary of your script's options:"
msgstr "і :mod:`optparse` виведе короткий опис параметрів вашого сценарію:"

msgid ""
"where the value of *yourscript* is determined at runtime (normally from "
"``sys.argv[0]``)."
msgstr ""
"де значення *yourscript* визначається під час виконання (зазвичай із ``sys."
"argv[0]``)."

msgid "Background"
msgstr "Фон"

msgid ""
":mod:`optparse` was explicitly designed to encourage the creation of "
"programs with straightforward, conventional command-line interfaces.  To "
"that end, it supports only the most common command-line syntax and semantics "
"conventionally used under Unix.  If you are unfamiliar with these "
"conventions, read this section to acquaint yourself with them."
msgstr ""
":mod:`optparse` був спеціально розроблений, щоб заохочувати створення "
"програм із простими звичайними інтерфейсами командного рядка. З цією метою "
"він підтримує лише найпоширеніший синтаксис і семантику командного рядка, "
"які зазвичай використовуються в Unix. Якщо ви не знайомі з цими умовними "
"поняттями, прочитайте цей розділ, щоб ознайомитися з ними."

msgid "Terminology"
msgstr "Термінологія"

msgid "argument"
msgstr "аргумент"

msgid ""
"a string entered on the command-line, and passed by the shell to ``execl()`` "
"or ``execv()``.  In Python, arguments are elements of ``sys.argv[1:]`` "
"(``sys.argv[0]`` is the name of the program being executed).  Unix shells "
"also use the term \"word\"."
msgstr ""
"рядок, введений у командному рядку та переданий оболонкою до ``execl()`` або "
"``execv()``. У Python аргументи є елементами ``sys.argv[1:]`` (``sys."
"argv[0]`` це ім'я програми, що виконується). Оболонки Unix також "
"використовують термін \"слово\"."

msgid ""
"It is occasionally desirable to substitute an argument list other than ``sys."
"argv[1:]``, so you should read \"argument\" as \"an element of ``sys."
"argv[1:]``, or of some other list provided as a substitute for ``sys."
"argv[1:]``\"."
msgstr ""
"Час від часу бажано замінити список аргументів іншим, ніж ``sys.argv[1:]``, "
"тому ви повинні читати \"аргумент\" як \"елемент ``sys.argv[1:]`` або деяких "
"інший список надається замість ``sys.argv[1:]``\"."

msgid "option"
msgstr "варіант"

msgid ""
"an argument used to supply extra information to guide or customize the "
"execution of a program.  There are many different syntaxes for options; the "
"traditional Unix syntax is a hyphen (\"-\") followed by a single letter, e."
"g. ``-x`` or ``-F``.  Also, traditional Unix syntax allows multiple options "
"to be merged into a single argument, e.g. ``-x -F`` is equivalent to ``-"
"xF``.  The GNU project introduced ``--`` followed by a series of hyphen-"
"separated words, e.g. ``--file`` or ``--dry-run``.  These are the only two "
"option syntaxes provided by :mod:`optparse`."
msgstr ""
"аргумент, який використовується для надання додаткової інформації для "
"керівництва або налаштування виконання програми. Існує багато різних "
"синтаксисів для параметрів; традиційний синтаксис Unix - це дефіс (\"-\"), "
"за яким йде одна літера, напр. ``-x`` або ``-F``. Крім того, традиційний "
"синтаксис Unix дозволяє об’єднати кілька параметрів в один аргумент, "
"наприклад. ``-x -F`` еквівалентно ``-xF``. У проекті GNU було введено ``--"
"``, за яким йшов ряд слів, розділених дефісом, напр. ``--file`` або ``--dry-"
"run``. Це єдині два синтаксиси параметрів, які надає :mod:`optparse`."

msgid "Some other option syntaxes that the world has seen include:"
msgstr "Деякі інші синтаксиси параметрів, які бачив світ, включають:"

msgid ""
"a hyphen followed by a few letters, e.g. ``-pf`` (this is *not* the same as "
"multiple options merged into a single argument)"
msgstr ""
"дефіс, за яким слідує кілька літер, напр. ``-pf`` (це *не* те саме, що "
"кілька параметрів, об’єднаних в один аргумент)"

msgid ""
"a hyphen followed by a whole word, e.g. ``-file`` (this is technically "
"equivalent to the previous syntax, but they aren't usually seen in the same "
"program)"
msgstr ""
"дефіс, за яким іде ціле слово, напр. ``-файл`` (технічно це еквівалент "
"попереднього синтаксису, але вони зазвичай не зустрічаються в одній програмі)"

msgid ""
"a plus sign followed by a single letter, or a few letters, or a word, e.g. "
"``+f``, ``+rgb``"
msgstr ""
"знак плюс, після якого йде одна літера, або кілька літер, або слово, напр. "
"``+f``, ``+rgb``"

msgid ""
"a slash followed by a letter, or a few letters, or a word, e.g. ``/f``, ``/"
"file``"
msgstr ""
"косу риску, за якою йде літера, або кілька літер, або слово, напр. ``/f``, "
"``/file``"

msgid ""
"These option syntaxes are not supported by :mod:`optparse`, and they never "
"will be.  This is deliberate: the first three are non-standard on any "
"environment, and the last only makes sense if you're exclusively targeting "
"Windows or certain legacy platforms (e.g. VMS, MS-DOS)."
msgstr ""
"Ці синтаксиси параметрів не підтримуються :mod:`optparse`, і вони ніколи не "
"будуть. Це зроблено навмисно: перші три є нестандартними для будь-якого "
"середовища, а останній має сенс, лише якщо ви націлені виключно на Windows "
"або певні застарілі платформи (наприклад, VMS, MS-DOS)."

msgid "option argument"
msgstr "аргумент опції"

msgid ""
"an argument that follows an option, is closely associated with that option, "
"and is consumed from the argument list when that option is. With :mod:"
"`optparse`, option arguments may either be in a separate argument from their "
"option:"
msgstr ""
"аргумент, який слідує за опцією, тісно пов’язаний із цією опцією та "
"споживається зі списку аргументів, коли ця опція є. З :mod:`optparse` "
"аргументи опції можуть бути в окремому аргументі від їхньої опції:"

msgid "or included in the same argument:"
msgstr "або включено в той самий аргумент:"

msgid ""
"Typically, a given option either takes an argument or it doesn't. Lots of "
"people want an \"optional option arguments\" feature, meaning that some "
"options will take an argument if they see it, and won't if they don't.  This "
"is somewhat controversial, because it makes parsing ambiguous: if ``-a`` "
"takes an optional argument and ``-b`` is another option entirely, how do we "
"interpret ``-ab``?  Because of this ambiguity, :mod:`optparse` does not "
"support this feature."
msgstr ""
"Як правило, певна опція приймає аргумент або ні. Багатьом людям потрібна "
"функція \"необов’язкових аргументів параметрів\", тобто деякі параметри "
"прийматимуть аргумент, якщо вони його бачать, і ні, якщо вони його не "
"бачать. Це дещо суперечливо, оскільки це робить розбір неоднозначним: якщо "
"``-a`` приймає необов’язковий аргумент, а ``-b`` є іншим варіантом, як ми "
"інтерпретуємо ``-ab``? Через цю неоднозначність :mod:`optparse` не підтримує "
"цю функцію."

msgid "positional argument"
msgstr "позиційний аргумент"

msgid ""
"something leftover in the argument list after options have been parsed, i.e. "
"after options and their arguments have been parsed and removed from the "
"argument list."
msgstr ""
"щось, що залишилося в списку аргументів після аналізу параметрів, тобто "
"після аналізу параметрів і їхніх аргументів і видалення зі списку аргументів."

msgid "required option"
msgstr "необхідна опція"

msgid ""
"an option that must be supplied on the command-line; note that the phrase "
"\"required option\" is self-contradictory in English.  :mod:`optparse` "
"doesn't prevent you from implementing required options, but doesn't give you "
"much help at it either."
msgstr ""
"параметр, який необхідно вказати в командному рядку; зауважте, що фраза "
"\"необхідна опція\" є суперечливою англійською мовою. :mod:`optparse` не "
"заважає вам реалізовувати необхідні параметри, але й не дуже допомагає в "
"цьому."

msgid "For example, consider this hypothetical command-line::"
msgstr "Наприклад, розглянемо цей гіпотетичний командний рядок::"

msgid ""
"``-v`` and ``--report`` are both options.  Assuming that ``--report`` takes "
"one argument, ``report.txt`` is an option argument.  ``foo`` and ``bar`` are "
"positional arguments."
msgstr ""
"``-v`` і ``--report`` є варіантами. Якщо припустити, що ``--report`` приймає "
"один аргумент, ``report.txt`` є аргументом опції. ``foo`` і ``bar`` є "
"позиційними аргументами."

msgid "What are options for?"
msgstr "Для чого існують варіанти?"

msgid ""
"Options are used to provide extra information to tune or customize the "
"execution of a program.  In case it wasn't clear, options are usually "
"*optional*.  A program should be able to run just fine with no options "
"whatsoever.  (Pick a random program from the Unix or GNU toolsets.  Can it "
"run without any options at all and still make sense?  The main exceptions "
"are ``find``, ``tar``, and ``dd``\\ ---all of which are mutant oddballs that "
"have been rightly criticized for their non-standard syntax and confusing "
"interfaces.)"
msgstr ""
"Параметри використовуються для надання додаткової інформації для "
"налаштування або налаштування виконання програми. Якщо це було незрозуміло, "
"параметри зазвичай *необов’язкові*. Програма повинна нормально працювати без "
"будь-яких опцій. (Виберіть випадкову програму з наборів інструментів Unix "
"або GNU. Чи може вона запускатися взагалі без будь-яких параметрів і мати "
"сенс? Основними винятками є ``find``, ``tar`` і ``dd``\\ -- - усі вони є "
"диваками-мутантами, яких справедливо критикували за нестандартний синтаксис "
"і заплутані інтерфейси.)"

msgid ""
"Lots of people want their programs to have \"required options\".  Think "
"about it. If it's required, then it's *not optional*!  If there is a piece "
"of information that your program absolutely requires in order to run "
"successfully, that's what positional arguments are for."
msgstr ""
"Багато людей хочуть, щоб їхні програми мали \"необхідні параметри\". Подумай "
"над цим. Якщо це потрібно, то це *не обов’язково*! Якщо є частина "
"інформації, яка абсолютно необхідна вашій програмі для успішної роботи, це "
"те, для чого потрібні позиційні аргументи."

msgid ""
"As an example of good command-line interface design, consider the humble "
"``cp`` utility, for copying files.  It doesn't make much sense to try to "
"copy files without supplying a destination and at least one source. Hence, "
"``cp`` fails if you run it with no arguments.  However, it has a flexible, "
"useful syntax that does not require any options at all::"
msgstr ""
"Як приклад гарного дизайну інтерфейсу командного рядка розглянемо скромну "
"утиліту ``cp`` для копіювання файлів. Немає особливого сенсу намагатися "
"скопіювати файли, не вказавши місце призначення та принаймні одне джерело. "
"Отже, ``cp`` не вдається, якщо ви запускаєте його без аргументів. Однак він "
"має гнучкий, корисний синтаксис, який не потребує жодних опцій:"

msgid ""
"You can get pretty far with just that.  Most ``cp`` implementations provide "
"a bunch of options to tweak exactly how the files are copied: you can "
"preserve mode and modification time, avoid following symlinks, ask before "
"clobbering existing files, etc.  But none of this distracts from the core "
"mission of ``cp``, which is to copy either one file to another, or several "
"files to another directory."
msgstr ""
"Тільки з цим можна зайти досить далеко. Більшість реалізацій ``cp`` надають "
"безліч параметрів для точного налаштування способу копіювання файлів: ви "
"можете зберегти режим і час модифікації, уникати переходу за символічними "
"посиланнями, запитувати перед тим, як затирати існуючі файли, тощо. Але це "
"не відволікає від основної місії ``cp``, який скопіює або один файл до "
"іншого, або декілька файлів до іншого каталогу."

msgid "What are positional arguments for?"
msgstr "Для чого потрібні позиційні аргументи?"

msgid ""
"Positional arguments are for those pieces of information that your program "
"absolutely, positively requires to run."
msgstr ""
"Позиційні аргументи призначені для тих фрагментів інформації, які вашій "
"програмі абсолютно необхідні для роботи."

msgid ""
"A good user interface should have as few absolute requirements as possible.  "
"If your program requires 17 distinct pieces of information in order to run "
"successfully, it doesn't much matter *how* you get that information from the "
"user---most people will give up and walk away before they successfully run "
"the program.  This applies whether the user interface is a command-line, a "
"configuration file, or a GUI: if you make that many demands on your users, "
"most of them will simply give up."
msgstr ""
"Хороший інтерфейс користувача повинен мати якомога менше абсолютних вимог. "
"Якщо ваша програма потребує 17 окремих фрагментів інформації для успішної "
"роботи, не має великого значення *як* ви отримуєте цю інформацію від "
"користувача --- більшість людей здадуться та підуть, перш ніж вони успішно "
"запустять програму. Це стосується незалежно від того, чи є інтерфейс "
"користувача командним рядком, файлом конфігурації чи графічним інтерфейсом "
"користувача: якщо ви поставите стільки вимог до своїх користувачів, "
"більшість із них просто здадуться."

msgid ""
"In short, try to minimize the amount of information that users are "
"absolutely required to supply---use sensible defaults whenever possible.  Of "
"course, you also want to make your programs reasonably flexible.  That's "
"what options are for.  Again, it doesn't matter if they are entries in a "
"config file, widgets in the \"Preferences\" dialog of a GUI, or command-line "
"options---the more options you implement, the more flexible your program is, "
"and the more complicated its implementation becomes.  Too much flexibility "
"has drawbacks as well, of course; too many options can overwhelm users and "
"make your code much harder to maintain."
msgstr ""
"Коротше кажучи, намагайтеся мінімізувати кількість інформації, яку "
"користувачі абсолютно зобов’язані надавати --- використовуйте розумні "
"значення за замовчуванням, коли це можливо. Звичайно, ви також хочете "
"зробити свої програми досить гнучкими. Для цього і потрібні варіанти. Знову "
"ж таки, не має значення, чи це записи у конфігураційному файлі, віджети в "
"діалоговому вікні \"Параметри\" графічного інтерфейсу користувача чи "
"параметри командного рядка --- чим більше параметрів ви застосовуєте, тим "
"гнучкішою є ваша програма, і ускладнюється його реалізація. Занадто велика "
"гнучкість також має недоліки, звичайно; занадто багато параметрів може "
"перевантажити користувачів і зробити ваш код набагато складнішим для "
"підтримки."

msgid "Tutorial"
msgstr "Підручник"

msgid ""
"While :mod:`optparse` is quite flexible and powerful, it's also "
"straightforward to use in most cases.  This section covers the code patterns "
"that are common to any :mod:`optparse`\\ -based program."
msgstr ""
"Хоча :mod:`optparse` досить гнучкий і потужний, він також простий у "
"використанні в більшості випадків. Цей розділ охоплює шаблони коду, які є "
"спільними для будь-якої програми на основі :mod:`optparse`\\."

msgid ""
"First, you need to import the OptionParser class; then, early in the main "
"program, create an OptionParser instance::"
msgstr ""
"По-перше, вам потрібно імпортувати клас OptionParser; потім на початку "
"основної програми створіть екземпляр OptionParser::"

msgid "Then you can start defining options.  The basic syntax is::"
msgstr "Потім можна приступати до визначення варіантів. Основний синтаксис::"

msgid ""
"Each option has one or more option strings, such as ``-f`` or ``--file``, "
"and several option attributes that tell :mod:`optparse` what to expect and "
"what to do when it encounters that option on the command line."
msgstr ""
"Кожна опція має один або більше рядків опції, наприклад ``-f`` або ``--"
"file``, і кілька атрибутів опції, які повідомляють :mod:`optparse`, чого "
"очікувати і що робити, коли він зустрічає цю опцію в командному рядку."

msgid ""
"Typically, each option will have one short option string and one long option "
"string, e.g.::"
msgstr ""
"Як правило, кожен параметр матиме один короткий рядок параметра та один "
"довгий рядок параметра, наприклад::"

msgid ""
"You're free to define as many short option strings and as many long option "
"strings as you like (including zero), as long as there is at least one "
"option string overall."
msgstr ""
"Ви можете визначати скільки завгодно коротких рядків параметрів і скільки "
"завгодно довгих рядків параметрів (включаючи нуль), за умови, що є принаймні "
"один рядок параметрів."

msgid ""
"The option strings passed to :meth:`OptionParser.add_option` are effectively "
"labels for the option defined by that call.  For brevity, we will frequently "
"refer to *encountering an option* on the command line; in reality, :mod:"
"`optparse` encounters *option strings* and looks up options from them."
msgstr ""
"Рядки параметрів, передані до :meth:`OptionParser.add_option`, фактично є "
"мітками для параметра, визначеного цим викликом. Для стислості ми будемо "
"часто посилатися на *зустріч параметра* в командному рядку; насправді :mod:"
"`optparse` зустрічає *рядки параметрів* і шукає параметри з них."

msgid ""
"Once all of your options are defined, instruct :mod:`optparse` to parse your "
"program's command line::"
msgstr ""
"Коли всі ваші параметри визначено, дайте команду :mod:`optparse` "
"проаналізувати командний рядок вашої програми:"

msgid ""
"(If you like, you can pass a custom argument list to :meth:`parse_args`, but "
"that's rarely necessary: by default it uses ``sys.argv[1:]``.)"
msgstr ""
"(Якщо хочете, ви можете передати настроюваний список аргументів до :meth:"
"`parse_args`, але це рідко потрібно: за замовчуванням він використовує ``sys."
"argv[1:]``.)"

msgid ":meth:`parse_args` returns two values:"
msgstr ":meth:`parse_args` повертає два значення:"

msgid ""
"``options``, an object containing values for all of your options---e.g. if "
"``--file`` takes a single string argument, then ``options.file`` will be the "
"filename supplied by the user, or ``None`` if the user did not supply that "
"option"
msgstr ""
"``options``, об’єкт, що містить значення для всіх ваших параметрів --- напр. "
"якщо ``--file`` приймає один рядковий аргумент, ``options.file`` буде іменем "
"файлу, наданим користувачем, або ``None``, якщо користувач не вказав цей "
"параметр"

msgid ""
"``args``, the list of positional arguments leftover after parsing options"
msgstr ""
"``args``, список позиційних аргументів, що залишилися після аналізу "
"параметрів"

msgid ""
"This tutorial section only covers the four most important option "
"attributes: :attr:`~Option.action`, :attr:`~Option.type`, :attr:`~Option."
"dest` (destination), and :attr:`~Option.help`. Of these, :attr:`~Option."
"action` is the most fundamental."
msgstr ""
"Цей розділ посібника охоплює лише чотири найважливіші атрибути параметрів: :"
"attr:`~Option.action`, :attr:`~Option.type`, :attr:`~Option.dest` "
"(призначення) і :attr:`~Option.help`. З них :attr:`~Option.action` є "
"найбільш фундаментальним."

msgid "Understanding option actions"
msgstr "Розуміння опціональних дій"

msgid ""
"Actions tell :mod:`optparse` what to do when it encounters an option on the "
"command line.  There is a fixed set of actions hard-coded into :mod:"
"`optparse`; adding new actions is an advanced topic covered in section :ref:"
"`optparse-extending-optparse`.  Most actions tell :mod:`optparse` to store a "
"value in some variable---for example, take a string from the command line "
"and store it in an attribute of ``options``."
msgstr ""
"Дії повідомляють :mod:`optparse`, що робити, коли він зустрічає опцію в "
"командному рядку. Існує фіксований набір дій, жорстко закодований у :mod:"
"`optparse`; додавання нових дій є розширеною темою, розглянутою в розділі :"
"ref:`optparse-extending-optparse`. Більшість дій говорять :mod:`optparse` "
"зберігати значення в деякій змінній --- наприклад, взяти рядок із командного "
"рядка та зберегти його в атрибуті ``options``."

msgid ""
"If you don't specify an option action, :mod:`optparse` defaults to ``store``."
msgstr ""
"Якщо ви не вкажете опцію дії, :mod:`optparse` за замовчуванням буде "
"``store``."

msgid "The store action"
msgstr "Акція магазину"

msgid ""
"The most common option action is ``store``, which tells :mod:`optparse` to "
"take the next argument (or the remainder of the current argument), ensure "
"that it is of the correct type, and store it to your chosen destination."
msgstr ""
"Найпоширенішою дією опції є ``store``, яка повідомляє :mod:`optparse` взяти "
"наступний аргумент (або решту поточного аргументу), переконатися, що він має "
"правильний тип, і зберегти його у вибраному призначення."

msgid "For example::"
msgstr "Наприклад::"

msgid ""
"Now let's make up a fake command line and ask :mod:`optparse` to parse it::"
msgstr ""
"Тепер давайте створимо фальшивий командний рядок і попросимо :mod:`optparse` "
"розібрати його::"

msgid ""
"When :mod:`optparse` sees the option string ``-f``, it consumes the next "
"argument, ``foo.txt``, and stores it in ``options.filename``.  So, after "
"this call to :meth:`parse_args`, ``options.filename`` is ``\"foo.txt\"``."
msgstr ""
"Коли :mod:`optparse` бачить рядок параметрів ``-f``, він використовує "
"наступний аргумент ``foo.txt`` і зберігає його в ``options.filename``. Отже, "
"після цього виклику :meth:`parse_args`, ``options.filename`` буде ``\"foo."
"txt\"``."

msgid ""
"Some other option types supported by :mod:`optparse` are ``int`` and "
"``float``. Here's an option that expects an integer argument::"
msgstr ""
"Деякі інші типи опцій, які підтримує :mod:`optparse`, це ``int`` і "
"``float``. Ось варіант, який очікує цілочисельний аргумент::"

msgid ""
"Note that this option has no long option string, which is perfectly "
"acceptable. Also, there's no explicit action, since the default is ``store``."
msgstr ""
"Зауважте, що цей параметр не має довгого рядка параметрів, що цілком "
"прийнятно. Крім того, немає явної дії, оскільки за замовчуванням є ``store``."

msgid ""
"Let's parse another fake command-line.  This time, we'll jam the option "
"argument right up against the option: since ``-n42`` (one argument) is "
"equivalent to ``-n 42`` (two arguments), the code ::"
msgstr ""
"Давайте розберемо ще один підроблений командний рядок. Цього разу ми "
"зіткнемося з аргументом option прямо проти параметра: оскільки ``-n42`` "
"(один аргумент) еквівалентний ``-n 42`` (два аргументи), код ::"

msgid "will print ``42``."
msgstr "надрукує ``42``."

msgid ""
"If you don't specify a type, :mod:`optparse` assumes ``string``.  Combined "
"with the fact that the default action is ``store``, that means our first "
"example can be a lot shorter::"
msgstr ""
"Якщо ви не вкажете тип, :mod:`optparse` припускає ``рядок``. У поєднанні з "
"тим фактом, що типовою дією є ``store``, це означає, що наш перший приклад "
"може бути набагато коротшим:"

msgid ""
"If you don't supply a destination, :mod:`optparse` figures out a sensible "
"default from the option strings: if the first long option string is ``--foo-"
"bar``, then the default destination is ``foo_bar``.  If there are no long "
"option strings, :mod:`optparse` looks at the first short option string: the "
"default destination for ``-f`` is ``f``."
msgstr ""
"Якщо ви не вкажете призначення, :mod:`optparse` визначає розумне значення за "
"замовчуванням із рядків параметрів: якщо перший довгий рядок параметрів – "
"``--foo-bar``, тоді призначенням за замовчуванням є ``foo_bar``. Якщо довгих "
"рядків параметрів немає, :mod:`optparse` шукає перший короткий рядок "
"параметрів: типовим призначенням для ``-f`` є ``f``."

msgid ""
":mod:`optparse` also includes the built-in ``complex`` type.  Adding types "
"is covered in section :ref:`optparse-extending-optparse`."
msgstr ""
":mod:`optparse` також містить вбудований тип ``complex``. Додавання типів "
"описано в розділі :ref:`optparse-extending-optparse`."

msgid "Handling boolean (flag) options"
msgstr "Обробка логічних параметрів (прапорів)."

msgid ""
"Flag options---set a variable to true or false when a particular option is "
"seen---are quite common.  :mod:`optparse` supports them with two separate "
"actions, ``store_true`` and ``store_false``.  For example, you might have a "
"``verbose`` flag that is turned on with ``-v`` and off with ``-q``::"
msgstr ""
"Параметри прапорів --- встановлюють для змінної значення true або false, "
"коли відображається певний параметр --- досить поширені. :mod:`optparse` "
"підтримує їх за допомогою двох окремих дій, ``store_true`` і "
"``store_false``. Наприклад, у вас може бути прапорець ``verbose``, який "
"вмикається за допомогою ``-v`` і вимикається ``-q``::"

msgid ""
"Here we have two different options with the same destination, which is "
"perfectly OK.  (It just means you have to be a bit careful when setting "
"default values---see below.)"
msgstr ""
"Тут у нас є два різні варіанти з тим самим пунктом призначення, що цілком "
"нормально. (Це лише означає, що ви повинні бути трохи обережними, "
"встановлюючи значення за замовчуванням --- див. нижче.)"

msgid ""
"When :mod:`optparse` encounters ``-v`` on the command line, it sets "
"``options.verbose`` to ``True``; when it encounters ``-q``, ``options."
"verbose`` is set to ``False``."
msgstr ""
"Коли :mod:`optparse` зустрічає ``-v`` у командному рядку, він встановлює "
"``options.verbose`` на ``True``; коли зустрічається ``-q``, ``options."
"verbose`` встановлюється на ``False``."

msgid "Other actions"
msgstr "Інші дії"

msgid "Some other actions supported by :mod:`optparse` are:"
msgstr "Деякі інші дії, які підтримує :mod:`optparse`:"

msgid "``\"store_const\"``"
msgstr "``\"store_const\"``"

msgid "store a constant value"
msgstr "зберігати постійне значення"

msgid "``\"append\"``"
msgstr "``\"додати\"``"

msgid "append this option's argument to a list"
msgstr "додати аргумент цього параметра до списку"

msgid "``\"count\"``"
msgstr "``\"рахувати\"``"

msgid "increment a counter by one"
msgstr "збільшити лічильник на одиницю"

msgid "``\"callback\"``"
msgstr "``\"зворотний виклик\"``"

msgid "call a specified function"
msgstr "викликати вказану функцію"

msgid ""
"These are covered in section :ref:`optparse-reference-guide`, and section :"
"ref:`optparse-option-callbacks`."
msgstr ""
"Вони описані в розділі :ref:`optparse-reference-guide` і розділі :ref:"
"`optparse-option-callbacks`."

msgid "Default values"
msgstr "Значення за замовчуванням"

msgid ""
"All of the above examples involve setting some variable (the "
"\"destination\") when certain command-line options are seen.  What happens "
"if those options are never seen?  Since we didn't supply any defaults, they "
"are all set to ``None``.  This is usually fine, but sometimes you want more "
"control.  :mod:`optparse` lets you supply a default value for each "
"destination, which is assigned before the command line is parsed."
msgstr ""
"Усі наведені вище приклади включають встановлення деякої змінної "
"(\"призначення\"), коли відображаються певні параметри командного рядка. Що "
"трапиться, якщо ці варіанти ніколи не побачать? Оскільки ми не вказали "
"жодних значень за замовчуванням, для всіх встановлено значення ``None``. "
"Зазвичай це добре, але іноді потрібно більше контролю. :mod:`optparse` "
"дозволяє вказати значення за умовчанням для кожного пункту призначення, яке "
"призначається перед аналізом командного рядка."

msgid ""
"First, consider the verbose/quiet example.  If we want :mod:`optparse` to "
"set ``verbose`` to ``True`` unless ``-q`` is seen, then we can do this::"
msgstr ""
"Спочатку розглянемо багатослівний/тихий приклад. Якщо ми хочемо, щоб :mod:"
"`optparse` встановив для ``verbose`` значення ``True``, якщо не видно ``-"
"q``, ми можемо зробити це:"

msgid ""
"Since default values apply to the *destination* rather than to any "
"particular option, and these two options happen to have the same "
"destination, this is exactly equivalent::"
msgstr ""
"Оскільки значення за замовчуванням застосовуються до *призначення*, а не до "
"будь-якого конкретного параметра, і ці два параметри мають одне призначення, "
"це точно еквівалентно::"

msgid "Consider this::"
msgstr "Розглянемо це::"

msgid ""
"Again, the default value for ``verbose`` will be ``True``: the last default "
"value supplied for any particular destination is the one that counts."
msgstr ""
"Знову ж таки, значенням за замовчуванням для ``verbose`` буде ``True``: "
"останнє значення за замовчуванням, надане для будь-якого конкретного "
"призначення, є тим, яке враховується."

msgid ""
"A clearer way to specify default values is the :meth:`set_defaults` method "
"of OptionParser, which you can call at any time before calling :meth:"
"`parse_args`::"
msgstr ""
"Більш зрозумілим способом визначення значень за замовчуванням є метод :meth:"
"`set_defaults` OptionParser, який можна викликати будь-коли перед викликом :"
"meth:`parse_args`::"

msgid ""
"As before, the last value specified for a given option destination is the "
"one that counts.  For clarity, try to use one method or the other of setting "
"default values, not both."
msgstr ""
"Як і раніше, зараховується останнє значення, указане для даного призначення "
"опції. Для ясності спробуйте використовувати один або інший метод "
"встановлення значень за замовчуванням, а не обидва."

msgid "Generating help"
msgstr "Створення довідки"

msgid ""
":mod:`optparse`'s ability to generate help and usage text automatically is "
"useful for creating user-friendly command-line interfaces.  All you have to "
"do is supply a :attr:`~Option.help` value for each option, and optionally a "
"short usage message for your whole program.  Here's an OptionParser "
"populated with user-friendly (documented) options::"
msgstr ""
"Здатність :mod:`optparse` автоматично генерувати текст довідки та "
"використання корисна для створення зручних інтерфейсів командного рядка. "
"Все, що вам потрібно зробити, це вказати значення :attr:`~Option.help` для "
"кожного параметра та, за бажанням, коротке повідомлення про використання для "
"всієї програми. Ось OptionParser, заповнений зручними (задокументованими) "
"параметрами::"

msgid ""
"If :mod:`optparse` encounters either ``-h`` or ``--help`` on the command-"
"line, or if you just call :meth:`parser.print_help`, it prints the following "
"to standard output:"
msgstr ""
"Якщо :mod:`optparse` зустрічає ``-h`` або ``--help`` у командному рядку, або "
"якщо ви просто викликаєте :meth:`parser.print_help`, він виводить наступне у "
"стандартний вивід :"

msgid ""
"(If the help output is triggered by a help option, :mod:`optparse` exits "
"after printing the help text.)"
msgstr ""
"(Якщо вихід довідки ініціюється опцією довідки, :mod:`optparse` завершує "
"роботу після друку тексту довідки.)"

msgid ""
"There's a lot going on here to help :mod:`optparse` generate the best "
"possible help message:"
msgstr ""
"Тут багато чого робиться, щоб допомогти :mod:`optparse` створити найкраще "
"довідкове повідомлення:"

msgid "the script defines its own usage message::"
msgstr "сценарій визначає власне повідомлення про використання::"

msgid ""
":mod:`optparse` expands ``%prog`` in the usage string to the name of the "
"current program, i.e. ``os.path.basename(sys.argv[0])``.  The expanded "
"string is then printed before the detailed option help."
msgstr ""
":mod:`optparse` розширює ``%prog`` у рядку використання до назви поточної "
"програми, тобто ``os.path.basename(sys.argv[0])``. Потім розгорнутий рядок "
"друкується перед детальною довідкою параметрів."

msgid ""
"If you don't supply a usage string, :mod:`optparse` uses a bland but "
"sensible default: ``\"Usage: %prog [options]\"``, which is fine if your "
"script doesn't take any positional arguments."
msgstr ""
"Якщо ви не вказали рядок використання, :mod:`optparse` використовує м’яке, "
"але розумне значення за умовчанням: ``\"Використання: %prog [параметри]\"``, "
"що добре, якщо ваш сценарій не приймає жодних позиційних аргументів."

msgid ""
"every option defines a help string, and doesn't worry about line-wrapping---"
"\\ :mod:`optparse` takes care of wrapping lines and making the help output "
"look good."
msgstr ""
"кожен параметр визначає довідковий рядок і не турбується про перенесення "
"рядків---\\ :mod:`optparse` піклується про обтікання рядків і робить вихід "
"довідки гарним."

msgid ""
"options that take a value indicate this fact in their automatically "
"generated help message, e.g. for the \"mode\" option::"
msgstr ""

msgid ""
"Here, \"MODE\" is called the meta-variable: it stands for the argument that "
"the user is expected to supply to ``-m``/``--mode``.  By default, :mod:"
"`optparse` converts the destination variable name to uppercase and uses that "
"for the meta-variable.  Sometimes, that's not what you want---for example, "
"the ``--filename`` option explicitly sets ``metavar=\"FILE\"``, resulting in "
"this automatically generated option description::"
msgstr ""

msgid ""
"This is important for more than just saving space, though: the manually "
"written help text uses the meta-variable ``FILE`` to clue the user in that "
"there's a connection between the semi-formal syntax ``-f FILE`` and the "
"informal semantic description \"write output to FILE\". This is a simple but "
"effective way to make your help text a lot clearer and more useful for end "
"users."
msgstr ""
"Однак це важливо не тільки для економії місця: написаний вручну текст "
"довідки використовує мета-змінну ``FILE``, щоб зрозуміти користувачеві, що "
"існує зв’язок між напівформальним синтаксисом ``-f FILE`` і неформальний "
"семантичний опис \"записати вихід у ФАЙЛ\". Це простий, але ефективний "
"спосіб зробити ваш текст довідки набагато зрозумілішим і кориснішим для "
"кінцевих користувачів."

msgid ""
"options that have a default value can include ``%default`` in the help "
"string---\\ :mod:`optparse` will replace it with :func:`str` of the option's "
"default value.  If an option has no default value (or the default value is "
"``None``), ``%default`` expands to ``none``."
msgstr ""
"параметри, які мають значення за замовчуванням, можуть містити ``%default`` "
"у рядку довідки ---\\ :mod:`optparse` замінить його на :func:`str` значення "
"параметра за замовчуванням. Якщо параметр не має значення за замовчуванням "
"(або стандартним значенням є ``None``), ``%default`` розширюється до "
"``none``."

msgid "Grouping Options"
msgstr "Параметри групування"

msgid ""
"When dealing with many options, it is convenient to group these options for "
"better help output.  An :class:`OptionParser` can contain several option "
"groups, each of which can contain several options."
msgstr ""
"Коли ви маєте справу з багатьма параметрами, зручно згрупувати ці параметри "
"для кращого виведення довідки. :class:`OptionParser` може містити кілька "
"груп опцій, кожна з яких може містити кілька опцій."

msgid "An option group is obtained using the class :class:`OptionGroup`:"
msgstr "Група опцій отримується за допомогою класу :class:`OptionGroup`:"

msgid "where"
msgstr "де"

msgid ""
"parser is the :class:`OptionParser` instance the group will be inserted in to"
msgstr ""
"parser — це екземпляр :class:`OptionParser`, до якого буде вставлено групу"

msgid "title is the group title"
msgstr "title — назва групи"

msgid "description, optional, is a long description of the group"
msgstr "description, необов'язковий, це довгий опис групи"

msgid ""
":class:`OptionGroup` inherits from :class:`OptionContainer` (like :class:"
"`OptionParser`) and so the :meth:`add_option` method can be used to add an "
"option to the group."
msgstr ""
":class:`OptionGroup` успадковує :class:`OptionContainer` (наприклад, :class:"
"`OptionParser`), тому метод :meth:`add_option` можна використовувати для "
"додавання опції до групи."

msgid ""
"Once all the options are declared, using the :class:`OptionParser` method :"
"meth:`add_option_group` the group is added to the previously defined parser."
msgstr ""
"Після оголошення всіх опцій за допомогою методу :class:`OptionParser` :meth:"
"`add_option_group` група додається до попередньо визначеного аналізатора."

msgid ""
"Continuing with the parser defined in the previous section, adding an :class:"
"`OptionGroup` to a parser is easy::"
msgstr ""
"Продовжуючи роботу з аналізатором, визначеним у попередньому розділі, "
"додати :class:`OptionGroup` до аналізатора легко:"

msgid "This would result in the following help output:"
msgstr "Це призведе до наступного результату довідки:"

msgid ""
"A bit more complete example might involve using more than one group: still "
"extending the previous example::"
msgstr ""
"Трохи повніший приклад може включати використання кількох груп: все ще "
"розширюючи попередній приклад::"

msgid "that results in the following output:"
msgstr "що призводить до наступного результату:"

msgid ""
"Another interesting method, in particular when working programmatically with "
"option groups is:"
msgstr ""
"Ще один цікавий метод, зокрема під час програмної роботи з групами "
"параметрів:"

msgid ""
"Return the :class:`OptionGroup` to which the short or long option string "
"*opt_str* (e.g. ``'-o'`` or ``'--option'``) belongs. If there's no such :"
"class:`OptionGroup`, return ``None``."
msgstr ""
"Повертає :class:`OptionGroup`, до якої належить короткий або довгий рядок "
"параметрів *opt_str* (наприклад, ``'-o'`` або ``'--option'``). Якщо такої :"
"class:`OptionGroup` немає, поверніть ``None``."

msgid "Printing a version string"
msgstr "Друк рядка версії"

msgid ""
"Similar to the brief usage string, :mod:`optparse` can also print a version "
"string for your program.  You have to supply the string as the ``version`` "
"argument to OptionParser::"
msgstr ""
"Подібно до короткого рядка використання, :mod:`optparse` також може "
"надрукувати рядок версії вашої програми. Ви повинні надати рядок як аргумент "
"``version`` для OptionParser::"

msgid ""
"``%prog`` is expanded just like it is in ``usage``.  Apart from that, "
"``version`` can contain anything you like.  When you supply it, :mod:"
"`optparse` automatically adds a ``--version`` option to your parser. If it "
"encounters this option on the command line, it expands your ``version`` "
"string (by replacing ``%prog``), prints it to stdout, and exits."
msgstr ""
"``%prog`` розгортається так само, як і в ``usage``. Окрім цього, ``версія`` "
"може містити все, що завгодно. Коли ви вказуєте його, :mod:`optparse` "
"автоматично додає опцію ``--version`` до вашого аналізатора. Якщо він "
"зустрічає цей параметр у командному рядку, він розгортає ваш рядок "
"``version`` (шляхом заміни ``%prog``), друкує його в stdout і завершує "
"роботу."

msgid "For example, if your script is called ``/usr/bin/foo``:"
msgstr "Наприклад, якщо ваш скрипт називається ``/usr/bin/foo``:"

msgid ""
"The following two methods can be used to print and get the ``version`` "
"string:"
msgstr ""
"Наступні два методи можна використати для друку та отримання рядка "
"``version``:"

msgid ""
"Print the version message for the current program (``self.version``) to "
"*file* (default stdout).  As with :meth:`print_usage`, any occurrence of "
"``%prog`` in ``self.version`` is replaced with the name of the current "
"program.  Does nothing if ``self.version`` is empty or undefined."
msgstr ""
"Вивести повідомлення про версію для поточної програми (``self.version``) у "
"*файл* (стандартний вивід за замовчуванням). Як і у випадку з :meth:"
"`print_usage`, будь-яке входження ``%prog`` у ``self.version`` замінюється "
"назвою поточної програми. Нічого не робить, якщо ``self.version`` порожній "
"або невизначений."

msgid ""
"Same as :meth:`print_version` but returns the version string instead of "
"printing it."
msgstr ""
"Те саме, що :meth:`print_version`, але повертає рядок версії замість її "
"друку."

msgid "How :mod:`optparse` handles errors"
msgstr "Як :mod:`optparse` обробляє помилки"

msgid ""
"There are two broad classes of errors that :mod:`optparse` has to worry "
"about: programmer errors and user errors.  Programmer errors are usually "
"erroneous calls to :func:`OptionParser.add_option`, e.g. invalid option "
"strings, unknown option attributes, missing option attributes, etc.  These "
"are dealt with in the usual way: raise an exception (either :exc:`optparse."
"OptionError` or :exc:`TypeError`) and let the program crash."
msgstr ""
"Є два широких класи помилок, про які :mod:`optparse` має турбуватися: "
"помилки програміста та помилки користувача. Помилки програміста зазвичай є "
"помилковими викликами :func:`OptionParser.add_option`, напр. недійсні рядки "
"опцій, невідомі атрибути опцій, відсутні атрибути опцій тощо. З цими "
"справляються звичайним способом: викликають виняток (або :exc:`optparse."
"OptionError` або :exc:`TypeError`) і дозволяють програмі аварійно "
"завершувати роботу."

msgid ""
"Handling user errors is much more important, since they are guaranteed to "
"happen no matter how stable your code is.  :mod:`optparse` can automatically "
"detect some user errors, such as bad option arguments (passing ``-n 4x`` "
"where ``-n`` takes an integer argument), missing arguments (``-n`` at the "
"end of the command line, where ``-n`` takes an argument of any type).  Also, "
"you can call :func:`OptionParser.error` to signal an application-defined "
"error condition::"
msgstr ""
"Обробка помилок користувача є набагато важливішою, оскільки вони гарантовано "
"траплятимуться незалежно від того, наскільки стабільним є ваш код. :mod:"
"`optparse` може автоматично виявляти деякі помилки користувача, такі як "
"неправильні аргументи параметрів (передача ``-n 4x``, де ``-n`` приймає "
"цілочисельний аргумент), відсутні аргументи (``-n`` у кінець командного "
"рядка, де ``-n`` приймає аргумент будь-якого типу). Крім того, ви можете "
"викликати :func:`OptionParser.error`, щоб повідомити про помилку, визначену "
"програмою:"

msgid ""
"In either case, :mod:`optparse` handles the error the same way: it prints "
"the program's usage message and an error message to standard error and exits "
"with error status 2."
msgstr ""
"У будь-якому випадку :mod:`optparse` обробляє помилку однаково: він друкує "
"повідомлення про використання програми та повідомлення про помилку до "
"стандартної помилки та виходить зі статусом помилки 2."

msgid ""
"Consider the first example above, where the user passes ``4x`` to an option "
"that takes an integer:"
msgstr ""
"Розглянемо перший приклад вище, де користувач передає ``4x`` опції, яка "
"приймає ціле число:"

msgid "Or, where the user fails to pass a value at all:"
msgstr "Або, коли користувач взагалі не може передати значення:"

msgid ""
":mod:`optparse`\\ -generated error messages take care always to mention the "
"option involved in the error; be sure to do the same when calling :func:"
"`OptionParser.error` from your application code."
msgstr ""
":mod:`optparse`\\ -згенеровані повідомлення про помилку завжди вказують "
"опцію, пов’язану з помилкою; обов’язково зробіть те саме під час виклику :"
"func:`OptionParser.error` із коду програми."

msgid ""
"If :mod:`optparse`'s default error-handling behaviour does not suit your "
"needs, you'll need to subclass OptionParser and override its :meth:"
"`~OptionParser.exit` and/or :meth:`~OptionParser.error` methods."
msgstr ""
"Якщо стандартна поведінка обробки помилок :mod:`optparse` не відповідає "
"вашим потребам, вам потрібно створити підклас OptionParser і перевизначити "
"його :meth:`~OptionParser.exit` та/або :meth:`~OptionParser.error` методи."

msgid "Putting it all together"
msgstr "Зібравши все разом"

msgid "Here's what :mod:`optparse`\\ -based scripts usually look like::"
msgstr "Ось як зазвичай виглядають сценарії на основі :mod:`optparse`\\:"

msgid "Reference Guide"
msgstr "Довідковий посібник"

msgid "Creating the parser"
msgstr "Створення аналізатора"

msgid ""
"The first step in using :mod:`optparse` is to create an OptionParser "
"instance."
msgstr ""
"Першим кроком у використанні :mod:`optparse` є створення екземпляра "
"OptionParser."

msgid ""
"The OptionParser constructor has no required arguments, but a number of "
"optional keyword arguments.  You should always pass them as keyword "
"arguments, i.e. do not rely on the order in which the arguments are declared."
msgstr ""
"Конструктор OptionParser не має обов’язкових аргументів, але має декілька "
"необов’язкових ключових аргументів. Ви завжди повинні передавати їх як "
"аргументи ключового слова, тобто не покладайтеся на порядок, у якому "
"оголошено аргументи."

msgid "``usage`` (default: ``\"%prog [options]\"``)"
msgstr "``використання`` (за замовчуванням: ``\"%prog [параметри]\"``)"

msgid ""
"The usage summary to print when your program is run incorrectly or with a "
"help option.  When :mod:`optparse` prints the usage string, it expands "
"``%prog`` to ``os.path.basename(sys.argv[0])`` (or to ``prog`` if you passed "
"that keyword argument).  To suppress a usage message, pass the special "
"value :data:`optparse.SUPPRESS_USAGE`."
msgstr ""
"Підсумок використання для друку, коли ваша програма працює неправильно або з "
"опцією довідки. Коли :mod:`optparse` друкує рядок використання, він розширює "
"``%prog`` до ``os.path.basename(sys.argv[0])`` (або до ``prog``, якщо ви "
"передали це ключове слово аргумент). Щоб приховати повідомлення про "
"використання, передайте спеціальне значення :data:`optparse.SUPPRESS_USAGE`."

msgid "``option_list`` (default: ``[]``)"
msgstr "``option_list`` (за замовчуванням: ``[]``)"

msgid ""
"A list of Option objects to populate the parser with.  The options in "
"``option_list`` are added after any options in ``standard_option_list`` (a "
"class attribute that may be set by OptionParser subclasses), but before any "
"version or help options. Deprecated; use :meth:`add_option` after creating "
"the parser instead."
msgstr ""
"Список об’єктів Option для заповнення аналізатора. Опції в ``option_list`` "
"додаються після будь-яких опцій в ``standard_option_list`` (атрибут класу, "
"який може бути встановлений підкласами OptionParser), але перед будь-якою "
"версією або опціями довідки. Застаріле; замість цього використовуйте :meth:"
"`add_option` після створення аналізатора."

msgid "``option_class`` (default: optparse.Option)"
msgstr "``option_class`` (за замовчуванням: optparse.Option)"

msgid "Class to use when adding options to the parser in :meth:`add_option`."
msgstr ""
"Клас для використання під час додавання параметрів до аналізатора в :meth:"
"`add_option`."

msgid "``version`` (default: ``None``)"
msgstr "``version`` (за замовчуванням: ``None``)"

msgid ""
"A version string to print when the user supplies a version option. If you "
"supply a true value for ``version``, :mod:`optparse` automatically adds a "
"version option with the single option string ``--version``.  The substring "
"``%prog`` is expanded the same as for ``usage``."
msgstr ""
"Рядок версії для друку, коли користувач вказує параметр версії. Якщо ви "
"вказуєте справжнє значення для ``version``, :mod:`optparse` автоматично "
"додає опцію версії з єдиним рядком опції ``--version``. Підрядок ``%prog`` "
"розгортається так само, як і ``usage``."

msgid "``conflict_handler`` (default: ``\"error\"``)"
msgstr "``conflict_handler`` (за замовчуванням: ``\"помилка\"``)"

msgid ""
"Specifies what to do when options with conflicting option strings are added "
"to the parser; see section :ref:`optparse-conflicts-between-options`."
msgstr ""
"Вказує, що робити, коли параметри з конфліктуючими рядками параметрів "
"додаються до аналізатора; див. розділ :ref:`optparse-conflicts-between-"
"options`."

msgid "``description`` (default: ``None``)"
msgstr "``опис`` (за замовчуванням: ``None``)"

msgid ""
"A paragraph of text giving a brief overview of your program. :mod:`optparse` "
"reformats this paragraph to fit the current terminal width and prints it "
"when the user requests help (after ``usage``, but before the list of "
"options)."
msgstr ""
"Абзац тексту, що дає короткий огляд вашої програми. :mod:`optparse` "
"переформатує цей абзац відповідно до поточної ширини терміналу та друкує "
"його, коли користувач запитує допомогу (після ``використання``, але перед "
"списком параметрів)."

msgid "``formatter`` (default: a new :class:`IndentedHelpFormatter`)"
msgstr "``formatter`` (за замовчуванням: новий :class:`IndentedHelpFormatter`)"

msgid ""
"An instance of optparse.HelpFormatter that will be used for printing help "
"text.  :mod:`optparse` provides two concrete classes for this purpose: "
"IndentedHelpFormatter and TitledHelpFormatter."
msgstr ""
"Екземпляр optparse.HelpFormatter, який використовуватиметься для друку "
"тексту довідки. :mod:`optparse` надає два конкретних класи для цієї мети: "
"IndentedHelpFormatter і TitledHelpFormatter."

msgid "``add_help_option`` (default: ``True``)"
msgstr "``add_help_option`` (за замовчуванням: ``True``)"

msgid ""
"If true, :mod:`optparse` will add a help option (with option strings ``-h`` "
"and ``--help``) to the parser."
msgstr ""
"Якщо істина, :mod:`optparse` додасть параметр довідки (із рядками параметрів "
"``-h`` і ``--help``) до аналізатора."

msgid "``prog``"
msgstr "``програма``"

msgid ""
"The string to use when expanding ``%prog`` in ``usage`` and ``version`` "
"instead of ``os.path.basename(sys.argv[0])``."
msgstr ""
"Рядок для використання під час розширення ``%prog`` у ``usage`` і "
"``version`` замість ``os.path.basename(sys.argv[0])``."

msgid "``epilog`` (default: ``None``)"
msgstr "``епілог`` (за замовчуванням: ``None``)"

msgid "A paragraph of help text to print after the option help."
msgstr "Абзац тексту довідки для друку після довідки параметра."

msgid "Populating the parser"
msgstr "Заповнення аналізатора"

msgid ""
"There are several ways to populate the parser with options.  The preferred "
"way is by using :meth:`OptionParser.add_option`, as shown in section :ref:"
"`optparse-tutorial`.  :meth:`add_option` can be called in one of two ways:"
msgstr ""
"Є кілька способів заповнити аналізатор параметрами. Кращим способом є "
"використання :meth:`OptionParser.add_option`, як показано в розділі :ref:"
"`optparse-tutorial`. :meth:`add_option` можна викликати одним із двох "
"способів:"

msgid "pass it an Option instance (as returned by :func:`make_option`)"
msgstr "передати йому екземпляр Option (як повертає :func:`make_option`)"

msgid ""
"pass it any combination of positional and keyword arguments that are "
"acceptable to :func:`make_option` (i.e., to the Option constructor), and it "
"will create the Option instance for you"
msgstr ""
"передайте йому будь-яку комбінацію позиційних і ключових аргументів, які "
"прийнятні для :func:`make_option` (тобто для конструктора Option), і він "
"створить екземпляр Option для вас"

msgid ""
"The other alternative is to pass a list of pre-constructed Option instances "
"to the OptionParser constructor, as in::"
msgstr ""
"Іншою альтернативою є передача списку попередньо сконструйованих екземплярів "
"Option конструктору OptionParser, як у::"

msgid ""
"(:func:`make_option` is a factory function for creating Option instances; "
"currently it is an alias for the Option constructor.  A future version of :"
"mod:`optparse` may split Option into several classes, and :func:"
"`make_option` will pick the right class to instantiate.  Do not instantiate "
"Option directly.)"
msgstr ""
"(:func:`make_option` є фабричною функцією для створення екземплярів Option; "
"наразі це псевдонім для конструктора Option. Майбутня версія :mod:`optparse` "
"може розділити Option на кілька класів і :func:`make_option` вибере "
"правильний клас для створення екземпляра. Не створюйте екземпляр Option "
"безпосередньо.)"

msgid "Defining options"
msgstr "Визначення варіантів"

msgid ""
"Each Option instance represents a set of synonymous command-line option "
"strings, e.g. ``-f`` and ``--file``.  You can specify any number of short or "
"long option strings, but you must specify at least one overall option string."
msgstr ""
"Кожен екземпляр Option представляє набір синонімічних рядків параметрів "
"командного рядка, напр. ``-f`` і ``--file``. Ви можете вказати будь-яку "
"кількість коротких або довгих рядків параметрів, але ви повинні вказати "
"принаймні один загальний рядок параметрів."

msgid ""
"The canonical way to create an :class:`Option` instance is with the :meth:"
"`add_option` method of :class:`OptionParser`."
msgstr ""
"Канонічним способом створення екземпляра :class:`Option` є метод :meth:"
"`add_option` :class:`OptionParser`."

msgid "To define an option with only a short option string::"
msgstr "Щоб визначити опцію лише за допомогою короткого рядка опції:"

msgid "And to define an option with only a long option string::"
msgstr "І щоб визначити опцію лише з довгим рядком опції::"

msgid ""
"The keyword arguments define attributes of the new Option object.  The most "
"important option attribute is :attr:`~Option.action`, and it largely "
"determines which other attributes are relevant or required.  If you pass "
"irrelevant option attributes, or fail to pass required ones, :mod:`optparse` "
"raises an :exc:`OptionError` exception explaining your mistake."
msgstr ""
"Ключові аргументи визначають атрибути нового об’єкта Option. Найважливішим "
"атрибутом параметра є :attr:`~Option.action`, і він значною мірою визначає, "
"які інші атрибути є доречними або необхідними. Якщо ви передаєте "
"нерелевантні атрибути параметрів або не передаєте необхідні, :mod:`optparse` "
"викликає виняток :exc:`OptionError`, пояснюючи вашу помилку."

msgid ""
"An option's *action* determines what :mod:`optparse` does when it encounters "
"this option on the command-line.  The standard option actions hard-coded "
"into :mod:`optparse` are:"
msgstr ""
"*Дія* параметра визначає, що робить :mod:`optparse`, коли він зустрічає цей "
"параметр у командному рядку. Стандартні дії параметрів, жорстко закодовані "
"в :mod:`optparse`:"

msgid "``\"store\"``"
msgstr "``\"магазин\"``"

msgid "store this option's argument (default)"
msgstr "зберегти аргумент цього параметра (за замовчуванням)"

msgid "``\"store_true\"``"
msgstr "``\"store_true\"``"

msgid "store ``True``"
msgstr "зберігати ``Правда``"

msgid "``\"store_false\"``"
msgstr "``\"store_false\"``"

msgid "store ``False``"
msgstr "зберігати ``False``"

msgid "``\"append_const\"``"
msgstr "``\"append_const\"``"

msgid "append a constant value to a list"
msgstr "додати постійне значення до списку"

msgid "``\"help\"``"
msgstr "``\"допомога\"``"

msgid ""
"print a usage message including all options and the documentation for them"
msgstr ""
"роздрукувати повідомлення про використання, включно з усіма параметрами та "
"документацією до них"

msgid ""
"(If you don't supply an action, the default is ``\"store\"``.  For this "
"action, you may also supply :attr:`~Option.type` and :attr:`~Option.dest` "
"option attributes; see :ref:`optparse-standard-option-actions`.)"
msgstr ""
"(Якщо ви не вказали дію, за замовчуванням буде ``\"store\"``. Для цієї дії "
"ви також можете вказати атрибути параметрів :attr:`~Option.type` і :attr:"
"`~Option.dest` див. :ref:`optparse-standard-option-actions`.)"

msgid ""
"As you can see, most actions involve storing or updating a value somewhere. :"
"mod:`optparse` always creates a special object for this, conventionally "
"called ``options`` (it happens to be an instance of :class:`optparse."
"Values`).  Option arguments (and various other values) are stored as "
"attributes of this object, according to the :attr:`~Option.dest` "
"(destination) option attribute."
msgstr ""
"Як бачите, більшість дій передбачає збереження або оновлення значення десь. :"
"mod:`optparse` завжди створює для цього спеціальний об’єкт, умовно званий "
"``options`` (він є екземпляром :class:`optparse.Values`). Аргументи опції (і "
"різні інші значення) зберігаються як атрибути цього об’єкта відповідно до "
"атрибута опції :attr:`~Option.dest` (призначення)."

msgid "For example, when you call ::"
msgstr "Наприклад, коли ви дзвоните ::"

msgid ""
"one of the first things :mod:`optparse` does is create the ``options`` "
"object::"
msgstr ""
"одна з перших речей, які робить :mod:`optparse`, це створює об’єкт "
"``options``::"

msgid "If one of the options in this parser is defined with ::"
msgstr ""
"Якщо один із параметрів цього синтаксичного аналізатора визначено за "
"допомогою ::"

msgid "and the command-line being parsed includes any of the following::"
msgstr "а командний рядок, що аналізується, містить будь-яке з наступного:"

msgid ""
"then :mod:`optparse`, on seeing this option, will do the equivalent of ::"
msgstr "тоді :mod:`optparse`, побачивши цю опцію, зробить еквівалент::"

msgid ""
"The :attr:`~Option.type` and :attr:`~Option.dest` option attributes are "
"almost as important as :attr:`~Option.action`, but :attr:`~Option.action` is "
"the only one that makes sense for *all* options."
msgstr ""
"Атрибути :attr:`~Option.type` і :attr:`~Option.dest` майже такі ж важливі, "
"як і :attr:`~Option.action`, але :attr:`~Option.action` є єдиним такий, який "
"має сенс для *всіх* варіантів."

msgid "Option attributes"
msgstr "Атрибути варіантів"

msgid ""
"The following option attributes may be passed as keyword arguments to :meth:"
"`OptionParser.add_option`.  If you pass an option attribute that is not "
"relevant to a particular option, or fail to pass a required option "
"attribute, :mod:`optparse` raises :exc:`OptionError`."
msgstr ""
"Наступні атрибути параметрів можна передати як ключові аргументи до :meth:"
"`OptionParser.add_option`. Якщо ви передаєте атрибут опції, який не має "
"відношення до певної опції, або не передаєте потрібний атрибут опції, :mod:"
"`optparse` викликає :exc:`OptionError`."

msgid "(default: ``\"store\"``)"
msgstr "(за замовчуванням: ``\"магазин\"``)"

msgid ""
"Determines :mod:`optparse`'s behaviour when this option is seen on the "
"command line; the available options are documented :ref:`here <optparse-"
"standard-option-actions>`."
msgstr ""
"Визначає поведінку :mod:`optparse`, коли цей параметр відображається в "
"командному рядку; доступні параметри задокументовані :ref:`тут <optparse-"
"standard-option-actions>`."

msgid "(default: ``\"string\"``)"
msgstr "(за замовчуванням: ``\"рядок\"``)"

msgid ""
"The argument type expected by this option (e.g., ``\"string\"`` or "
"``\"int\"``); the available option types are documented :ref:`here <optparse-"
"standard-option-types>`."
msgstr ""
"Тип аргументу, очікуваний цією опцією (наприклад, ``\"string\"`` або "
"``\"int\"``); доступні типи опцій задокументовані :ref:`тут <optparse-"
"standard-option-types>`."

msgid "(default: derived from option strings)"
msgstr "(за замовчуванням: отримано з рядків параметрів)"

msgid ""
"If the option's action implies writing or modifying a value somewhere, this "
"tells :mod:`optparse` where to write it: :attr:`~Option.dest` names an "
"attribute of the ``options`` object that :mod:`optparse` builds as it parses "
"the command line."
msgstr ""
"Якщо дія опції передбачає запис або зміну значення десь, це вказує :mod:"
"`optparse`, де його писати: :attr:`~Option.dest` називає атрибут об’єкта "
"``options``, який :mod:`optparse` збирається, коли аналізує командний рядок."

msgid ""
"The value to use for this option's destination if the option is not seen on "
"the command line.  See also :meth:`OptionParser.set_defaults`."
msgstr ""
"Значення для призначення цього параметра, якщо параметр не відображається в "
"командному рядку. Дивіться також :meth:`OptionParser.set_defaults`."

msgid "(default: 1)"
msgstr "(за замовчуванням: 1)"

msgid ""
"How many arguments of type :attr:`~Option.type` should be consumed when this "
"option is seen.  If > 1, :mod:`optparse` will store a tuple of values to :"
"attr:`~Option.dest`."
msgstr ""
"Скільки аргументів типу :attr:`~Option.type` має споживатися, коли "
"відображається цей параметр. Якщо > 1, :mod:`optparse` зберігатиме кортеж "
"значень у :attr:`~Option.dest`."

msgid "For actions that store a constant value, the constant value to store."
msgstr ""
"Для дій, які зберігають постійне значення, постійне значення для збереження."

msgid ""
"For options of type ``\"choice\"``, the list of strings the user may choose "
"from."
msgstr ""
"Для параметрів типу ``\"вибір\"``, список рядків, з яких користувач може "
"вибрати."

msgid ""
"For options with action ``\"callback\"``, the callable to call when this "
"option is seen.  See section :ref:`optparse-option-callbacks` for detail on "
"the arguments passed to the callable."
msgstr ""
"Для параметрів із дією ``\"callback\"``, виклик якого потрібно викликати, "
"коли цей параметр видно. Дивіться розділ :ref:`optparse-option-callbacks` "
"для детальної інформації про аргументи, які передаються викликаному."

msgid ""
"Additional positional and keyword arguments to pass to ``callback`` after "
"the four standard callback arguments."
msgstr ""
"Додаткові позиційні та ключові аргументи для передачі в ``callback`` після "
"чотирьох стандартних аргументів зворотного виклику."

msgid ""
"Help text to print for this option when listing all available options after "
"the user supplies a :attr:`~Option.help` option (such as ``--help``).  If no "
"help text is supplied, the option will be listed without help text.  To hide "
"this option, use the special value :data:`optparse.SUPPRESS_HELP`."
msgstr ""
"Текст довідки, який потрібно надрукувати для цього параметра, коли "
"перераховуються всі доступні параметри після того, як користувач введе "
"параметр :attr:`~Option.help` (наприклад, ``--help``). Якщо текст довідки не "
"надано, параметр буде показано без тексту довідки. Щоб приховати цей "
"параметр, використовуйте спеціальне значення :data:`optparse.SUPPRESS_HELP`."

msgid ""
"Stand-in for the option argument(s) to use when printing help text.  See "
"section :ref:`optparse-tutorial` for an example."
msgstr ""
"Заміна аргументу(ів) опції для використання під час друку довідкового "
"тексту. Перегляньте розділ :ref:`optparse-tutorial` для прикладу."

msgid "Standard option actions"
msgstr "Стандартні опційні дії"

msgid ""
"The various option actions all have slightly different requirements and "
"effects. Most actions have several relevant option attributes which you may "
"specify to guide :mod:`optparse`'s behaviour; a few have required "
"attributes, which you must specify for any option using that action."
msgstr ""
"Усі різні опціональні дії мають дещо різні вимоги та наслідки. Більшість дій "
"мають кілька відповідних атрибутів параметрів, які ви можете вказати, щоб "
"керувати поведінкою :mod:`optparse`; деякі з них мають обов’язкові атрибути, "
"які ви повинні вказати для будь-якої опції, що використовує цю дію."

msgid ""
"``\"store\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"магазин\"`` [релевантний: :attr:`~Option.type`, :attr:`~Option.dest`, :"
"attr:`~Option.nargs`, :attr:`~Option.choices`]"

msgid ""
"The option must be followed by an argument, which is converted to a value "
"according to :attr:`~Option.type` and stored in :attr:`~Option.dest`.  If :"
"attr:`~Option.nargs` > 1, multiple arguments will be consumed from the "
"command line; all will be converted according to :attr:`~Option.type` and "
"stored to :attr:`~Option.dest` as a tuple.  See the :ref:`optparse-standard-"
"option-types` section."
msgstr ""
"За параметром має слідувати аргумент, який перетворюється на значення "
"відповідно до :attr:`~Option.type` і зберігається в :attr:`~Option.dest`. "
"Якщо :attr:`~Option.nargs` > 1, з командного рядка буде використано кілька "
"аргументів; усе буде перетворено відповідно до :attr:`~Option.type` і "
"збережено в :attr:`~Option.dest` як кортеж. Перегляньте розділ :ref:"
"`optparse-standard-option-types`."

msgid ""
"If :attr:`~Option.choices` is supplied (a list or tuple of strings), the "
"type defaults to ``\"choice\"``."
msgstr ""
"Якщо надано :attr:`~Option.choices` (список або кортеж рядків), типом за "
"замовчуванням є ``\"choice\"``."

msgid "If :attr:`~Option.type` is not supplied, it defaults to ``\"string\"``."
msgstr ""
"Якщо :attr:`~Option.type` не вказано, за замовчуванням буде ``\"string\"``."

msgid ""
"If :attr:`~Option.dest` is not supplied, :mod:`optparse` derives a "
"destination from the first long option string (e.g., ``--foo-bar`` implies "
"``foo_bar``). If there are no long option strings, :mod:`optparse` derives a "
"destination from the first short option string (e.g., ``-f`` implies ``f``)."
msgstr ""
"Якщо :attr:`~Option.dest` не надано, :mod:`optparse` отримує призначення з "
"першого довгого рядка параметрів (наприклад, ``--foo-bar`` передбачає "
"``foo_bar``). Якщо довгих рядків параметрів немає, :mod:`optparse` отримує "
"адресат із першого короткого рядка параметрів (наприклад, ``-f`` означає "
"``f``)."

msgid "Example::"
msgstr "Приклад::"

msgid "As it parses the command line ::"
msgstr "Під час аналізу командного рядка ::"

msgid ":mod:`optparse` will set ::"
msgstr ":mod:`optparse` встановить ::"

msgid ""
"``\"store_const\"`` [required: :attr:`~Option.const`; relevant: :attr:"
"`~Option.dest`]"
msgstr ""
"``\"store_const\"`` [потрібно: :attr:`~Option.const`; релевантний: :attr:"
"`~Option.dest`]"

msgid "The value :attr:`~Option.const` is stored in :attr:`~Option.dest`."
msgstr "Значення :attr:`~Option.const` зберігається в :attr:`~Option.dest`."

msgid "If ``--noisy`` is seen, :mod:`optparse` will set  ::"
msgstr "Якщо відображається ``--noisy``, :mod:`optparse` встановить ::"

msgid "``\"store_true\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_true\"`` [релевантний: :attr:`~Option.dest`]"

msgid ""
"A special case of ``\"store_const\"`` that stores ``True`` to :attr:`~Option."
"dest`."
msgstr ""
"Особливий випадок ``\"store_const\"``, який зберігає ``True`` у :attr:"
"`~Option.dest`."

msgid "``\"store_false\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"store_false\"`` [релевантний: :attr:`~Option.dest`]"

msgid "Like ``\"store_true\"``, but stores ``False``."
msgstr "Подібно до ``\"store_true\"``, але зберігає ``False``."

msgid ""
"``\"append\"`` [relevant: :attr:`~Option.type`, :attr:`~Option.dest`, :attr:"
"`~Option.nargs`, :attr:`~Option.choices`]"
msgstr ""
"``\"append\"`` [релевантні: :attr:`~Option.type`, :attr:`~Option.dest`, :"
"attr:`~Option.nargs`, :attr:`~Option.choices`]"

msgid ""
"The option must be followed by an argument, which is appended to the list "
"in :attr:`~Option.dest`.  If no default value for :attr:`~Option.dest` is "
"supplied, an empty list is automatically created when :mod:`optparse` first "
"encounters this option on the command-line.  If :attr:`~Option.nargs` > 1, "
"multiple arguments are consumed, and a tuple of length :attr:`~Option.nargs` "
"is appended to :attr:`~Option.dest`."
msgstr ""
"За параметром має слідувати аргумент, який додається до списку в :attr:"
"`~Option.dest`. Якщо значення за замовчуванням для :attr:`~Option.dest` не "
"вказано, порожній список створюється автоматично, коли :mod:`optparse` "
"вперше зустрічає цей параметр у командному рядку. Якщо :attr:`~Option.nargs` "
"> 1, споживаються кілька аргументів, а кортеж довжини :attr:`~Option.nargs` "
"додається до :attr:`~Option.dest`."

msgid ""
"The defaults for :attr:`~Option.type` and :attr:`~Option.dest` are the same "
"as for the ``\"store\"`` action."
msgstr ""
"Значення за замовчуванням для :attr:`~Option.type` і :attr:`~Option.dest` "
"такі самі, як і для дії ``\"store\"``."

msgid ""
"If ``-t3`` is seen on the command-line, :mod:`optparse` does the equivalent "
"of::"
msgstr ""
"Якщо в командному рядку відображається ``-t3``, :mod:`optparse` виконує "
"еквівалент:"

msgid "If, a little later on, ``--tracks=4`` is seen, it does::"
msgstr "Якщо трохи пізніше з’явиться ``--tracks=4``, це так:"

msgid ""
"The ``append`` action calls the ``append`` method on the current value of "
"the option.  This means that any default value specified must have an "
"``append`` method.  It also means that if the default value is non-empty, "
"the default elements will be present in the parsed value for the option, "
"with any values from the command line appended after those default values::"
msgstr ""
"Дія ``append`` викликає метод ``append`` для поточного значення опції. Це "
"означає, що будь-яке вказане значення за замовчуванням повинно мати метод "
"``додавання``. Це також означає, що якщо значення за замовчуванням не є "
"порожнім, елементи за замовчуванням будуть присутні в розібраному значенні "
"для параметра, а будь-які значення з командного рядка будуть додані після "
"цих значень за замовчуванням::"

msgid ""
"``\"append_const\"`` [required: :attr:`~Option.const`; relevant: :attr:"
"`~Option.dest`]"
msgstr ""
"``\"append_const\"`` [потрібно: :attr:`~Option.const`; релевантний: :attr:"
"`~Option.dest`]"

msgid ""
"Like ``\"store_const\"``, but the value :attr:`~Option.const` is appended "
"to :attr:`~Option.dest`; as with ``\"append\"``, :attr:`~Option.dest` "
"defaults to ``None``, and an empty list is automatically created the first "
"time the option is encountered."
msgstr ""
"Як ``\"store_const\"``, але значення :attr:`~Option.const` додається до :"
"attr:`~Option.dest`; як і у випадку з ``\"append\"``, :attr:`~Option.dest` "
"за замовчуванням має значення ``None``, і порожній список автоматично "
"створюється, коли вперше зустрічається опція."

msgid "``\"count\"`` [relevant: :attr:`~Option.dest`]"
msgstr "``\"count\"`` [relevant: :attr:`~Option.dest`]"

msgid ""
"Increment the integer stored at :attr:`~Option.dest`.  If no default value "
"is supplied, :attr:`~Option.dest` is set to zero before being incremented "
"the first time."
msgstr ""
"Збільшити ціле число, що зберігається в :attr:`~Option.dest`. Якщо значення "
"за замовчуванням не вказано, :attr:`~Option.dest` встановлюється на нуль "
"перед першим збільшенням."

msgid ""
"The first time ``-v`` is seen on the command line, :mod:`optparse` does the "
"equivalent of::"
msgstr ""
"Коли ``-v`` з'являється в командному рядку вперше, :mod:`optparse` виконує "
"еквівалент:"

msgid "Every subsequent occurrence of ``-v`` results in  ::"
msgstr "Кожне наступне повторення ``-v`` призводить до:"

msgid ""
"``\"callback\"`` [required: :attr:`~Option.callback`; relevant: :attr:"
"`~Option.type`, :attr:`~Option.nargs`, :attr:`~Option.callback_args`, :attr:"
"`~Option.callback_kwargs`]"
msgstr ""
"``\"callback\"`` [потрібно: :attr:`~Option.callback`; релевантні: :attr:"
"`~Option.type`, :attr:`~Option.nargs`, :attr:`~Option.callback_args`, :attr:"
"`~Option.callback_kwargs`]"

msgid ""
"Call the function specified by :attr:`~Option.callback`, which is called "
"as ::"
msgstr ""
"Виклик функції, визначеної :attr:`~Option.callback`, яка викликається як ::"

msgid "See section :ref:`optparse-option-callbacks` for more detail."
msgstr ""
"Дивіться розділ :ref:`optparse-option-callbacks` для більш детальної "
"інформації."

msgid ""
"Prints a complete help message for all the options in the current option "
"parser.  The help message is constructed from the ``usage`` string passed to "
"OptionParser's constructor and the :attr:`~Option.help` string passed to "
"every option."
msgstr ""
"Друкує повне довідкове повідомлення для всіх параметрів у поточному "
"аналізаторі параметрів. Повідомлення довідки складається з рядка ``usage``, "
"переданого конструктору OptionParser, і рядка :attr:`~Option.help`, "
"переданого кожному параметру."

msgid ""
"If no :attr:`~Option.help` string is supplied for an option, it will still "
"be listed in the help message.  To omit an option entirely, use the special "
"value :data:`optparse.SUPPRESS_HELP`."
msgstr ""
"Якщо для параметра не надано рядок :attr:`~Option.help`, він все одно буде "
"вказаний у повідомленні довідки. Щоб повністю пропустити опцію, "
"використовуйте спеціальне значення :data:`optparse.SUPPRESS_HELP`."

msgid ""
":mod:`optparse` automatically adds a :attr:`~Option.help` option to all "
"OptionParsers, so you do not normally need to create one."
msgstr ""
":mod:`optparse` автоматично додає опцію :attr:`~Option.help` до всіх "
"аналізаторів опцій, тому зазвичай вам не потрібно її створювати."

msgid ""
"If :mod:`optparse` sees either ``-h`` or ``--help`` on the command line, it "
"will print something like the following help message to stdout (assuming "
"``sys.argv[0]`` is ``\"foo.py\"``):"
msgstr ""
"Якщо :mod:`optparse` бачить або ``-h``, або ``--help`` у командному рядку, "
"він надрукує щось на кшталт наступного довідкового повідомлення до stdout "
"(за умови ``sys.argv[0]`).` є ``\"foo.py\"``):"

msgid ""
"After printing the help message, :mod:`optparse` terminates your process "
"with ``sys.exit(0)``."
msgstr ""
"Після друку довідкового повідомлення :mod:`optparse` завершує ваш процес за "
"допомогою ``sys.exit(0)``."

msgid "``\"version\"``"
msgstr "``\"версія\"``"

msgid ""
"Prints the version number supplied to the OptionParser to stdout and exits. "
"The version number is actually formatted and printed by the "
"``print_version()`` method of OptionParser.  Generally only relevant if the "
"``version`` argument is supplied to the OptionParser constructor.  As with :"
"attr:`~Option.help` options, you will rarely create ``version`` options, "
"since :mod:`optparse` automatically adds them when needed."
msgstr ""
"Друкує номер версії, наданий OptionParser, у stdout і завершує роботу. Номер "
"версії фактично форматується та друкується методом ``print_version()`` "
"OptionParser. Зазвичай актуально, лише якщо аргумент ``version`` надається "
"конструктору OptionParser. Як і у випадку з параметрами :attr:`~Option."
"help`, ви рідко будете створювати параметри ``version``, оскільки :mod:"
"`optparse` автоматично додає їх за потреби."

msgid "Standard option types"
msgstr "Типи стандартних варіантів"

msgid ""
":mod:`optparse` has five built-in option types: ``\"string\"``, ``\"int\"``, "
"``\"choice\"``, ``\"float\"`` and ``\"complex\"``.  If you need to add new "
"option types, see section :ref:`optparse-extending-optparse`."
msgstr ""
":mod:`optparse` має п’ять вбудованих типів параметрів: ``\"string\"``, "
"``\"int\"``, ``\"choice\"``, ``\"float\"`` і ``\"complex \"``. Якщо вам "
"потрібно додати нові типи опцій, перегляньте розділ :ref:`optparse-extending-"
"optparse`."

msgid ""
"Arguments to string options are not checked or converted in any way: the "
"text on the command line is stored in the destination (or passed to the "
"callback) as-is."
msgstr ""
"Аргументи параметрів рядка не перевіряються та не перетворюються жодним "
"чином: текст у командному рядку зберігається в місці призначення (або "
"передається зворотному виклику) як є."

msgid "Integer arguments (type ``\"int\"``) are parsed as follows:"
msgstr "Цілі аргументи (тип ``\"int\"``) аналізуються таким чином:"

msgid "if the number starts with ``0x``, it is parsed as a hexadecimal number"
msgstr ""
"якщо число починається з ``0x``, воно аналізується як шістнадцяткове число"

msgid "if the number starts with ``0``, it is parsed as an octal number"
msgstr "якщо число починається з ``0``, воно аналізується як вісімкове число"

msgid "if the number starts with ``0b``, it is parsed as a binary number"
msgstr "якщо число починається з ``0b``, воно аналізується як двійкове число"

msgid "otherwise, the number is parsed as a decimal number"
msgstr "інакше число аналізується як десяткове число"

msgid ""
"The conversion is done by calling :func:`int` with the appropriate base (2, "
"8, 10, or 16).  If this fails, so will :mod:`optparse`, although with a more "
"useful error message."
msgstr ""
"Перетворення виконується викликом :func:`int` із відповідною основою (2, 8, "
"10 або 16). Якщо це не вдасться, не вийде і :mod:`optparse`, хоча з більш "
"корисним повідомленням про помилку."

msgid ""
"``\"float\"`` and ``\"complex\"`` option arguments are converted directly "
"with :func:`float` and :func:`complex`, with similar error-handling."
msgstr ""
"Аргументи параметрів ``\"float\"`` і ``\"complex\"`` перетворюються "
"безпосередньо за допомогою :func:`float` і :func:`complex`, з подібною "
"обробкою помилок."

msgid ""
"``\"choice\"`` options are a subtype of ``\"string\"`` options.  The :attr:"
"`~Option.choices` option attribute (a sequence of strings) defines the set "
"of allowed option arguments.  :func:`optparse.check_choice` compares user-"
"supplied option arguments against this master list and raises :exc:"
"`OptionValueError` if an invalid string is given."
msgstr ""
"Опції ``\"choice\"`` є підтипом опцій ``\"string\"``. Атрибут опції :attr:"
"`~Option.choices` (послідовність рядків) визначає набір дозволених "
"аргументів опції. :func:`optparse.check_choice` порівнює аргументи "
"параметрів, надані користувачем, із цим головним списком і викликає :exc:"
"`OptionValueError`, якщо вказано недійсний рядок."

msgid "Parsing arguments"
msgstr "Розбір аргументів"

msgid ""
"The whole point of creating and populating an OptionParser is to call its :"
"meth:`parse_args` method::"
msgstr ""
"Суть створення та заповнення OptionParser полягає у виклику його методу :"
"meth:`parse_args`::"

msgid "where the input parameters are"
msgstr "де знаходяться вхідні параметри"

msgid "``args``"
msgstr "``args``"

msgid "the list of arguments to process (default: ``sys.argv[1:]``)"
msgstr "список аргументів для обробки (за замовчуванням: ``sys.argv[1:]``)"

msgid "``values``"
msgstr "``значення``"

msgid ""
"an :class:`optparse.Values` object to store option arguments in (default: a "
"new instance of :class:`Values`) -- if you give an existing object, the "
"option defaults will not be initialized on it"
msgstr ""
"об’єкт :class:`optparse.Values` для зберігання аргументів параметрів (за "
"замовчуванням: новий екземпляр :class:`Values`) -- якщо ви надаєте існуючий "
"об’єкт, параметри за замовчуванням не будуть ініціалізовані на ньому"

msgid "and the return values are"
msgstr "і повертаються значення"

msgid "``options``"
msgstr "``параметри``"

msgid ""
"the same object that was passed in as ``values``, or the optparse.Values "
"instance created by :mod:`optparse`"
msgstr ""
"той самий об’єкт, який було передано як ``values``, або екземпляр optparse."
"Values, створений :mod:`optparse`"

msgid "the leftover positional arguments after all options have been processed"
msgstr "залишкові позиційні аргументи після обробки всіх опцій"

msgid ""
"The most common usage is to supply neither keyword argument.  If you supply "
"``values``, it will be modified with repeated :func:`setattr` calls (roughly "
"one for every option argument stored to an option destination) and returned "
"by :meth:`parse_args`."
msgstr ""
"Найпоширенішим використанням є відсутність аргументів ключового слова. Якщо "
"ви вкажете ``значення``, воно буде змінено за допомогою повторних викликів :"
"func:`setattr` (приблизно по одному для кожного аргументу опції, збереженого "
"в цільовій опції) і повернено :meth:`parse_args`."

msgid ""
"If :meth:`parse_args` encounters any errors in the argument list, it calls "
"the OptionParser's :meth:`error` method with an appropriate end-user error "
"message. This ultimately terminates your process with an exit status of 2 "
"(the traditional Unix exit status for command-line errors)."
msgstr ""
"Якщо :meth:`parse_args` зустрічає будь-які помилки в списку аргументів, він "
"викликає метод :meth:`error` OptionParser з відповідним повідомленням про "
"помилку кінцевого користувача. Це остаточно завершує ваш процес із статусом "
"виходу 2 (традиційний статус виходу Unix для помилок командного рядка)."

msgid "Querying and manipulating your option parser"
msgstr "Запити та маніпулювання вашим аналізатором параметрів"

msgid ""
"The default behavior of the option parser can be customized slightly, and "
"you can also poke around your option parser and see what's there.  "
"OptionParser provides several methods to help you out:"
msgstr ""
"Поведінку аналізатора параметрів за замовчуванням можна дещо налаштувати, і "
"ви також можете пошукати свій аналізатор параметрів і подивитися, що там є. "
"OptionParser пропонує кілька методів, які допоможуть вам:"

msgid ""
"Set parsing to stop on the first non-option.  For example, if ``-a`` and ``-"
"b`` are both simple options that take no arguments, :mod:`optparse` normally "
"accepts this syntax::"
msgstr ""
"Встановіть зупинку аналізу на першому варіанті. Наприклад, якщо ``-a`` і ``-"
"b`` є простими параметрами, які не приймають аргументів, :mod:`optparse` "
"зазвичай приймає такий синтаксис::"

msgid "and treats it as equivalent to  ::"
msgstr "і розглядає його як еквівалент ::"

msgid ""
"To disable this feature, call :meth:`disable_interspersed_args`.  This "
"restores traditional Unix syntax, where option parsing stops with the first "
"non-option argument."
msgstr ""
"Щоб вимкнути цю функцію, викличте :meth:`disable_interspersed_args`. Це "
"відновлює традиційний синтаксис Unix, де розбір параметрів припиняється з "
"першим аргументом, що не є параметром."

msgid ""
"Use this if you have a command processor which runs another command which "
"has options of its own and you want to make sure these options don't get "
"confused.  For example, each command might have a different set of options."
msgstr ""
"Використовуйте це, якщо у вас є командний процесор, який виконує іншу "
"команду, яка має власні параметри, і ви хочете переконатися, що ці параметри "
"не плутаються. Наприклад, кожна команда може мати різний набір параметрів."

msgid ""
"Set parsing to not stop on the first non-option, allowing interspersing "
"switches with command arguments.  This is the default behavior."
msgstr ""
"Налаштуйте розбір так, щоб він не зупинявся на першому не-параметрі, "
"дозволяючи вставляти перемикачі в аргументи команди. Це типова поведінка."

msgid ""
"Returns the Option instance with the option string *opt_str*, or ``None`` if "
"no options have that option string."
msgstr ""
"Повертає екземпляр Option із рядком параметра *opt_str* або ``None``, якщо "
"параметри не мають такого рядка параметра."

msgid ""
"Return ``True`` if the OptionParser has an option with option string "
"*opt_str* (e.g., ``-q`` or ``--verbose``)."
msgstr ""
"Повертає ``True``, якщо OptionParser має параметр із рядком параметра "
"*opt_str* (наприклад, ``-q`` або ``--verbose``)."

msgid ""
"If the :class:`OptionParser` has an option corresponding to *opt_str*, that "
"option is removed.  If that option provided any other option strings, all of "
"those option strings become invalid. If *opt_str* does not occur in any "
"option belonging to this :class:`OptionParser`, raises :exc:`ValueError`."
msgstr ""
"Якщо :class:`OptionParser` має параметр, що відповідає *opt_str*, цей "
"параметр буде видалено. Якщо цей параметр містить будь-які інші рядки "
"параметрів, усі ці рядки параметрів стають недійсними. Якщо *opt_str* не "
"зустрічається в жодному параметрі, що належить цьому :class:`OptionParser`, "
"викликає :exc:`ValueError`."

msgid "Conflicts between options"
msgstr "Конфлікти між варіантами"

msgid ""
"If you're not careful, it's easy to define options with conflicting option "
"strings::"
msgstr ""
"Якщо ви не будете обережні, можна легко визначити параметри з конфліктуючими "
"рядками параметрів::"

msgid ""
"(This is particularly true if you've defined your own OptionParser subclass "
"with some standard options.)"
msgstr ""
"(Це особливо вірно, якщо ви визначили свій власний підклас OptionParser з "
"деякими стандартними параметрами.)"

msgid ""
"Every time you add an option, :mod:`optparse` checks for conflicts with "
"existing options.  If it finds any, it invokes the current conflict-handling "
"mechanism. You can set the conflict-handling mechanism either in the "
"constructor::"
msgstr ""
"Кожного разу, коли ви додаєте опцію, :mod:`optparse` перевіряє наявність "
"конфліктів із існуючими опціями. Якщо він знайде будь-який, він викликає "
"поточний механізм обробки конфліктів. Ви можете встановити механізм обробки "
"конфліктів у конструкторі:"

msgid "or with a separate call::"
msgstr "або окремим дзвінком::"

msgid "The available conflict handlers are:"
msgstr "Доступні засоби обробки конфліктів:"

msgid "``\"error\"`` (default)"
msgstr "``\"помилка\"`` (за замовчуванням)"

msgid ""
"assume option conflicts are a programming error and raise :exc:"
"`OptionConflictError`"
msgstr ""
"припустити, що конфлікти параметрів є помилкою програмування, і викликати :"
"exc:`OptionConflictError`"

msgid "``\"resolve\"``"
msgstr "``\"розв'язати\"``"

msgid "resolve option conflicts intelligently (see below)"
msgstr "розумно вирішувати конфлікти варіантів (див. нижче)"

msgid ""
"As an example, let's define an :class:`OptionParser` that resolves conflicts "
"intelligently and add conflicting options to it::"
msgstr ""
"Як приклад, давайте визначимо :class:`OptionParser`, який розумно вирішує "
"конфлікти, і додамо до нього конфліктуючі параметри::"

msgid ""
"At this point, :mod:`optparse` detects that a previously added option is "
"already using the ``-n`` option string.  Since ``conflict_handler`` is "
"``\"resolve\"``, it resolves the situation by removing ``-n`` from the "
"earlier option's list of option strings.  Now ``--dry-run`` is the only way "
"for the user to activate that option.  If the user asks for help, the help "
"message will reflect that::"
msgstr ""

msgid ""
"It's possible to whittle away the option strings for a previously added "
"option until there are none left, and the user has no way of invoking that "
"option from the command-line.  In that case, :mod:`optparse` removes that "
"option completely, so it doesn't show up in help text or anywhere else. "
"Carrying on with our existing OptionParser::"
msgstr ""

msgid ""
"At this point, the original ``-n``/``--dry-run`` option is no longer "
"accessible, so :mod:`optparse` removes it, leaving this help text::"
msgstr ""
"На цьому етапі вихідний параметр ``-n``/``--dry-run`` більше не доступний, "
"тому :mod:`optparse` видаляє його, залишаючи цей текст довідки::"

msgid "Cleanup"
msgstr "Прибирати"

msgid ""
"OptionParser instances have several cyclic references.  This should not be a "
"problem for Python's garbage collector, but you may wish to break the cyclic "
"references explicitly by calling :meth:`~OptionParser.destroy` on your "
"OptionParser once you are done with it.  This is particularly useful in long-"
"running applications where large object graphs are reachable from your "
"OptionParser."
msgstr ""
"Екземпляри OptionParser мають кілька циклічних посилань. Це не повинно бути "
"проблемою для збирача сміття Python, але ви можете розірвати циклічні "
"посилання явно, викликавши :meth:`~OptionParser.destroy` на вашому "
"OptionParser, коли ви закінчите з цим. Це особливо корисно в довготривалих "
"програмах, де великі об’єктні графіки доступні з вашого OptionParser."

msgid "Other methods"
msgstr "Інші методи"

msgid "OptionParser supports several other public methods:"
msgstr "OptionParser підтримує кілька інших публічних методів:"

msgid ""
"Set the usage string according to the rules described above for the "
"``usage`` constructor keyword argument.  Passing ``None`` sets the default "
"usage string; use :data:`optparse.SUPPRESS_USAGE` to suppress a usage "
"message."
msgstr ""
"Встановіть рядок використання відповідно до правил, описаних вище для "
"ключового аргументу конструктора ``usage``. Передача ``None`` встановлює "
"рядок використання за умовчанням; використовуйте :data:`optparse."
"SUPPRESS_USAGE` для придушення повідомлення про використання."

msgid ""
"Print the usage message for the current program (``self.usage``) to *file* "
"(default stdout).  Any occurrence of the string ``%prog`` in ``self.usage`` "
"is replaced with the name of the current program.  Does nothing if ``self."
"usage`` is empty or not defined."
msgstr ""
"Надрукувати повідомлення про використання для поточної програми (``self."
"usage``) у *файл* (стандартний вихід за замовчуванням). Будь-яке входження "
"рядка ``%prog`` у ``self.usage`` замінюється назвою поточної програми. "
"Нічого не робить, якщо ``self.usage`` порожній або не визначений."

msgid ""
"Same as :meth:`print_usage` but returns the usage string instead of printing "
"it."
msgstr ""
"Те саме, що :meth:`print_usage`, але повертає рядок використання замість "
"його друку."

msgid ""
"Set default values for several option destinations at once.  Using :meth:"
"`set_defaults` is the preferred way to set default values for options, since "
"multiple options can share the same destination.  For example, if several "
"\"mode\" options all set the same destination, any one of them can set the "
"default, and the last one wins::"
msgstr ""
"Встановіть значення за замовчуванням для кількох пунктів призначення "
"одночасно. Використання :meth:`set_defaults` є кращим способом встановлення "
"значень за замовчуванням для параметрів, оскільки кілька параметрів можуть "
"мати одне призначення. Наприклад, якщо кілька параметрів \"режиму\" "
"встановлюють одне й те саме призначення, будь-який із них може встановити "
"значення за замовчуванням, і виграє останній:"

msgid "To avoid this confusion, use :meth:`set_defaults`::"
msgstr "Щоб уникнути цієї плутанини, використовуйте :meth:`set_defaults`::"

msgid "Option Callbacks"
msgstr "Опція зворотних викликів"

msgid ""
"When :mod:`optparse`'s built-in actions and types aren't quite enough for "
"your needs, you have two choices: extend :mod:`optparse` or define a "
"callback option. Extending :mod:`optparse` is more general, but overkill for "
"a lot of simple cases.  Quite often a simple callback is all you need."
msgstr ""
"Якщо вбудованих дій і типів :mod:`optparse` недостатньо для ваших потреб, у "
"вас є два варіанти: розширити :mod:`optparse` або визначити опцію зворотного "
"виклику. Розширення :mod:`optparse` є більш загальним, але надмірним для "
"багатьох простих випадків. Досить часто простий зворотний дзвінок - це все, "
"що вам потрібно."

msgid "There are two steps to defining a callback option:"
msgstr "Існує два кроки, щоб визначити опцію зворотного виклику:"

msgid "define the option itself using the ``\"callback\"`` action"
msgstr "визначте саму опцію за допомогою дії ``\"callback\"``"

msgid ""
"write the callback; this is a function (or method) that takes at least four "
"arguments, as described below"
msgstr ""
"написати зворотний дзвінок; це функція (або метод), яка приймає щонайменше "
"чотири аргументи, як описано нижче"

msgid "Defining a callback option"
msgstr "Визначення опції зворотного виклику"

msgid ""
"As always, the easiest way to define a callback option is by using the :meth:"
"`OptionParser.add_option` method.  Apart from :attr:`~Option.action`, the "
"only option attribute you must specify is ``callback``, the function to "
"call::"
msgstr ""
"Як завжди, найпростішим способом визначення опції зворотного виклику є "
"використання методу :meth:`OptionParser.add_option`. Окрім :attr:`~Option."
"action`, єдиним атрибутом параметра, який ви повинні вказати, є "
"``callback``, функція для виклику::"

msgid ""
"``callback`` is a function (or other callable object), so you must have "
"already defined ``my_callback()`` when you create this callback option. In "
"this simple case, :mod:`optparse` doesn't even know if ``-c`` takes any "
"arguments, which usually means that the option takes no arguments---the mere "
"presence of ``-c`` on the command-line is all it needs to know.  In some "
"circumstances, though, you might want your callback to consume an arbitrary "
"number of command-line arguments.  This is where writing callbacks gets "
"tricky; it's covered later in this section."
msgstr ""
"``callback`` є функцією (або іншим викликаним об'єктом), тому ви повинні вже "
"визначати ``my_callback()``, створюючи цю опцію зворотного виклику. У цьому "
"простому випадку :mod:`optparse` навіть не знає, чи ``-c`` приймає будь-які "
"аргументи, що зазвичай означає, що опція не приймає аргументів --- сама "
"наявність ``-c`` на командний рядок — це все, що йому потрібно знати. Проте "
"за деяких обставин ви можете захотіти, щоб ваш зворотній виклик споживав "
"довільну кількість аргументів командного рядка. Тут написання зворотних "
"викликів стає складним; це розглянуто далі в цьому розділі."

msgid ""
":mod:`optparse` always passes four particular arguments to your callback, "
"and it will only pass additional arguments if you specify them via :attr:"
"`~Option.callback_args` and :attr:`~Option.callback_kwargs`.  Thus, the "
"minimal callback function signature is::"
msgstr ""
":mod:`optparse` завжди передає чотири конкретні аргументи вашому зворотному "
"виклику, і він передасть додаткові аргументи, лише якщо ви вкажете їх через :"
"attr:`~Option.callback_args` і :attr:`~Option.callback_kwargs`. Таким чином, "
"мінімальна сигнатура функції зворотного виклику:"

msgid "The four arguments to a callback are described below."
msgstr "Чотири аргументи зворотного виклику описані нижче."

msgid ""
"There are several other option attributes that you can supply when you "
"define a callback option:"
msgstr ""
"Є кілька інших атрибутів опції, які ви можете надати, коли визначаєте опцію "
"зворотного виклику:"

msgid ":attr:`~Option.type`"
msgstr ":attr:`~Option.type`"

msgid ""
"has its usual meaning: as with the ``\"store\"`` or ``\"append\"`` actions, "
"it instructs :mod:`optparse` to consume one argument and convert it to :attr:"
"`~Option.type`.  Rather than storing the converted value(s) anywhere, "
"though, :mod:`optparse` passes it to your callback function."
msgstr ""
"має своє звичайне значення: як і з діями ``\"store\"`` або ``\"append\"``, "
"воно наказує :mod:`optparse` споживати один аргумент і перетворювати його "
"на :attr:`~Option.type` . Замість того, щоб десь зберігати перетворені "
"значення, :mod:`optparse` передає їх вашій функції зворотного виклику."

msgid ":attr:`~Option.nargs`"
msgstr ":attr:`~Option.nargs`"

msgid ""
"also has its usual meaning: if it is supplied and > 1, :mod:`optparse` will "
"consume :attr:`~Option.nargs` arguments, each of which must be convertible "
"to :attr:`~Option.type`.  It then passes a tuple of converted values to your "
"callback."
msgstr ""
"також має своє звичайне значення: якщо його надано та > 1, :mod:`optparse` "
"споживатиме аргументи :attr:`~Option.nargs`, кожен із яких має бути "
"конвертованим у :attr:`~Option.type`. Потім він передає кортеж перетворених "
"значень у ваш зворотній виклик."

msgid ":attr:`~Option.callback_args`"
msgstr ":attr:`~Option.callback_args`"

msgid "a tuple of extra positional arguments to pass to the callback"
msgstr ""
"кортеж додаткових позиційних аргументів для передачі зворотному виклику"

msgid ":attr:`~Option.callback_kwargs`"
msgstr ":attr:`~Option.callback_kwargs`"

msgid "a dictionary of extra keyword arguments to pass to the callback"
msgstr "словник додаткових ключових аргументів для передачі зворотному виклику"

msgid "How callbacks are called"
msgstr "Як називаються зворотні виклики"

msgid "All callbacks are called as follows::"
msgstr "Усі зворотні виклики викликаються наступним чином:"

msgid "``option``"
msgstr "``опція``"

msgid "is the Option instance that's calling the callback"
msgstr "це екземпляр Option, який викликає зворотний виклик"

msgid "``opt_str``"
msgstr "``opt_str``"

msgid ""
"is the option string seen on the command-line that's triggering the "
"callback. (If an abbreviated long option was used, ``opt_str`` will be the "
"full, canonical option string---e.g. if the user puts ``--foo`` on the "
"command-line as an abbreviation for ``--foobar``, then ``opt_str`` will be "
"``\"--foobar\"``.)"
msgstr ""
"це рядок параметрів, який можна побачити в командному рядку, який запускає "
"зворотний виклик. (Якщо використовувався скорочений довгий параметр, "
"``opt_str`` буде повним, канонічним рядком параметра --- наприклад, якщо "
"користувач розміщує ``--foo`` у командному рядку як скорочення для ``-- "
"foobar``, тоді ``opt_str`` буде ``\"--foobar\"``.)"

msgid "``value``"
msgstr "``значення``"

msgid ""
"is the argument to this option seen on the command-line.  :mod:`optparse` "
"will only expect an argument if :attr:`~Option.type` is set; the type of "
"``value`` will be the type implied by the option's type.  If :attr:`~Option."
"type` for this option is ``None`` (no argument expected), then ``value`` "
"will be ``None``.  If :attr:`~Option.nargs` > 1, ``value`` will be a tuple "
"of values of the appropriate type."
msgstr ""
"є аргументом цього параметра в командному рядку. :mod:`optparse` очікуватиме "
"аргумент, лише якщо встановлено :attr:`~Option.type`; тип ``значення`` буде "
"типом, який передбачається типом опції. Якщо :attr:`~Option.type` для цього "
"параметра має значення ``None`` (аргумент не очікується), тоді ``value`` "
"буде ``None``. Якщо :attr:`~Option.nargs` > 1, ``value`` буде кортежем "
"значень відповідного типу."

msgid "``parser``"
msgstr "``парсер``"

msgid ""
"is the OptionParser instance driving the whole thing, mainly useful because "
"you can access some other interesting data through its instance attributes:"
msgstr ""
"це екземпляр OptionParser, який керує всім цим, головним чином корисний, "
"оскільки ви можете отримати доступ до деяких інших цікавих даних через його "
"атрибути екземпляра:"

msgid "``parser.largs``"
msgstr "``parser.largs``"

msgid ""
"the current list of leftover arguments, ie. arguments that have been "
"consumed but are neither options nor option arguments. Feel free to modify "
"``parser.largs``, e.g. by adding more arguments to it.  (This list will "
"become ``args``, the second return value of :meth:`parse_args`.)"
msgstr ""
"поточний список залишкових аргументів, тобто. аргументи, які були "
"використані, але не є ні параметрами, ні аргументами варіантів. Не соромтеся "
"змінити ``parser.largs``, напр. додавши до нього більше аргументів. (Цей "
"список стане ``args``, другим значенням, що повертається :meth:`parse_args`.)"

msgid "``parser.rargs``"
msgstr "``parser.rargs``"

msgid ""
"the current list of remaining arguments, ie. with ``opt_str`` and ``value`` "
"(if applicable) removed, and only the arguments following them still there.  "
"Feel free to modify ``parser.rargs``, e.g. by consuming more arguments."
msgstr ""
"поточний список аргументів, що залишилися, тобто. з вилученими параметрами "
"``opt_str`` і ``value`` (якщо застосовно), і залишаються лише наступні за "
"ними аргументи. Не соромтеся змінити ``parser.rargs``, напр. споживаючи "
"більше аргументів."

msgid "``parser.values``"
msgstr "``parser.values``"

msgid ""
"the object where option values are by default stored (an instance of "
"optparse.OptionValues).  This lets callbacks use the same mechanism as the "
"rest of :mod:`optparse` for storing option values; you don't need to mess "
"around with globals or closures.  You can also access or modify the value(s) "
"of any options already encountered on the command-line."
msgstr ""
"об’єкт, де за замовчуванням зберігаються значення параметрів (екземпляр "
"optparse.OptionValues). Це дозволяє зворотним викликам використовувати той "
"самий механізм, що й решта :mod:`optparse` для зберігання значень "
"параметрів; вам не потрібно возитися з глобалами чи закриттями. Ви також "
"можете отримати доступ або змінити значення будь-яких параметрів, які вже "
"зустрічаються в командному рядку."

msgid ""
"is a tuple of arbitrary positional arguments supplied via the :attr:`~Option."
"callback_args` option attribute."
msgstr ""
"це кортеж довільних позиційних аргументів, що надаються через атрибут опції :"
"attr:`~Option.callback_args`."

msgid "``kwargs``"
msgstr "``кварги``"

msgid ""
"is a dictionary of arbitrary keyword arguments supplied via :attr:`~Option."
"callback_kwargs`."
msgstr ""
"це словник довільних аргументів ключових слів, які надаються через :attr:"
"`~Option.callback_kwargs`."

msgid "Raising errors in a callback"
msgstr "Викликання помилок у зворотному виклику"

msgid ""
"The callback function should raise :exc:`OptionValueError` if there are any "
"problems with the option or its argument(s).  :mod:`optparse` catches this "
"and terminates the program, printing the error message you supply to "
"stderr.  Your message should be clear, concise, accurate, and mention the "
"option at fault. Otherwise, the user will have a hard time figuring out what "
"they did wrong."
msgstr ""
"Функція зворотного виклику має викликати :exc:`OptionValueError`, якщо є "
"проблеми з параметром або його аргументом(ами). :mod:`optparse` вловлює це "
"та завершує програму, друкуючи повідомлення про помилку, яке ви надаєте на "
"stderr. Ваше повідомлення має бути ясним, лаконічним, точним і вказувати на "
"помилковий варіант. В іншому випадку користувачеві буде важко зрозуміти, що "
"він зробив не так."

msgid "Callback example 1: trivial callback"
msgstr "Приклад зворотного виклику 1: тривіальний зворотний виклик"

msgid ""
"Here's an example of a callback option that takes no arguments, and simply "
"records that the option was seen::"
msgstr ""
"Ось приклад опції зворотного виклику, яка не приймає аргументів і просто "
"записує, що опцію було розглянуто::"

msgid "Of course, you could do that with the ``\"store_true\"`` action."
msgstr "Звичайно, ви можете зробити це за допомогою дії ``\"store_true\"``."

msgid "Callback example 2: check option order"
msgstr "Приклад зворотного виклику 2: перевірте порядок варіантів"

msgid ""
"Here's a slightly more interesting example: record the fact that ``-a`` is "
"seen, but blow up if it comes after ``-b`` in the command-line.  ::"
msgstr ""
"Ось трохи цікавіший приклад: зафіксуйте факт відображення ``-a``, але "
"роздуйте, якщо він стоїть після ``-b`` у командному рядку. ::"

msgid "Callback example 3: check option order (generalized)"
msgstr "Приклад зворотного виклику 3: перевірка порядку опцій (узагальнено)"

msgid ""
"If you want to re-use this callback for several similar options (set a flag, "
"but blow up if ``-b`` has already been seen), it needs a bit of work: the "
"error message and the flag that it sets must be generalized.  ::"
msgstr ""
"Якщо ви хочете повторно використати цей зворотній виклик для кількох "
"подібних параметрів (встановити прапорець, але роздути, якщо ``-b`` вже було "
"помічено), це потребує трохи роботи: повідомлення про помилку та прапорець, "
"який він встановлює необхідно узагальнити. ::"

msgid "Callback example 4: check arbitrary condition"
msgstr "Приклад зворотного виклику 4: перевірка довільної умови"

msgid ""
"Of course, you could put any condition in there---you're not limited to "
"checking the values of already-defined options.  For example, if you have "
"options that should not be called when the moon is full, all you have to do "
"is this::"
msgstr ""
"Звичайно, ви можете поставити туди будь-яку умову --- ви не обмежені "
"перевіркою значень уже визначених параметрів. Наприклад, якщо у вас є опції, "
"які не слід викликати в повний місяць, все, що вам потрібно зробити, це:"

msgid ""
"(The definition of ``is_moon_full()`` is left as an exercise for the reader.)"
msgstr "(Визначення ``is_moon_full()`` залишено як вправа для читача.)"

msgid "Callback example 5: fixed arguments"
msgstr "Приклад зворотного виклику 5: фіксовані аргументи"

msgid ""
"Things get slightly more interesting when you define callback options that "
"take a fixed number of arguments.  Specifying that a callback option takes "
"arguments is similar to defining a ``\"store\"`` or ``\"append\"`` option: "
"if you define :attr:`~Option.type`, then the option takes one argument that "
"must be convertible to that type; if you further define :attr:`~Option."
"nargs`, then the option takes :attr:`~Option.nargs` arguments."
msgstr ""
"Справи стають трохи цікавішими, коли ви визначаєте параметри зворотного "
"виклику, які приймають фіксовану кількість аргументів. Вказівка того, що "
"опція зворотного виклику приймає аргументи, подібна до визначення опції "
"``\"store\"`` або ``\"append\"``: якщо ви визначаєте :attr:`~Option.type`, "
"тоді опція приймає один аргумент, який повинен бути конвертованим у цей тип; "
"якщо ви далі визначаєте :attr:`~Option.nargs`, тоді параметр приймає "
"аргументи :attr:`~Option.nargs`."

msgid ""
"Here's an example that just emulates the standard ``\"store\"`` action::"
msgstr "Ось приклад, який просто емулює стандартну дію ``\"store\"``:"

msgid ""
"Note that :mod:`optparse` takes care of consuming 3 arguments and converting "
"them to integers for you; all you have to do is store them.  (Or whatever; "
"obviously you don't need a callback for this example.)"
msgstr ""
"Зауважте, що :mod:`optparse` піклується про споживання 3 аргументів і "
"перетворення їх на цілі числа за вас; все, що вам потрібно зробити, це "
"зберегти їх. (Або що завгодно; очевидно, вам не потрібен зворотний виклик "
"для цього прикладу.)"

msgid "Callback example 6: variable arguments"
msgstr "Приклад зворотного виклику 6: змінні аргументи"

msgid ""
"Things get hairy when you want an option to take a variable number of "
"arguments. For this case, you must write a callback, as :mod:`optparse` "
"doesn't provide any built-in capabilities for it.  And you have to deal with "
"certain intricacies of conventional Unix command-line parsing that :mod:"
"`optparse` normally handles for you.  In particular, callbacks should "
"implement the conventional rules for bare ``--`` and ``-`` arguments:"
msgstr ""
"Справи стають заплутаними, коли ви хочете, щоб параметр приймав змінну "
"кількість аргументів. У цьому випадку ви повинні написати зворотний виклик, "
"оскільки :mod:`optparse` не надає жодних вбудованих можливостей для нього. І "
"вам доведеться мати справу з певними тонкощами звичайного аналізу командного "
"рядка Unix, який :mod:`optparse` зазвичай обробляє для вас. Зокрема, "
"зворотні виклики мають реалізовувати звичайні правила для голих аргументів "
"``--`` і ``-``:"

msgid "either ``--`` or ``-`` can be option arguments"
msgstr "``--`` або ``-`` можуть бути аргументами опції"

msgid ""
"bare ``--`` (if not the argument to some option): halt command-line "
"processing and discard the ``--``"
msgstr ""
"голий ``--`` (якщо не аргумент для якогось параметра): зупинити обробку "
"командного рядка та відкинути ``--``"

msgid ""
"bare ``-`` (if not the argument to some option): halt command-line "
"processing but keep the ``-`` (append it to ``parser.largs``)"
msgstr ""
"голий ``-`` (якщо не аргумент для якогось параметра): зупинити обробку "
"командного рядка, але зберегти ``-`` (додати його до ``parser.largs``)"

msgid ""
"If you want an option that takes a variable number of arguments, there are "
"several subtle, tricky issues to worry about.  The exact implementation you "
"choose will be based on which trade-offs you're willing to make for your "
"application (which is why :mod:`optparse` doesn't support this sort of thing "
"directly)."
msgstr ""
"Якщо вам потрібна опція, яка приймає змінну кількість аргументів, є кілька "
"тонких, складних питань, про які варто потурбуватися. Точна реалізація, яку "
"ви виберете, базуватиметься на компромісах, які ви готові зробити для своєї "
"програми (саме тому :mod:`optparse` не підтримує подібні речі напряму)."

msgid ""
"Nevertheless, here's a stab at a callback for an option with variable "
"arguments::"
msgstr ""
"Тим не менш, ось спроба зворотного виклику для опції зі змінними "
"аргументами::"

msgid "Extending :mod:`optparse`"
msgstr "Розширення :mod:`optparse`"

msgid ""
"Since the two major controlling factors in how :mod:`optparse` interprets "
"command-line options are the action and type of each option, the most likely "
"direction of extension is to add new actions and new types."
msgstr ""
"Оскільки двома основними факторами, що впливають на те, як :mod:`optparse` "
"інтерпретує параметри командного рядка, є дія та тип кожного параметра, "
"найімовірнішим напрямком розширення є додавання нових дій і нових типів."

msgid "Adding new types"
msgstr "Додавання нових типів"

msgid ""
"To add new types, you need to define your own subclass of :mod:`optparse`'s :"
"class:`Option` class.  This class has a couple of attributes that define :"
"mod:`optparse`'s types: :attr:`~Option.TYPES` and :attr:`~Option."
"TYPE_CHECKER`."
msgstr ""
"Щоб додати нові типи, вам потрібно визначити власний підклас класу :mod:"
"`optparse` :class:`Option`. Цей клас має кілька атрибутів, які визначають "
"типи :mod:`optparse`: :attr:`~Option.TYPES` і :attr:`~Option.TYPE_CHECKER`."

msgid ""
"A tuple of type names; in your subclass, simply define a new tuple :attr:"
"`TYPES` that builds on the standard one."
msgstr ""
"Кортеж імен типів; у своєму підкласі просто визначте новий кортеж :attr:"
"`TYPES`, який базується на стандартному."

msgid ""
"A dictionary mapping type names to type-checking functions.  A type-checking "
"function has the following signature::"
msgstr ""
"Словник, що зіставляє назви типів із функціями перевірки типу. Функція "
"перевірки типу має такий підпис:"

msgid ""
"where ``option`` is an :class:`Option` instance, ``opt`` is an option string "
"(e.g., ``-f``), and ``value`` is the string from the command line that must "
"be checked and converted to your desired type.  ``check_mytype()`` should "
"return an object of the hypothetical type ``mytype``.  The value returned by "
"a type-checking function will wind up in the OptionValues instance returned "
"by :meth:`OptionParser.parse_args`, or be passed to a callback as the "
"``value`` parameter."
msgstr ""
"де ``option`` - це екземпляр :class:`Option`, ``opt`` - це рядок параметра "
"(наприклад, ``-f``), а ``value`` - це рядок із командного рядка, який "
"необхідно перевірити та перетворити на потрібний тип. ``check_mytype()`` має "
"повертати об’єкт гіпотетичного типу ``mytype``. Значення, повернуте функцією "
"перевірки типу, з’явиться в екземплярі OptionValues, поверненому :meth:"
"`OptionParser.parse_args`, або буде передано зворотному виклику як параметр "
"``value``."

msgid ""
"Your type-checking function should raise :exc:`OptionValueError` if it "
"encounters any problems.  :exc:`OptionValueError` takes a single string "
"argument, which is passed as-is to :class:`OptionParser`'s :meth:`error` "
"method, which in turn prepends the program name and the string ``\"error:"
"\"`` and prints everything to stderr before terminating the process."
msgstr ""
"Ваша функція перевірки типу має викликати :exc:`OptionValueError`, якщо вона "
"стикається з будь-якими проблемами. :exc:`OptionValueError` приймає один "
"рядковий аргумент, який передається як є до методу :meth:`error` :class:"
"`OptionParser`, який, у свою чергу, додає назву програми та рядок "
"``\"помилка: \"`` і друкує все в stderr перед завершенням процесу."

msgid ""
"Here's a silly example that demonstrates adding a ``\"complex\"`` option "
"type to parse Python-style complex numbers on the command line.  (This is "
"even sillier than it used to be, because :mod:`optparse` 1.3 added built-in "
"support for complex numbers, but never mind.)"
msgstr ""
"Ось дурний приклад, який демонструє додавання типу параметра ``\"complex\"`` "
"для аналізу комплексних чисел у стилі Python у командному рядку. (Це ще "
"безглуздіше, ніж було раніше, тому що :mod:`optparse` 1.3 додав вбудовану "
"підтримку комплексних чисел, але нічого.)"

msgid "First, the necessary imports::"
msgstr "По-перше, необхідний імпорт::"

msgid ""
"You need to define your type-checker first, since it's referred to later (in "
"the :attr:`~Option.TYPE_CHECKER` class attribute of your Option subclass)::"
msgstr ""
"Спершу вам потрібно визначити свій засіб перевірки типів, оскільки на нього "
"посилатимуться пізніше (в атрибуті класу :attr:`~Option.TYPE_CHECKER` вашого "
"підкласу Option):"

msgid "Finally, the Option subclass::"
msgstr "Нарешті, підклас Option::"

msgid ""
"(If we didn't make a :func:`copy` of :attr:`Option.TYPE_CHECKER`, we would "
"end up modifying the :attr:`~Option.TYPE_CHECKER` attribute of :mod:"
"`optparse`'s Option class.  This being Python, nothing stops you from doing "
"that except good manners and common sense.)"
msgstr ""
"(Якби ми не зробили :func:`copy` :attr:`Option.TYPE_CHECKER`, ми б завершили "
"зміну атрибута :attr:`~Option.TYPE_CHECKER` параметра :mod:`optparse` "
"Оскільки це Python, ніщо не заважає вам це зробити, крім хороших манер і "
"здорового глузду.)"

msgid ""
"That's it!  Now you can write a script that uses the new option type just "
"like any other :mod:`optparse`\\ -based script, except you have to instruct "
"your OptionParser to use MyOption instead of Option::"
msgstr ""
"Це воно! Тепер ви можете написати сценарій, який використовує новий тип "
"опцій, як і будь-який інший сценарій на основі :mod:`optparse`\\, за "
"винятком того, що вам потрібно вказати вашому OptionParser використовувати "
"MyOption замість Option::"

msgid ""
"Alternately, you can build your own option list and pass it to OptionParser; "
"if you don't use :meth:`add_option` in the above way, you don't need to tell "
"OptionParser which option class to use::"
msgstr ""
"Крім того, ви можете створити власний список параметрів і передати його в "
"OptionParser; якщо ви не використовуєте :meth:`add_option` вищезгаданим "
"способом, вам не потрібно вказувати OptionParser, який клас параметрів "
"використовувати::"

msgid "Adding new actions"
msgstr "Додавання нових дій"

msgid ""
"Adding new actions is a bit trickier, because you have to understand that :"
"mod:`optparse` has a couple of classifications for actions:"
msgstr ""
"Додавати нові дії трохи складніше, тому що ви повинні розуміти, що :mod:"
"`optparse` має кілька класифікацій для дій:"

msgid "\"store\" actions"
msgstr "дії \"магазину\"."

msgid ""
"actions that result in :mod:`optparse` storing a value to an attribute of "
"the current OptionValues instance; these options require a :attr:`~Option."
"dest` attribute to be supplied to the Option constructor."
msgstr ""
"дії, які призводять до того, що :mod:`optparse` зберігає значення в атрибуті "
"поточного екземпляра OptionValues; ці параметри вимагають надання атрибута :"
"attr:`~Option.dest` конструктору Option."

msgid "\"typed\" actions"
msgstr "\"набрані\" дії"

msgid ""
"actions that take a value from the command line and expect it to be of a "
"certain type; or rather, a string that can be converted to a certain type. "
"These options require a :attr:`~Option.type` attribute to the Option "
"constructor."
msgstr ""
"дії, які беруть значення з командного рядка та очікують, що воно буде "
"певного типу; точніше, рядок, який можна перетворити на певний тип. Для цих "
"параметрів потрібен атрибут :attr:`~Option.type` конструктору Option."

msgid ""
"These are overlapping sets: some default \"store\" actions are "
"``\"store\"``, ``\"store_const\"``, ``\"append\"``, and ``\"count\"``, while "
"the default \"typed\" actions are ``\"store\"``, ``\"append\"``, and "
"``\"callback\"``."
msgstr ""
"Це набори, що перекриваються: деякі дії \"зберігання\" за замовчуванням - це "
"``\"store\"``, ``\"store_const\"``, ``\"append\"`` і ``\"count\"``, а за "
"замовчуванням \"typed\" \" діями є ``\"зберігати\"``, ``\"додавати\"`` і "
"``\"зворотний виклик\"``."

msgid ""
"When you add an action, you need to categorize it by listing it in at least "
"one of the following class attributes of Option (all are lists of strings):"
msgstr ""
"Коли ви додаєте дію, вам потрібно класифікувати її, перерахувавши принаймні "
"в одному з наступних атрибутів класу Option (усі є списками рядків):"

msgid "All actions must be listed in ACTIONS."
msgstr "Усі дії мають бути вказані в ACTIONS."

msgid "\"store\" actions are additionally listed here."
msgstr "тут додатково перераховані дії \"магазину\"."

msgid "\"typed\" actions are additionally listed here."
msgstr "\"введені\" дії додатково перераховані тут."

msgid ""
"Actions that always take a type (i.e. whose options always take a value) are "
"additionally listed here.  The only effect of this is that :mod:`optparse` "
"assigns the default type, ``\"string\"``, to options with no explicit type "
"whose action is listed in :attr:`ALWAYS_TYPED_ACTIONS`."
msgstr ""
"Дії, які завжди мають тип (тобто чиї параметри завжди приймають значення), "
"додатково перераховані тут. Єдиним ефектом цього є те, що :mod:`optparse` "
"призначає тип за замовчуванням, ``\"string\"``, параметрам без явного типу, "
"дія яких указана в :attr:`ALWAYS_TYPED_ACTIONS`."

msgid ""
"In order to actually implement your new action, you must override Option's :"
"meth:`take_action` method and add a case that recognizes your action."
msgstr ""
"Щоб фактично реалізувати вашу нову дію, ви повинні перевизначити метод :meth:"
"`take_action` Option і додати регістр, який розпізнає вашу дію."

msgid ""
"For example, let's add an ``\"extend\"`` action.  This is similar to the "
"standard ``\"append\"`` action, but instead of taking a single value from "
"the command-line and appending it to an existing list, ``\"extend\"`` will "
"take multiple values in a single comma-delimited string, and extend an "
"existing list with them.  That is, if ``--names`` is an ``\"extend\"`` "
"option of type ``\"string\"``, the command line ::"
msgstr ""
"Наприклад, давайте додамо дію ``\"розширити\"``. Це схоже на стандартну дію "
"``\"append\"``, але замість того, щоб брати одне значення з командного рядка "
"та додавати його до існуючого списку, ``\"extend\"`` прийматиме кілька "
"значень в одній комі -рядок із роздільниками та розширити ними існуючий "
"список. Тобто, якщо ``--names`` є опцією ``\"extend\"`` типу ``\"string\"``, "
"командний рядок::"

msgid "would result in a list  ::"
msgstr "призведе до списку ::"

msgid "Again we define a subclass of Option::"
msgstr "Знову ми визначаємо підклас Option::"

msgid "Features of note:"
msgstr "Примітка."

msgid ""
"``\"extend\"`` both expects a value on the command-line and stores that "
"value somewhere, so it goes in both :attr:`~Option.STORE_ACTIONS` and :attr:"
"`~Option.TYPED_ACTIONS`."
msgstr ""
"``\"extend\"`` очікує значення в командному рядку та десь зберігає це "
"значення, тому воно входить і в :attr:`~Option.STORE_ACTIONS`, і в :attr:"
"`~Option.TYPED_ACTIONS`."

msgid ""
"to ensure that :mod:`optparse` assigns the default type of ``\"string\"`` to "
"``\"extend\"`` actions, we put the ``\"extend\"`` action in :attr:`~Option."
"ALWAYS_TYPED_ACTIONS` as well."
msgstr ""
"щоб гарантувати, що :mod:`optparse` призначає типовий тип ``\"string\"`` "
"діям ``\"extend\"``, ми додаємо дію ``\"extend\"`` в :attr:`~Option. "
"ALWAYS_TYPED_ACTIONS` також."

msgid ""
":meth:`MyOption.take_action` implements just this one new action, and passes "
"control back to :meth:`Option.take_action` for the standard :mod:`optparse` "
"actions."
msgstr ""
":meth:`MyOption.take_action` реалізує лише цю нову дію та передає керування "
"назад :meth:`Option.take_action` для стандартних дій :mod:`optparse`."

msgid ""
"``values`` is an instance of the optparse_parser.Values class, which "
"provides the very useful :meth:`ensure_value` method. :meth:`ensure_value` "
"is essentially :func:`getattr` with a safety valve; it is called as ::"
msgstr ""
"``values`` є екземпляром класу optparse_parser.Values, який надає дуже "
"корисний метод :meth:`ensure_value`. :meth:`ensure_value` це по суті :func:"
"`getattr` із запобіжним клапаном; це називається як ::"

msgid ""
"If the ``attr`` attribute of ``values`` doesn't exist or is ``None``, then "
"ensure_value() first sets it to ``value``, and then returns 'value. This is "
"very handy for actions like ``\"extend\"``, ``\"append\"``, and "
"``\"count\"``, all of which accumulate data in a variable and expect that "
"variable to be of a certain type (a list for the first two, an integer for "
"the latter).  Using :meth:`ensure_value` means that scripts using your "
"action don't have to worry about setting a default value for the option "
"destinations in question; they can just leave the default as ``None`` and :"
"meth:`ensure_value` will take care of getting it right when it's needed."
msgstr ""
"Якщо атрибут ``attr`` ``values`` не існує або має значення ``None``, тоді "
"secure_value() спочатку встановлює для нього значення ``value``, а потім "
"повертає значення ``value``. Це дуже зручно для таких дій, як "
"``\"extend\"``, ``\"append\"`` і ``\"count\"``, усі з яких накопичують дані "
"в змінній і очікують, що ця змінна матиме певний тип (список для перших "
"двох, ціле число для останнього). Використання :meth:`ensure_value` означає, "
"що сценаріям, які використовують вашу дію, не потрібно турбуватися про "
"встановлення значення за замовчуванням для відповідних цільових параметрів; "
"вони можуть просто залишити значення за замовчуванням як ``None``, і :meth:"
"`ensure_value` подбає про те, щоб зробити це правильно, коли це буде "
"потрібно."
