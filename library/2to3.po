# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "2to3 --- Automated Python 2 to 3 code translation"
msgstr ""

msgid ""
"2to3 is a Python program that reads Python 2.x source code and applies a "
"series of *fixers* to transform it into valid Python 3.x code.  The standard "
"library contains a rich set of fixers that will handle almost all code.  "
"2to3 supporting library :mod:`lib2to3` is, however, a flexible and generic "
"library, so it is possible to write your own fixers for 2to3."
msgstr ""
"2to3 — це програма Python, яка зчитує вихідний код Python 2.x і застосовує "
"серію *фіксаторів*, щоб перетворити його на дійсний код Python 3.x. "
"Стандартна бібліотека містить багатий набір фіксаторів, які оброблять майже "
"весь код. Бібліотека підтримки 2to3 :mod:`lib2to3`, однак, є гнучкою та "
"загальною бібліотекою, тому можна написати власні фіксатори для 2to3."

msgid ""
"The ``lib2to3`` module was marked pending for deprecation in Python 3.9 "
"(raising :exc:`PendingDeprecationWarning` on import) and fully deprecated in "
"Python 3.11 (raising :exc:`DeprecationWarning`).  The ``2to3`` tool is part "
"of that.  It will be removed in Python 3.13."
msgstr ""

msgid "Using 2to3"
msgstr "Використовуючи 2 до 3"

msgid ""
"2to3 will usually be installed with the Python interpreter as a script.  It "
"is also located in the :file:`Tools/scripts` directory of the Python root."
msgstr ""
"2to3 зазвичай встановлюється з інтерпретатором Python як сценарієм. Він "
"також знаходиться в каталозі :file:`Tools/scripts` кореневого каталогу "
"Python."

msgid ""
"2to3's basic arguments are a list of files or directories to transform.  The "
"directories are recursively traversed for Python sources."
msgstr ""
"Основними аргументами 2to3 є список файлів або каталогів для трансформації. "
"Для вихідних кодів Python каталоги проходять рекурсивно."

msgid "Here is a sample Python 2.x source file, :file:`example.py`::"
msgstr "Ось зразок вихідного файлу Python 2.x, :file:`example.py`::"

msgid "It can be converted to Python 3.x code via 2to3 on the command line:"
msgstr ""
"Його можна перетворити на код Python 3.x за допомогою 2to3 у командному "
"рядку:"

msgid ""
"A diff against the original source file is printed.  2to3 can also write the "
"needed modifications right back to the source file.  (A backup of the "
"original file is made unless :option:`!-n` is also given.)  Writing the "
"changes back is enabled with the :option:`!-w` flag:"
msgstr ""
"Друкується порівняння з вихідним вихідним файлом. 2to3 також може записати "
"необхідні зміни прямо у вихідний файл. (Буде створено резервну копію "
"вихідного файлу, якщо також не вказано :option:`!-n`.) Записування змін "
"увімкнено за допомогою прапорця :option:`!-w`:"

msgid "After transformation, :file:`example.py` looks like this::"
msgstr "Після трансформації :file:`example.py` виглядає так:"

msgid ""
"Comments and exact indentation are preserved throughout the translation "
"process."
msgstr ""
"Коментарі та точні відступи зберігаються протягом усього процесу перекладу."

msgid ""
"By default, 2to3 runs a set of :ref:`predefined fixers <2to3-fixers>`.  The :"
"option:`!-l` flag lists all available fixers.  An explicit set of fixers to "
"run can be given with :option:`!-f`.  Likewise the :option:`!-x` explicitly "
"disables a fixer.  The following example runs only the ``imports`` and "
"``has_key`` fixers:"
msgstr ""
"За замовчуванням 2to3 запускає набір :ref:`передвизначених фіксаторів <2to3-"
"fixers>`. Прапорець :option:`!-l` містить список усіх доступних фіксаторів. "
"Явний набір фіксаторів для запуску можна надати за допомогою :option:`!-f`. "
"Так само :option:`!-x` явно вимикає фіксатор. У наступному прикладі "
"запускаються лише фіксатори ``imports`` і ``has_key``:"

msgid "This command runs every fixer except the ``apply`` fixer:"
msgstr "Ця команда запускає всі фіксатори, крім фіксатора ``apply``:"

msgid ""
"Some fixers are *explicit*, meaning they aren't run by default and must be "
"listed on the command line to be run.  Here, in addition to the default "
"fixers, the ``idioms`` fixer is run:"
msgstr ""
"Деякі фіксатори є *явними*, що означає, що вони не запускаються за "
"замовчуванням і повинні бути зазначені в командному рядку для запуску. Тут, "
"на додаток до типових фіксаторів, запускається фіксатор ``ідіом``:"

msgid "Notice how passing ``all`` enables all default fixers."
msgstr "Зверніть увагу, як передача ``all`` вмикає всі стандартні фіксатори."

msgid ""
"Sometimes 2to3 will find a place in your source code that needs to be "
"changed, but 2to3 cannot fix automatically.  In this case, 2to3 will print a "
"warning beneath the diff for a file.  You should address the warning in "
"order to have compliant 3.x code."
msgstr ""
"Іноді 2to3 знаходить місце у вашому вихідному коді, яке потрібно змінити, "
"але 2to3 не може виправити автоматично. У цьому випадку 2to3 надрукує "
"попередження під diff для файлу. Вам слід усунути попередження, щоб мати "
"сумісний код 3.x."

msgid ""
"2to3 can also refactor doctests.  To enable this mode, use the :option:`!-d` "
"flag.  Note that *only* doctests will be refactored.  This also doesn't "
"require the module to be valid Python.  For example, doctest like examples "
"in a reST document could also be refactored with this option."
msgstr ""
"2to3 також може виконувати рефакторинг doctests. Щоб увімкнути цей режим, "
"використовуйте прапорець :option:`!-d`. Зауважте, що *тільки* doctests "
"будуть перероблені. Для цього також не потрібно, щоб модуль був дійсним "
"Python. Наприклад, приклади, схожі на doctest, у документі reST також можуть "
"бути перероблені за допомогою цієї опції."

msgid ""
"The :option:`!-v` option enables output of more information on the "
"translation process."
msgstr ""
"Опція :option:`!-v` дозволяє виводити більше інформації про процес перекладу."

msgid ""
"Since some print statements can be parsed as function calls or statements, "
"2to3 cannot always read files containing the print function.  When 2to3 "
"detects the presence of the ``from __future__ import print_function`` "
"compiler directive, it modifies its internal grammar to interpret :func:"
"`print` as a function.  This change can also be enabled manually with the :"
"option:`!-p` flag.  Use :option:`!-p` to run fixers on code that already has "
"had its print statements converted. Also :option:`!-e` can be used to make :"
"func:`exec` a function."
msgstr ""
"Оскільки деякі оператори друку можна проаналізувати як виклики функцій або "
"оператори, 2to3 не завжди може читати файли, що містять функцію друку. Коли "
"2to3 виявляє наявність директиви компілятора ``from __future__ import "
"print_function``, він змінює свою внутрішню граматику, щоб інтерпретувати :"
"func:`print` як функцію. Цю зміну також можна ввімкнути вручну за допомогою "
"позначки :option:`!-p`. Використовуйте :option:`!-p`, щоб запустити "
"фіксатори для коду, оператори друку якого вже перетворені. Також :option:`!-"
"e` можна використовувати, щоб зробити :func:`exec` функцією."

msgid ""
"The :option:`!-o` or :option:`!--output-dir` option allows specification of "
"an alternate directory for processed output files to be written to.  The :"
"option:`!-n` flag is required when using this as backup files do not make "
"sense when not overwriting the input files."
msgstr ""
"Параметр :option:`!-o` або :option:`!--output-dir` дозволяє вказати "
"альтернативний каталог для запису оброблених вихідних файлів. Прапорець :"
"option:`!-n` потрібен під час використання, оскільки файли резервних копій "
"не мають сенсу, якщо не перезаписувати вхідні файли."

msgid "The :option:`!-o` option was added."
msgstr "Додано параметр :option:`!-o`."

msgid ""
"The :option:`!-W` or :option:`!--write-unchanged-files` flag tells 2to3 to "
"always write output files even if no changes were required to the file.  "
"This is most useful with :option:`!-o` so that an entire Python source tree "
"is copied with translation from one directory to another. This option "
"implies the :option:`!-w` flag as it would not make sense otherwise."
msgstr ""
"Прапорець :option:`!-W` або :option:`!--write-unchanged-files` вказує 2to3 "
"завжди записувати вихідні файли, навіть якщо до файлу не потрібні зміни. Це "
"найбільш корисно з :option:`!-o`, так що все дерево вихідних кодів Python "
"копіюється з перекладом з одного каталогу в інший. Ця опція передбачає "
"прапорець :option:`!-w`, оскільки інакше це не мало б сенсу."

msgid "The :option:`!-W` flag was added."
msgstr "Додано прапорець :option:`!-W`."

msgid ""
"The :option:`!--add-suffix` option specifies a string to append to all "
"output filenames.  The :option:`!-n` flag is required when specifying this "
"as backups are not necessary when writing to different filenames.  Example:"
msgstr ""
"Параметр :option:`!--add-suffix` визначає рядок, який додається до всіх назв "
"вихідних файлів. Прапорець :option:`!-n` є обов’язковим, коли вказується це, "
"оскільки резервні копії не потрібні під час запису в різні імена файлів. "
"приклад:"

msgid "Will cause a converted file named ``example.py3`` to be written."
msgstr "Викличе запис перетвореного файлу під назвою ``example.py3``."

msgid "The :option:`!--add-suffix` option was added."
msgstr "Додано параметр :option:`!--add-suffix`."

msgid "To translate an entire project from one directory tree to another use:"
msgstr ""
"Щоб перекласти весь проект з одного дерева каталогів в інше, використовуйте:"

msgid "Fixers"
msgstr "Закріплювачі"

msgid ""
"Each step of transforming code is encapsulated in a fixer.  The command "
"``2to3 -l`` lists them.  As :ref:`documented above <2to3-using>`, each can "
"be turned on and off individually.  They are described here in more detail."
msgstr ""
"Кожен крок трансформації коду інкапсульований у фіксаторі. Команда ``2to3 -"
"l`` перераховує їх. Як :ref:`задокументовано вище <2to3-using>`, кожен з них "
"можна вмикати та вимикати окремо. Тут вони описані більш детально."

msgid ""
"Removes usage of :func:`apply`.  For example ``apply(function, *args, "
"**kwargs)`` is converted to ``function(*args, **kwargs)``."
msgstr ""
"Вилучає використання :func:`apply`. Наприклад, ``apply(function, *args, "
"**kwargs)`` перетворюється на ``function(*args, **kwargs)``."

msgid "Replaces deprecated :mod:`unittest` method names with the correct ones."
msgstr "Замінює застарілі назви методів :mod:`unittest` на правильні."

msgid "From"
msgstr "Від"

msgid "To"
msgstr "до"

msgid "``failUnlessEqual(a, b)``"
msgstr "``failUnlessEqual(a, b)``"

msgid ":meth:`assertEqual(a, b) <unittest.TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <unittest.TestCase.assertEqual>`"

msgid "``assertEquals(a, b)``"
msgstr "``assertEquals(a, b)``"

msgid "``failIfEqual(a, b)``"
msgstr "``failIfEqual(a, b)``"

msgid ":meth:`assertNotEqual(a, b) <unittest.TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <unittest.TestCase.assertNotEqual>`"

msgid "``assertNotEquals(a, b)``"
msgstr "``assertNotEquals(a, b)``"

msgid "``failUnless(a)``"
msgstr "``failUnless(a)``"

msgid ":meth:`assertTrue(a) <unittest.TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(a) <unittest.TestCase.assertTrue>`"

msgid "``assert_(a)``"
msgstr "``assert_(a)``"

msgid "``failIf(a)``"
msgstr "``failIf(a)``"

msgid ":meth:`assertFalse(a) <unittest.TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(a) <unittest.TestCase.assertFalse>`"

msgid "``failUnlessRaises(exc, cal)``"
msgstr "``failUnlessRaises(exc, cal)``"

msgid ":meth:`assertRaises(exc, cal) <unittest.TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, cal) <unittest.TestCase.assertRaises>`"

msgid "``failUnlessAlmostEqual(a, b)``"
msgstr "``failUnlessAlmostEqual(a, b)``"

msgid ":meth:`assertAlmostEqual(a, b) <unittest.TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <unittest.TestCase.assertAlmostEqual>`"

msgid "``assertAlmostEquals(a, b)``"
msgstr "``assertAlmostEquals(a, b)``"

msgid "``failIfAlmostEqual(a, b)``"
msgstr "``failIfAlmostEqual(a, b)``"

msgid ""
":meth:`assertNotAlmostEqual(a, b) <unittest.TestCase.assertNotAlmostEqual>`"
msgstr ""
":meth:`assertNotAlmostEqual(a, b) <unittest.TestCase.assertNotAlmostEqual>`"

msgid "``assertNotAlmostEquals(a, b)``"
msgstr "``assertNotAlmostEquals(a, b)``"

msgid "Converts :class:`basestring` to :class:`str`."
msgstr "Перетворює :class:`basestring` на :class:`str`."

msgid ""
"Converts :class:`buffer` to :class:`memoryview`.  This fixer is optional "
"because the :class:`memoryview` API is similar but not exactly the same as "
"that of :class:`buffer`."
msgstr ""
"Перетворює :class:`buffer` на :class:`memoryview`. Цей засіб виправлення є "
"необов’язковим, оскільки API :class:`memoryview` схожий, але не зовсім "
"такий, як API :class:`buffer`."

msgid ""
"Fixes dictionary iteration methods.  :meth:`dict.iteritems` is converted to :"
"meth:`dict.items`, :meth:`dict.iterkeys` to :meth:`dict.keys`, and :meth:"
"`dict.itervalues` to :meth:`dict.values`.  Similarly, :meth:`dict."
"viewitems`, :meth:`dict.viewkeys` and :meth:`dict.viewvalues` are converted "
"respectively to :meth:`dict.items`, :meth:`dict.keys` and :meth:`dict."
"values`.  It also wraps existing usages of :meth:`dict.items`, :meth:`dict."
"keys`, and :meth:`dict.values` in a call to :class:`list`."
msgstr ""
"Виправляє методи ітерації словника. :meth:`dict.iteritems` перетворюється "
"на :meth:`dict.items`, :meth:`dict.iterkeys` на :meth:`dict.keys`, а :meth:"
"`dict.itervalues` на :meth:`dict.values`. Так само :meth:`dict.viewitems`, :"
"meth:`dict.viewkeys` і :meth:`dict.viewvalues` перетворюються відповідно на :"
"meth:`dict.items`, :meth:`dict.keys` і :meth:`dict.values`. Він також "
"обгортає існуючі використання :meth:`dict.items`, :meth:`dict.keys` і :meth:"
"`dict.values` у виклику :class:`list`."

msgid "Converts ``except X, T`` to ``except X as T``."
msgstr "Перетворює ``крім X, T`` на ``крім X як T``."

msgid "Converts the ``exec`` statement to the :func:`exec` function."
msgstr "Перетворює оператор ``exec`` на функцію :func:`exec`."

msgid ""
"Removes usage of :func:`execfile`.  The argument to :func:`execfile` is "
"wrapped in calls to :func:`open`, :func:`compile`, and :func:`exec`."
msgstr ""
"Видаляє використання :func:`execfile`. Аргумент :func:`execfile` містить "
"виклики :func:`open`, :func:`compile` і :func:`exec`."

msgid ""
"Changes assignment of :attr:`sys.exitfunc` to use of the :mod:`atexit` "
"module."
msgstr ""
"Змінює призначення :attr:`sys.exitfunc` на використання модуля :mod:`atexit`."

msgid "Wraps :func:`filter` usage in a :class:`list` call."
msgstr "Обгортає використання :func:`filter` у виклику :class:`list`."

msgid ""
"Fixes function attributes that have been renamed.  For example, "
"``my_function.func_closure`` is converted to ``my_function.__closure__``."
msgstr ""
"Виправляє атрибути функції, які були перейменовані. Наприклад, ``my_function."
"func_closure`` перетворюється на ``my_function.__closure__``."

msgid "Removes ``from __future__ import new_feature`` statements."
msgstr "Вилучає оператори ``from __future__ import new_feature``."

msgid "Renames :func:`os.getcwdu` to :func:`os.getcwd`."
msgstr "Перейменовує :func:`os.getcwdu` на :func:`os.getcwd`."

msgid "Changes ``dict.has_key(key)`` to ``key in dict``."
msgstr "Змінює ``dict.has_key(key)`` на ``ключ у dict``."

msgid ""
"This optional fixer performs several transformations that make Python code "
"more idiomatic.  Type comparisons like ``type(x) is SomeClass`` and "
"``type(x) == SomeClass`` are converted to ``isinstance(x, SomeClass)``. "
"``while 1`` becomes ``while True``.  This fixer also tries to make use of :"
"func:`sorted` in appropriate places.  For example, this block ::"
msgstr ""
"Цей додатковий засіб виправлення виконує декілька перетворень, які роблять "
"код Python більш ідіоматичним. Порівняння типів, як-от ``type(x) is "
"SomeClass`` і ``type(x) == SomeClass``, перетворюються на ``isinstance(x, "
"SomeClass)``. ``while 1`` стає ``while True``. Цей фіксатор також "
"намагається використовувати :func:`sorted` у відповідних місцях. Наприклад, "
"цей блок ::"

msgid "is changed to ::"
msgstr "змінюється на ::"

msgid "Detects sibling imports and converts them to relative imports."
msgstr "Виявляє однорідний імпорт і перетворює його на відносний імпорт."

msgid "Handles module renames in the standard library."
msgstr "Обробляє перейменування модулів у стандартній бібліотеці."

msgid ""
"Handles other modules renames in the standard library.  It is separate from "
"the :2to3fixer:`imports` fixer only because of technical limitations."
msgstr ""
"Обробляє перейменування інших модулів у стандартній бібліотеці. Він "
"відокремлений від фіксатора :2to3fixer:`imports` лише через технічні "
"обмеження."

msgid "Converts ``input(prompt)`` to ``eval(input(prompt))``."
msgstr "Перетворює ``input(prompt)`` на ``eval(input(prompt))``."

msgid "Converts :func:`intern` to :func:`sys.intern`."
msgstr "Перетворює :func:`intern` на :func:`sys.intern`."

msgid ""
"Fixes duplicate types in the second argument of :func:`isinstance`.  For "
"example, ``isinstance(x, (int, int))`` is converted to ``isinstance(x, "
"int)`` and ``isinstance(x, (int, float, int))`` is converted to "
"``isinstance(x, (int, float))``."
msgstr ""
"Виправляє дублікати типів у другому аргументі :func:`isinstance`. Наприклад, "
"``isinstance(x, (int, int))`` перетворюється на ``isinstance(x, int)``, а "
"``isinstance(x, (int, float, int))`` перетворюється на ``isinstance(x, (int, "
"float))``."

msgid ""
"Removes imports of :func:`itertools.ifilter`, :func:`itertools.izip`, and :"
"func:`itertools.imap`.  Imports of :func:`itertools.ifilterfalse` are also "
"changed to :func:`itertools.filterfalse`."
msgstr ""
"Видаляє імпорт :func:`itertools.ifilter`, :func:`itertools.izip` і :func:"
"`itertools.imap`. Імпорт :func:`itertools.ifilterfalse` також змінено на :"
"func:`itertools.filterfalse`."

msgid ""
"Changes usage of :func:`itertools.ifilter`, :func:`itertools.izip`, and :"
"func:`itertools.imap` to their built-in equivalents. :func:`itertools."
"ifilterfalse` is changed to :func:`itertools.filterfalse`."
msgstr ""
"Змінює використання :func:`itertools.ifilter`, :func:`itertools.izip` і :"
"func:`itertools.imap` на їхні вбудовані еквіваленти. :func:`itertools."
"ifilterfalse` змінено на :func:`itertools.filterfalse`."

msgid "Renames :class:`long` to :class:`int`."
msgstr "Перейменовує :class:`long` на :class:`int`."

msgid ""
"Wraps :func:`map` in a :class:`list` call.  It also changes ``map(None, x)`` "
"to ``list(x)``.  Using ``from future_builtins import map`` disables this "
"fixer."
msgstr ""
"Переносить :func:`map` у виклик :class:`list`. Він також змінює ``map(None, "
"x)`` на ``list(x)``. Використання ``from future_builtins import map`` "
"вимикає цей засіб виправлення."

msgid ""
"Converts the old metaclass syntax (``__metaclass__ = Meta`` in the class "
"body) to the new (``class X(metaclass=Meta)``)."
msgstr ""
"Перетворює старий синтаксис метакласу (``__metaclass__ = Meta`` у тілі "
"класу) на новий (``class X(metaclass=Meta)``)."

msgid ""
"Fixes old method attribute names.  For example, ``meth.im_func`` is "
"converted to ``meth.__func__``."
msgstr ""
"Виправляє старі назви атрибутів методів. Наприклад, ``meth.im_func`` "
"перетворюється на ``meth.__func__``."

msgid "Converts the old not-equal syntax, ``<>``, to ``!=``."
msgstr "Перетворює старий синтаксис нерівності, ``<>``, на ``!=``."

msgid ""
"Converts the use of iterator's :meth:`~iterator.next` methods to the :func:"
"`next` function.  It also renames :meth:`next` methods to :meth:`~iterator."
"__next__`."
msgstr ""
"Перетворює використання методів ітератора :meth:`~iterator.next` на функцію :"
"func:`next`. Він також перейменовує методи :meth:`next` на :meth:`~iterator."
"__next__`."

msgid ""
"Renames definitions of methods called :meth:`__nonzero__` to :meth:`~object."
"__bool__`."
msgstr ""
"Перейменовує визначення методів під назвою :meth:`__nonzero__` на :meth:"
"`~object.__bool__`."

msgid "Converts octal literals into the new syntax."
msgstr "Перетворює вісімкові літерали на новий синтаксис."

msgid ""
"Converts calls to various functions in the :mod:`operator` module to other, "
"but equivalent, function calls.  When needed, the appropriate ``import`` "
"statements are added, e.g. ``import collections.abc``.  The following "
"mapping are made:"
msgstr ""
"Перетворює виклики різних функцій у модулі :mod:`operator` на інші, але "
"еквівалентні виклики функцій. За потреби додаються відповідні оператори "
"``import``, наприклад. ``import collections.abc``. Виконується наступне "
"відображення:"

msgid "``operator.isCallable(obj)``"
msgstr "``operator.isCallable(obj)``"

msgid "``callable(obj)``"
msgstr "``callable(obj)``"

msgid "``operator.sequenceIncludes(obj)``"
msgstr "``operator.sequenceIncludes(obj)``"

msgid "``operator.contains(obj)``"
msgstr "``operator.contains(obj)``"

msgid "``operator.isSequenceType(obj)``"
msgstr "``operator.isSequenceType(obj)``"

msgid "``isinstance(obj, collections.abc.Sequence)``"
msgstr "``isinstance(obj, collections.abc.Sequence)``"

msgid "``operator.isMappingType(obj)``"
msgstr "``operator.isMappingType(obj)``"

msgid "``isinstance(obj, collections.abc.Mapping)``"
msgstr "``isinstance(obj, collections.abc.Mapping)``"

msgid "``operator.isNumberType(obj)``"
msgstr "``operator.isNumberType(obj)``"

msgid "``isinstance(obj, numbers.Number)``"
msgstr "``isinstance(obj, numbers.Number)``"

msgid "``operator.repeat(obj, n)``"
msgstr "``operator.repeat(obj, n)``"

msgid "``operator.mul(obj, n)``"
msgstr "``operator.mul(obj, n)``"

msgid "``operator.irepeat(obj, n)``"
msgstr "``operator.irepeat(obj, n)``"

msgid "``operator.imul(obj, n)``"
msgstr "``operator.imul(obj, n)``"

msgid ""
"Add extra parenthesis where they are required in list comprehensions.  For "
"example, ``[x for x in 1, 2]`` becomes ``[x for x in (1, 2)]``."
msgstr ""
"Додайте додаткові дужки там, де вони потрібні для розуміння списку. "
"Наприклад, \"[x для x в 1, 2]\" перетворюється на \"[x для x в (1, 2)]\"."

msgid "Converts the ``print`` statement to the :func:`print` function."
msgstr "Перетворює оператор ``print`` на функцію :func:`print`."

msgid ""
"Converts ``raise E, V`` to ``raise E(V)``, and ``raise E, V, T`` to ``raise "
"E(V).with_traceback(T)``.  If ``E`` is a tuple, the translation will be "
"incorrect because substituting tuples for exceptions has been removed in 3.0."
msgstr ""
"Перетворює \"raise E, V\" на \"raise E(V)\", а \"raise E, V, T\" на \"raise "
"E(V).with_traceback(T)\". Якщо ``E`` є кортежем, переклад буде неправильним, "
"оскільки заміну кортежів для винятків було видалено в 3.0."

msgid "Converts :func:`raw_input` to :func:`input`."
msgstr "Перетворює :func:`raw_input` на :func:`input`."

msgid "Handles the move of :func:`reduce` to :func:`functools.reduce`."
msgstr "Обробляє переміщення :func:`reduce` до :func:`functools.reduce`."

msgid "Converts :func:`reload` to :func:`importlib.reload`."
msgstr "Перетворює :func:`reload` на :func:`importlib.reload`."

msgid "Changes :data:`sys.maxint` to :data:`sys.maxsize`."
msgstr "Змінює :data:`sys.maxint` на :data:`sys.maxsize`."

msgid "Replaces backtick repr with the :func:`repr` function."
msgstr "Замінює зворотну галочку repr на функцію :func:`repr`."

msgid ""
"Replaces use of the :class:`set` constructor with set literals.  This fixer "
"is optional."
msgstr ""
"Замінює використання конструктора :class:`set` літералами набору. Цей "
"закріплювач необов’язковий."

msgid "Renames :exc:`StandardError` to :exc:`Exception`."
msgstr "Перейменовує :exc:`StandardError` на :exc:`Exception`."

msgid ""
"Changes the deprecated :data:`sys.exc_value`, :data:`sys.exc_type`, :data:"
"`sys.exc_traceback` to use :func:`sys.exc_info`."
msgstr ""
"Змінює застарілі :data:`sys.exc_value`, :data:`sys.exc_type`, :data:`sys."
"exc_traceback` на використання :func:`sys.exc_info`."

msgid "Fixes the API change in generator's :meth:`throw` method."
msgstr "Виправляє зміну API у методі :meth:`throw` генератора."

msgid ""
"Removes implicit tuple parameter unpacking.  This fixer inserts temporary "
"variables."
msgstr ""
"Видаляє неявне розпакування параметрів кортежу. Цей фіксатор вставляє "
"тимчасові змінні."

msgid ""
"Fixes code broken from the removal of some members in the :mod:`types` "
"module."
msgstr ""
"Виправляє код, пошкоджений через видалення деяких членів у модулі :mod:"
"`types`."

msgid "Renames :class:`unicode` to :class:`str`."
msgstr "Перейменовує :class:`unicode` на :class:`str`."

msgid ""
"Handles the rename of :mod:`urllib` and :mod:`urllib2` to the :mod:`urllib` "
"package."
msgstr ""
"Обробляє перейменування :mod:`urllib` і :mod:`urllib2` на пакет :mod:"
"`urllib`."

msgid ""
"Removes excess whitespace from comma separated items.  This fixer is "
"optional."
msgstr ""
"Видаляє зайві пробіли з елементів, розділених комами. Цей закріплювач "
"необов’язковий."

msgid ""
"Renames :func:`xrange` to :func:`range` and wraps existing :func:`range` "
"calls with :class:`list`."
msgstr ""
"Перейменовує :func:`xrange` на :func:`range` і обгортає існуючі виклики :"
"func:`range` :class:`list`."

msgid "Changes ``for x in file.xreadlines()`` to ``for x in file``."
msgstr "Змінює ``for x in file.xreadlines()`` на ``for x in file``."

msgid ""
"Wraps :func:`zip` usage in a :class:`list` call.  This is disabled when "
"``from future_builtins import zip`` appears."
msgstr ""
"Обгортає використання :func:`zip` у виклику :class:`list`. Це вимкнено, коли "
"з’являється ``from future_builtins import zip``."

msgid ":mod:`lib2to3` --- 2to3's library"
msgstr ""

msgid "**Source code:** :source:`Lib/lib2to3/`"
msgstr "**Вихідний код:** :source:`Lib/lib2to3/`"

msgid ""
"Python 3.9 switched to a PEG parser (see :pep:`617`) while lib2to3 is using "
"a less flexible LL(1) parser.  Python 3.10 includes new language syntax that "
"is not parsable by lib2to3's LL(1) parser (see :pep:`634`). The ``lib2to3`` "
"module was marked pending for deprecation in Python 3.9 (raising :exc:"
"`PendingDeprecationWarning` on import) and fully deprecated in Python 3.11 "
"(raising :exc:`DeprecationWarning`). It will be removed from the standard "
"library in Python 3.13. Consider third-party alternatives such as `LibCST`_ "
"or `parso`_."
msgstr ""
"Python 3.9 перейшов на аналізатор PEG (див. :pep:`617`), тоді як lib2to3 "
"використовує менш гнучкий аналізатор LL(1). Python 3.10 включає новий мовний "
"синтаксис, який не піддається синтаксичному аналізу LL(1) lib2to3 (див. :pep:"
"`634`). Модуль ``lib2to3`` було позначено як очікуючий на припинення в "
"Python 3.9 (підвищення :exc:`PendingDeprecationWarning` під час імпорту) і "
"повністю застаріле в Python 3.11 (підвищення :exc:`DeprecationWarning`). "
"Його буде видалено зі стандартної бібліотеки в Python 3.13. Розгляньте "
"сторонні альтернативи, такі як `LibCST`_ або `parso`_."

msgid ""
"The :mod:`lib2to3` API should be considered unstable and may change "
"drastically in the future."
msgstr ""
"API :mod:`lib2to3` слід вважати нестабільним і може кардинально змінитися в "
"майбутньому."
