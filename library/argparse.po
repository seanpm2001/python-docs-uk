# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ""
":mod:`argparse` --- Parser for command-line options, arguments and sub-"
"commands"
msgstr ""
":mod:`argparse` --- аналізатор параметрів командного рядка, аргументів і "
"підкоманд"

msgid "**Source code:** :source:`Lib/argparse.py`"
msgstr "**Вихідний код:** :source:`Lib/argparse.py`"

msgid "Tutorial"
msgstr "Підручник"

msgid ""
"This page contains the API reference information. For a more gentle "
"introduction to Python command-line parsing, have a look at the :ref:"
"`argparse tutorial <argparse-tutorial>`."
msgstr ""
"Ця сторінка містить довідкову інформацію про API. Для більш обережного "
"ознайомлення з розбором командного рядка Python перегляньте :ref:`argparse "
"tutorial <argparse-tutorial>`."

msgid ""
"The :mod:`argparse` module makes it easy to write user-friendly command-line "
"interfaces. The program defines what arguments it requires, and :mod:"
"`argparse` will figure out how to parse those out of :data:`sys.argv`.  The :"
"mod:`argparse` module also automatically generates help and usage messages.  "
"The module will also issue errors when users give the program invalid "
"arguments."
msgstr ""

msgid "Core Functionality"
msgstr ""

msgid ""
"The :mod:`argparse` module's support for command-line interfaces is built "
"around an instance of :class:`argparse.ArgumentParser`.  It is a container "
"for argument specifications and has options that apply the parser as whole::"
msgstr ""

msgid ""
"The :meth:`ArgumentParser.add_argument` method attaches individual argument "
"specifications to the parser.  It supports positional arguments, options "
"that accept values, and on/off flags::"
msgstr ""

msgid ""
"The :meth:`ArgumentParser.parse_args` method runs the parser and places the "
"extracted data in a :class:`argparse.Namespace` object::"
msgstr ""

msgid "Quick Links for add_argument()"
msgstr ""

msgid "Name"
msgstr "Ім'я"

msgid "Description"
msgstr "Опис"

msgid "Values"
msgstr "Цінності"

msgid "action_"
msgstr ""

msgid "Specify how an argument should be handled"
msgstr ""

msgid ""
"``'store'``, ``'store_const'``, ``'store_true'``, ``'append'``, "
"``'append_const'``, ``'count'``, ``'help'``, ``'version'``"
msgstr ""

msgid "choices_"
msgstr ""

msgid "Limit values to a specific set of choices"
msgstr ""

msgid ""
"``['foo', 'bar']``, ``range(1, 10)``, or :class:`~collections.abc.Container` "
"instance"
msgstr ""

msgid "const_"
msgstr ""

msgid "Store a constant value"
msgstr ""

msgid "default_"
msgstr ""

msgid "Default value used when an argument is not provided"
msgstr ""

msgid "Defaults to ``None``"
msgstr ""

msgid "dest_"
msgstr ""

msgid "Specify the attribute name used in the result namespace"
msgstr ""

msgid "help_"
msgstr ""

msgid "Help message for an argument"
msgstr ""

msgid "metavar_"
msgstr ""

msgid "Alternate display name for the argument as shown in help"
msgstr ""

msgid "nargs_"
msgstr ""

msgid "Number of times the argument can be used"
msgstr ""

msgid ":class:`int`, ``'?'``, ``'*'``, ``'+'``, or ``argparse.REMAINDER``"
msgstr ""

msgid "required_"
msgstr ""

msgid "Indicate whether an argument is required or optional"
msgstr ""

msgid "``True`` or ``False``"
msgstr ""

msgid "type_"
msgstr ""

msgid "Automatically convert an argument to the given type"
msgstr ""

msgid ""
":class:`int`, :class:`float`, ``argparse.FileType('w')``, or callable "
"function"
msgstr ""

msgid "Example"
msgstr "приклад"

msgid ""
"The following code is a Python program that takes a list of integers and "
"produces either the sum or the max::"
msgstr ""
"Наступний код є програмою на Python, яка отримує список цілих чисел і "
"створює або суму, або максимум::"

msgid ""
"Assuming the above Python code is saved into a file called ``prog.py``, it "
"can be run at the command line and it provides useful help messages:"
msgstr ""

msgid ""
"When run with the appropriate arguments, it prints either the sum or the max "
"of the command-line integers:"
msgstr ""
"При запуску з відповідними аргументами він друкує або суму, або максимальне "
"значення цілих чисел командного рядка:"

msgid "If invalid arguments are passed in, an error will be displayed:"
msgstr ""

msgid "The following sections walk you through this example."
msgstr "У наступних розділах ви ознайомитеся з цим прикладом."

msgid "Creating a parser"
msgstr "Створення синтаксичного аналізатора"

msgid ""
"The first step in using the :mod:`argparse` is creating an :class:"
"`ArgumentParser` object::"
msgstr ""
"Першим кроком у використанні :mod:`argparse` є створення об’єкта :class:"
"`ArgumentParser`::"

msgid ""
"The :class:`ArgumentParser` object will hold all the information necessary "
"to parse the command line into Python data types."
msgstr ""
"Об’єкт :class:`ArgumentParser` буде містити всю інформацію, необхідну для "
"аналізу командного рядка на типи даних Python."

msgid "Adding arguments"
msgstr "Додавання аргументів"

msgid ""
"Filling an :class:`ArgumentParser` with information about program arguments "
"is done by making calls to the :meth:`~ArgumentParser.add_argument` method. "
"Generally, these calls tell the :class:`ArgumentParser` how to take the "
"strings on the command line and turn them into objects.  This information is "
"stored and used when :meth:`~ArgumentParser.parse_args` is called. For "
"example::"
msgstr ""
"Заповнення :class:`ArgumentParser` інформацією про аргументи програми "
"здійснюється шляхом виклику методу :meth:`~ArgumentParser.add_argument`. "
"Зазвичай ці виклики повідомляють :class:`ArgumentParser`, як брати рядки в "
"командному рядку та перетворювати їх на об’єкти. Ця інформація зберігається "
"та використовується під час виклику :meth:`~ArgumentParser.parse_args`. "
"Наприклад::"

msgid ""
"Later, calling :meth:`~ArgumentParser.parse_args` will return an object with "
"two attributes, ``integers`` and ``accumulate``.  The ``integers`` attribute "
"will be a list of one or more integers, and the ``accumulate`` attribute "
"will be either the :func:`sum` function, if ``--sum`` was specified at the "
"command line, or the :func:`max` function if it was not."
msgstr ""

msgid "Parsing arguments"
msgstr "Розбір аргументів"

msgid ""
":class:`ArgumentParser` parses arguments through the :meth:`~ArgumentParser."
"parse_args` method.  This will inspect the command line, convert each "
"argument to the appropriate type and then invoke the appropriate action. In "
"most cases, this means a simple :class:`Namespace` object will be built up "
"from attributes parsed out of the command line::"
msgstr ""
":class:`ArgumentParser` аналізує аргументи за допомогою методу :meth:"
"`~ArgumentParser.parse_args`. Це перевірить командний рядок, перетворить "
"кожен аргумент у відповідний тип, а потім викличе відповідну дію. У "
"більшості випадків це означає, що простий об’єкт :class:`Namespace` буде "
"створено з атрибутів, проаналізованих із командного рядка::"

msgid ""
"In a script, :meth:`~ArgumentParser.parse_args` will typically be called "
"with no arguments, and the :class:`ArgumentParser` will automatically "
"determine the command-line arguments from :data:`sys.argv`."
msgstr ""
"У сценарії :meth:`~ArgumentParser.parse_args` зазвичай викликається без "
"аргументів, а :class:`ArgumentParser` автоматично визначатиме аргументи "
"командного рядка з :data:`sys.argv`."

msgid "ArgumentParser objects"
msgstr "Об’єкти ArgumentParser"

msgid ""
"Create a new :class:`ArgumentParser` object. All parameters should be passed "
"as keyword arguments. Each parameter has its own more detailed description "
"below, but in short they are:"
msgstr ""
"Створіть новий об’єкт :class:`ArgumentParser`. Усі параметри слід передати "
"як аргументи ключового слова. Кожен параметр має власний більш детальний "
"опис нижче, але коротко вони:"

msgid ""
"prog_ - The name of the program (default: ``os.path.basename(sys.argv[0])``)"
msgstr ""
"prog_ - назва програми (за замовчуванням: ``os.path.basename(sys.argv[0])``)"

msgid ""
"usage_ - The string describing the program usage (default: generated from "
"arguments added to parser)"
msgstr ""
"usage_ - рядок, що описує використання програми (за замовчуванням: "
"генерується з аргументів, доданих до аналізатора)"

msgid ""
"description_ - Text to display before the argument help (by default, no text)"
msgstr ""

msgid "epilog_ - Text to display after the argument help (by default, no text)"
msgstr ""

msgid ""
"parents_ - A list of :class:`ArgumentParser` objects whose arguments should "
"also be included"
msgstr ""
"Parents_ - список об'єктів :class:`ArgumentParser`, аргументи яких також "
"мають бути включені"

msgid "formatter_class_ - A class for customizing the help output"
msgstr "formatter_class_ - клас для налаштування виведення довідки"

msgid ""
"prefix_chars_ - The set of characters that prefix optional arguments "
"(default: '-')"
msgstr ""
"prefix_chars_ - набір символів, які є префіксом необов'язкових аргументів "
"(за замовчуванням: '-')"

msgid ""
"fromfile_prefix_chars_ - The set of characters that prefix files from which "
"additional arguments should be read (default: ``None``)"
msgstr ""
"fromfile_prefix_chars_ - набір символів, які є префіксами файлів, з яких "
"слід читати додаткові аргументи (за замовчуванням: ``None``)"

msgid ""
"argument_default_ - The global default value for arguments (default: "
"``None``)"
msgstr ""
"argument_default_ - глобальне значення за замовчуванням для аргументів (за "
"замовчуванням: ``None``)"

msgid ""
"conflict_handler_ - The strategy for resolving conflicting optionals "
"(usually unnecessary)"
msgstr ""
"конфлікт_обробник_ - стратегія вирішення конфліктних опцій (зазвичай "
"непотрібних)"

msgid ""
"add_help_ - Add a ``-h/--help`` option to the parser (default: ``True``)"
msgstr ""
"add_help_ - додає опцію ``-h/--help`` до аналізатора (за замовчуванням: "
"``True``)"

msgid ""
"allow_abbrev_ - Allows long options to be abbreviated if the abbreviation is "
"unambiguous. (default: ``True``)"
msgstr ""
"allow_abbrev_ - Дозволяє скорочувати довгі параметри, якщо скорочення є "
"однозначним. (за замовчуванням: ``True``)"

msgid ""
"exit_on_error_ - Determines whether or not ArgumentParser exits with error "
"info when an error occurs. (default: ``True``)"
msgstr ""
"exit_on_error_ – визначає, чи завершує роботу ArgumentParser з інформацією "
"про помилку, коли виникає помилка. (за замовчуванням: ``True``)"

msgid "*allow_abbrev* parameter was added."
msgstr "Додано параметр *allow_abbrev*."

msgid ""
"In previous versions, *allow_abbrev* also disabled grouping of short flags "
"such as ``-vv`` to mean ``-v -v``."
msgstr ""
"У попередніх версіях *allow_abbrev* також вимикав групування коротких "
"прапорців, таких як ``-vv``, щоб означати ``-v -v``."

msgid "*exit_on_error* parameter was added."
msgstr "Додано параметр *exit_on_error*."

msgid "The following sections describe how each of these are used."
msgstr "У наступних розділах описано, як використовується кожен із них."

msgid "prog"
msgstr "прог"

msgid ""
"By default, :class:`ArgumentParser` objects use ``sys.argv[0]`` to determine "
"how to display the name of the program in help messages.  This default is "
"almost always desirable because it will make the help messages match how the "
"program was invoked on the command line.  For example, consider a file named "
"``myprogram.py`` with the following code::"
msgstr ""
"За замовчуванням об’єкти :class:`ArgumentParser` використовують ``sys."
"argv[0]``, щоб визначити, як відображати назву програми в довідкових "
"повідомленнях. Це за замовчуванням є майже завжди бажаним, оскільки воно "
"змусить повідомлення довідки відповідати тому, як програма була викликана в "
"командному рядку. Наприклад, розглянемо файл з назвою ``myprogram.py`` з "
"таким кодом::"

msgid ""
"The help for this program will display ``myprogram.py`` as the program name "
"(regardless of where the program was invoked from):"
msgstr ""
"Довідка для цієї програми відображатиме ``myprogram.py`` як назву програми "
"(незалежно від того, звідки програму було викликано):"

msgid ""
"To change this default behavior, another value can be supplied using the "
"``prog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"Щоб змінити цю типову поведінку, можна надати інше значення за допомогою "
"аргументу ``prog=`` до :class:`ArgumentParser`::"

msgid ""
"Note that the program name, whether determined from ``sys.argv[0]`` or from "
"the ``prog=`` argument, is available to help messages using the ``%(prog)s`` "
"format specifier."
msgstr ""
"Зауважте, що ім’я програми, незалежно від того, чи визначається з ``sys."
"argv[0]`` або з ``prog=`` аргументу, доступне для довідкових повідомлень за "
"допомогою специфікатора формату ``%(prog)s``."

msgid "usage"
msgstr "використання"

msgid ""
"By default, :class:`ArgumentParser` calculates the usage message from the "
"arguments it contains::"
msgstr ""
"За замовчуванням :class:`ArgumentParser` обчислює повідомлення про "
"використання з аргументів, які він містить:"

msgid ""
"The default message can be overridden with the ``usage=`` keyword argument::"
msgstr ""
"Повідомлення за замовчуванням можна замінити аргументом ключового слова "
"``usage=``::"

msgid ""
"The ``%(prog)s`` format specifier is available to fill in the program name "
"in your usage messages."
msgstr ""
"Специфікатор формату ``%(prog)s`` доступний для заповнення назви програми у "
"ваших повідомленнях про використання."

msgid "description"
msgstr "опис"

msgid ""
"Most calls to the :class:`ArgumentParser` constructor will use the "
"``description=`` keyword argument.  This argument gives a brief description "
"of what the program does and how it works.  In help messages, the "
"description is displayed between the command-line usage string and the help "
"messages for the various arguments::"
msgstr ""
"Більшість викликів конструктора :class:`ArgumentParser` використовуватимуть "
"аргумент ключового слова ``description=``. Цей аргумент дає короткий опис "
"того, що програма робить і як вона працює. У довідкових повідомленнях опис "
"відображається між рядком використання командного рядка та довідковими "
"повідомленнями для різних аргументів:"

msgid ""
"By default, the description will be line-wrapped so that it fits within the "
"given space.  To change this behavior, see the formatter_class_ argument."
msgstr ""
"За замовчуванням опис буде перенесено на рядок, щоб він поміщався в заданий "
"простір. Щоб змінити цю поведінку, перегляньте аргумент formatter_class_."

msgid "epilog"
msgstr "епілог"

msgid ""
"Some programs like to display additional description of the program after "
"the description of the arguments.  Such text can be specified using the "
"``epilog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"Деякі програми люблять відображати додатковий опис програми після опису "
"аргументів. Такий текст можна вказати за допомогою аргументу ``epilog=`` "
"для :class:`ArgumentParser`::"

msgid ""
"As with the description_ argument, the ``epilog=`` text is by default line-"
"wrapped, but this behavior can be adjusted with the formatter_class_ "
"argument to :class:`ArgumentParser`."
msgstr ""
"Як і в випадку з аргументом description_, текст ``epilog=`` за замовчуванням "
"переносить рядки, але цю поведінку можна налаштувати за допомогою аргументу "
"formatter_class_ на :class:`ArgumentParser`."

msgid "parents"
msgstr "батьки"

msgid ""
"Sometimes, several parsers share a common set of arguments. Rather than "
"repeating the definitions of these arguments, a single parser with all the "
"shared arguments and passed to ``parents=`` argument to :class:"
"`ArgumentParser` can be used.  The ``parents=`` argument takes a list of :"
"class:`ArgumentParser` objects, collects all the positional and optional "
"actions from them, and adds these actions to the :class:`ArgumentParser` "
"object being constructed::"
msgstr ""
"Іноді кілька аналізаторів використовують загальний набір аргументів. Замість "
"того, щоб повторювати визначення цих аргументів, можна використати єдиний "
"синтаксичний аналізатор із усіма спільними аргументами та переданим "
"аргументом ``parents=`` для :class:`ArgumentParser`. Аргумент ``parents=`` "
"бере список об’єктів :class:`ArgumentParser`, збирає всі позиційні та "
"необов’язкові дії з них і додає ці дії до об’єкта :class:`ArgumentParser`, "
"який створюється::"

msgid ""
"Note that most parent parsers will specify ``add_help=False``.  Otherwise, "
"the :class:`ArgumentParser` will see two ``-h/--help`` options (one in the "
"parent and one in the child) and raise an error."
msgstr ""
"Зауважте, що більшість батьківських аналізаторів вказуватимуть "
"``add_help=False``. Інакше :class:`ArgumentParser` побачить два параметри ``-"
"h/--help`` (один у батьківському і один у дочірньому) і викличе помилку."

msgid ""
"You must fully initialize the parsers before passing them via ``parents=``. "
"If you change the parent parsers after the child parser, those changes will "
"not be reflected in the child."
msgstr ""
"Ви повинні повністю ініціалізувати аналізатори перед тим, як передавати їх "
"через ``parents=``. Якщо ви змінюєте батьківські аналізатори після "
"дочірнього, ці зміни не відображатимуться в дочірньому."

msgid "formatter_class"
msgstr "formatter_class"

msgid ""
":class:`ArgumentParser` objects allow the help formatting to be customized "
"by specifying an alternate formatting class.  Currently, there are four such "
"classes:"
msgstr ""
"Об’єкти :class:`ArgumentParser` дозволяють налаштувати форматування довідки "
"шляхом визначення альтернативного класу форматування. На даний момент існує "
"чотири таких класи:"

msgid ""
":class:`RawDescriptionHelpFormatter` and :class:`RawTextHelpFormatter` give "
"more control over how textual descriptions are displayed. By default, :class:"
"`ArgumentParser` objects line-wrap the description_ and epilog_ texts in "
"command-line help messages::"
msgstr ""
":class:`RawDescriptionHelpFormatter` і :class:`RawTextHelpFormatter` дають "
"більше контролю над тим, як відображаються текстові описи. За замовчуванням "
"об’єкти :class:`ArgumentParser` переносять тексти description_ і epilog_ у "
"довідкові повідомлення командного рядка:"

msgid ""
"Passing :class:`RawDescriptionHelpFormatter` as ``formatter_class=`` "
"indicates that description_ and epilog_ are already correctly formatted and "
"should not be line-wrapped::"
msgstr ""
"Передача :class:`RawDescriptionHelpFormatter` як ``formatter_class=`` вказує "
"на те, що description_ і epilog_ вже правильно відформатовані і не повинні "
"бути перенесені в рядок::"

msgid ""
":class:`RawTextHelpFormatter` maintains whitespace for all sorts of help "
"text, including argument descriptions. However, multiple new lines are "
"replaced with one. If you wish to preserve multiple blank lines, add spaces "
"between the newlines."
msgstr ""
":class:`RawTextHelpFormatter` зберігає пробіли для всіх видів довідкового "
"тексту, включаючи описи аргументів. Однак кілька нових рядків замінено "
"одним. Якщо ви бажаєте зберегти кілька порожніх рядків, додайте пробіли між "
"новими рядками."

msgid ""
":class:`ArgumentDefaultsHelpFormatter` automatically adds information about "
"default values to each of the argument help messages::"
msgstr ""
":class:`ArgumentDefaultsHelpFormatter` автоматично додає інформацію про "
"значення за замовчуванням до кожного довідкового повідомлення аргументу::"

msgid ""
":class:`MetavarTypeHelpFormatter` uses the name of the type_ argument for "
"each argument as the display name for its values (rather than using the "
"dest_ as the regular formatter does)::"
msgstr ""
":class:`MetavarTypeHelpFormatter` використовує ім’я аргументу type_ для "
"кожного аргументу як відображуване ім’я для його значень (замість "
"використання dest_, як це робить звичайний засіб форматування):"

msgid "prefix_chars"
msgstr "prefix_chars"

msgid ""
"Most command-line options will use ``-`` as the prefix, e.g. ``-f/--foo``. "
"Parsers that need to support different or additional prefix characters, e.g. "
"for options like ``+f`` or ``/foo``, may specify them using the "
"``prefix_chars=`` argument to the ArgumentParser constructor::"
msgstr ""
"Більшість параметрів командного рядка використовуватимуть ``-`` як префікс, "
"напр. ``-f/--foo``. Парсери, які повинні підтримувати різні або додаткові "
"префіксні символи, напр. для таких параметрів, як ``+f`` або ``/foo``, можна "
"вказати їх за допомогою аргументу ``prefix_chars=`` конструктора "
"ArgumentParser::"

msgid ""
"The ``prefix_chars=`` argument defaults to ``'-'``. Supplying a set of "
"characters that does not include ``-`` will cause ``-f/--foo`` options to be "
"disallowed."
msgstr ""
"Аргумент ``prefix_chars=`` за умовчанням має значення ``'-'``. Якщо вказати "
"набір символів, який не містить ``-``, параметри ``-f/--foo`` будуть "
"заборонені."

msgid "fromfile_prefix_chars"
msgstr "fromfile_prefix_chars"

msgid ""
"Sometimes, when dealing with a particularly long argument list, it may make "
"sense to keep the list of arguments in a file rather than typing it out at "
"the command line.  If the ``fromfile_prefix_chars=`` argument is given to "
"the :class:`ArgumentParser` constructor, then arguments that start with any "
"of the specified characters will be treated as files, and will be replaced "
"by the arguments they contain.  For example::"
msgstr ""

msgid ""
"Arguments read from a file must by default be one per line (but see also :"
"meth:`~ArgumentParser.convert_arg_line_to_args`) and are treated as if they "
"were in the same place as the original file referencing argument on the "
"command line.  So in the example above, the expression ``['-f', 'foo', "
"'@args.txt']`` is considered equivalent to the expression ``['-f', 'foo', '-"
"f', 'bar']``."
msgstr ""
"Аргументи, зчитані з файлу, за замовчуванням мають бути по одному на рядок "
"(але дивіться також :meth:`~ArgumentParser.convert_arg_line_to_args`) і "
"обробляються так, ніби вони знаходяться в тому самому місці, що й вихідний "
"аргумент посилання на файл у командному рядку. Отже, у наведеному вище "
"прикладі вираз ``['-f', 'foo', '@args.txt']`` вважається еквівалентним "
"виразу ``['-f', 'foo', '-f ', 'бар']``."

msgid ""
"The ``fromfile_prefix_chars=`` argument defaults to ``None``, meaning that "
"arguments will never be treated as file references."
msgstr ""
"Аргумент ``fromfile_prefix_chars=`` за умовчанням має значення ``None``, що "
"означає, що аргументи ніколи не розглядатимуться як посилання на файли."

msgid "argument_default"
msgstr "аргумент_за замовчуванням"

msgid ""
"Generally, argument defaults are specified either by passing a default to :"
"meth:`~ArgumentParser.add_argument` or by calling the :meth:`~ArgumentParser."
"set_defaults` methods with a specific set of name-value pairs.  Sometimes "
"however, it may be useful to specify a single parser-wide default for "
"arguments.  This can be accomplished by passing the ``argument_default=`` "
"keyword argument to :class:`ArgumentParser`.  For example, to globally "
"suppress attribute creation on :meth:`~ArgumentParser.parse_args` calls, we "
"supply ``argument_default=SUPPRESS``::"
msgstr ""
"Як правило, параметри за замовчуванням вказуються або передачею значення за "
"замовчуванням :meth:`~ArgumentParser.add_argument`, або викликом методів :"
"meth:`~ArgumentParser.set_defaults` із певним набором пар ім’я-значення. "
"Іноді, однак, може бути корисно вказати єдине значення за замовчуванням для "
"параметрів аналізатора. Це можна зробити, передавши аргумент ключового слова "
"``argument_default=`` до :class:`ArgumentParser`. Наприклад, щоб глобально "
"заборонити створення атрибутів у викликах :meth:`~ArgumentParser."
"parse_args`, ми надаємо ``argument_default=SUPPRESS``::"

msgid "allow_abbrev"
msgstr "дозволити_скорочене"

msgid ""
"Normally, when you pass an argument list to the :meth:`~ArgumentParser."
"parse_args` method of an :class:`ArgumentParser`, it :ref:`recognizes "
"abbreviations <prefix-matching>` of long options."
msgstr ""
"Зазвичай, коли ви передаєте список аргументів у метод :meth:`~ArgumentParser."
"parse_args` :class:`ArgumentParser`, він :ref:`розпізнає абревіатури <prefix-"
"matching>` довгих параметрів."

msgid "This feature can be disabled by setting ``allow_abbrev`` to ``False``::"
msgstr ""
"Цю функцію можна вимкнути, встановивши для параметра ``allow_abbrev`` "
"значення ``False``::"

msgid "conflict_handler"
msgstr "обробник_конфлікту"

msgid ""
":class:`ArgumentParser` objects do not allow two actions with the same "
"option string.  By default, :class:`ArgumentParser` objects raise an "
"exception if an attempt is made to create an argument with an option string "
"that is already in use::"
msgstr ""
"Об’єкти :class:`ArgumentParser` не дозволяють дві дії з однаковим рядком "
"параметрів. За замовчуванням об’єкти :class:`ArgumentParser` викликають "
"виняток, якщо робиться спроба створити аргумент із рядком параметрів, який "
"уже використовується:"

msgid ""
"Sometimes (e.g. when using parents_) it may be useful to simply override any "
"older arguments with the same option string.  To get this behavior, the "
"value ``'resolve'`` can be supplied to the ``conflict_handler=`` argument "
"of :class:`ArgumentParser`::"
msgstr ""
"Іноді (наприклад, під час використання батьків_) може бути корисним просто "
"замінити будь-які старіші аргументи тим самим рядком параметрів. Щоб "
"отримати таку поведінку, значення ``'resolve'`` можна надати аргументу "
"``conflict_handler=`` :class:`ArgumentParser`::"

msgid ""
"Note that :class:`ArgumentParser` objects only remove an action if all of "
"its option strings are overridden.  So, in the example above, the old ``-f/--"
"foo`` action is retained as the ``-f`` action, because only the ``--foo`` "
"option string was overridden."
msgstr ""
"Зауважте, що об’єкти :class:`ArgumentParser` видаляють дію лише в тому "
"випадку, якщо перевизначено всі рядки параметрів. Отже, у наведеному вище "
"прикладі стара дія ``-f/--foo`` зберігається як дія ``-f``, тому що було "
"замінено лише рядок опції ``--foo``."

msgid "add_help"
msgstr "add_help"

msgid ""
"By default, ArgumentParser objects add an option which simply displays the "
"parser's help message. For example, consider a file named ``myprogram.py`` "
"containing the following code::"
msgstr ""
"За замовчуванням об’єкти ArgumentParser додають параметр, який просто "
"відображає довідкове повідомлення аналізатора. Наприклад, розглянемо файл з "
"назвою ``myprogram.py``, який містить наступний код:"

msgid ""
"If ``-h`` or ``--help`` is supplied at the command line, the ArgumentParser "
"help will be printed:"
msgstr ""
"Якщо в командному рядку вказано ``-h`` або ``--help``, буде надруковано "
"довідку ArgumentParser:"

msgid ""
"Occasionally, it may be useful to disable the addition of this help option. "
"This can be achieved by passing ``False`` as the ``add_help=`` argument to :"
"class:`ArgumentParser`::"
msgstr ""
"Іноді може бути корисним вимкнути додавання цієї опції довідки. Цього можна "
"досягти, передавши ``False`` як аргумент ``add_help=`` до :class:"
"`ArgumentParser`::"

msgid ""
"The help option is typically ``-h/--help``. The exception to this is if the "
"``prefix_chars=`` is specified and does not include ``-``, in which case ``-"
"h`` and ``--help`` are not valid options.  In this case, the first character "
"in ``prefix_chars`` is used to prefix the help options::"
msgstr ""
"Параметром довідки зазвичай є ``-h/--help``. Винятком є те, що "
"``prefix_chars=`` указано і не містить ``-``, у цьому випадку ``-h`` і ``--"
"help`` не є дійсними параметрами. У цьому випадку перший символ у "
"``prefix_chars`` використовується для префіксу параметрів довідки::"

msgid "exit_on_error"
msgstr "exit_on_error"

msgid ""
"Normally, when you pass an invalid argument list to the :meth:"
"`~ArgumentParser.parse_args` method of an :class:`ArgumentParser`, it will "
"exit with error info."
msgstr ""
"Зазвичай, коли ви передаєте недійсний список аргументів у метод :meth:"
"`~ArgumentParser.parse_args` :class:`ArgumentParser`, він завершить роботу з "
"інформацією про помилку."

msgid ""
"If the user would like to catch errors manually, the feature can be enabled "
"by setting ``exit_on_error`` to ``False``::"
msgstr ""
"Якщо користувач хоче виловлювати помилки вручну, цю функцію можна ввімкнути, "
"встановивши для ``exit_on_error`` значення ``False``::"

msgid "The add_argument() method"
msgstr "Метод add_argument()."

msgid ""
"Define how a single command-line argument should be parsed.  Each parameter "
"has its own more detailed description below, but in short they are:"
msgstr ""
"Визначте, як слід аналізувати один аргумент командного рядка. Кожен параметр "
"має власний більш детальний опис нижче, але коротко вони:"

msgid ""
"`name or flags`_ - Either a name or a list of option strings, e.g. ``foo`` "
"or ``-f, --foo``."
msgstr ""
"`name or flags`_ - або ім'я, або список рядків параметрів, напр. ``foo`` або "
"``-f, --foo``."

msgid ""
"action_ - The basic type of action to be taken when this argument is "
"encountered at the command line."
msgstr ""
"action_ - основний тип дії, яку потрібно виконати, коли цей аргумент "
"зустрічається в командному рядку."

msgid "nargs_ - The number of command-line arguments that should be consumed."
msgstr ""
"nargs_ – кількість аргументів командного рядка, які мають бути використані."

msgid ""
"const_ - A constant value required by some action_ and nargs_ selections."
msgstr ""
"const_ – постійне значення, необхідне для вибору деяких action_ і nargs_."

msgid ""
"default_ - The value produced if the argument is absent from the command "
"line and if it is absent from the namespace object."
msgstr ""
"default_ – значення, створене, якщо аргумент відсутній у командному рядку та "
"якщо він відсутній в об’єкті простору імен."

msgid ""
"type_ - The type to which the command-line argument should be converted."
msgstr "type_ – тип, до якого потрібно перетворити аргумент командного рядка."

msgid "choices_ - A container of the allowable values for the argument."
msgstr "choices_ – контейнер допустимих значень для аргументу."

msgid ""
"required_ - Whether or not the command-line option may be omitted (optionals "
"only)."
msgstr ""
"required_ – чи можна пропустити параметр командного рядка (тільки "
"необов’язковий)."

msgid "help_ - A brief description of what the argument does."
msgstr "help_ - короткий опис того, що робить аргумент."

msgid "metavar_ - A name for the argument in usage messages."
msgstr "metavar_ – назва аргументу в повідомленнях про використання."

msgid ""
"dest_ - The name of the attribute to be added to the object returned by :"
"meth:`parse_args`."
msgstr ""
"dest_ – ім’я атрибута, який буде додано до об’єкта, повернутого :meth:"
"`parse_args`."

msgid "name or flags"
msgstr "назву чи прапори"

msgid ""
"The :meth:`~ArgumentParser.add_argument` method must know whether an "
"optional argument, like ``-f`` or ``--foo``, or a positional argument, like "
"a list of filenames, is expected.  The first arguments passed to :meth:"
"`~ArgumentParser.add_argument` must therefore be either a series of flags, "
"or a simple argument name."
msgstr ""

msgid "For example, an optional argument could be created like::"
msgstr ""

msgid "while a positional argument could be created like::"
msgstr "тоді як позиційний аргумент може бути створений таким чином::"

msgid ""
"When :meth:`~ArgumentParser.parse_args` is called, optional arguments will "
"be identified by the ``-`` prefix, and the remaining arguments will be "
"assumed to be positional::"
msgstr ""
"Під час виклику :meth:`~ArgumentParser.parse_args` необов’язкові аргументи "
"ідентифікуються префіксом ``-``, а решта аргументів вважатиметься "
"позиційними:"

msgid "action"
msgstr "дію"

msgid ""
":class:`ArgumentParser` objects associate command-line arguments with "
"actions.  These actions can do just about anything with the command-line "
"arguments associated with them, though most actions simply add an attribute "
"to the object returned by :meth:`~ArgumentParser.parse_args`.  The "
"``action`` keyword argument specifies how the command-line arguments should "
"be handled. The supplied actions are:"
msgstr ""
"Об’єкти :class:`ArgumentParser` пов’язують аргументи командного рядка з "
"діями. Ці дії можуть робити що завгодно з пов’язаними з ними аргументами "
"командного рядка, хоча більшість дій просто додають атрибут до об’єкта, який "
"повертає :meth:`~ArgumentParser.parse_args`. Аргумент ключового слова "
"``action`` визначає, як слід обробляти аргументи командного рядка. Надані "
"дії:"

msgid ""
"``'store'`` - This just stores the argument's value.  This is the default "
"action. For example::"
msgstr ""
"``'store'`` – тут лише зберігається значення аргументу. Це типова дія. "
"Наприклад::"

msgid ""
"``'store_const'`` - This stores the value specified by the const_ keyword "
"argument; note that the const_ keyword argument defaults to ``None``.  The "
"``'store_const'`` action is most commonly used with optional arguments that "
"specify some sort of flag.  For example::"
msgstr ""

msgid ""
"``'store_true'`` and ``'store_false'`` - These are special cases of "
"``'store_const'`` used for storing the values ``True`` and ``False`` "
"respectively.  In addition, they create default values of ``False`` and "
"``True`` respectively.  For example::"
msgstr ""
"``'store_true'`` і ``'store_false'`` – це особливі випадки "
"``'store_const'``, які використовуються для зберігання значень ``True`` і "
"``False`` відповідно. Крім того, вони створюють значення за замовчуванням "
"``False`` і ``True`` відповідно. Наприклад::"

msgid ""
"``'append'`` - This stores a list, and appends each argument value to the "
"list. It is useful to allow an option to be specified multiple times. If the "
"default value is non-empty, the default elements will be present in the "
"parsed value for the option, with any values from the command line appended "
"after those default values. Example usage::"
msgstr ""

msgid ""
"``'append_const'`` - This stores a list, and appends the value specified by "
"the const_ keyword argument to the list; note that the const_ keyword "
"argument defaults to ``None``. The ``'append_const'`` action is typically "
"useful when multiple arguments need to store constants to the same list. For "
"example::"
msgstr ""

msgid ""
"``'count'`` - This counts the number of times a keyword argument occurs. For "
"example, this is useful for increasing verbosity levels::"
msgstr ""
"``'count'`` – підраховує кількість разів, коли виникає аргумент ключового "
"слова. Наприклад, це корисно для збільшення рівнів докладності:"

msgid "Note, the *default* will be ``None`` unless explicitly set to *0*."
msgstr ""
"Зауважте, *за замовчуванням* буде ``None``, якщо явно не встановлено *0*."

msgid ""
"``'help'`` - This prints a complete help message for all the options in the "
"current parser and then exits. By default a help action is automatically "
"added to the parser. See :class:`ArgumentParser` for details of how the "
"output is created."
msgstr ""
"``'help'`` - друкує повне повідомлення довідки для всіх параметрів у "
"поточному парсері, а потім завершує роботу. За замовчуванням дія довідки "
"автоматично додається до аналізатора. Дивіться :class:`ArgumentParser` для "
"детальної інформації про те, як створюється вихід."

msgid ""
"``'version'`` - This expects a ``version=`` keyword argument in the :meth:"
"`~ArgumentParser.add_argument` call, and prints version information and "
"exits when invoked::"
msgstr ""
"``'version'`` – очікується ключовий аргумент ``version=`` у виклику :meth:"
"`~ArgumentParser.add_argument`, друкується інформація про версію та "
"завершується після виклику::"

msgid ""
"``'extend'`` - This stores a list, and extends each argument value to the "
"list. Example usage::"
msgstr ""
"``'extend'`` – це зберігає список і розширює кожне значення аргументу до "
"списку. Приклад використання::"

msgid ""
"You may also specify an arbitrary action by passing an Action subclass or "
"other object that implements the same interface. The "
"``BooleanOptionalAction`` is available in ``argparse`` and adds support for "
"boolean actions such as ``--foo`` and ``--no-foo``::"
msgstr ""
"Ви також можете вказати довільну дію, передавши підклас Action або інший "
"об’єкт, який реалізує той самий інтерфейс. ``BooleanOptionalAction`` "
"доступна в ``argparse`` і додає підтримку логічних дій, таких як ``--foo`` і "
"``--no-foo``::"

msgid ""
"The recommended way to create a custom action is to extend :class:`Action`, "
"overriding the ``__call__`` method and optionally the ``__init__`` and "
"``format_usage`` methods."
msgstr ""
"Рекомендований спосіб створити спеціальну дію — розширити :class:`Action`, "
"замінивши метод ``__call__`` і, за бажанням, ``__init__`` та "
"``format_usage``."

msgid "An example of a custom action::"
msgstr "Приклад спеціальної дії::"

msgid "For more details, see :class:`Action`."
msgstr "Для отримання додаткової інформації див. :class:`Action`."

msgid "nargs"
msgstr "наргс"

msgid ""
"ArgumentParser objects usually associate a single command-line argument with "
"a single action to be taken.  The ``nargs`` keyword argument associates a "
"different number of command-line arguments with a single action.  The "
"supported values are:"
msgstr ""
"Об’єкти ArgumentParser зазвичай пов’язують один аргумент командного рядка з "
"однією дією, яку потрібно виконати. Аргумент ключового слова ``nargs`` "
"пов’язує різну кількість аргументів командного рядка з однією дією. "
"Підтримувані значення:"

msgid ""
"``N`` (an integer).  ``N`` arguments from the command line will be gathered "
"together into a list.  For example::"
msgstr ""
"``N`` (ціле число). ``N`` аргументів з командного рядка буде зібрано разом у "
"список. Наприклад::"

msgid ""
"Note that ``nargs=1`` produces a list of one item.  This is different from "
"the default, in which the item is produced by itself."
msgstr ""
"Зауважте, що ``nargs=1`` створює список з одного елемента. Це відрізняється "
"від типового, коли елемент створюється сам по собі."

msgid ""
"``'?'``. One argument will be consumed from the command line if possible, "
"and produced as a single item.  If no command-line argument is present, the "
"value from default_ will be produced.  Note that for optional arguments, "
"there is an additional case - the option string is present but not followed "
"by a command-line argument.  In this case the value from const_ will be "
"produced.  Some examples to illustrate this::"
msgstr ""
"``'?'``. Один аргумент буде використано з командного рядка, якщо це можливо, "
"і створено як окремий елемент. Якщо аргумент командного рядка відсутній, "
"буде отримано значення з default_. Зауважте, що для необов’язкових "
"аргументів існує додатковий випадок – рядок параметрів присутній, але не "
"слідує за аргументом командного рядка. У цьому випадку буде отримано "
"значення з const_. Деякі приклади для ілюстрації:"

msgid ""
"One of the more common uses of ``nargs='?'`` is to allow optional input and "
"output files::"
msgstr ""
"Одне з найпоширеніших застосувань ``nargs='?''`` — дозволити додаткові файли "
"введення та виведення:"

msgid ""
"``'*'``.  All command-line arguments present are gathered into a list.  Note "
"that it generally doesn't make much sense to have more than one positional "
"argument with ``nargs='*'``, but multiple optional arguments with "
"``nargs='*'`` is possible.  For example::"
msgstr ""
"``'*'``. Усі присутні аргументи командного рядка збираються у список. "
"Зауважте, що зазвичай не має сенсу мати більше одного позиційного аргументу "
"з ``nargs='*'``, але кілька необов'язкових аргументів з ``nargs='*'`` "
"можливі. Наприклад::"

msgid ""
"``'+'``. Just like ``'*'``, all command-line args present are gathered into "
"a list.  Additionally, an error message will be generated if there wasn't at "
"least one command-line argument present.  For example::"
msgstr ""
"``'+'``. Подібно до ``'*'``, усі наявні аргументи командного рядка "
"збираються в список. Крім того, буде створено повідомлення про помилку, якщо "
"не було принаймні одного аргументу командного рядка. Наприклад::"

msgid ""
"If the ``nargs`` keyword argument is not provided, the number of arguments "
"consumed is determined by the action_.  Generally this means a single "
"command-line argument will be consumed and a single item (not a list) will "
"be produced."
msgstr ""
"Якщо аргумент ключового слова ``nargs`` не надано, кількість споживаних "
"аргументів визначається дією_. Загалом це означає, що один аргумент "
"командного рядка буде використано, і буде створено один елемент (не список)."

msgid "const"
msgstr "конст"

msgid ""
"The ``const`` argument of :meth:`~ArgumentParser.add_argument` is used to "
"hold constant values that are not read from the command line but are "
"required for the various :class:`ArgumentParser` actions.  The two most "
"common uses of it are:"
msgstr ""
"Аргумент ``const`` :meth:`~ArgumentParser.add_argument` використовується для "
"зберігання постійних значень, які не читаються з командного рядка, але "
"потрібні для різних дій :class:`ArgumentParser`. Два найпоширеніші його "
"використання:"

msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with "
"``action='store_const'`` or ``action='append_const'``.  These actions add "
"the ``const`` value to one of the attributes of the object returned by :meth:"
"`~ArgumentParser.parse_args`. See the action_ description for examples. If "
"``const`` is not provided to :meth:`~ArgumentParser.add_argument`, it will "
"receive a default value of ``None``."
msgstr ""

msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with option strings "
"(like ``-f`` or ``--foo``) and ``nargs='?'``.  This creates an optional "
"argument that can be followed by zero or one command-line arguments. When "
"parsing the command line, if the option string is encountered with no "
"command-line argument following it, the value of ``const`` will be assumed "
"to be ``None`` instead.  See the nargs_ description for examples."
msgstr ""

msgid ""
"``const=None`` by default, including when ``action='append_const'`` or "
"``action='store_const'``."
msgstr ""

msgid "default"
msgstr "за замовчуванням"

msgid ""
"All optional arguments and some positional arguments may be omitted at the "
"command line.  The ``default`` keyword argument of :meth:`~ArgumentParser."
"add_argument`, whose value defaults to ``None``, specifies what value should "
"be used if the command-line argument is not present. For optional arguments, "
"the ``default`` value is used when the option string was not present at the "
"command line::"
msgstr ""
"Усі додаткові аргументи та деякі позиційні аргументи можна пропустити в "
"командному рядку. Аргумент ключового слова ``default`` :meth:"
"`~ArgumentParser.add_argument`, значення якого за замовчуванням ``None``, "
"визначає, яке значення слід використовувати, якщо аргумент командного рядка "
"відсутній. Для необов’язкових аргументів використовується значення ``за "
"замовчуванням``, якщо рядок параметрів відсутній у командному рядку::"

msgid ""
"If the target namespace already has an attribute set, the action *default* "
"will not over write it::"
msgstr ""
"Якщо цільовий простір імен уже має встановлений атрибут, дія *default* не "
"перезаписує його:"

msgid ""
"If the ``default`` value is a string, the parser parses the value as if it "
"were a command-line argument.  In particular, the parser applies any type_ "
"conversion argument, if provided, before setting the attribute on the :class:"
"`Namespace` return value.  Otherwise, the parser uses the value as is::"
msgstr ""
"Якщо значенням ``default`` є рядок, синтаксичний аналізатор аналізує "
"значення так, ніби це аргумент командного рядка. Зокрема, синтаксичний "
"аналізатор застосовує будь-який аргумент перетворення type_, якщо він "
"надається, перед встановленням атрибута для значення, що повертається :class:"
"`Namespace`. В іншому випадку аналізатор використовує значення як є::"

msgid ""
"For positional arguments with nargs_ equal to ``?`` or ``*``, the "
"``default`` value is used when no command-line argument was present::"
msgstr ""
"Для позиційних аргументів, у яких nargs_ дорівнює ``?`` або ``*``, значення "
"``default`` використовується, якщо аргумент командного рядка відсутній:"

msgid ""
"Providing ``default=argparse.SUPPRESS`` causes no attribute to be added if "
"the command-line argument was not present::"
msgstr ""
"Якщо вказати ``default=argparse.SUPPRESS``, атрибут не буде додано, якщо "
"аргумент командного рядка відсутній:"

msgid "type"
msgstr "типу"

msgid ""
"By default, the parser reads command-line arguments in as simple strings. "
"However, quite often the command-line string should instead be interpreted "
"as another type, such as a :class:`float` or :class:`int`.  The ``type`` "
"keyword for :meth:`~ArgumentParser.add_argument` allows any necessary type-"
"checking and type conversions to be performed."
msgstr ""
"За замовчуванням аналізатор читає аргументи командного рядка як прості "
"рядки. Однак досить часто рядок командного рядка слід інтерпретувати як "
"інший тип, наприклад :class:`float` або :class:`int`. Ключове слово ``type`` "
"для :meth:`~ArgumentParser.add_argument` дозволяє виконувати будь-які "
"необхідні перевірки типів і перетворення типів."

msgid ""
"If the type_ keyword is used with the default_ keyword, the type converter "
"is only applied if the default is a string."
msgstr ""
"Якщо ключове слово type_ використовується з ключовим словом default_, "
"конвертер типів застосовується, лише якщо значенням за замовчуванням є рядок."

msgid ""
"The argument to ``type`` can be any callable that accepts a single string. "
"If the function raises :exc:`ArgumentTypeError`, :exc:`TypeError`, or :exc:"
"`ValueError`, the exception is caught and a nicely formatted error message "
"is displayed.  No other exception types are handled."
msgstr ""
"Аргументом типу може бути будь-який виклик, який приймає один рядок. Якщо "
"функція викликає помилку :exc:`ArgumentTypeError`, :exc:`TypeError` або :exc:"
"`ValueError`, виняток буде перехоплено, і відобразиться повідомлення про "
"помилку в гарному форматі. Інші типи винятків не обробляються."

msgid "Common built-in types and functions can be used as type converters:"
msgstr ""
"Загальні вбудовані типи та функції можна використовувати як перетворювачі "
"типів:"

msgid "User defined functions can be used as well:"
msgstr "Також можна використовувати визначені користувачем функції:"

msgid ""
"The :func:`bool` function is not recommended as a type converter.  All it "
"does is convert empty strings to ``False`` and non-empty strings to "
"``True``. This is usually not what is desired."
msgstr ""
"Функцію :func:`bool` не рекомендується використовувати як перетворювач "
"типів. Усе, що він робить, це перетворює порожні рядки на ``False``, а "
"непорожні рядки — на ``True``. Зазвичай це не те, чого хочеться."

msgid ""
"In general, the ``type`` keyword is a convenience that should only be used "
"for simple conversions that can only raise one of the three supported "
"exceptions. Anything with more interesting error-handling or resource "
"management should be done downstream after the arguments are parsed."
msgstr ""
"Загалом, ключове слово ``type`` є зручним, і його слід використовувати лише "
"для простих перетворень, які можуть викликати лише одне з трьох "
"підтримуваних винятків. Усе, що має більш цікаву обробку помилок або "
"керування ресурсами, має бути зроблено нижче за течією після аналізу "
"аргументів."

msgid ""
"For example, JSON or YAML conversions have complex error cases that require "
"better reporting than can be given by the ``type`` keyword.  A :exc:`~json."
"JSONDecodeError` would not be well formatted and a :exc:`FileNotFound` "
"exception would not be handled at all."
msgstr ""
"Наприклад, перетворення JSON або YAML мають складні випадки помилок, які "
"вимагають кращого звітування, ніж те, що може надати ключове слово ``type``. "
"Помилка :exc:`~json.JSONDecodeError` буде неправильно відформатована, а "
"виняток :exc:`FileNotFound` взагалі не оброблятиметься."

msgid ""
"Even :class:`~argparse.FileType` has its limitations for use with the "
"``type`` keyword.  If one argument uses *FileType* and then a subsequent "
"argument fails, an error is reported but the file is not automatically "
"closed.  In this case, it would be better to wait until after the parser has "
"run and then use the :keyword:`with`-statement to manage the files."
msgstr ""
"Навіть :class:`~argparse.FileType` має свої обмеження щодо використання з "
"ключовим словом ``type``. Якщо один аргумент використовує *FileType*, а "
"наступний аргумент не виконується, повідомляється про помилку, але файл не "
"закривається автоматично. У цьому випадку було б краще дочекатися завершення "
"роботи синтаксичного аналізатора, а потім використовувати оператор :keyword:"
"`with` для керування файлами."

msgid ""
"For type checkers that simply check against a fixed set of values, consider "
"using the choices_ keyword instead."
msgstr ""
"Для засобів перевірки типів, які просто перевіряють фіксований набір "
"значень, подумайте про використання ключового слова choices_."

msgid "choices"
msgstr "вибір"

msgid ""
"Some command-line arguments should be selected from a restricted set of "
"values. These can be handled by passing a container object as the *choices* "
"keyword argument to :meth:`~ArgumentParser.add_argument`.  When the command "
"line is parsed, argument values will be checked, and an error message will "
"be displayed if the argument was not one of the acceptable values::"
msgstr ""
"Деякі аргументи командного рядка слід вибирати з обмеженого набору значень. "
"З ними можна впоратися, передавши об’єкт-контейнер як аргумент ключового "
"слова *choices* до :meth:`~ArgumentParser.add_argument`. Під час "
"синтаксичного аналізу командного рядка значення аргументів буде перевірено, "
"і якщо аргумент не буде одним із допустимих значень, відобразиться "
"повідомлення про помилку:"

msgid ""
"Note that inclusion in the *choices* container is checked after any type_ "
"conversions have been performed, so the type of the objects in the *choices* "
"container should match the type_ specified::"
msgstr ""
"Зауважте, що включення до контейнера *choices* перевіряється після виконання "
"будь-яких перетворень type_, тому тип об’єктів у контейнері *choices* має "
"відповідати вказаному type_::"

msgid ""
"Any container can be passed as the *choices* value, so :class:`list` "
"objects, :class:`set` objects, and custom containers are all supported."
msgstr ""
"Будь-який контейнер можна передати як значення *choices*, тому підтримуються "
"об’єкти :class:`list`, об’єкти :class:`set` і спеціальні контейнери."

msgid ""
"Use of :class:`enum.Enum` is not recommended because it is difficult to "
"control its appearance in usage, help, and error messages."
msgstr ""
"Використання :class:`enum.Enum` не рекомендується, оскільки важко "
"контролювати його появу в повідомленнях про використання, довідці та "
"помилках."

msgid ""
"Formatted choices override the default *metavar* which is normally derived "
"from *dest*.  This is usually what you want because the user never sees the "
"*dest* parameter.  If this display isn't desirable (perhaps because there "
"are many choices), just specify an explicit metavar_."
msgstr ""

msgid "required"
msgstr "вимагається"

msgid ""
"In general, the :mod:`argparse` module assumes that flags like ``-f`` and "
"``--bar`` indicate *optional* arguments, which can always be omitted at the "
"command line. To make an option *required*, ``True`` can be specified for "
"the ``required=`` keyword argument to :meth:`~ArgumentParser.add_argument`::"
msgstr ""
"Загалом, модуль :mod:`argparse` припускає, що такі прапорці, як ``-f`` і ``--"
"bar``, вказують на *необов’язкові* аргументи, які завжди можна пропустити в "
"командному рядку. Щоб зробити опцію *обов’язковою*, можна вказати ``True`` "
"для ключового аргументу ``required=`` для :meth:`~ArgumentParser."
"add_argument`::"

msgid ""
"As the example shows, if an option is marked as ``required``, :meth:"
"`~ArgumentParser.parse_args` will report an error if that option is not "
"present at the command line."
msgstr ""
"Як показує приклад, якщо параметр позначено як ``required``, :meth:"
"`~ArgumentParser.parse_args` повідомить про помилку, якщо цей параметр "
"відсутній у командному рядку."

msgid ""
"Required options are generally considered bad form because users expect "
"*options* to be *optional*, and thus they should be avoided when possible."
msgstr ""
"Обов’язкові параметри зазвичай вважаються поганим тоном, оскільки "
"користувачі очікують, що *параметри* будуть *необов’язковими*, тому їх слід "
"уникати, коли це можливо."

msgid "help"
msgstr "допомогти"

msgid ""
"The ``help`` value is a string containing a brief description of the "
"argument. When a user requests help (usually by using ``-h`` or ``--help`` "
"at the command line), these ``help`` descriptions will be displayed with "
"each argument::"
msgstr ""
"Значення ``help`` - це рядок, що містить короткий опис аргументу. Коли "
"користувач запитує довідку (зазвичай за допомогою ``-h`` або ``--help`` у "
"командному рядку), ці описи ``help`` відображатимуться з кожним аргументом:"

msgid ""
"The ``help`` strings can include various format specifiers to avoid "
"repetition of things like the program name or the argument default_.  The "
"available specifiers include the program name, ``%(prog)s`` and most keyword "
"arguments to :meth:`~ArgumentParser.add_argument`, e.g. ``%(default)s``, "
"``%(type)s``, etc.::"
msgstr ""
"Рядки ``help`` можуть містити різні специфікатори формату, щоб уникнути "
"повторення таких речей, як назва програми або аргумент default_. Доступні "
"специфікатори включають назву програми, ``%(prog)s`` та більшість ключових "
"аргументів для :meth:`~ArgumentParser.add_argument`, напр. ``%(default)s``, "
"``%(type)s`` тощо::"

msgid ""
"As the help string supports %-formatting, if you want a literal ``%`` to "
"appear in the help string, you must escape it as ``%%``."
msgstr ""
"Оскільки рядок довідки підтримує %-formatting, якщо ви хочете, щоб літерал "
"``%`` з’явився в рядку довідки, ви повинні екранувати його як ``%%``."

msgid ""
":mod:`argparse` supports silencing the help entry for certain options, by "
"setting the ``help`` value to ``argparse.SUPPRESS``::"
msgstr ""
":mod:`argparse` підтримує вимикання запису довідки для певних параметрів "
"шляхом встановлення значення ``help`` на ``argparse.SUPPRESS``::"

msgid "metavar"
msgstr "метавар"

msgid ""
"When :class:`ArgumentParser` generates help messages, it needs some way to "
"refer to each expected argument.  By default, ArgumentParser objects use the "
"dest_ value as the \"name\" of each object.  By default, for positional "
"argument actions, the dest_ value is used directly, and for optional "
"argument actions, the dest_ value is uppercased.  So, a single positional "
"argument with ``dest='bar'`` will be referred to as ``bar``. A single "
"optional argument ``--foo`` that should be followed by a single command-line "
"argument will be referred to as ``FOO``.  An example::"
msgstr ""
"Коли :class:`ArgumentParser` створює довідкові повідомлення, йому потрібен "
"певний спосіб посилатися на кожен очікуваний аргумент. За замовчуванням "
"об’єкти ArgumentParser використовують значення dest_ як \"ім’я\" кожного "
"об’єкта. За замовчуванням для дій позиційного аргументу значення dest_ "
"використовується безпосередньо, а для необов’язкових дій аргументу значення "
"dest_ пишеться у верхньому регістрі. Отже, один позиційний аргумент із "
"``dest='bar`` буде називатися ``bar``. Один необов’язковий аргумент ``--"
"foo``, за яким має слідувати один аргумент командного рядка, буде називатися "
"``FOO``. Приклад::"

msgid "An alternative name can be specified with ``metavar``::"
msgstr "Альтернативну назву можна вказати за допомогою ``metavar``::"

msgid ""
"Note that ``metavar`` only changes the *displayed* name - the name of the "
"attribute on the :meth:`~ArgumentParser.parse_args` object is still "
"determined by the dest_ value."
msgstr ""
"Зауважте, що ``metavar`` змінює лише *відображене* ім’я – ім’я атрибута "
"об’єкта :meth:`~ArgumentParser.parse_args` все ще визначається значенням "
"dest_."

msgid ""
"Different values of ``nargs`` may cause the metavar to be used multiple "
"times. Providing a tuple to ``metavar`` specifies a different display for "
"each of the arguments::"
msgstr ""
"Різні значення ``nargs`` можуть спричинити багаторазове використання "
"метаперемінної. Надання кортежу для ``metavar`` визначає інше відображення "
"для кожного з аргументів::"

msgid "dest"
msgstr "дест"

msgid ""
"Most :class:`ArgumentParser` actions add some value as an attribute of the "
"object returned by :meth:`~ArgumentParser.parse_args`.  The name of this "
"attribute is determined by the ``dest`` keyword argument of :meth:"
"`~ArgumentParser.add_argument`.  For positional argument actions, ``dest`` "
"is normally supplied as the first argument to :meth:`~ArgumentParser."
"add_argument`::"
msgstr ""
"Більшість дій :class:`ArgumentParser` додають певне значення як атрибут "
"об’єкта, який повертає :meth:`~ArgumentParser.parse_args`. Ім’я цього "
"атрибута визначається ключовим аргументом ``dest`` :meth:`~ArgumentParser."
"add_argument`. Для дій позиційного аргументу ``dest`` зазвичай надається як "
"перший аргумент :meth:`~ArgumentParser.add_argument`::"

msgid ""
"For optional argument actions, the value of ``dest`` is normally inferred "
"from the option strings.  :class:`ArgumentParser` generates the value of "
"``dest`` by taking the first long option string and stripping away the "
"initial ``--`` string.  If no long option strings were supplied, ``dest`` "
"will be derived from the first short option string by stripping the initial "
"``-`` character.  Any internal ``-`` characters will be converted to ``_`` "
"characters to make sure the string is a valid attribute name.  The examples "
"below illustrate this behavior::"
msgstr ""
"Для необов’язкових дій аргументів значення ``dest`` зазвичай виводиться з "
"рядків параметрів. :class:`ArgumentParser` генерує значення ``dest``, беручи "
"перший довгий рядок параметрів і видаляючи початковий рядок ``--``. Якщо не "
"було надано довгих рядків параметрів, ``dest`` буде отримано з першого "
"короткого рядка параметрів шляхом видалення початкового символу ``-``. Усі "
"внутрішні символи \"-\" буде перетворено на символи \"_\", щоб переконатися, "
"що рядок є дійсною назвою атрибута. Наведені нижче приклади ілюструють цю "
"поведінку:"

msgid "``dest`` allows a custom attribute name to be provided::"
msgstr "``dest`` дозволяє надати ім'я спеціального атрибута:"

msgid "Action classes"
msgstr "Класи дії"

msgid ""
"Action classes implement the Action API, a callable which returns a callable "
"which processes arguments from the command-line. Any object which follows "
"this API may be passed as the ``action`` parameter to :meth:`add_argument`."
msgstr ""
"Класи дій реалізують Action API, виклик, який повертає виклик, який обробляє "
"аргументи з командного рядка. Будь-який об’єкт, який слідує за цим API, "
"можна передати як параметр ``action`` до :meth:`add_argument`."

msgid ""
"Action objects are used by an ArgumentParser to represent the information "
"needed to parse a single argument from one or more strings from the command "
"line. The Action class must accept the two positional arguments plus any "
"keyword arguments passed to :meth:`ArgumentParser.add_argument` except for "
"the ``action`` itself."
msgstr ""
"Об’єкти дії використовуються ArgumentParser для представлення інформації, "
"необхідної для аналізу одного аргументу з одного або кількох рядків із "
"командного рядка. Клас Action повинен приймати два позиційні аргументи плюс "
"будь-які ключові аргументи, передані в :meth:`ArgumentParser.add_argument`, "
"крім самої ``action``."

msgid ""
"Instances of Action (or return value of any callable to the ``action`` "
"parameter) should have attributes \"dest\", \"option_strings\", \"default\", "
"\"type\", \"required\", \"help\", etc. defined. The easiest way to ensure "
"these attributes are defined is to call ``Action.__init__``."
msgstr ""
"Екземпляри Action (або значення, що повертається будь-яким викликом "
"параметра ``action``) повинні мати визначені атрибути \"dest\", "
"\"option_strings\", \"default\", \"type\", \"required\", \"help\" тощо. "
"Найпростіший спосіб переконатися, що ці атрибути визначені, це викликати "
"``Action.__init__``."

msgid ""
"Action instances should be callable, so subclasses must override the "
"``__call__`` method, which should accept four parameters:"
msgstr ""
"Екземпляри дій мають бути викликаними, тому підкласи повинні перевизначати "
"метод ``__call__``, який має приймати чотири параметри:"

msgid "``parser`` - The ArgumentParser object which contains this action."
msgstr "``parser`` – об’єкт ArgumentParser, який містить цю дію."

msgid ""
"``namespace`` - The :class:`Namespace` object that will be returned by :meth:"
"`~ArgumentParser.parse_args`.  Most actions add an attribute to this object "
"using :func:`setattr`."
msgstr ""
"``простір імен`` – об’єкт :class:`Namespace`, який повертатиме :meth:"
"`~ArgumentParser.parse_args`. Більшість дій додають атрибут до цього об’єкта "
"за допомогою :func:`setattr`."

msgid ""
"``values`` - The associated command-line arguments, with any type "
"conversions applied.  Type conversions are specified with the type_ keyword "
"argument to :meth:`~ArgumentParser.add_argument`."
msgstr ""
"``значення`` – пов’язані аргументи командного рядка з будь-якими "
"застосованими перетвореннями типів. Перетворення типів вказуються аргументом "
"ключового слова type_ для :meth:`~ArgumentParser.add_argument`."

msgid ""
"``option_string`` - The option string that was used to invoke this action. "
"The ``option_string`` argument is optional, and will be absent if the action "
"is associated with a positional argument."
msgstr ""
"``option_string`` - рядок параметра, який використовувався для виклику цієї "
"дії. Аргумент ``option_string`` необов’язковий і буде відсутній, якщо дію "
"пов’язано з позиційним аргументом."

msgid ""
"The ``__call__`` method may perform arbitrary actions, but will typically "
"set attributes on the ``namespace`` based on ``dest`` and ``values``."
msgstr ""
"Метод ``__call__`` може виконувати довільні дії, але зазвичай встановлює "
"атрибути в ``простір імен`` на основі ``dest`` і ``values``."

msgid ""
"Action subclasses can define a ``format_usage`` method that takes no "
"argument and return a string which will be used when printing the usage of "
"the program. If such method is not provided, a sensible default will be used."
msgstr ""
"Підкласи дій можуть визначати метод ``format_usage``, який не приймає "
"аргументів і повертає рядок, який використовуватиметься під час друку "
"використання програми. Якщо такий метод не надано, буде використано розумне "
"значення за умовчанням."

msgid "The parse_args() method"
msgstr "Метод parse_args()."

msgid ""
"Convert argument strings to objects and assign them as attributes of the "
"namespace.  Return the populated namespace."
msgstr ""
"Перетворіть рядки аргументів на об’єкти та призначте їх як атрибути простору "
"імен. Повернути заповнений простір імен."

msgid ""
"Previous calls to :meth:`add_argument` determine exactly what objects are "
"created and how they are assigned. See the documentation for :meth:"
"`add_argument` for details."
msgstr ""
"Попередні виклики :meth:`add_argument` точно визначають, які об’єкти "
"створюються та як вони призначаються. Перегляньте документацію для :meth:"
"`add_argument` для деталей."

msgid ""
"args_ - List of strings to parse.  The default is taken from :data:`sys."
"argv`."
msgstr ""
"args_ - список рядків для аналізу. Типове значення взято з :data:`sys.argv`."

msgid ""
"namespace_ - An object to take the attributes.  The default is a new empty :"
"class:`Namespace` object."
msgstr ""
"namespace_ – об’єкт для отримання атрибутів. Типовим є новий порожній "
"об’єкт :class:`Namespace`."

msgid "Option value syntax"
msgstr "Синтаксис значення опції"

msgid ""
"The :meth:`~ArgumentParser.parse_args` method supports several ways of "
"specifying the value of an option (if it takes one).  In the simplest case, "
"the option and its value are passed as two separate arguments::"
msgstr ""
"Метод :meth:`~ArgumentParser.parse_args` підтримує кілька способів "
"визначення значення параметра (якщо воно приймається). У найпростішому "
"випадку параметр і його значення передаються як два окремих аргументи:"

msgid ""
"For long options (options with names longer than a single character), the "
"option and value can also be passed as a single command-line argument, using "
"``=`` to separate them::"
msgstr ""
"Для довгих параметрів (параметрів з іменами, довшими за один символ), "
"параметр і значення також можна передати як один аргумент командного рядка, "
"використовуючи ``=``, щоб розділити їх::"

msgid ""
"For short options (options only one character long), the option and its "
"value can be concatenated::"
msgstr ""
"Для коротких опцій (опції лише з одного символу) опцію та її значення можна "
"об’єднати:"

msgid ""
"Several short options can be joined together, using only a single ``-`` "
"prefix, as long as only the last option (or none of them) requires a value::"
msgstr ""
"Кілька коротких опцій можна об’єднати разом, використовуючи лише один "
"префікс ``-``, якщо тільки остання опція (або жодна з них) вимагає значення::"

msgid "Invalid arguments"
msgstr "Недійсні аргументи"

msgid ""
"While parsing the command line, :meth:`~ArgumentParser.parse_args` checks "
"for a variety of errors, including ambiguous options, invalid types, invalid "
"options, wrong number of positional arguments, etc.  When it encounters such "
"an error, it exits and prints the error along with a usage message::"
msgstr ""
"Під час аналізу командного рядка :meth:`~ArgumentParser.parse_args` "
"перевіряє наявність різноманітних помилок, включаючи неоднозначні параметри, "
"недійсні типи, недійсні параметри, неправильну кількість позиційних "
"аргументів тощо. Коли він стикається з такою помилкою, він виходить і друкує "
"помилку разом із повідомленням про використання::"

msgid "Arguments containing ``-``"
msgstr "Аргументи, що містять ``-``"

msgid ""
"The :meth:`~ArgumentParser.parse_args` method attempts to give errors "
"whenever the user has clearly made a mistake, but some situations are "
"inherently ambiguous.  For example, the command-line argument ``-1`` could "
"either be an attempt to specify an option or an attempt to provide a "
"positional argument. The :meth:`~ArgumentParser.parse_args` method is "
"cautious here: positional arguments may only begin with ``-`` if they look "
"like negative numbers and there are no options in the parser that look like "
"negative numbers::"
msgstr ""
"Метод :meth:`~ArgumentParser.parse_args` намагається видавати помилки "
"щоразу, коли користувач явно зробив помилку, але деякі ситуації за своєю "
"суттю неоднозначні. Наприклад, аргумент командного рядка \"-1\" може бути "
"або спробою вказати параметр, або спробою надати позиційний аргумент. Метод :"
"meth:`~ArgumentParser.parse_args` тут обережний: позиційні аргументи можуть "
"починатися лише з ``-``, якщо вони виглядають як від’ємні числа, і в "
"аналізаторі немає параметрів, які виглядають як від’ємні числа:"

msgid ""
"If you have positional arguments that must begin with ``-`` and don't look "
"like negative numbers, you can insert the pseudo-argument ``'--'`` which "
"tells :meth:`~ArgumentParser.parse_args` that everything after that is a "
"positional argument::"
msgstr ""
"Якщо у вас є позиційні аргументи, які повинні починатися з ``-`` і не "
"виглядати як від’ємні числа, ви можете вставити псевдоаргумент ``''--'``, "
"який повідомляє :meth:`~ArgumentParser.parse_args`, що все після цього є "
"позиційним аргументом::"

msgid "Argument abbreviations (prefix matching)"
msgstr "Скорочення аргументів (відповідність префіксу)"

msgid ""
"The :meth:`~ArgumentParser.parse_args` method :ref:`by default "
"<allow_abbrev>` allows long options to be abbreviated to a prefix, if the "
"abbreviation is unambiguous (the prefix matches a unique option)::"
msgstr ""
"Метод :meth:`~ArgumentParser.parse_args` :ref:`за замовчуванням "
"<allow_abbrev>` дозволяє скорочувати довгі параметри до префікса, якщо "
"скорочення є однозначним (префікс відповідає унікальному параметру)::"

msgid ""
"An error is produced for arguments that could produce more than one options. "
"This feature can be disabled by setting :ref:`allow_abbrev` to ``False``."
msgstr ""
"Помилка створюється для аргументів, які можуть давати більше одного "
"варіанту. Цю функцію можна вимкнути, встановивши для :ref:`allow_abbrev` "
"значення ``False``."

msgid "Beyond ``sys.argv``"
msgstr "За межами ``sys.argv``"

msgid ""
"Sometimes it may be useful to have an ArgumentParser parse arguments other "
"than those of :data:`sys.argv`.  This can be accomplished by passing a list "
"of strings to :meth:`~ArgumentParser.parse_args`.  This is useful for "
"testing at the interactive prompt::"
msgstr ""
"Іноді може бути корисним, щоб ArgumentParser аналізував аргументи, відмінні "
"від аргументів :data:`sys.argv`. Це можна зробити, передавши список рядків "
"до :meth:`~ArgumentParser.parse_args`. Це корисно для тестування в "
"інтерактивному запиті:"

msgid "The Namespace object"
msgstr "Об'єкт простору імен"

msgid ""
"Simple class used by default by :meth:`~ArgumentParser.parse_args` to create "
"an object holding attributes and return it."
msgstr ""
"Простий клас, який за замовчуванням використовується :meth:`~ArgumentParser."
"parse_args` для створення об’єкта з атрибутами та повернення його."

msgid ""
"This class is deliberately simple, just an :class:`object` subclass with a "
"readable string representation. If you prefer to have dict-like view of the "
"attributes, you can use the standard Python idiom, :func:`vars`::"
msgstr ""
"Цей клас навмисне простий, просто підклас :class:`object` із читабельним "
"представленням рядка. Якщо ви віддаєте перевагу перегляду атрибутів у "
"форматі dict, ви можете використовувати стандартну ідіому Python :func:"
"`vars`::"

msgid ""
"It may also be useful to have an :class:`ArgumentParser` assign attributes "
"to an already existing object, rather than a new :class:`Namespace` object.  "
"This can be achieved by specifying the ``namespace=`` keyword argument::"
msgstr ""
"Також може бути корисним, щоб :class:`ArgumentParser` призначав атрибути вже "
"існуючому об’єкту, а не новому об’єкту :class:`Namespace`. Цього можна "
"досягти, вказавши аргумент ключового слова ``namespace=``::"

msgid "Other utilities"
msgstr "Інші комунальні послуги"

msgid "Sub-commands"
msgstr "Підкоманди"

msgid ""
"Many programs split up their functionality into a number of sub-commands, "
"for example, the ``svn`` program can invoke sub-commands like ``svn "
"checkout``, ``svn update``, and ``svn commit``.  Splitting up functionality "
"this way can be a particularly good idea when a program performs several "
"different functions which require different kinds of command-line "
"arguments. :class:`ArgumentParser` supports the creation of such sub-"
"commands with the :meth:`add_subparsers` method.  The :meth:`add_subparsers` "
"method is normally called with no arguments and returns a special action "
"object.  This object has a single method, :meth:`~ArgumentParser."
"add_parser`, which takes a command name and any :class:`ArgumentParser` "
"constructor arguments, and returns an :class:`ArgumentParser` object that "
"can be modified as usual."
msgstr ""
"Багато програм поділяють свої функції на декілька підкоманд, наприклад, "
"програма ``svn`` може викликати такі підкоманди, як ``svn checkout``, ``svn "
"update`` і ``svn commit``. Поділ функціональності таким чином може бути "
"особливо гарною ідеєю, коли програма виконує кілька різних функцій, які "
"потребують різних типів аргументів командного рядка. :class:`ArgumentParser` "
"підтримує створення таких підкоманд за допомогою методу :meth:"
"`add_subparsers`. Метод :meth:`add_subparsers` зазвичай викликається без "
"аргументів і повертає спеціальний об’єкт дії. Цей об’єкт має один метод, :"
"meth:`~ArgumentParser.add_parser`, який приймає ім’я команди та будь-які "
"аргументи конструктора :class:`ArgumentParser` і повертає об’єкт :class:"
"`ArgumentParser`, який можна змінювати як зазвичай."

msgid "Description of parameters:"
msgstr "Опис параметрів:"

msgid ""
"title - title for the sub-parser group in help output; by default "
"\"subcommands\" if description is provided, otherwise uses title for "
"positional arguments"
msgstr ""
"title - заголовок для групи суб-парсера у виведенні довідки; за "
"замовчуванням \"підкоманди\", якщо надається опис, інакше використовує "
"заголовок для позиційних аргументів"

msgid ""
"description - description for the sub-parser group in help output, by "
"default ``None``"
msgstr ""
"description - опис для групи суб-парсера у виведенні довідки, за "
"замовчуванням ``None``"

msgid ""
"prog - usage information that will be displayed with sub-command help, by "
"default the name of the program and any positional arguments before the "
"subparser argument"
msgstr ""
"prog - інформація про використання, яка відображатиметься з довідкою "
"підкоманд, за замовчуванням назва програми та будь-які позиційні аргументи "
"перед аргументом subparser"

msgid ""
"parser_class - class which will be used to create sub-parser instances, by "
"default the class of the current parser (e.g. ArgumentParser)"
msgstr ""
"parser_class - клас, який використовуватиметься для створення екземплярів "
"суб-парсера, за замовчуванням клас поточного аналізатора (наприклад, "
"ArgumentParser)"

msgid ""
"action_ - the basic type of action to be taken when this argument is "
"encountered at the command line"
msgstr ""
"action_ - основний тип дії, яка виконується, коли цей аргумент зустрічається "
"в командному рядку"

msgid ""
"dest_ - name of the attribute under which sub-command name will be stored; "
"by default ``None`` and no value is stored"
msgstr ""
"dest_ - ім'я атрибута, під яким буде зберігатися ім'я підкоманди; за "
"замовчуванням ``None`` і жодне значення не зберігається"

msgid ""
"required_ - Whether or not a subcommand must be provided, by default "
"``False`` (added in 3.7)"
msgstr ""
"required_ - чи потрібно надавати підкоманду, за замовчуванням ``False`` "
"(додано в 3.7)"

msgid "help_ - help for sub-parser group in help output, by default ``None``"
msgstr ""
"help_ - довідка для групи суб-парсера у виведенні довідки, за замовчуванням "
"``None``"

msgid ""
"metavar_ - string presenting available sub-commands in help; by default it "
"is ``None`` and presents sub-commands in form {cmd1, cmd2, ..}"
msgstr ""
"metavar_ - рядок, що представляє доступні підкоманди в довідці; за "
"замовчуванням це ``None`` і представляє підкоманди у формі {cmd1, cmd2, ..}"

msgid "Some example usage::"
msgstr "Деякі приклади використання::"

msgid ""
"Note that the object returned by :meth:`parse_args` will only contain "
"attributes for the main parser and the subparser that was selected by the "
"command line (and not any other subparsers).  So in the example above, when "
"the ``a`` command is specified, only the ``foo`` and ``bar`` attributes are "
"present, and when the ``b`` command is specified, only the ``foo`` and "
"``baz`` attributes are present."
msgstr ""
"Зауважте, що об’єкт, який повертає :meth:`parse_args`, міститиме лише "
"атрибути для головного синтаксичного аналізатора та підпарсера, вибраного "
"командним рядком (а не будь-яких інших підпарсерів). Отже, у прикладі вище, "
"коли вказано команду ``a``, присутні лише атрибути ``foo`` і ``bar``, а коли "
"вказано команду ``b``, лише наявні атрибути ``foo`` і ``baz``."

msgid ""
"Similarly, when a help message is requested from a subparser, only the help "
"for that particular parser will be printed.  The help message will not "
"include parent parser or sibling parser messages.  (A help message for each "
"subparser command, however, can be given by supplying the ``help=`` argument "
"to :meth:`add_parser` as above.)"
msgstr ""
"Подібним чином, коли довідкове повідомлення запитується від субпарсера, буде "
"надруковано лише довідку для цього конкретного парсера. Повідомлення довідки "
"не включатиме повідомлення батьківського аналізатора або братського "
"аналізатора. (Однак довідкове повідомлення для кожної команди субпарсера "
"можна надати, надавши аргумент ``help=`` для :meth:`add_parser`, як "
"зазначено вище.)"

msgid ""
"The :meth:`add_subparsers` method also supports ``title`` and "
"``description`` keyword arguments.  When either is present, the subparser's "
"commands will appear in their own group in the help output.  For example::"
msgstr ""
"Метод :meth:`add_subparsers` також підтримує ключові аргументи ``title`` і "
"``description``. Якщо будь-який з них присутній, команди субпарсера "
"відображатимуться у власній групі у виведенні довідки. Наприклад::"

msgid ""
"Furthermore, ``add_parser`` supports an additional ``aliases`` argument, "
"which allows multiple strings to refer to the same subparser. This example, "
"like ``svn``, aliases ``co`` as a shorthand for ``checkout``::"
msgstr ""
"Крім того, ``add_parser`` підтримує додатковий аргумент ``aliases``, який "
"дозволяє кільком рядкам посилатися на той самий підпарсер. Цей приклад, як і "
"``svn``, використовує псевдонім ``co`` як скорочення для ``checkout``::"

msgid ""
"One particularly effective way of handling sub-commands is to combine the "
"use of the :meth:`add_subparsers` method with calls to :meth:`set_defaults` "
"so that each subparser knows which Python function it should execute.  For "
"example::"
msgstr ""
"Одним із особливо ефективних способів обробки підкоманд є поєднання "
"використання методу :meth:`add_subparsers` із викликами :meth:"
"`set_defaults`, щоб кожен підрозмір знав, яку функцію Python він має "
"виконати. Наприклад::"

msgid ""
"This way, you can let :meth:`parse_args` do the job of calling the "
"appropriate function after argument parsing is complete.  Associating "
"functions with actions like this is typically the easiest way to handle the "
"different actions for each of your subparsers.  However, if it is necessary "
"to check the name of the subparser that was invoked, the ``dest`` keyword "
"argument to the :meth:`add_subparsers` call will work::"
msgstr ""
"Таким чином, ви можете дозволити :meth:`parse_args` виконати роботу з "
"виклику відповідної функції після завершення аналізу аргументу. Пов’язування "
"функцій із подібними діями зазвичай є найпростішим способом обробки різних "
"дій для кожного з ваших підпарсерів. Однак, якщо необхідно перевірити ім’я "
"викликаного субпарсера, аргумент ключового слова ``dest`` для виклику :meth:"
"`add_subparsers` буде працювати:"

msgid "New *required* keyword argument."
msgstr "Новий *обов’язковий* аргумент ключового слова."

msgid "FileType objects"
msgstr "Об'єкти FileType"

msgid ""
"The :class:`FileType` factory creates objects that can be passed to the type "
"argument of :meth:`ArgumentParser.add_argument`.  Arguments that have :class:"
"`FileType` objects as their type will open command-line arguments as files "
"with the requested modes, buffer sizes, encodings and error handling (see "
"the :func:`open` function for more details)::"
msgstr ""
"Фабрика :class:`FileType` створює об’єкти, які можна передати в аргумент "
"типу :meth:`ArgumentParser.add_argument`. Аргументи, які мають тип об’єктів :"
"class:`FileType`, відкриватимуть аргументи командного рядка як файли з "
"потрібними режимами, розмірами буфера, кодуванням і обробкою помилок "
"(додаткову інформацію див. у функції :func:`open`)::"

msgid ""
"FileType objects understand the pseudo-argument ``'-'`` and automatically "
"convert this into :data:`sys.stdin` for readable :class:`FileType` objects "
"and :data:`sys.stdout` for writable :class:`FileType` objects::"
msgstr ""

msgid "The *encodings* and *errors* keyword arguments."
msgstr "Аргументи ключових слів *encodings* і *errors*."

msgid "Argument groups"
msgstr "Групи аргументів"

msgid ""
"By default, :class:`ArgumentParser` groups command-line arguments into "
"\"positional arguments\" and \"optional arguments\" when displaying help "
"messages. When there is a better conceptual grouping of arguments than this "
"default one, appropriate groups can be created using the :meth:"
"`add_argument_group` method::"
msgstr ""
"За замовчуванням :class:`ArgumentParser` групує аргументи командного рядка в "
"\"позиційні аргументи\" та \"необов’язкові аргументи\" під час відображення "
"довідкових повідомлень. Якщо існує краща концептуальна група аргументів, ніж "
"стандартна, відповідні групи можна створити за допомогою методу :meth:"
"`add_argument_group`::"

msgid ""
"The :meth:`add_argument_group` method returns an argument group object which "
"has an :meth:`~ArgumentParser.add_argument` method just like a regular :"
"class:`ArgumentParser`.  When an argument is added to the group, the parser "
"treats it just like a normal argument, but displays the argument in a "
"separate group for help messages.  The :meth:`add_argument_group` method "
"accepts *title* and *description* arguments which can be used to customize "
"this display::"
msgstr ""
"Метод :meth:`add_argument_group` повертає об’єкт групи аргументів, який має "
"метод :meth:`~ArgumentParser.add_argument`, як і звичайний :class:"
"`ArgumentParser`. Коли аргумент додається до групи, аналізатор розглядає "
"його як звичайний аргумент, але відображає аргумент в окремій групі для "
"довідкових повідомлень. Метод :meth:`add_argument_group` приймає аргументи "
"*title* і *description*, які можна використовувати для налаштування цього "
"відображення:"

msgid ""
"Note that any arguments not in your user-defined groups will end up back in "
"the usual \"positional arguments\" and \"optional arguments\" sections."
msgstr ""
"Зверніть увагу, що будь-які аргументи, які не входять до визначених "
"користувачем груп, повертаються до звичайних розділів \"позиційні "
"аргументи\" та \"необов’язкові аргументи\"."

msgid ""
"Calling :meth:`add_argument_group` on an argument group is deprecated. This "
"feature was never supported and does not always work correctly. The function "
"exists on the API by accident through inheritance and will be removed in the "
"future."
msgstr ""

msgid "Mutual exclusion"
msgstr "Взаємне виключення"

msgid ""
"Create a mutually exclusive group. :mod:`argparse` will make sure that only "
"one of the arguments in the mutually exclusive group was present on the "
"command line::"
msgstr ""
"Створіть взаємовиключну групу. :mod:`argparse` переконається, що лише один "
"із аргументів у взаємовиключній групі присутній у командному рядку::"

msgid ""
"The :meth:`add_mutually_exclusive_group` method also accepts a *required* "
"argument, to indicate that at least one of the mutually exclusive arguments "
"is required::"
msgstr ""
"Метод :meth:`add_mutually_exclusive_group` також приймає *обов’язковий* "
"аргумент, щоб вказати, що потрібен принаймні один із взаємовиключних "
"аргументів:"

msgid ""
"Note that currently mutually exclusive argument groups do not support the "
"*title* and *description* arguments of :meth:`~ArgumentParser."
"add_argument_group`."
msgstr ""
"Зауважте, що наразі взаємовиключні групи аргументів не підтримують аргументи "
"*title* і *description* :meth:`~ArgumentParser.add_argument_group`."

msgid ""
"Calling :meth:`add_argument_group` or :meth:`add_mutually_exclusive_group` "
"on a mutually exclusive group is deprecated. These features were never "
"supported and do not always work correctly. The functions exist on the API "
"by accident through inheritance and will be removed in the future."
msgstr ""

msgid "Parser defaults"
msgstr "Параметри аналізатора за замовчуванням"

msgid ""
"Most of the time, the attributes of the object returned by :meth:"
"`parse_args` will be fully determined by inspecting the command-line "
"arguments and the argument actions.  :meth:`set_defaults` allows some "
"additional attributes that are determined without any inspection of the "
"command line to be added::"
msgstr ""
"У більшості випадків атрибути об’єкта, які повертає :meth:`parse_args`, "
"будуть повністю визначені шляхом перевірки аргументів командного рядка та "
"дій аргументів. :meth:`set_defaults` дозволяє додавати деякі додаткові "
"атрибути, які визначаються без перевірки командного рядка:"

msgid ""
"Note that parser-level defaults always override argument-level defaults::"
msgstr ""
"Зверніть увагу, що значення за замовчуванням на рівні аналізатора завжди "
"перекривають значення за замовчуванням на рівні аргументів::"

msgid ""
"Parser-level defaults can be particularly useful when working with multiple "
"parsers.  See the :meth:`~ArgumentParser.add_subparsers` method for an "
"example of this type."
msgstr ""
"Значення за замовчуванням на рівні парсера можуть бути особливо корисними "
"під час роботи з декількома парсерами. Перегляньте метод :meth:"
"`~ArgumentParser.add_subparsers` для прикладу цього типу."

msgid ""
"Get the default value for a namespace attribute, as set by either :meth:"
"`~ArgumentParser.add_argument` or by :meth:`~ArgumentParser.set_defaults`::"
msgstr ""
"Отримати значення за замовчуванням для атрибута простору імен, встановлене "
"або :meth:`~ArgumentParser.add_argument`, або :meth:`~ArgumentParser."
"set_defaults`::"

msgid "Printing help"
msgstr "Друк довідки"

msgid ""
"In most typical applications, :meth:`~ArgumentParser.parse_args` will take "
"care of formatting and printing any usage or error messages.  However, "
"several formatting methods are available:"
msgstr ""
"У більшості типових програм :meth:`~ArgumentParser.parse_args` подбає про "
"форматування та друк будь-яких повідомлень про використання чи помилки. "
"Однак доступно кілька методів форматування:"

msgid ""
"Print a brief description of how the :class:`ArgumentParser` should be "
"invoked on the command line.  If *file* is ``None``, :data:`sys.stdout` is "
"assumed."
msgstr ""
"Надрукуйте короткий опис того, як :class:`ArgumentParser` слід викликати в "
"командному рядку. Якщо *file* має значення ``None``, передбачається :data:"
"`sys.stdout`."

msgid ""
"Print a help message, including the program usage and information about the "
"arguments registered with the :class:`ArgumentParser`.  If *file* is "
"``None``, :data:`sys.stdout` is assumed."
msgstr ""
"Надрукуйте довідкове повідомлення, включно з використанням програми та "
"інформацією про аргументи, зареєстровані в :class:`ArgumentParser`. Якщо "
"*file* має значення ``None``, передбачається :data:`sys.stdout`."

msgid ""
"There are also variants of these methods that simply return a string instead "
"of printing it:"
msgstr ""
"Існують також варіанти цих методів, які просто повертають рядок замість "
"того, щоб друкувати його:"

msgid ""
"Return a string containing a brief description of how the :class:"
"`ArgumentParser` should be invoked on the command line."
msgstr ""
"Повертає рядок, що містить короткий опис того, як :class:`ArgumentParser` "
"слід викликати в командному рядку."

msgid ""
"Return a string containing a help message, including the program usage and "
"information about the arguments registered with the :class:`ArgumentParser`."
msgstr ""
"Повертає рядок, що містить довідкове повідомлення, включаючи використання "
"програми та інформацію про аргументи, зареєстровані в :class:"
"`ArgumentParser`."

msgid "Partial parsing"
msgstr "Частковий розбір"

msgid ""
"Sometimes a script may only parse a few of the command-line arguments, "
"passing the remaining arguments on to another script or program. In these "
"cases, the :meth:`~ArgumentParser.parse_known_args` method can be useful.  "
"It works much like :meth:`~ArgumentParser.parse_args` except that it does "
"not produce an error when extra arguments are present.  Instead, it returns "
"a two item tuple containing the populated namespace and the list of "
"remaining argument strings."
msgstr ""
"Іноді сценарій може аналізувати лише кілька аргументів командного рядка, "
"передаючи решту аргументів іншому сценарію чи програмі. У цих випадках може "
"бути корисним метод :meth:`~ArgumentParser.parse_known_args`. Він працює так "
"само, як :meth:`~ArgumentParser.parse_args`, за винятком того, що не створює "
"помилки, коли присутні додаткові аргументи. Замість цього він повертає "
"кортеж із двома елементами, що містить заповнений простір імен і список "
"решти рядків аргументів."

msgid ""
":ref:`Prefix matching <prefix-matching>` rules apply to :meth:"
"`parse_known_args`. The parser may consume an option even if it's just a "
"prefix of one of its known options, instead of leaving it in the remaining "
"arguments list."
msgstr ""
":ref:`Правила префікса, що відповідає <prefix-matching>`, застосовуються до :"
"meth:`parse_known_args`. Синтаксичний аналізатор може використати опцію, "
"навіть якщо це просто префікс однієї з відомих опцій, замість того, щоб "
"залишити її в списку аргументів, що залишилися."

msgid "Customizing file parsing"
msgstr "Налаштування аналізу файлів"

msgid ""
"Arguments that are read from a file (see the *fromfile_prefix_chars* keyword "
"argument to the :class:`ArgumentParser` constructor) are read one argument "
"per line. :meth:`convert_arg_line_to_args` can be overridden for fancier "
"reading."
msgstr ""
"Аргументи, які зчитуються з файлу (див. аргумент ключового слова "
"*fromfile_prefix_chars* конструктора :class:`ArgumentParser`), зчитуються по "
"одному аргументу на рядок. :meth:`convert_arg_line_to_args` можна замінити "
"для кращого читання."

msgid ""
"This method takes a single argument *arg_line* which is a string read from "
"the argument file.  It returns a list of arguments parsed from this string. "
"The method is called once per line read from the argument file, in order."
msgstr ""
"Цей метод приймає один аргумент *arg_line*, який є рядком, прочитаним з "
"файлу аргументів. Він повертає список аргументів, розібраних із цього рядка. "
"Метод викликається один раз на рядок, який читається з файлу аргументів, по "
"порядку."

msgid ""
"A useful override of this method is one that treats each space-separated "
"word as an argument.  The following example demonstrates how to do this::"
msgstr ""
"Корисною заміною цього методу є те, що розглядає кожне розділене пробілом "
"слово як аргумент. Наступний приклад демонструє, як це зробити:"

msgid "Exiting methods"
msgstr "Методи виходу"

msgid ""
"This method terminates the program, exiting with the specified *status* and, "
"if given, it prints a *message* before that. The user can override this "
"method to handle these steps differently::"
msgstr ""
"Цей метод завершує програму, виходячи з указаним *статусом* і, якщо він "
"заданий, перед цим друкує *повідомлення*. Користувач може перевизначити цей "
"метод, щоб виконати ці кроки інакше:"

msgid ""
"This method prints a usage message including the *message* to the standard "
"error and terminates the program with a status code of 2."
msgstr ""
"Цей метод друкує повідомлення про використання, включаючи *повідомлення* до "
"стандартної помилки, і завершує роботу програми з кодом стану 2."

msgid "Intermixed parsing"
msgstr "Змішаний розбір"

msgid ""
"A number of Unix commands allow the user to intermix optional arguments with "
"positional arguments.  The :meth:`~ArgumentParser.parse_intermixed_args` "
"and :meth:`~ArgumentParser.parse_known_intermixed_args` methods support this "
"parsing style."
msgstr ""
"Ряд команд Unix дозволяє користувачеві змішувати додаткові аргументи з "
"позиційними. Методи :meth:`~ArgumentParser.parse_intermixed_args` і :meth:"
"`~ArgumentParser.parse_known_intermixed_args` підтримують цей стиль аналізу."

msgid ""
"These parsers do not support all the argparse features, and will raise "
"exceptions if unsupported features are used.  In particular, subparsers, "
"``argparse.REMAINDER``, and mutually exclusive groups that include both "
"optionals and positionals are not supported."
msgstr ""
"Ці парсери не підтримують усі функції argparse і викликають винятки, якщо "
"використовуються непідтримувані функції. Зокрема, не підтримуються "
"субаналізатори, ``argparse.REMAINDER`` і взаємовиключні групи, які включають "
"опціональні та позиційні."

msgid ""
"The following example shows the difference between :meth:`~ArgumentParser."
"parse_known_args` and :meth:`~ArgumentParser.parse_intermixed_args`: the "
"former returns ``['2', '3']`` as unparsed arguments, while the latter "
"collects all the positionals into ``rest``.  ::"
msgstr ""
"У наступному прикладі показано різницю між :meth:`~ArgumentParser."
"parse_known_args` і :meth:`~ArgumentParser.parse_intermixed_args`: перший "
"повертає ``['2', '3']`` як нерозібрані аргументи, а другий збирає всі "
"позиційні елементи в ``rest``. ::"

msgid ""
":meth:`~ArgumentParser.parse_known_intermixed_args` returns a two item tuple "
"containing the populated namespace and the list of remaining argument "
"strings. :meth:`~ArgumentParser.parse_intermixed_args` raises an error if "
"there are any remaining unparsed argument strings."
msgstr ""
":meth:`~ArgumentParser.parse_known_intermixed_args` повертає кортеж із двома "
"елементами, що містить заповнений простір імен і список решти рядків "
"аргументів. :meth:`~ArgumentParser.parse_intermixed_args` викликає помилку, "
"якщо залишилися нерозібрані рядки аргументів."

msgid "Upgrading optparse code"
msgstr "Оновлення коду optparse"

msgid ""
"Originally, the :mod:`argparse` module had attempted to maintain "
"compatibility with :mod:`optparse`.  However, :mod:`optparse` was difficult "
"to extend transparently, particularly with the changes required to support "
"the new ``nargs=`` specifiers and better usage messages.  When most "
"everything in :mod:`optparse` had either been copy-pasted over or monkey-"
"patched, it no longer seemed practical to try to maintain the backwards "
"compatibility."
msgstr ""
"Спочатку модуль :mod:`argparse` намагався підтримувати сумісність із :mod:"
"`optparse`. Однак :mod:`optparse` було важко розширити прозоро, особливо зі "
"змінами, необхідними для підтримки нових специфікаторів ``nargs=`` і кращих "
"повідомлень про використання. Коли майже все в :mod:`optparse` було або "
"скопійовано, або виправлено мавпами, більше не здавалося практичним "
"намагатися підтримувати зворотну сумісність."

msgid ""
"The :mod:`argparse` module improves on the standard library :mod:`optparse` "
"module in a number of ways including:"
msgstr ""
"Модуль :mod:`argparse` покращує модуль стандартної бібліотеки :mod:"
"`optparse` кількома способами, зокрема:"

msgid "Handling positional arguments."
msgstr "Обробка позиційних аргументів."

msgid "Supporting sub-commands."
msgstr "Допоміжні підкоманди."

msgid "Allowing alternative option prefixes like ``+`` and ``/``."
msgstr "Дозволяє альтернативні префікси параметрів, наприклад ``+`` і ``/``."

msgid "Handling zero-or-more and one-or-more style arguments."
msgstr "Обробка нуля або більше та одного або кількох аргументів стилю."

msgid "Producing more informative usage messages."
msgstr "Створення більш інформативних повідомлень про використання."

msgid "Providing a much simpler interface for custom ``type`` and ``action``."
msgstr ""
"Забезпечення набагато простішого інтерфейсу для користувацького ``типу`` і "
"``дії``."

msgid "A partial upgrade path from :mod:`optparse` to :mod:`argparse`:"
msgstr "Шлях часткового оновлення з :mod:`optparse` до :mod:`argparse`:"

msgid ""
"Replace all :meth:`optparse.OptionParser.add_option` calls with :meth:"
"`ArgumentParser.add_argument` calls."
msgstr ""
"Замініть усі виклики :meth:`optparse.OptionParser.add_option` на виклики :"
"meth:`ArgumentParser.add_argument`."

msgid ""
"Replace ``(options, args) = parser.parse_args()`` with ``args = parser."
"parse_args()`` and add additional :meth:`ArgumentParser.add_argument` calls "
"for the positional arguments. Keep in mind that what was previously called "
"``options``, now in the :mod:`argparse` context is called ``args``."
msgstr ""
"Замініть ``(options, args) = parser.parse_args()`` на ``args = parser."
"parse_args()`` і додайте додаткові виклики :meth:`ArgumentParser."
"add_argument` для позиційних аргументів. Майте на увазі, що те, що раніше "
"називалося ``options``, тепер у контексті :mod:`argparse` називається "
"``args``."

msgid ""
"Replace :meth:`optparse.OptionParser.disable_interspersed_args` by using :"
"meth:`~ArgumentParser.parse_intermixed_args` instead of :meth:"
"`~ArgumentParser.parse_args`."
msgstr ""
"Замініть :meth:`optparse.OptionParser.disable_interspersed_args` на "
"використання :meth:`~ArgumentParser.parse_intermixed_args` замість :meth:"
"`~ArgumentParser.parse_args`."

msgid ""
"Replace callback actions and the ``callback_*`` keyword arguments with "
"``type`` or ``action`` arguments."
msgstr ""
"Замініть дії зворотного виклику та аргументи ключового слова ``callback_*`` "
"на аргументи ``type`` або ``action``."

msgid ""
"Replace string names for ``type`` keyword arguments with the corresponding "
"type objects (e.g. int, float, complex, etc)."
msgstr ""
"Замініть назви рядків для ключових аргументів ``type`` відповідними "
"об’єктами типу (наприклад, int, float, complex тощо)."

msgid ""
"Replace :class:`optparse.Values` with :class:`Namespace` and :exc:`optparse."
"OptionError` and :exc:`optparse.OptionValueError` with :exc:`ArgumentError`."
msgstr ""
"Замініть :class:`optparse.Values` на :class:`Namespace` і :exc:`optparse."
"OptionError` і :exc:`optparse.OptionValueError` на :exc:`ArgumentError`."

msgid ""
"Replace strings with implicit arguments such as ``%default`` or ``%prog`` "
"with the standard Python syntax to use dictionaries to format strings, that "
"is, ``%(default)s`` and ``%(prog)s``."
msgstr ""
"Замініть рядки неявними аргументами, такими як ``%default`` або ``%prog`` "
"стандартним синтаксисом Python, щоб використовувати словники для "
"форматування рядків, тобто ``%(default)s`` і ``%(prog)s``."

msgid ""
"Replace the OptionParser constructor ``version`` argument with a call to "
"``parser.add_argument('--version', action='version', version='<the "
"version>')``."
msgstr ""
"Замініть аргумент ``version`` конструктора OptionParser на виклик ``parser."
"add_argument('--version', action='version', version=' <the version> ')``."
