# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`socket` --- Low-level networking interface"
msgstr ":mod:`socket` --- Мережевий інтерфейс низького рівня"

msgid "**Source code:** :source:`Lib/socket.py`"
msgstr "**Вихідний код:** :source:`Lib/socket.py`"

msgid ""
"This module provides access to the BSD *socket* interface. It is available "
"on all modern Unix systems, Windows, MacOS, and probably additional "
"platforms."
msgstr ""
"Цей модуль забезпечує доступ до інтерфейсу BSD *socket*. Він доступний у "
"всіх сучасних системах Unix, Windows, MacOS і, можливо, на додаткових "
"платформах."

msgid ""
"Some behavior may be platform dependent, since calls are made to the "
"operating system socket APIs."
msgstr ""
"Деяка поведінка може залежати від платформи, оскільки виклики здійснюються "
"до API сокетів операційної системи."

msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ""

msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""

msgid ""
"The Python interface is a straightforward transliteration of the Unix system "
"call and library interface for sockets to Python's object-oriented style: "
"the :func:`.socket` function returns a :dfn:`socket object` whose methods "
"implement the various socket system calls.  Parameter types are somewhat "
"higher-level than in the C interface: as with :meth:`read` and :meth:`write` "
"operations on Python files, buffer allocation on receive operations is "
"automatic, and buffer length is implicit on send operations."
msgstr ""
"Інтерфейс Python є простою транслітерацією системного виклику Unix та "
"інтерфейсу бібліотеки для сокетів у об’єктно-орієнтований стиль Python: "
"функція :func:`.socket` повертає об’єкт :dfn:`socket`, методи якого "
"реалізують різноманітні системні виклики сокетів. . Типи параметрів дещо "
"вищого рівня, ніж в інтерфейсі C: як і з операціями :meth:`read` і :meth:"
"`write` для файлів Python, розподіл буфера для операцій отримання є "
"автоматичним, а довжина буфера неявна для операцій надсилання."

msgid "Module :mod:`socketserver`"
msgstr "Модуль :mod:`socketserver`"

msgid "Classes that simplify writing network servers."
msgstr "Класи, які спрощують написання мережевих серверів."

msgid "Module :mod:`ssl`"
msgstr "Модуль :mod:`ssl`"

msgid "A TLS/SSL wrapper for socket objects."
msgstr "Обгортка TLS/SSL для об’єктів сокета."

msgid "Socket families"
msgstr "Сімейства розеток"

msgid ""
"Depending on the system and the build options, various socket families are "
"supported by this module."
msgstr ""
"Залежно від системи та параметрів збірки, цей модуль підтримує різні "
"сімейства сокетів."

msgid ""
"The address format required by a particular socket object is automatically "
"selected based on the address family specified when the socket object was "
"created.  Socket addresses are represented as follows:"
msgstr ""
"Формат адреси, необхідний для певного об’єкта сокета, вибирається "
"автоматично на основі сімейства адрес, указаного під час створення об’єкта "
"сокета. Адреси сокетів представлені таким чином:"

msgid ""
"The address of an :const:`AF_UNIX` socket bound to a file system node is "
"represented as a string, using the file system encoding and the "
"``'surrogateescape'`` error handler (see :pep:`383`).  An address in Linux's "
"abstract namespace is returned as a :term:`bytes-like object` with an "
"initial null byte; note that sockets in this namespace can communicate with "
"normal file system sockets, so programs intended to run on Linux may need to "
"deal with both types of address.  A string or bytes-like object can be used "
"for either type of address when passing it as an argument."
msgstr ""
"Адреса сокета :const:`AF_UNIX`, пов’язаного з вузлом файлової системи, "
"представлена у вигляді рядка з використанням кодування файлової системи та "
"обробника помилок ``'surrogateescape'`` (див. :pep:`383`). Адреса в "
"абстрактному просторі імен Linux повертається як :term:`bytes-like object` з "
"початковим нульовим байтом; зауважте, що сокети в цьому просторі імен можуть "
"взаємодіяти зі звичайними сокетами файлової системи, тому програми, "
"призначені для роботи в Linux, можуть мати справу з обома типами адрес. "
"Рядок або байт-подібний об’єкт можна використовувати для будь-якого типу "
"адреси, передаючи його як аргумент."

msgid ""
"Previously, :const:`AF_UNIX` socket paths were assumed to use UTF-8 encoding."
msgstr ""
"Раніше вважалося, що шляхи сокетів :const:`AF_UNIX` використовували "
"кодування UTF-8."

msgid "Writable :term:`bytes-like object` is now accepted."
msgstr "Записуваний :term:`bytes-like object` тепер приймається."

msgid ""
"A pair ``(host, port)`` is used for the :const:`AF_INET` address family, "
"where *host* is a string representing either a hostname in internet domain "
"notation like ``'daring.cwi.nl'`` or an IPv4 address like "
"``'100.50.200.5'``, and *port* is an integer."
msgstr ""
"Пара ``(хост, порт)`` використовується для родини адрес :const:`AF_INET`, де "
"*хост* — це рядок, який представляє або ім’я хоста в нотації домену "
"Інтернету, як-от ``'daring.cwi.nl'`` або адреса IPv4, наприклад "
"``'100.50.200.5''``, і *порт* є цілим числом."

msgid ""
"For IPv4 addresses, two special forms are accepted instead of a host "
"address: ``''`` represents :const:`INADDR_ANY`, which is used to bind to all "
"interfaces, and the string ``'<broadcast>'`` represents :const:"
"`INADDR_BROADCAST`.  This behavior is not compatible with IPv6, therefore, "
"you may want to avoid these if you intend to support IPv6 with your Python "
"programs."
msgstr ""
"Для адрес IPv4 приймаються дві спеціальні форми замість адреси хоста: ``''`` "
"представляє :const:`INADDR_ANY`, який використовується для прив’язки до всіх "
"інтерфейсів, а рядок ``' <broadcast> ''`` представляє  :const:"
"`INADDR_BROADCAST`. Така поведінка несумісна з IPv6, тому ви можете уникнути "
"цього, якщо ви маєте намір підтримувати IPv6 у своїх програмах на Python."

msgid ""
"For :const:`AF_INET6` address family, a four-tuple ``(host, port, flowinfo, "
"scope_id)`` is used, where *flowinfo* and *scope_id* represent the "
"``sin6_flowinfo`` and ``sin6_scope_id`` members in :const:`struct "
"sockaddr_in6` in C.  For :mod:`socket` module methods, *flowinfo* and "
"*scope_id* can be omitted just for backward compatibility.  Note, however, "
"omission of *scope_id* can cause problems in manipulating scoped IPv6 "
"addresses."
msgstr ""
"Для родини адрес :const:`AF_INET6` використовується чотирикортеж ``(host, "
"port, flowinfo, scope_id)``, де *flowinfo* та *scope_id* представляють "
"``sin6_flowinfo`` та ``sin6_scope_id`` члени в :const:`struct sockaddr_in6` "
"в C. Для методів модуля :mod:`socket` *flowinfo* та *scope_id* можна "
"опустити тільки для зворотної сумісності. Однак зауважте, що пропуск "
"*scope_id* може спричинити проблеми під час маніпулювання адресами IPv6 із "
"областю дії."

msgid ""
"For multicast addresses (with *scope_id* meaningful) *address* may not "
"contain ``%scope_id`` (or ``zone id``) part. This information is superfluous "
"and may be safely omitted (recommended)."
msgstr ""
"Для багатоадресних адрес (зі значенням *scope_id*) *address* не може містити "
"частину ``%scope_id`` (або ``zone id``). Ця інформація є зайвою, і її можна "
"сміливо опустити (рекомендовано)."

msgid ":const:`AF_NETLINK` sockets are represented as pairs ``(pid, groups)``."
msgstr ":const:`AF_NETLINK` сокети представлені як пари ``(pid, groups)``."

msgid ""
"Linux-only support for TIPC is available using the :const:`AF_TIPC` address "
"family.  TIPC is an open, non-IP based networked protocol designed for use "
"in clustered computer environments.  Addresses are represented by a tuple, "
"and the fields depend on the address type. The general tuple form is "
"``(addr_type, v1, v2, v3 [, scope])``, where:"
msgstr ""
"Підтримка TIPC лише для Linux доступна за допомогою родини адрес :const:"
"`AF_TIPC`. TIPC — це відкритий мережевий протокол не на основі IP, "
"призначений для використання в кластерних комп’ютерних середовищах. Адреси "
"представлені кортежем, а поля залежать від типу адреси. Загальна форма "
"кортежу ``(addr_type, v1, v2, v3 [, scope])``, де:"

msgid ""
"*addr_type* is one of :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME`, "
"or :const:`TIPC_ADDR_ID`."
msgstr ""
"*addr_type* є одним із :const:`TIPC_ADDR_NAMESEQ`, :const:`TIPC_ADDR_NAME` "
"або :const:`TIPC_ADDR_ID`."

msgid ""
"*scope* is one of :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE`, "
"and :const:`TIPC_NODE_SCOPE`."
msgstr ""
"*scope* є одним із :const:`TIPC_ZONE_SCOPE`, :const:`TIPC_CLUSTER_SCOPE` та :"
"const:`TIPC_NODE_SCOPE`."

msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAME`, then *v1* is the server type, "
"*v2* is the port identifier, and *v3* should be 0."
msgstr ""
"Якщо *addr_type* дорівнює :const:`TIPC_ADDR_NAME`, тоді *v1* — це тип "
"сервера, *v2* — ідентифікатор порту, а *v3* має бути 0."

msgid ""
"If *addr_type* is :const:`TIPC_ADDR_NAMESEQ`, then *v1* is the server type, "
"*v2* is the lower port number, and *v3* is the upper port number."
msgstr ""
"Якщо *addr_type* дорівнює :const:`TIPC_ADDR_NAMESEQ`, то *v1* — це тип "
"сервера, *v2* — нижній номер порту, а *v3* — верхній номер порту."

msgid ""
"If *addr_type* is :const:`TIPC_ADDR_ID`, then *v1* is the node, *v2* is the "
"reference, and *v3* should be set to 0."
msgstr ""
"Якщо *addr_type* дорівнює :const:`TIPC_ADDR_ID`, тоді *v1* є вузлом, *v2* є "
"посиланням, а *v3* має бути встановлено на 0."

msgid ""
"A tuple ``(interface, )`` is used for the :const:`AF_CAN` address family, "
"where *interface* is a string representing a network interface name like "
"``'can0'``. The network interface name ``''`` can be used to receive packets "
"from all network interfaces of this family."
msgstr ""
"Кортеж ``(інтерфейс, )`` використовується для сімейства адрес :const:"
"`AF_CAN`, де *інтерфейс* — це рядок, що представляє назву мережевого "
"інтерфейсу, наприклад ``'can0'``. Ім'я мережевого інтерфейсу ``''`` можна "
"використовувати для отримання пакетів від усіх мережевих інтерфейсів цього "
"сімейства."

msgid ""
":const:`CAN_ISOTP` protocol require a tuple ``(interface, rx_addr, "
"tx_addr)`` where both additional parameters are unsigned long integer that "
"represent a CAN identifier (standard or extended)."
msgstr ""
"Протокол :const:`CAN_ISOTP` вимагає кортеж ``(interface, rx_addr, "
"tx_addr)``, де обидва додаткові параметри є довгим цілим числом без знаку, "
"що представляє ідентифікатор CAN (стандартний або розширений)."

msgid ""
":const:`CAN_J1939` protocol require a tuple ``(interface, name, pgn, addr)`` "
"where additional parameters are 64-bit unsigned integer representing the ECU "
"name, a 32-bit unsigned integer representing the Parameter Group Number "
"(PGN), and an 8-bit integer representing the address."
msgstr ""
" :const:(інтерфейс, ім'я, pgn, адреса)``, де додаткові параметри є 64-"
"розрядним цілим числом без знака, що представляє назву ECU, 32-розрядним "
"цілим числом без знака, що представляє номер групи параметрів (PGN ) і 8-"
"бітове ціле число, що представляє адресу."

msgid ""
"A string or a tuple ``(id, unit)`` is used for the :const:`SYSPROTO_CONTROL` "
"protocol of the :const:`PF_SYSTEM` family. The string is the name of a "
"kernel control using a dynamically assigned ID. The tuple can be used if ID "
"and unit number of the kernel control are known or if a registered ID is "
"used."
msgstr ""

msgid ""
":const:`AF_BLUETOOTH` supports the following protocols and address formats:"
msgstr ":const:`AF_BLUETOOTH` підтримує наступні протоколи та формати адрес:"

msgid ""
":const:`BTPROTO_L2CAP` accepts ``(bdaddr, psm)`` where ``bdaddr`` is the "
"Bluetooth address as a string and ``psm`` is an integer."
msgstr ""
":const:`BTPROTO_L2CAP` приймає ``(bdaddr, psm)``, де ``bdaddr`` — адреса "
"Bluetooth у вигляді рядка, а ``psm`` — ціле число."

msgid ""
":const:`BTPROTO_RFCOMM` accepts ``(bdaddr, channel)`` where ``bdaddr`` is "
"the Bluetooth address as a string and ``channel`` is an integer."
msgstr ""
":const:`BTPROTO_RFCOMM` приймає ``(bdaddr, канал)``, де ``bdaddr`` — це "
"адреса Bluetooth у вигляді рядка, а ``channel`` — ціле число."

msgid ""
":const:`BTPROTO_HCI` accepts ``(device_id,)`` where ``device_id`` is either "
"an integer or a string with the Bluetooth address of the interface. (This "
"depends on your OS; NetBSD and DragonFlyBSD expect a Bluetooth address while "
"everything else expects an integer.)"
msgstr ""
":const:`BTPROTO_HCI` приймає ``(device_id,)``, де ``device_id`` є або цілим "
"числом, або рядком з адресою Bluetooth інтерфейсу. (Це залежить від вашої "
"ОС; NetBSD і DragonFlyBSD очікують адресу Bluetooth, а всі інші очікують "
"ціле число.)"

msgid "NetBSD and DragonFlyBSD support added."
msgstr "Додано підтримку NetBSD і DragonFlyBSD."

msgid ""
":const:`BTPROTO_SCO` accepts ``bdaddr`` where ``bdaddr`` is a :class:`bytes` "
"object containing the Bluetooth address in a string format. (ex. "
"``b'12:23:34:45:56:67'``) This protocol is not supported under FreeBSD."
msgstr ""
":const:`BTPROTO_SCO` приймає ``bdaddr``, де ``bdaddr`` є об'єктом :class:"
"`bytes`, що містить адресу Bluetooth у форматі рядка. (наприклад, "
"``b'12:23:34:45:56:67''``) Цей протокол не підтримується FreeBSD."

msgid ""
":const:`AF_ALG` is a Linux-only socket based interface to Kernel "
"cryptography. An algorithm socket is configured with a tuple of two to four "
"elements ``(type, name [, feat [, mask]])``, where:"
msgstr ""
":const:`AF_ALG` — це інтерфейс для криптографії ядра на основі сокетів лише "
"для Linux. Сокет алгоритму налаштований за допомогою кортежу з двох-чотирьох "
"елементів ``(type, name [, feat [, mask]])``, де:"

msgid ""
"*type* is the algorithm type as string, e.g. ``aead``, ``hash``, "
"``skcipher`` or ``rng``."
msgstr ""
"*type* — це тип алгоритму як рядок, напр. ``aead``, ``hash``, ``skcipher`` "
"або ``rng``."

msgid ""
"*name* is the algorithm name and operation mode as string, e.g. ``sha256``, "
"``hmac(sha256)``, ``cbc(aes)`` or ``drbg_nopr_ctr_aes256``."
msgstr ""
"*ім’я* — це назва алгоритму та режим роботи у вигляді рядка, напр. "
"``sha256``, ``hmac(sha256)``, ``cbc(aes)`` або ``drbg_nopr_ctr_aes256``."

msgid "*feat* and *mask* are unsigned 32bit integers."
msgstr "*feat* і *mask* — це 32-розрядні цілі числа без знаку."

msgid "Some algorithm types require more recent Kernels."
msgstr ""

msgid ""
":const:`AF_VSOCK` allows communication between virtual machines and their "
"hosts. The sockets are represented as a ``(CID, port)`` tuple where the "
"context ID or CID and port are integers."
msgstr ""
":const:`AF_VSOCK` дозволяє спілкуватися між віртуальними машинами та їх "
"хостами. Сокети представлені як кортеж ``(CID, порт)``, де ідентифікатор "
"контексту або CID і порт є цілими числами."

msgid "See :manpage:`vsock(7)`"
msgstr ""

msgid ""
":const:`AF_PACKET` is a low-level interface directly to network devices. The "
"packets are represented by the tuple ``(ifname, proto[, pkttype[, hatype[, "
"addr]]])`` where:"
msgstr ""
":const:`AF_PACKET` — це низькорівневий інтерфейс безпосередньо до мережевих "
"пристроїв. Пакети представлені кортежем ``(ifname, proto[, pkttype[, "
"hatype[, addr]]])``, де:"

msgid "*ifname* - String specifying the device name."
msgstr "*ifname* - Рядок, що визначає назву пристрою."

msgid ""
"*proto* - An in network-byte-order integer specifying the Ethernet protocol "
"number."
msgstr ""
"*proto* – ціле число в мережевому порядку байтів, що визначає номер "
"протоколу Ethernet."

msgid "*pkttype* - Optional integer specifying the packet type:"
msgstr "*pkttype* - додаткове ціле число, що вказує тип пакета:"

msgid "``PACKET_HOST`` (the default) - Packet addressed to the local host."
msgstr ""
"``PACKET_HOST`` (за замовчуванням) - пакет, адресований локальному хосту."

msgid "``PACKET_BROADCAST`` - Physical-layer broadcast packet."
msgstr "``PACKET_BROADCAST`` - широкомовний пакет фізичного рівня."

msgid ""
"``PACKET_MULTICAST`` - Packet sent to a physical-layer multicast address."
msgstr ""

msgid ""
"``PACKET_OTHERHOST`` - Packet to some other host that has been caught by a "
"device driver in promiscuous mode."
msgstr ""
"``PACKET_OTHERHOST`` - Пакет до іншого хосту, який був перехоплений "
"драйвером пристрою в безладному режимі."

msgid ""
"``PACKET_OUTGOING`` - Packet originating from the local host that is looped "
"back to a packet socket."
msgstr ""
"``PACKET_OUTGOING`` – Пакет, що надходить від локального хосту і "
"повертається до сокета пакета."

msgid "*hatype* - Optional integer specifying the ARP hardware address type."
msgstr "*hatype* – додаткове ціле число, що визначає тип апаратної адреси ARP."

msgid ""
"*addr* - Optional bytes-like object specifying the hardware physical "
"address, whose interpretation depends on the device."
msgstr ""
"*addr* – необов’язковий байтовий об’єкт, що вказує апаратну фізичну адресу, "
"інтерпретація якої залежить від пристрою."

msgid ""
":const:`AF_QIPCRTR` is a Linux-only socket based interface for communicating "
"with services running on co-processors in Qualcomm platforms. The address "
"family is represented as a ``(node, port)`` tuple where the *node* and "
"*port* are non-negative integers."
msgstr ""
":const:`AF_QIPCRTR` — це інтерфейс на основі сокетів лише для Linux для "
"зв’язку зі службами, що працюють на співпроцесорах на платформах Qualcomm. "
"Сімейство адрес представлено як кортеж ``(вузол, порт)``, де *вузол* і "
"*порт* є невід’ємними цілими числами."

msgid ""
":const:`IPPROTO_UDPLITE` is a variant of UDP which allows you to specify "
"what portion of a packet is covered with the checksum. It adds two socket "
"options that you can change. ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_SEND_CSCOV, length)`` will change what portion of outgoing packets "
"are covered by the checksum and ``self.setsockopt(IPPROTO_UDPLITE, "
"UDPLITE_RECV_CSCOV, length)`` will filter out packets which cover too little "
"of their data. In both cases ``length`` should be in ``range(8, 2**16, 8)``."
msgstr ""
":const:`IPPROTO_UDPLITE` — це варіант UDP, який дозволяє вказати, яку "
"частину пакету охоплює контрольна сума. Він додає два варіанти розеток, які "
"ви можете змінити. ``self.setsockopt(IPPROTO_UDPLITE, UDPLITE_SEND_CSCOV, "
"length)`` змінить частину вихідних пакетів, охоплених контрольною сумою, а "
"``self.setsockopt(IPPROTO_UDPLITE, UDPLITE_RECV_CSCOV, length)`` "
"відфільтровує пакети, які покривають занадто мало їхні дані. В обох випадках "
"``довжина`` має бути в ``діапазоні (8, 2**16, 8)``."

msgid ""
"Such a socket should be constructed with ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv4 or ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` for IPv6."
msgstr ""
"Такий сокет має бути створений за допомогою ``socket(AF_INET, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` для IPv4 або ``socket(AF_INET6, SOCK_DGRAM, "
"IPPROTO_UDPLITE)`` для IPv6."

msgid ""
"If you use a hostname in the *host* portion of IPv4/v6 socket address, the "
"program may show a nondeterministic behavior, as Python uses the first "
"address returned from the DNS resolution.  The socket address will be "
"resolved differently into an actual IPv4/v6 address, depending on the "
"results from DNS resolution and/or the host configuration.  For "
"deterministic behavior use a numeric address in *host* portion."
msgstr ""
"Якщо ви використовуєте ім’я хоста в частині *host* адреси сокета IPv4/v6, "
"програма може продемонструвати недетерміновану поведінку, оскільки Python "
"використовує першу адресу, повернуту з вирішення DNS. Адреса сокета буде "
"перетворена по-іншому в фактичну адресу IPv4/v6, залежно від результатів "
"розв’язання DNS та/або конфігурації хоста. Для детермінованої поведінки "
"використовуйте числову адресу в частині *host*."

msgid ""
"All errors raise exceptions.  The normal exceptions for invalid argument "
"types and out-of-memory conditions can be raised. Errors related to socket "
"or address semantics raise :exc:`OSError` or one of its subclasses."
msgstr ""
"Усі помилки викликають винятки. Можна викликати звичайні винятки для "
"недійсних типів аргументів і умов браку пам’яті. Помилки, пов’язані із "
"семантикою сокета чи адреси, викликають :exc:`OSError` або один із його "
"підкласів."

msgid ""
"Non-blocking mode is supported through :meth:`~socket.setblocking`.  A "
"generalization of this based on timeouts is supported through :meth:`~socket."
"settimeout`."
msgstr ""
"Неблокуючий режим підтримується через :meth:`~socket.setblocking`. "
"Узагальнення цього на основі тайм-аутів підтримується через :meth:`~socket."
"settimeout`."

msgid "Module contents"
msgstr "Зміст модуля"

msgid "The module :mod:`socket` exports the following elements."
msgstr "Модуль :mod:`socket` експортує такі елементи."

msgid "Exceptions"
msgstr "Винятки"

msgid "A deprecated alias of :exc:`OSError`."
msgstr "Застарілий псевдонім :exc:`OSError`."

msgid "Following :pep:`3151`, this class was made an alias of :exc:`OSError`."
msgstr "Після :pep:`3151` цей клас отримав псевдонім :exc:`OSError`."

msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors, i.e. for functions that use *h_errno* in the POSIX C API, including :"
"func:`gethostbyname_ex` and :func:`gethostbyaddr`. The accompanying value is "
"a pair ``(h_errno, string)`` representing an error returned by a library "
"call.  *h_errno* is a numeric value, while *string* represents the "
"description of *h_errno*, as returned by the :c:func:`hstrerror` C function."
msgstr ""
"Підклас :exc:`OSError`, цей виняток виникає для помилок, пов’язаних з "
"адресою, тобто для функцій, які використовують *h_errno* в POSIX C API, "
"включаючи :func:`gethostbyname_ex` і :func:`gethostbyaddr`. Супровідним "
"значенням є пара ``(h_errno, string)``, яка представляє помилку, яку "
"повертає виклик бібліотеки. *h_errno* — це числове значення, тоді як "
"*string* представляє опис *h_errno*, який повертає функція :c:func:"
"`hstrerror` C."

msgid "This class was made a subclass of :exc:`OSError`."
msgstr "Цей клас було створено підкласом :exc:`OSError`."

msgid ""
"A subclass of :exc:`OSError`, this exception is raised for address-related "
"errors by :func:`getaddrinfo` and :func:`getnameinfo`. The accompanying "
"value is a pair ``(error, string)`` representing an error returned by a "
"library call.  *string* represents the description of *error*, as returned "
"by the :c:func:`gai_strerror` C function.  The numeric *error* value will "
"match one of the :const:`EAI_\\*` constants defined in this module."
msgstr ""
"Підклас :exc:`OSError`, цей виняток створюється для помилок, пов’язаних з "
"адресою, :func:`getaddrinfo` і :func:`getnameinfo`. Супровідним значенням є "
"пара ``(помилка, рядок)``, яка представляє помилку, яку повертає виклик "
"бібліотеки. *рядок* представляє опис *помилки*, яку повертає функція C :c:"
"func:`gai_strerror`. Числове значення *помилки* відповідатиме одній із "
"констант :const:`EAI_\\*`, визначених у цьому модулі."

msgid "A deprecated alias of :exc:`TimeoutError`."
msgstr "Застарілий псевдонім :exc:`TimeoutError`."

msgid ""
"A subclass of :exc:`OSError`, this exception is raised when a timeout occurs "
"on a socket which has had timeouts enabled via a prior call to :meth:"
"`~socket.settimeout` (or implicitly through :func:`~socket."
"setdefaulttimeout`).  The accompanying value is a string whose value is "
"currently always \"timed out\"."
msgstr ""
"Підклас :exc:`OSError`, цей виняток виникає, коли тайм-аут виникає в сокеті, "
"для якого було ввімкнено тайм-аути через попередній виклик :meth:`~socket."
"settimeout` (або неявно через :func:`~socket .setdefaulttimeout`). "
"Супровідне значення - це рядок, значення якого наразі завжди \"закінчено\"."

msgid "This class was made an alias of :exc:`TimeoutError`."
msgstr "Цей клас отримав псевдонім :exc:`TimeoutError`."

msgid "Constants"
msgstr "Константи"

msgid ""
"The AF_* and SOCK_* constants are now :class:`AddressFamily` and :class:"
"`SocketKind` :class:`.IntEnum` collections."
msgstr ""
"Константи AF_* і SOCK_* тепер є колекціями :class:`AddressFamily` і :class:"
"`SocketKind` :class:`.IntEnum`."

msgid ""
"These constants represent the address (and protocol) families, used for the "
"first argument to :func:`.socket`.  If the :const:`AF_UNIX` constant is not "
"defined then this protocol is unsupported.  More constants may be available "
"depending on the system."
msgstr ""
"Ці константи представляють родини адрес (і протоколів), які використовуються "
"для першого аргументу :func:`.socket`. Якщо константа :const:`AF_UNIX` не "
"визначена, цей протокол не підтримується. Залежно від системи можуть бути "
"доступні інші константи."

msgid ""
"These constants represent the socket types, used for the second argument to :"
"func:`.socket`.  More constants may be available depending on the system. "
"(Only :const:`SOCK_STREAM` and :const:`SOCK_DGRAM` appear to be generally "
"useful.)"
msgstr ""
"Ці константи представляють типи сокетів, які використовуються для другого "
"аргументу :func:`.socket`. Залежно від системи можуть бути доступні інші "
"константи. (Лише :const:`SOCK_STREAM` і :const:`SOCK_DGRAM` здаються загалом "
"корисними.)"

msgid ""
"These two constants, if defined, can be combined with the socket types and "
"allow you to set some flags atomically (thus avoiding possible race "
"conditions and the need for separate calls)."
msgstr ""
"Ці дві константи, якщо їх визначено, можна комбінувати з типами сокетів і "
"дозволити вам встановлювати деякі прапори атомарно (таким чином уникаючи "
"можливих умов змагання та потреби в окремих викликах)."

msgid ""
"`Secure File Descriptor Handling <https://udrepper.livejournal.com/20407."
"html>`_ for a more thorough explanation."
msgstr ""

msgid ":ref:`Availability <availability>`: Linux >= 2.6.27."
msgstr ":ref:`Доступність <availability>`: Linux >= 2.6.27."

msgid ""
"Many constants of these forms, documented in the Unix documentation on "
"sockets and/or the IP protocol, are also defined in the socket module. They "
"are generally used in arguments to the :meth:`setsockopt` and :meth:"
"`getsockopt` methods of socket objects.  In most cases, only those symbols "
"that are defined in the Unix header files are defined; for a few symbols, "
"default values are provided."
msgstr ""
"Багато констант цих форм, задокументованих у документації Unix щодо сокетів "
"та/або протоколу IP, також визначені в модулі сокета. Зазвичай вони "
"використовуються в аргументах методів :meth:`setsockopt` і :meth:"
"`getsockopt` об'єктів сокета. У більшості випадків визначаються лише ті "
"символи, які визначені у файлах заголовків Unix; для кількох символів "
"надаються значення за замовчуванням."

msgid ""
"``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION`` were added."
msgstr ""
"Додано ``SO_DOMAIN``, ``SO_PROTOCOL``, ``SO_PEERSEC``, ``SO_PASSSEC``, "
"``TCP_USER_TIMEOUT``, ``TCP_CONGESTION``."

msgid ""
"On Windows, ``TCP_FASTOPEN``, ``TCP_KEEPCNT`` appear if run-time Windows "
"supports."
msgstr ""
"У Windows відображаються ``TCP_FASTOPEN``, ``TCP_KEEPCNT``, якщо Windows "
"підтримує режим виконання."

msgid "``TCP_NOTSENT_LOWAT`` was added."
msgstr "``TCP_NOTSENT_LOWAT`` було додано."

msgid ""
"On Windows, ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL`` appear if run-time Windows "
"supports."
msgstr ""
"У Windows відображаються ``TCP_KEEPIDLE``, ``TCP_KEEPINTVL``, якщо Windows "
"підтримує режим виконання."

msgid ""
"``IP_RECVTOS`` was added.  Added ``TCP_KEEPALIVE``. On MacOS this constant "
"can be used in the same  way that ``TCP_KEEPIDLE`` is used on Linux."
msgstr ""
"``IP_RECVTOS`` було додано. Додано ``TCP_KEEPALIVE``. У MacOS цю константу "
"можна використовувати так само, як ``TCP_KEEPIDLE`` використовується в Linux."

msgid ""
"Added ``TCP_CONNECTION_INFO``. On MacOS this constant can be used in the "
"same way that ``TCP_INFO`` is used on Linux and BSD."
msgstr ""

msgid ""
"Many constants of these forms, documented in the Linux documentation, are "
"also defined in the socket module."
msgstr ""
"Багато констант цих форм, задокументованих у документації Linux, також "
"визначені в модулі сокета."

msgid ":ref:`Availability <availability>`: Linux >= 2.6.25, NetBSD >= 8."
msgstr ""

msgid "NetBSD support was added."
msgstr ""

msgid ""
"CAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) "
"protocol. Broadcast manager constants, documented in the Linux "
"documentation, are also defined in the socket module."
msgstr ""
"CAN_BCM, у сімействі протоколів CAN, є протоколом менеджера трансляції "
"(BCM). Константи менеджера трансляції, задокументовані в документації Linux, "
"також визначені в модулі сокета."

msgid ":ref:`Availability <availability>`: Linux >= 2.6.25."
msgstr ":ref:`Доступність <availability>`: Linux >= 2.6.25."

msgid ""
"The :data:`CAN_BCM_CAN_FD_FRAME` flag is only available on Linux >= 4.8."
msgstr "Прапор :data:`CAN_BCM_CAN_FD_FRAME` доступний лише в Linux >= 4.8."

msgid ""
"Enables CAN FD support in a CAN_RAW socket. This is disabled by default. "
"This allows your application to send both CAN and CAN FD frames; however, "
"you must accept both CAN and CAN FD frames when reading from the socket."
msgstr ""
"Вмикає підтримку CAN FD у гнізді CAN_RAW. За замовчуванням це вимкнено. Це "
"дозволяє вашій програмі надсилати кадри CAN і CAN FD; однак під час читання "
"з роз’єму ви повинні приймати як CAN, так і CAN FD кадри."

msgid "This constant is documented in the Linux documentation."
msgstr "Ця константа задокументована в документації Linux."

msgid ":ref:`Availability <availability>`: Linux >= 3.6."
msgstr ":ref:`Доступність <availability>`: Linux >= 3.6."

msgid ""
"Joins the applied CAN filters such that only CAN frames that match all given "
"CAN filters are passed to user space."
msgstr ""
"Об’єднує застосовані фільтри CAN, щоб у простір користувача передавалися "
"лише кадри CAN, які відповідають усім наданим фільтрам CAN."

msgid ":ref:`Availability <availability>`: Linux >= 4.1."
msgstr ":ref:`Доступність <availability>`: Linux >= 4.1."

msgid ""
"CAN_ISOTP, in the CAN protocol family, is the ISO-TP (ISO 15765-2) protocol. "
"ISO-TP constants, documented in the Linux documentation."
msgstr ""
"CAN_ISOTP у сімействі протоколів CAN є протоколом ISO-TP (ISO 15765-2). "
"Константи ISO-TP, задокументовані в документації Linux."

msgid ""
"CAN_J1939, in the CAN protocol family, is the SAE J1939 protocol. J1939 "
"constants, documented in the Linux documentation."
msgstr ""
"CAN_J1939 у сімействі протоколів CAN є протоколом SAE J1939. Константи "
"J1939, задокументовані в документації Linux."

msgid ":ref:`Availability <availability>`: Linux >= 5.4."
msgstr ":ref:`Доступність <availability>`: Linux >= 5.4."

msgid ":ref:`Availability <availability>`: Linux >= 2.2."
msgstr ":ref:`Доступність <availability>`: Linux >= 2.2."

msgid ":ref:`Availability <availability>`: Linux >= 2.6.30."
msgstr ":ref:`Доступність <availability>`: Linux >= 2.6.30."

msgid ""
"Constants for Windows' WSAIoctl(). The constants are used as arguments to "
"the :meth:`~socket.socket.ioctl` method of socket objects."
msgstr ""
"Константи для Windows WSAIoctl(). Константи використовуються як аргументи "
"методу :meth:`~socket.socket.ioctl` об’єктів сокета."

msgid "``SIO_LOOPBACK_FAST_PATH`` was added."
msgstr "``SIO_LOOPBACK_FAST_PATH`` було додано."

msgid ""
"TIPC related constants, matching the ones exported by the C socket API. See "
"the TIPC documentation for more information."
msgstr ""
"Константи, пов’язані з TIPC, що збігаються з тими, які експортує API сокета "
"C. Додаткову інформацію див. у документації TIPC."

msgid "Constants for Linux Kernel cryptography."
msgstr "Константи для криптографії ядра Linux."

msgid ":ref:`Availability <availability>`: Linux >= 2.6.38."
msgstr ":ref:`Доступність <availability>`: Linux >= 2.6.38."

msgid "Constants for Linux host/guest communication."
msgstr "Константи для зв’язку хост/гость Linux."

msgid ":ref:`Availability <availability>`: Linux >= 4.8."
msgstr ":ref:`Доступність <availability>`: Linux >= 4.8."

msgid ":ref:`Availability <availability>`: BSD, macOS."
msgstr ":ref:`Наявність <availability>`: BSD, macOS."

msgid ""
"This constant contains a boolean value which indicates if IPv6 is supported "
"on this platform."
msgstr ""
"Ця константа містить логічне значення, яке вказує, чи підтримується IPv6 на "
"цій платформі."

msgid ""
"These are string constants containing Bluetooth addresses with special "
"meanings. For example, :const:`BDADDR_ANY` can be used to indicate any "
"address when specifying the binding socket with :const:`BTPROTO_RFCOMM`."
msgstr ""
"Це рядкові константи, що містять адреси Bluetooth зі спеціальними "
"значеннями. Наприклад, :const:`BDADDR_ANY` можна використовувати для "
"вказівки будь-якої адреси, коли вказується сокет прив’язки за допомогою :"
"const:`BTPROTO_RFCOMM`."

msgid ""
"For use with :const:`BTPROTO_HCI`. :const:`HCI_FILTER` is not available for "
"NetBSD or DragonFlyBSD. :const:`HCI_TIME_STAMP` and :const:`HCI_DATA_DIR` "
"are not available for FreeBSD, NetBSD, or DragonFlyBSD."
msgstr ""
"Для використання з :const:`BTPROTO_HCI`. :const:`HCI_FILTER` недоступний для "
"NetBSD або DragonFlyBSD. :const:`HCI_TIME_STAMP` і :const:`HCI_DATA_DIR` "
"недоступні для FreeBSD, NetBSD або DragonFlyBSD."

msgid ""
"Constant for Qualcomm's IPC router protocol, used to communicate with "
"service providing remote processors."
msgstr ""
"Константа для протоколу маршрутизатора IPC Qualcomm, який використовується "
"для зв’язку з віддаленими процесорами, що надають послуги."

msgid ":ref:`Availability <availability>`: Linux >= 4.7."
msgstr ":ref:`Доступність <availability>`: Linux >= 4.7."

msgid ""
"LOCAL_CREDS and LOCAL_CREDS_PERSISTENT can be used with SOCK_DGRAM, "
"SOCK_STREAM sockets, equivalent to Linux/DragonFlyBSD SO_PASSCRED, while "
"LOCAL_CREDS sends the credentials at first read, LOCAL_CREDS_PERSISTENT "
"sends for each read, SCM_CREDS2 must be then used for the latter for the "
"message type."
msgstr ""

msgid ":ref:`Availability <availability>`: FreeBSD."
msgstr ""

msgid ""
"Constant to optimize CPU locality, to be used in conjunction with :data:"
"`SO_REUSEPORT`."
msgstr ""

msgid ":ref:`Availability <availability>`: Linux >= 3.9"
msgstr ""

msgid "Functions"
msgstr "Функції"

msgid "Creating sockets"
msgstr "Створення сокетів"

msgid ""
"The following functions all create :ref:`socket objects <socket-objects>`."
msgstr "Усі наступні функції створюють :ref:`об’єкти socket <socket-objects>`."

msgid ""
"Create a new socket using the given address family, socket type and protocol "
"number.  The address family should be :const:`AF_INET` (the default), :const:"
"`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:`AF_PACKET`, or :const:"
"`AF_RDS`. The socket type should be :const:`SOCK_STREAM` (the default), :"
"const:`SOCK_DGRAM`, :const:`SOCK_RAW` or perhaps one of the other ``SOCK_`` "
"constants. The protocol number is usually zero and may be omitted or in the "
"case where the address family is :const:`AF_CAN` the protocol should be one "
"of :const:`CAN_RAW`, :const:`CAN_BCM`, :const:`CAN_ISOTP` or :const:"
"`CAN_J1939`."
msgstr ""
"Створіть новий сокет, використовуючи вказане сімейство адрес, тип сокета та "
"номер протоколу. Сімейство адрес має бути :const:`AF_INET` (за "
"замовчуванням), :const:`AF_INET6`, :const:`AF_UNIX`, :const:`AF_CAN`, :const:"
"`AF_PACKET` або :const:`AF_RDS`. Тип сокета має бути :const:`SOCK_STREAM` "
"(за замовчуванням), :const:`SOCK_DGRAM`, :const:`SOCK_RAW` або, можливо, "
"одна з інших констант ``SOCK_``. Номер протоколу зазвичай дорівнює нулю і "
"може бути пропущений або у випадку, коли сімейство адрес :const:`AF_CAN`, "
"протокол має бути одним із :const:`CAN_RAW`, :const:`CAN_BCM`, :const:"
"`CAN_ISOTP` або :const:`CAN_J1939`."

msgid ""
"If *fileno* is specified, the values for *family*, *type*, and *proto* are "
"auto-detected from the specified file descriptor.  Auto-detection can be "
"overruled by calling the function with explicit *family*, *type*, or *proto* "
"arguments.  This only affects how Python represents e.g. the return value "
"of :meth:`socket.getpeername` but not the actual OS resource.  Unlike :func:"
"`socket.fromfd`, *fileno* will return the same socket and not a duplicate. "
"This may help close a detached socket using :meth:`socket.close()`."
msgstr ""
"Якщо вказано *fileno*, значення для *family*, *type* і *proto* автоматично "
"визначаються з указаного дескриптора файлу. Автоматичне визначення можна "
"скасувати, викликавши функцію з явними аргументами *family*, *type* або "
"*proto*. Це впливає лише на те, як Python представляє, наприклад. "
"повертається значення :meth:`socket.getpeername`, але не фактичний ресурс "
"ОС. На відміну від :func:`socket.fromfd`, *fileno* поверне той самий сокет, "
"а не дублікат. Це може допомогти закрити відокремлений сокет за допомогою :"
"meth:`socket.close()`."

msgid "The newly created socket is :ref:`non-inheritable <fd_inheritance>`."
msgstr "Новостворений сокет :ref:`не успадковується <fd_inheritance>`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.__new__`` with arguments "
"``self``, ``family``, ``type``, ``protocol``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``socket.__new__`` з аргументами "
"``self``, ``family``, ``type``, ``protocol``."

msgid "The AF_CAN family was added. The AF_RDS family was added."
msgstr "Додано сімейство AF_CAN. Додано сімейство AF_RDS."

msgid "The CAN_BCM protocol was added."
msgstr "Додано протокол CAN_BCM."

msgid "The returned socket is now non-inheritable."
msgstr "Повернений сокет тепер не успадковується."

msgid "The CAN_ISOTP protocol was added."
msgstr "Додано протокол CAN_ISOTP."

msgid ""
"When :const:`SOCK_NONBLOCK` or :const:`SOCK_CLOEXEC` bit flags are applied "
"to *type* they are cleared, and :attr:`socket.type` will not reflect them.  "
"They are still passed to the underlying system ``socket()`` call.  Therefore,"
msgstr ""

msgid ""
"will still create a non-blocking socket on OSes that support "
"``SOCK_NONBLOCK``, but ``sock.type`` will be set to ``socket.SOCK_STREAM``."
msgstr ""
"усе одно створить неблокуючий сокет в ОС, які підтримують ``SOCK_NONBLOCK``, "
"але ``sock.type`` буде встановлено на ``socket.SOCK_STREAM``."

msgid "The CAN_J1939 protocol was added."
msgstr "Додано протокол CAN_J1939."

msgid "The IPPROTO_MPTCP protocol was added."
msgstr "Додано протокол IPPROTO_MPTCP."

msgid ""
"Build a pair of connected socket objects using the given address family, "
"socket type, and protocol number.  Address family, socket type, and protocol "
"number are as for the :func:`.socket` function above. The default family is :"
"const:`AF_UNIX` if defined on the platform; otherwise, the default is :const:"
"`AF_INET`."
msgstr ""
"Створіть пару з’єднаних об’єктів сокета, використовуючи вказане сімейство "
"адрес, тип сокета та номер протоколу. Родина адрес, тип сокета та номер "
"протоколу такі ж, як для функції :func:`.socket` вище. Сімейство за "
"замовчуванням :const:`AF_UNIX`, якщо визначено на платформі; інакше за "
"замовчуванням :const:`AF_INET`."

msgid "The newly created sockets are :ref:`non-inheritable <fd_inheritance>`."
msgstr "Новостворені сокети :ref:`не успадковуються <fd_inheritance>`."

msgid ""
"The returned socket objects now support the whole socket API, rather than a "
"subset."
msgstr ""
"Повернені об’єкти сокета тепер підтримують весь API сокета, а не його "
"підмножину."

msgid "The returned sockets are now non-inheritable."
msgstr "Повернені сокети тепер не успадковуються."

msgid "Windows support added."
msgstr "Додано підтримку Windows."

msgid ""
"Connect to a TCP service listening on the internet *address* (a 2-tuple "
"``(host, port)``), and return the socket object.  This is a higher-level "
"function than :meth:`socket.connect`: if *host* is a non-numeric hostname, "
"it will try to resolve it for both :data:`AF_INET` and :data:`AF_INET6`, and "
"then try to connect to all possible addresses in turn until a connection "
"succeeds.  This makes it easy to write clients that are compatible to both "
"IPv4 and IPv6."
msgstr ""
"Підключіться до служби TCP, яка прослуховує *адресу* в Інтернеті (2-кортеж "
"``(хост, порт)``) і поверніть об’єкт сокета. Це функція вищого рівня, ніж :"
"meth:`socket.connect`: якщо *host* є нечисловим ім’ям хоста, вона "
"намагатиметься вирішити його як для :data:`AF_INET`, так і для :data:"
"`AF_INET6`, а потім спробуйте підключитися до всіх можливих адрес по черзі, "
"доки підключення не вдасться. Це полегшує написання клієнтів, сумісних як з "
"IPv4, так і з IPv6."

msgid ""
"Passing the optional *timeout* parameter will set the timeout on the socket "
"instance before attempting to connect.  If no *timeout* is supplied, the "
"global default timeout setting returned by :func:`getdefaulttimeout` is used."
msgstr ""
"Передача додаткового параметра *timeout* встановить час очікування для "
"екземпляра сокета перед спробою підключення. Якщо *тайм-аут* не вказано, "
"використовується глобальне налаштування тайм-ауту за умовчанням, яке "
"повертає :func:`getdefaulttimeout`."

msgid ""
"If supplied, *source_address* must be a 2-tuple ``(host, port)`` for the "
"socket to bind to as its source address before connecting.  If host or port "
"are '' or 0 respectively the OS default behavior will be used."
msgstr ""
"Якщо надано, *source_address* має бути 2-кортежем ``(хост, порт)``, щоб "
"сокет прив’язувався до своєї адреси джерела перед підключенням. Якщо хост "
"або порт мають значення '' або 0 відповідно, буде використано типову "
"поведінку ОС."

msgid ""
"When a connection cannot be created, an exception is raised. By default, it "
"is the exception from the last address in the list. If *all_errors* is "
"``True``, it is an :exc:`ExceptionGroup` containing the errors of all "
"attempts."
msgstr ""

msgid "*source_address* was added."
msgstr "*вихідна_адреса* була додана."

msgid "*all_errors* was added."
msgstr ""

msgid ""
"Convenience function which creates a TCP socket bound to *address* (a 2-"
"tuple ``(host, port)``) and return the socket object."
msgstr ""
"Зручна функція, яка створює TCP-сокет, прив’язаний до *адреси* (2-кортеж "
"``(хост, порт)``) і повертає об’єкт сокета."

msgid ""
"*family* should be either :data:`AF_INET` or :data:`AF_INET6`. *backlog* is "
"the queue size passed to :meth:`socket.listen`; when ``0`` a default "
"reasonable value is chosen. *reuse_port* dictates whether to set the :data:"
"`SO_REUSEPORT` socket option."
msgstr ""
"*family* має бути :data:`AF_INET` або :data:`AF_INET6`. *backlog* — це "
"розмір черги, переданий до :meth:`socket.listen`; коли ``0`` вибрано розумне "
"значення за умовчанням. *reuse_port* визначає, чи встановлювати параметр "
"сокета :data:`SO_REUSEPORT`."

msgid ""
"If *dualstack_ipv6* is true and the platform supports it the socket will be "
"able to accept both IPv4 and IPv6 connections, else it will raise :exc:"
"`ValueError`. Most POSIX platforms and Windows are supposed to support this "
"functionality. When this functionality is enabled the address returned by :"
"meth:`socket.getpeername` when an IPv4 connection occurs will be an IPv6 "
"address represented as an IPv4-mapped IPv6 address. If *dualstack_ipv6* is "
"false it will explicitly disable this functionality on platforms that enable "
"it by default (e.g. Linux). This parameter can be used in conjunction with :"
"func:`has_dualstack_ipv6`:"
msgstr ""
"Якщо *dualstack_ipv6* має значення true і платформа підтримує його, сокет "
"зможе приймати як з’єднання IPv4, так і IPv6, інакше виникне :exc:"
"`ValueError`. Більшість платформ POSIX і Windows повинні підтримувати цю "
"функцію. Якщо цю функцію ввімкнено, адреса, яку повертає :meth:`socket."
"getpeername` під час встановлення з’єднання IPv4, буде адресою IPv6, "
"представленою як адреса IPv6, відображена в IPv4. Якщо *dualstack_ipv6* має "
"значення false, це явно вимикає цю функцію на платформах, які ввімкнули її "
"за замовчуванням (наприклад, Linux). Цей параметр можна використовувати в "
"поєднанні з :func:`has_dualstack_ipv6`:"

msgid ""
"On POSIX platforms the :data:`SO_REUSEADDR` socket option is set in order to "
"immediately reuse previous sockets which were bound on the same *address* "
"and remained in TIME_WAIT state."
msgstr ""
"На платформах POSIX параметр сокета :data:`SO_REUSEADDR` встановлено для "
"негайного повторного використання попередніх сокетів, які були прив’язані до "
"тієї самої *адреси* та залишалися в стані TIME_WAIT."

msgid ""
"Return ``True`` if the platform supports creating a TCP socket which can "
"handle both IPv4 and IPv6 connections."
msgstr ""
"Повертає ``True``, якщо платформа підтримує створення TCP-сокета, який може "
"обробляти з’єднання IPv4 і IPv6."

msgid ""
"Duplicate the file descriptor *fd* (an integer as returned by a file "
"object's :meth:`fileno` method) and build a socket object from the result.  "
"Address family, socket type and protocol number are as for the :func:`."
"socket` function above. The file descriptor should refer to a socket, but "
"this is not checked --- subsequent operations on the object may fail if the "
"file descriptor is invalid. This function is rarely needed, but can be used "
"to get or set socket options on a socket passed to a program as standard "
"input or output (such as a server started by the Unix inet daemon).  The "
"socket is assumed to be in blocking mode."
msgstr ""
"Скопіюйте файловий дескриптор *fd* (ціле число, яке повертає метод :meth:"
"`fileno` файлового об’єкта) і створіть об’єкт сокета з результату. Родина "
"адрес, тип сокета та номер протоколу такі ж, як для функції :func:`.socket` "
"вище. Дескриптор файлу має посилатися на сокет, але це не перевірено --- "
"подальші операції з об’єктом можуть завершитися помилкою, якщо дескриптор "
"файлу недійсний. Ця функція рідко потрібна, але її можна використовувати для "
"отримання або встановлення параметрів сокета для сокета, який передається "
"програмі як стандартний ввід або вихід (наприклад, сервер, запущений демоном "
"Unix inet). Передбачається, що розетка знаходиться в режимі блокування."

msgid ""
"Instantiate a socket from data obtained from the :meth:`socket.share` "
"method.  The socket is assumed to be in blocking mode."
msgstr ""
"Створіть екземпляр сокета з даних, отриманих з методу :meth:`socket.share`. "
"Передбачається, що розетка знаходиться в режимі блокування."

msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Наявність <availability>`: Windows."

msgid ""
"This is a Python type object that represents the socket object type. It is "
"the same as ``type(socket(...))``."
msgstr ""
"Це об’єкт типу Python, який представляє тип об’єкта сокета. Це те саме, що "
"``type(socket(...))``."

msgid "Other functions"
msgstr "Інші функції"

msgid "The :mod:`socket` module also offers various network-related services:"
msgstr "Модуль :mod:`socket` також пропонує різноманітні мережеві служби:"

msgid ""
"Close a socket file descriptor. This is like :func:`os.close`, but for "
"sockets. On some platforms (most noticeable Windows) :func:`os.close` does "
"not work for socket file descriptors."
msgstr ""
"Закрийте дескриптор файлу сокета. Це як :func:`os.close`, але для сокетів. "
"На деяких платформах (найбільш помітна Windows) :func:`os.close` не працює "
"для дескрипторів файлів сокетів."

msgid ""
"Translate the *host*/*port* argument into a sequence of 5-tuples that "
"contain all the necessary arguments for creating a socket connected to that "
"service. *host* is a domain name, a string representation of an IPv4/v6 "
"address or ``None``. *port* is a string service name such as ``'http'``, a "
"numeric port number or ``None``.  By passing ``None`` as the value of *host* "
"and *port*, you can pass ``NULL`` to the underlying C API."
msgstr ""
"Переведіть аргумент *host*/*port* у послідовність із 5 кортежів, які містять "
"усі необхідні аргументи для створення сокета, підключеного до цієї служби. "
"*host* – це доменне ім’я, рядкове представлення адреси IPv4/v6 або ``None``. "
"*порт* — це рядкова назва служби, наприклад ``'http'``, числовий номер порту "
"або ``None``. Передаючи ``None`` як значення *host* і *port*, ви можете "
"передати ``NULL`` базовому C API."

msgid ""
"The *family*, *type* and *proto* arguments can be optionally specified in "
"order to narrow the list of addresses returned.  Passing zero as a value for "
"each of these arguments selects the full range of results. The *flags* "
"argument can be one or several of the ``AI_*`` constants, and will influence "
"how results are computed and returned. For example, :const:`AI_NUMERICHOST` "
"will disable domain name resolution and will raise an error if *host* is a "
"domain name."
msgstr ""
"Аргументи *сімейство*, *тип* і *прото* можна додатково вказати, щоб звузити "
"список адрес, що повертаються. Передача нуля як значення для кожного з цих "
"аргументів вибирає повний діапазон результатів. Аргумент *flags* може бути "
"однією або декількома константами ``AI_*`` і впливатиме на спосіб обчислення "
"та повернення результатів. Наприклад, :const:`AI_NUMERICHOST` вимкне "
"розпізнавання доменного імені та викличе помилку, якщо *host* є доменним "
"іменем."

msgid "The function returns a list of 5-tuples with the following structure:"
msgstr "Функція повертає список із 5-ти кортежів із такою структурою:"

msgid "``(family, type, proto, canonname, sockaddr)``"
msgstr "``(сімейство, тип, прото, canonname, sockaddr)``"

msgid ""
"In these tuples, *family*, *type*, *proto* are all integers and are meant to "
"be passed to the :func:`.socket` function.  *canonname* will be a string "
"representing the canonical name of the *host* if :const:`AI_CANONNAME` is "
"part of the *flags* argument; else *canonname* will be empty.  *sockaddr* is "
"a tuple describing a socket address, whose format depends on the returned "
"*family* (a ``(address, port)`` 2-tuple for :const:`AF_INET`, a ``(address, "
"port, flowinfo, scope_id)`` 4-tuple for :const:`AF_INET6`), and is meant to "
"be passed to the :meth:`socket.connect` method."
msgstr ""
"У цих кортежах усі *family*, *type*, *proto* є цілими числами, і вони "
"призначені для передачі у функцію :func:`.socket`. *canonname* буде рядком, "
"що представлятиме канонічне ім’я *хосту*, якщо :const:`AI_CANONNAME` є "
"частиною аргументу *flags*; інакше *canonname* буде порожнім. *sockaddr* — "
"це кортеж, що описує адресу сокета, формат якого залежить від повернутого "
"*сімейства* (2-кортеж ``(адреса, порт)`` для :const:`AF_INET`, ``(адреса, "
"порт, flowinfo, scope_id)`` 4-кортеж для :const:`AF_INET6`), і призначений "
"для передачі в метод :meth:`socket.connect`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getaddrinfo`` with "
"arguments ``host``, ``port``, ``family``, ``type``, ``protocol``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``socket.getaddrinfo`` з аргументами "
"``хост``, ``порт``, ``сімейство``, ``тип``, ``протокол``."

msgid ""
"The following example fetches address information for a hypothetical TCP "
"connection to ``example.org`` on port 80 (results may differ on your system "
"if IPv6 isn't enabled)::"
msgstr ""
"У наступному прикладі отримується інформація про адресу для гіпотетичного "
"TCP-з’єднання з ``example.org`` на порту 80 (результати можуть відрізнятися "
"у вашій системі, якщо IPv6 не ввімкнено):"

msgid "parameters can now be passed using keyword arguments."
msgstr ""
"параметри тепер можна передавати за допомогою аргументів ключових слів."

msgid ""
"for IPv6 multicast addresses, string representing an address will not "
"contain ``%scope_id`` part."
msgstr ""
"для багатоадресних адрес IPv6 рядок, що представляє адресу, не міститиме "
"частину ``%scope_id``."

msgid ""
"Return a fully qualified domain name for *name*. If *name* is omitted or "
"empty, it is interpreted as the local host.  To find the fully qualified "
"name, the hostname returned by :func:`gethostbyaddr` is checked, followed by "
"aliases for the host, if available.  The first name which includes a period "
"is selected.  In case no fully qualified domain name is available and *name* "
"was provided, it is returned unchanged.  If *name* was empty or equal to "
"``'0.0.0.0'``, the hostname from :func:`gethostname` is returned."
msgstr ""
"Повернути повне доменне ім’я для *name*. Якщо *ім’я* опущене або порожнє, "
"воно інтерпретується як локальний хост. Щоб знайти повне ім’я, перевіряється "
"ім’я хоста, яке повертає :func:`gethostbyaddr`, а потім ідуть псевдоніми "
"хоста, якщо вони доступні. Вибрано перше ім’я, яке містить крапку. Якщо "
"повне доменне ім’я недоступне, а було вказано *ім’я*, воно повертається без "
"змін. Якщо *name* було порожнім або дорівнює ``'0.0.0.0'``, повертається "
"ім'я хоста з :func:`gethostname`."

msgid ""
"Translate a host name to IPv4 address format.  The IPv4 address is returned "
"as a string, such as  ``'100.50.200.5'``.  If the host name is an IPv4 "
"address itself it is returned unchanged.  See :func:`gethostbyname_ex` for a "
"more complete interface. :func:`gethostbyname` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"Перекладіть ім’я хоста у формат адреси IPv4. Адреса IPv4 повертається у "
"вигляді рядка, наприклад ``'100.50.200.5``. Якщо ім’я хоста є адресою IPv4, "
"воно повертається без змін. Дивіться :func:`gethostbyname_ex` для більш "
"повного інтерфейсу. :func:`gethostbyname` не підтримує розпізнавання імен "
"IPv6, а :func:`getaddrinfo` слід використовувати замість цього для підтримки "
"подвійного стеку IPv4/v6."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyname`` with "
"argument ``hostname``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``socket.gethostbyname`` з "
"аргументом ``hostname``."

msgid ":ref:`Availability <availability>`: not WASI."
msgstr ""

msgid ""
"Translate a host name to IPv4 address format, extended interface. Return a "
"triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the host's "
"primary host name, *aliaslist* is a (possibly empty) list of alternative "
"host names for the same address, and *ipaddrlist* is a list of IPv4 "
"addresses for the same interface on the same host (often but not always a "
"single address). :func:`gethostbyname_ex` does not support IPv6 name "
"resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual "
"stack support."
msgstr ""
"Переклад імені хоста у формат адреси IPv4, розширений інтерфейс. Повертає "
"потрійний ``(hostname, aliaslist, ipaddrlist)``, де *hostname* — основне "
"ім’я хоста, *aliaslist* — (можливо, порожній) список альтернативних імен "
"хостів для тієї самої адреси, а *ipaddrlist* — список IPv4-адрес для одного "
"інтерфейсу на одному хості (часто, але не завжди одна адреса). :func:"
"`gethostbyname_ex` не підтримує розпізнавання імен IPv6, а :func:"
"`getaddrinfo` слід використовувати замість цього для підтримки подвійного "
"стеку IPv4/v6."

msgid ""
"Return a string containing the hostname of the machine where  the Python "
"interpreter is currently executing."
msgstr ""
"Повертає рядок, що містить ім’я хоста машини, на якій зараз виконується "
"інтерпретатор Python."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostname`` with no "
"arguments."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``socket.gethostname`` без "
"аргументів."

msgid ""
"Note: :func:`gethostname` doesn't always return the fully qualified domain "
"name; use :func:`getfqdn` for that."
msgstr ""
"Примітка: :func:`gethostname` не завжди повертає повне доменне ім’я; "
"використовуйте для цього :func:`getfqdn`."

msgid ""
"Return a triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is "
"the primary host name responding to the given *ip_address*, *aliaslist* is a "
"(possibly empty) list of alternative host names for the same address, and "
"*ipaddrlist* is a list of IPv4/v6 addresses for the same interface on the "
"same host (most likely containing only a single address). To find the fully "
"qualified domain name, use the function :func:`getfqdn`. :func:"
"`gethostbyaddr` supports both IPv4 and IPv6."
msgstr ""
"Повертає потрійний ``(hostname, aliaslist, ipaddrlist)``, де *hostname* — "
"основне ім’я хоста, що відповідає заданій *ip_address*, *aliaslist* — "
"(можливо, порожній) список альтернативних імен хостів для тієї самої адреси, "
"а *ipaddrlist* — це список адрес IPv4/v6 для того самого інтерфейсу на тому "
"самому хості (швидше за все, містить лише одну адресу). Щоб знайти повне "
"доменне ім’я, скористайтеся функцією :func:`getfqdn`. :func:`gethostbyaddr` "
"підтримує як IPv4, так і IPv6."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.gethostbyaddr`` with "
"argument ``ip_address``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``socket.gethostbyaddr`` з "
"аргументом ``ip_address``."

msgid ""
"Translate a socket address *sockaddr* into a 2-tuple ``(host, port)``. "
"Depending on the settings of *flags*, the result can contain a fully "
"qualified domain name or numeric address representation in *host*.  "
"Similarly, *port* can contain a string port name or a numeric port number."
msgstr ""

msgid ""
"For IPv6 addresses, ``%scope_id`` is appended to the host part if *sockaddr* "
"contains meaningful *scope_id*. Usually this happens for multicast addresses."
msgstr ""
"Для адрес IPv6 ``%scope_id`` додається до частини хоста, якщо *sockaddr* "
"містить значимий *scope_id*. Зазвичай це відбувається для багатоадресних "
"адрес."

msgid ""
"For more information about *flags* you can consult :manpage:`getnameinfo(3)`."
msgstr ""
"Для отримання додаткової інформації про *прапори* ви можете звернутися до :"
"manpage:`getnameinfo(3)`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getnameinfo`` with "
"argument ``sockaddr``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``socket.getnameinfo`` з аргументом "
"``sockaddr``."

msgid ""
"Translate an internet protocol name (for example, ``'icmp'``) to a constant "
"suitable for passing as the (optional) third argument to the :func:`.socket` "
"function.  This is usually only needed for sockets opened in \"raw\" mode (:"
"const:`SOCK_RAW`); for the normal socket modes, the correct protocol is "
"chosen automatically if the protocol is omitted or zero."
msgstr ""
"Перекладіть ім’я інтернет-протоколу (наприклад, ``'icmp'``) у константу, "
"придатну для передачі як (необов’язковий) третій аргумент функції :func:`."
"socket`. Зазвичай це потрібно лише для сокетів, відкритих у режимі \"raw\" (:"
"const:`SOCK_RAW`); для звичайних режимів сокетів правильний протокол "
"вибирається автоматично, якщо протокол пропущений або нульовий."

msgid ""
"Translate an internet service name and protocol name to a port number for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"Перекладіть назву інтернет-сервісу та назву протоколу на номер порту для "
"цієї служби. Додаткова назва протоколу, якщо її вказано, має бути ``'tcp'`` "
"або ``'udp'``, інакше будь-який протокол збігатиметься."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyname`` with "
"arguments ``servicename``, ``protocolname``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``socket.getservbyname`` з "
"аргументами ``servicename``, ``protocolname``."

msgid ""
"Translate an internet port number and protocol name to a service name for "
"that service.  The optional protocol name, if given, should be ``'tcp'`` or "
"``'udp'``, otherwise any protocol will match."
msgstr ""
"Перекладіть номер інтернет-порту та назву протоколу на назву служби для цієї "
"служби. Додаткова назва протоколу, якщо її вказано, має бути ``'tcp'`` або "
"``'udp'``, інакше будь-який протокол збігатиметься."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.getservbyport`` with "
"arguments ``port``, ``protocolname``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``socket.getservbyport`` з "
"аргументами ``port``, ``protocolname``."

msgid ""
"Convert 32-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"Перетворення 32-розрядних додатних чисел із мережевого порядку байтів на "
"хост. На машинах, де порядок байтів хоста збігається з порядком байтів у "
"мережі, це заборонено; інакше він виконує 4-байтову операцію обміну."

msgid ""
"Convert 16-bit positive integers from network to host byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"Перетворення 16-розрядних додатних чисел із мережевого порядку байтів на "
"хост. На машинах, де порядок байтів хоста збігається з порядком байтів у "
"мережі, це заборонено; інакше він виконує 2-байтову операцію обміну."

msgid ""
"Raises :exc:`OverflowError` if *x* does not fit in a 16-bit unsigned integer."
msgstr ""
"Викликає :exc:`OverflowError`, якщо *x* не вміщується в 16-бітне ціле число "
"без знаку."

msgid ""
"Convert 32-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 4-byte swap operation."
msgstr ""
"Перетворюйте 32-розрядні додатні цілі числа з хоста на мережевий порядок "
"байтів. На машинах, де порядок байтів хоста збігається з порядком байтів у "
"мережі, це заборонено; інакше він виконує 4-байтову операцію обміну."

msgid ""
"Convert 16-bit positive integers from host to network byte order.  On "
"machines where the host byte order is the same as network byte order, this "
"is a no-op; otherwise, it performs a 2-byte swap operation."
msgstr ""
"Перетворення 16-розрядних додатних чисел із хоста в мережевий порядок "
"байтів. На машинах, де порядок байтів хоста збігається з порядком байтів у "
"мережі, це заборонено; інакше він виконує 2-байтову операцію обміну."

msgid ""
"Convert an IPv4 address from dotted-quad string format (for example, "
"'123.45.67.89') to 32-bit packed binary format, as a bytes object four "
"characters in length.  This is useful when conversing with a program that "
"uses the standard C library and needs objects of type :c:struct:`in_addr`, "
"which is the C type for the 32-bit packed binary this function returns."
msgstr ""

msgid ""
":func:`inet_aton` also accepts strings with less than three dots; see the "
"Unix manual page :manpage:`inet(3)` for details."
msgstr ""
":func:`inet_aton` також приймає рядки з менш ніж трьома крапками; подробиці "
"див. на сторінці посібника Unix :manpage:`inet(3)`."

msgid ""
"If the IPv4 address string passed to this function is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on the "
"underlying C implementation of :c:func:`inet_aton`."
msgstr ""
"Якщо рядок адреси IPv4, переданий цій функції, недійсний, буде викликано :"
"exc:`OSError`. Зауважте, що саме те, що є дійсним, залежить від базової "
"реалізації C :c:func:`inet_aton`."

msgid ""
":func:`inet_aton` does not support IPv6, and :func:`inet_pton` should be "
"used instead for IPv4/v6 dual stack support."
msgstr ""
":func:`inet_aton` не підтримує IPv6, а :func:`inet_pton` слід "
"використовувати замість цього для підтримки подвійного стеку IPv4/v6."

msgid ""
"Convert a 32-bit packed IPv4 address (a :term:`bytes-like object` four bytes "
"in length) to its standard dotted-quad string representation (for example, "
"'123.45.67.89').  This is useful when conversing with a program that uses "
"the standard C library and needs objects of type :c:struct:`in_addr`, which "
"is the C type for the 32-bit packed binary data this function takes as an "
"argument."
msgstr ""

msgid ""
"If the byte sequence passed to this function is not exactly 4 bytes in "
"length, :exc:`OSError` will be raised. :func:`inet_ntoa` does not support "
"IPv6, and :func:`inet_ntop` should be used instead for IPv4/v6 dual stack "
"support."
msgstr ""
"Якщо послідовність байтів, передана цій функції, не має довжини точно 4 "
"байти, виникне :exc:`OSError`. :func:`inet_ntoa` не підтримує IPv6, а :func:"
"`inet_ntop` слід використовувати замість цього для підтримки подвійного "
"стеку IPv4/v6."

msgid ""
"Convert an IP address from its family-specific string format to a packed, "
"binary format. :func:`inet_pton` is useful when a library or network "
"protocol calls for an object of type :c:struct:`in_addr` (similar to :func:"
"`inet_aton`) or :c:struct:`in6_addr`."
msgstr ""

msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the IP address string *ip_string* is invalid, :exc:"
"`OSError` will be raised. Note that exactly what is valid depends on both "
"the value of *address_family* and the underlying implementation of :c:func:"
"`inet_pton`."
msgstr ""
"Підтримувані значення для *address_family* наразі: :const:`AF_INET` і :const:"
"`AF_INET6`. Якщо рядок IP-адреси *ip_string* недійсний, виникне :exc:"
"`OSError`. Зауважте, що саме те, що є дійсним, залежить як від значення "
"*address_family*, так і від базової реалізації :c:func:`inet_pton`."

msgid ":ref:`Availability <availability>`: Unix, Windows."
msgstr ":ref:`Наявність <availability>`: Unix, Windows."

msgid "Windows support added"
msgstr "Додано підтримку Windows"

msgid ""
"Convert a packed IP address (a :term:`bytes-like object` of some number of "
"bytes) to its standard, family-specific string representation (for example, "
"``'7.10.0.5'`` or ``'5aef:2b::8'``). :func:`inet_ntop` is useful when a "
"library or network protocol returns an object of type :c:struct:`in_addr` "
"(similar to :func:`inet_ntoa`) or :c:struct:`in6_addr`."
msgstr ""

msgid ""
"Supported values for *address_family* are currently :const:`AF_INET` and :"
"const:`AF_INET6`. If the bytes object *packed_ip* is not the correct length "
"for the specified address family, :exc:`ValueError` will be raised. :exc:"
"`OSError` is raised for errors from the call to :func:`inet_ntop`."
msgstr ""
"Підтримувані значення для *address_family* наразі: :const:`AF_INET` і :const:"
"`AF_INET6`. Якщо об’єкт bytes *packed_ip* не має правильної довжини для "
"вказаного сімейства адрес, буде викликано :exc:`ValueError`. :exc:`OSError` "
"викликається для помилок виклику :func:`inet_ntop`."

msgid ""
"Return the total length, without trailing padding, of an ancillary data item "
"with associated data of the given *length*.  This value can often be used as "
"the buffer size for :meth:`~socket.recvmsg` to receive a single item of "
"ancillary data, but :rfc:`3542` requires portable applications to use :func:"
"`CMSG_SPACE` and thus include space for padding, even when the item will be "
"the last in the buffer.  Raises :exc:`OverflowError` if *length* is outside "
"the permissible range of values."
msgstr ""
"Повертає загальну довжину, без заповнення в кінці, елемента допоміжних даних "
"із пов’язаними даними заданої *довжини*. Це значення часто можна "
"використовувати як розмір буфера для :meth:`~socket.recvmsg` для отримання "
"окремого елемента допоміжних даних, але :rfc:`3542` вимагає, щоб портативні "
"програми використовували :func:`CMSG_SPACE` і таким чином включали простір "
"для заповнення, навіть якщо елемент буде останнім у буфері. Викликає :exc:"
"`OverflowError`, якщо *length* виходить за межі допустимого діапазону "
"значень."

msgid ":ref:`Availability <availability>`: Unix, not Emscripten, not WASI."
msgstr ""

msgid "Most Unix platforms."
msgstr ""

msgid ""
"Return the buffer size needed for :meth:`~socket.recvmsg` to receive an "
"ancillary data item with associated data of the given *length*, along with "
"any trailing padding.  The buffer space needed to receive multiple items is "
"the sum of the :func:`CMSG_SPACE` values for their associated data lengths.  "
"Raises :exc:`OverflowError` if *length* is outside the permissible range of "
"values."
msgstr ""
"Повертає розмір буфера, необхідний для :meth:`~socket.recvmsg` для отримання "
"елемента допоміжних даних із пов’язаними даними заданої *довжини* разом із "
"будь-яким доповненням у кінці. Буферний простір, необхідний для отримання "
"кількох елементів, є сумою значень :func:`CMSG_SPACE` для відповідної "
"довжини даних. Викликає :exc:`OverflowError`, якщо *length* виходить за межі "
"допустимого діапазону значень."

msgid ""
"Note that some systems might support ancillary data without providing this "
"function.  Also note that setting the buffer size using the results of this "
"function may not precisely limit the amount of ancillary data that can be "
"received, since additional data may be able to fit into the padding area."
msgstr ""
"Зауважте, що деякі системи можуть підтримувати допоміжні дані без надання "
"цієї функції. Також зауважте, що встановлення розміру буфера за допомогою "
"результатів цієї функції може не обмежувати точно кількість допоміжних "
"даних, які можна отримати, оскільки додаткові дані можуть поміститися в "
"область заповнення."

msgid "most Unix platforms."
msgstr ""

msgid ""
"Return the default timeout in seconds (float) for new socket objects. A "
"value of ``None`` indicates that new socket objects have no timeout. When "
"the socket module is first imported, the default is ``None``."
msgstr ""
"Повертає стандартний час очікування в секундах (float) для нових об’єктів "
"сокета. Значення ``None`` вказує на те, що нові об’єкти сокета не мають часу "
"очікування. Коли модуль сокета імпортовано вперше, за замовчуванням буде "
"``None``."

msgid ""
"Set the default timeout in seconds (float) for new socket objects.  When the "
"socket module is first imported, the default is ``None``.  See :meth:"
"`~socket.settimeout` for possible values and their respective meanings."
msgstr ""
"Встановіть стандартний час очікування в секундах (float) для нових об’єктів "
"сокета. Коли модуль сокета імпортовано вперше, за замовчуванням буде "
"``None``. Перегляньте :meth:`~socket.settimeout` можливі значення та їх "
"відповідні значення."

msgid ""
"Set the machine's hostname to *name*.  This will raise an :exc:`OSError` if "
"you don't have enough rights."
msgstr ""
"Встановіть ім’я хоста машини на *name*. Це викличе :exc:`OSError`, якщо у "
"вас недостатньо прав."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sethostname`` with "
"argument ``name``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``socket.sethostname`` з аргументом "
"``name``."

msgid ":ref:`Availability <availability>`: Unix."
msgstr ":ref:`Наявність <availability>`: Unix."

msgid ""
"Return a list of network interface information (index int, name string) "
"tuples. :exc:`OSError` if the system call fails."
msgstr ""
"Повертає список кортежів інформації про мережевий інтерфейс (index int, name "
"string). :exc:`OSError`, якщо системний виклик не вдається."

msgid ""
":ref:`Availability <availability>`: Unix, Windows, not Emscripten, not WASI."
msgstr ""

msgid "Windows support was added."
msgstr "Додано підтримку Windows."

msgid ""
"On Windows network interfaces have different names in different contexts "
"(all names are examples):"
msgstr ""
"У Windows мережеві інтерфейси мають різні імена в різних контекстах (усі "
"імена є прикладами):"

msgid "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"
msgstr "UUID: ``{FB605B73-AAC2-49A6-9A2F-25416AEA0573}``"

msgid "name: ``ethernet_32770``"
msgstr "назва: ``ethernet_32770``"

msgid "friendly name: ``vEthernet (nat)``"
msgstr "зрозуміла назва: ``vEthernet (nat)``"

msgid "description: ``Hyper-V Virtual Ethernet Adapter``"
msgstr "опис: ``Hyper-V Virtual Ethernet Adapter``"

msgid ""
"This function returns names of the second form from the list, "
"``ethernet_32770`` in this example case."
msgstr ""
"Ця функція повертає імена другої форми зі списку, ``ethernet_32770`` у цьому "
"прикладі."

msgid ""
"Return a network interface index number corresponding to an interface name. :"
"exc:`OSError` if no interface with the given name exists."
msgstr ""
"Повертає номер індексу мережевого інтерфейсу, який відповідає імені "
"інтерфейсу. :exc:`OSError`, якщо не існує інтерфейсу з вказаною назвою."

msgid "\"Interface name\" is a name as documented in :func:`if_nameindex`."
msgstr ""
"\"Назва інтерфейсу\" — це назва, задокументована в :func:`if_nameindex`."

msgid ""
"Return a network interface name corresponding to an interface index number. :"
"exc:`OSError` if no interface with the given index exists."
msgstr ""
"Повертає назву мережевого інтерфейсу, що відповідає номеру індексу "
"інтерфейсу. :exc:`OSError`, якщо не існує інтерфейсу з даним індексом."

msgid ""
"Send the list of file descriptors *fds* over an :const:`AF_UNIX` socket "
"*sock*. The *fds* parameter is a sequence of file descriptors. Consult :meth:"
"`sendmsg` for the documentation of these parameters."
msgstr ""
"Надішліть список дескрипторів файлів *fds* через сокет :const:`AF_UNIX` "
"*sock*. Параметр *fds* — це послідовність дескрипторів файлів. Зверніться "
"до :meth:`sendmsg` для документації щодо цих параметрів."

msgid ""
"Unix platforms supporting :meth:`~socket.sendmsg` and :const:`SCM_RIGHTS` "
"mechanism."
msgstr ""

msgid ""
"Receive up to *maxfds* file descriptors from an :const:`AF_UNIX` socket "
"*sock*. Return ``(msg, list(fds), flags, addr)``. Consult :meth:`recvmsg` "
"for the documentation of these parameters."
msgstr ""
"Отримайте до *maxfds* файлових дескрипторів із :const:`AF_UNIX` сокета "
"*sock*. Повернути ``(msg, list(fds), flags, addr)``. Зверніться до :meth:"
"`recvmsg` для документації цих параметрів."

msgid "Any truncated integers at the end of the list of file descriptors."
msgstr "Будь-які скорочені цілі числа в кінці списку дескрипторів файлів."

msgid "Socket Objects"
msgstr "Об'єкти Socket"

msgid ""
"Socket objects have the following methods.  Except for :meth:`~socket."
"makefile`, these correspond to Unix system calls applicable to sockets."
msgstr ""
"Об’єкти Socket мають такі методи. За винятком :meth:`~socket.makefile`, вони "
"відповідають системним викликам Unix, застосовним до сокетів."

msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`~socket.close`."
msgstr ""
"Додано підтримку протоколу :term:`context manager`. Вихід із контекстного "
"менеджера еквівалентний виклику :meth:`~socket.close`."

msgid ""
"Accept a connection. The socket must be bound to an address and listening "
"for connections. The return value is a pair ``(conn, address)`` where *conn* "
"is a *new* socket object usable to send and receive data on the connection, "
"and *address* is the address bound to the socket on the other end of the "
"connection."
msgstr ""
"Прийняти підключення. Сокет має бути прив’язаний до адреси та прослуховувати "
"підключення. Поверненим значенням є пара ``(conn, address)``, де *conn* — це "
"*новий* об’єкт сокета, який можна використовувати для надсилання та "
"отримання даних під час з’єднання, а *address* — це адреса, прив’язана до "
"сокета на іншому кінець з'єднання."

msgid "The socket is now non-inheritable."
msgstr "Тепер сокет не успадковується."

msgid ""
"If the system call is interrupted and the signal handler does not raise an "
"exception, the method now retries the system call instead of raising an :exc:"
"`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"Якщо системний виклик перервано, а обробник сигналу не викликає виключення, "
"метод тепер повторює системний виклик замість того, щоб викликати виняток :"
"exc:`InterruptedError` (перегляньте :pep:`475` для обґрунтування)."

msgid ""
"Bind the socket to *address*.  The socket must not already be bound. (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"Прив’яжіть сокет до *адреси*. Розетка ще не повинна бути прив’язаною. "
"(Формат *адреси* залежить від групи адрес --- див. вище.)"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.bind`` with arguments "
"``self``, ``address``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``socket.bind`` з аргументами "
"``self``, ``address``."

msgid ""
"Mark the socket closed.  The underlying system resource (e.g. a file "
"descriptor) is also closed when all file objects from :meth:`makefile()` are "
"closed.  Once that happens, all future operations on the socket object will "
"fail. The remote end will receive no more data (after queued data is "
"flushed)."
msgstr ""
"Позначте розетку закритою. Базовий системний ресурс (наприклад, дескриптор "
"файлу) також закривається, коли закриваються всі файлові об’єкти з :meth:"
"`makefile()`. Як тільки це станеться, усі подальші операції над об’єктом "
"сокета не вдадуться. Віддалена сторона більше не отримуватиме даних (після "
"видалення даних із черги)."

msgid ""
"Sockets are automatically closed when they are garbage-collected, but it is "
"recommended to :meth:`close` them explicitly, or to use a :keyword:`with` "
"statement around them."
msgstr ""
"Сокети автоматично закриваються під час збирання сміття, але рекомендується :"
"meth:`close` їх явно або використовувати оператор :keyword:`with` навколо "
"них."

msgid ""
":exc:`OSError` is now raised if an error occurs when the underlying :c:func:"
"`close` call is made."
msgstr ""
":exc:`OSError` тепер викликається, якщо виникає помилка під час основного "
"виклику :c:func:`close`."

msgid ""
":meth:`close()` releases the resource associated with a connection but does "
"not necessarily close the connection immediately.  If you want to close the "
"connection in a timely fashion, call :meth:`shutdown()` before :meth:"
"`close()`."
msgstr ""
":meth:`close()` звільняє ресурс, пов’язаний із з’єднанням, але не "
"обов’язково закриває з’єднання негайно. Якщо ви хочете своєчасно закрити "
"з’єднання, викличте :meth:`shutdown()` перед :meth:`close()`."

msgid ""
"Connect to a remote socket at *address*. (The format of *address* depends on "
"the address family --- see above.)"
msgstr ""
"Підключіться до віддаленої розетки за *адресою*. (Формат *адреси* залежить "
"від групи адрес --- див. вище.)"

msgid ""
"If the connection is interrupted by a signal, the method waits until the "
"connection completes, or raise a :exc:`TimeoutError` on timeout, if the "
"signal handler doesn't raise an exception and the socket is blocking or has "
"a timeout. For non-blocking sockets, the method raises an :exc:"
"`InterruptedError` exception if the connection is interrupted by a signal "
"(or the exception raised by the signal handler)."
msgstr ""
"Якщо з’єднання перервано сигналом, метод чекає, доки з’єднання не "
"завершиться, або викликає :exc:`TimeoutError` після тайм-ауту, якщо обробник "
"сигналу не викликає виключення, а сокет блокується або має тайм-аут. Для "
"неблокуючих сокетів метод викликає виняток :exc:`InterruptedError`, якщо "
"з’єднання переривається сигналом (або винятком, викликаним обробником "
"сигналу)."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.connect`` with arguments "
"``self``, ``address``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``socket.connect`` з аргументами "
"``self``, ``address``."

msgid ""
"The method now waits until the connection completes instead of raising an :"
"exc:`InterruptedError` exception if the connection is interrupted by a "
"signal, the signal handler doesn't raise an exception and the socket is "
"blocking or has a timeout (see the :pep:`475` for the rationale)."
msgstr ""
"Тепер метод очікує, доки з’єднання завершиться, замість того, щоб викликати "
"виняток :exc:`InterruptedError`, якщо з’єднання перервано сигналом, обробник "
"сигналу не викликає виключення, а сокет блокується або має тайм-аут (див. :"
"pep:`475` для обґрунтування)."

msgid ""
"Like ``connect(address)``, but return an error indicator instead of raising "
"an exception for errors returned by the C-level :c:func:`connect` call "
"(other problems, such as \"host not found,\" can still raise exceptions).  "
"The error indicator is ``0`` if the operation succeeded, otherwise the value "
"of the :c:data:`errno` variable.  This is useful to support, for example, "
"asynchronous connects."
msgstr ""
"Подібно до ``connect(address)``, але повертає індикатор помилки замість "
"виклику винятку для помилок, які повертає виклик :c:func:`connect` рівня C "
"(інші проблеми, такі як \"хост не знайдено\", можуть все ще викликають "
"винятки). Індикатор помилки – ``0``, якщо операція виконана успішно, інакше "
"значення змінної :c:data:`errno`. Це корисно для підтримки, наприклад, "
"асинхронних підключень."

msgid ""
"Put the socket object into closed state without actually closing the "
"underlying file descriptor.  The file descriptor is returned, and can be "
"reused for other purposes."
msgstr ""
"Переведіть об’єкт сокета в закритий стан, фактично не закриваючи базовий "
"файловий дескриптор. Файловий дескриптор повертається, і його можна повторно "
"використовувати для інших цілей."

msgid "Duplicate the socket."
msgstr "Дублюйте розетку."

msgid ""
"Return the socket's file descriptor (a small integer), or -1 on failure. "
"This is useful with :func:`select.select`."
msgstr ""
"Повертає дескриптор файлу сокета (мале ціле число) або -1 у разі помилки. Це "
"корисно з :func:`select.select`."

msgid ""
"Under Windows the small integer returned by this method cannot be used where "
"a file descriptor can be used (such as :func:`os.fdopen`).  Unix does not "
"have this limitation."
msgstr ""
"Під Windows мале ціле число, яке повертає цей метод, не можна "
"використовувати там, де можна використовувати дескриптор файлу (наприклад, :"
"func:`os.fdopen`). Unix не має цього обмеження."

msgid ""
"Get the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle: ``True`` if the socket can be inherited in "
"child processes, ``False`` if it cannot."
msgstr ""
"Отримайте :ref:`inheritable flag <fd_inheritance>` дескриптора файлу сокета "
"або дескриптора сокета: ``True``, якщо сокет можна успадкувати в дочірніх "
"процесах, ``False``, якщо це неможливо."

msgid ""
"Return the remote address to which the socket is connected.  This is useful "
"to find out the port number of a remote IPv4/v6 socket, for instance. (The "
"format of the address returned depends on the address family --- see "
"above.)  On some systems this function is not supported."
msgstr ""
"Повертає віддалену адресу, до якої підключений сокет. Це корисно, наприклад, "
"щоб дізнатися номер порту віддаленого сокета IPv4/v6. (Формат адреси, що "
"повертається, залежить від родини адрес --- див. вище.) У деяких системах ця "
"функція не підтримується."

msgid ""
"Return the socket's own address.  This is useful to find out the port number "
"of an IPv4/v6 socket, for instance. (The format of the address returned "
"depends on the address family --- see above.)"
msgstr ""
"Повернути власну адресу сокета. Це корисно, наприклад, щоб дізнатися номер "
"порту сокета IPv4/v6. (Формат адреси, що повертається, залежить від "
"сімейства адрес --- див. вище.)"

msgid ""
"Return the value of the given socket option (see the Unix man page :manpage:"
"`getsockopt(2)`).  The needed symbolic constants (:const:`SO_\\*` etc.) are "
"defined in this module.  If *buflen* is absent, an integer option is assumed "
"and its integer value is returned by the function.  If *buflen* is present, "
"it specifies the maximum length of the buffer used to receive the option in, "
"and this buffer is returned as a bytes object.  It is up to the caller to "
"decode the contents of the buffer (see the optional built-in module :mod:"
"`struct` for a way to decode C structures encoded as byte strings)."
msgstr ""
"Повертає значення вказаного параметра сокета (див. сторінку довідки Unix :"
"manpage:`getsockopt(2)`). Необхідні символічні константи (:const:`SO_\\*` "
"тощо) визначені в цьому модулі. Якщо *buflen* відсутній, передбачається "
"цілочисельний параметр, і функція повертає його ціле значення. Якщо "
"присутній *buflen*, він визначає максимальну довжину буфера, який "
"використовується для отримання опції, і цей буфер повертається як об’єкт "
"bytes. Вміст буфера повинен розшифровувати той, хто викликає (перегляньте "
"додатковий вбудований модуль :mod:`struct`, щоб дізнатися про спосіб "
"декодування структур C, закодованих як рядки байтів)."

msgid ""
"Return ``True`` if socket is in blocking mode, ``False`` if in non-blocking."
msgstr ""
"Повертає ``True``, якщо сокет знаходиться в режимі блокування, ``False``, "
"якщо він не блокується."

msgid "This is equivalent to checking ``socket.gettimeout() == 0``."
msgstr "Це еквівалентно перевірці ``socket.gettimeout() == 0``."

msgid ""
"Return the timeout in seconds (float) associated with socket operations, or "
"``None`` if no timeout is set.  This reflects the last call to :meth:"
"`setblocking` or :meth:`settimeout`."
msgstr ""
"Повертає тайм-аут у секундах (float), пов’язаний з операціями сокета, або "
"``None``, якщо тайм-аут не встановлено. Це відображає останній виклик :meth:"
"`setblocking` або :meth:`settimeout`."

msgid "platform"
msgstr "платформа"

msgid "Windows"
msgstr "вікна"

msgid ""
"The :meth:`ioctl` method is a limited interface to the WSAIoctl system "
"interface.  Please refer to the `Win32 documentation <https://msdn.microsoft."
"com/en-us/library/ms741621%28VS.85%29.aspx>`_ for more information."
msgstr ""
"Метод :meth:`ioctl` є обмеженим інтерфейсом системного інтерфейсу WSAIoctl. "
"Будь ласка, зверніться до `документації Win32 <https://msdn.microsoft.com/en-"
"us/library/ms741621%28VS.85%29.aspx>`_ для отримання додаткової інформації."

msgid ""
"On other platforms, the generic :func:`fcntl.fcntl` and :func:`fcntl.ioctl` "
"functions may be used; they accept a socket object as their first argument."
msgstr ""
"На інших платформах можна використовувати загальні функції :func:`fcntl."
"fcntl` і :func:`fcntl.ioctl`; вони приймають об'єкт сокета як свій перший "
"аргумент."

msgid ""
"Currently only the following control codes are supported: ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS``, and ``SIO_LOOPBACK_FAST_PATH``."
msgstr ""
"Наразі підтримуються лише такі керуючі коди: ``SIO_RCVALL``, "
"``SIO_KEEPALIVE_VALS`` і ``SIO_LOOPBACK_FAST_PATH``."

msgid ""
"Enable a server to accept connections.  If *backlog* is specified, it must "
"be at least 0 (if it is lower, it is set to 0); it specifies the number of "
"unaccepted connections that the system will allow before refusing new "
"connections. If not specified, a default reasonable value is chosen."
msgstr ""
"Увімкніть сервер для прийняття підключень. Якщо вказано *backlog*, воно має "
"бути принаймні 0 (якщо менше, то встановлюється на 0); він визначає "
"кількість неприйнятих підключень, які система дозволить перед тим, як "
"відхилити нові підключення. Якщо не вказано, вибирається розумне значення за "
"умовчанням."

msgid "The *backlog* parameter is now optional."
msgstr "Параметр *backlog* тепер необов’язковий."

msgid ""
"Return a :term:`file object` associated with the socket.  The exact returned "
"type depends on the arguments given to :meth:`makefile`.  These arguments "
"are interpreted the same way as by the built-in :func:`open` function, "
"except the only supported *mode* values are ``'r'`` (default), ``'w'`` and "
"``'b'``."
msgstr ""
"Повертає :term:`file object`, пов’язаний із сокетом. Точний тип, що "
"повертається, залежить від аргументів, наданих :meth:`makefile`. Ці "
"аргументи інтерпретуються так само, як і вбудована функція :func:`open`, за "
"винятком підтримуваних тільки значень *mode*: ``'r'`` (за замовчуванням), "
"``'w'`` і ``'b'``."

msgid ""
"The socket must be in blocking mode; it can have a timeout, but the file "
"object's internal buffer may end up in an inconsistent state if a timeout "
"occurs."
msgstr ""
"Розетка повинна бути в режимі блокування; він може мати тайм-аут, але "
"внутрішній буфер файлового об’єкта може опинитися в неузгодженому стані, "
"якщо відбудеться тайм-аут."

msgid ""
"Closing the file object returned by :meth:`makefile` won't close the "
"original socket unless all other file objects have been closed and :meth:"
"`socket.close` has been called on the socket object."
msgstr ""
"Закриття файлового об’єкта, який повертає :meth:`makefile`, не закриє "
"оригінальний сокет, якщо всі інші файлові об’єкти не закриті та :meth:"
"`socket.close` не викликано для об’єкта сокета."

msgid ""
"On Windows, the file-like object created by :meth:`makefile` cannot be used "
"where a file object with a file descriptor is expected, such as the stream "
"arguments of :meth:`subprocess.Popen`."
msgstr ""
"У Windows файлоподібний об’єкт, створений :meth:`makefile`, не можна "
"використовувати там, де очікується файловий об’єкт із дескриптором файлу, "
"наприклад аргументи потоку :meth:`subprocess.Popen`."

msgid ""
"Receive data from the socket.  The return value is a bytes object "
"representing the data received.  The maximum amount of data to be received "
"at once is specified by *bufsize*.  See the Unix manual page :manpage:"
"`recv(2)` for the meaning of the optional argument *flags*; it defaults to "
"zero."
msgstr ""
"Отримувати дані з розетки. Повернене значення — це об’єкт байтів, що "
"представляє отримані дані. Максимальний обсяг даних, які потрібно отримати "
"одночасно, визначається *bufsize*. Перегляньте сторінку посібника Unix :"
"manpage:`recv(2)` для визначення значення необов’язкового аргументу *flags*; "
"за замовчуванням він дорівнює нулю."

msgid ""
"For best match with hardware and network realities, the value of  *bufsize* "
"should be a relatively small power of 2, for example, 4096."
msgstr ""
"Для найкращої відповідності апаратному забезпеченню та мережевим реаліям "
"значення *bufsize* має бути відносно малим ступенем 2, наприклад, 4096."

msgid ""
"Receive data from the socket.  The return value is a pair ``(bytes, "
"address)`` where *bytes* is a bytes object representing the data received "
"and *address* is the address of the socket sending the data.  See the Unix "
"manual page :manpage:`recv(2)` for the meaning of the optional argument "
"*flags*; it defaults to zero. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"Отримувати дані з розетки. Поверненим значенням є пара ``(байти, адреса)``, "
"де *байт* — об’єкт байтів, що представляє отримані дані, а *адреса* — адреса "
"сокета, який надсилає дані. Перегляньте сторінку посібника Unix :manpage:"
"`recv(2)` для визначення значення необов’язкового аргументу *flags*; за "
"замовчуванням він дорівнює нулю. (Формат *адреси* залежить від групи адрес "
"--- див. вище.)"

msgid ""
"For multicast IPv6 address, first item of *address* does not contain "
"``%scope_id`` part anymore. In order to get full IPv6 address use :func:"
"`getnameinfo`."
msgstr ""
"Для багатоадресної адреси IPv6 перший елемент *address* більше не містить "
"частини ``%scope_id``. Щоб отримати повну адресу IPv6, використовуйте :func:"
"`getnameinfo`."

msgid ""
"Receive normal data (up to *bufsize* bytes) and ancillary data from the "
"socket.  The *ancbufsize* argument sets the size in bytes of the internal "
"buffer used to receive the ancillary data; it defaults to 0, meaning that no "
"ancillary data will be received.  Appropriate buffer sizes for ancillary "
"data can be calculated using :func:`CMSG_SPACE` or :func:`CMSG_LEN`, and "
"items which do not fit into the buffer might be truncated or discarded.  The "
"*flags* argument defaults to 0 and has the same meaning as for :meth:`recv`."
msgstr ""
"Отримувати звичайні дані (до *bufsize* байтів) і допоміжні дані з сокета. "
"Аргумент *ancbufsize* встановлює розмір у байтах внутрішнього буфера, який "
"використовується для отримання допоміжних даних; за замовчуванням він "
"дорівнює 0, що означає, що допоміжні дані не будуть отримані. Відповідні "
"розміри буферів для допоміжних даних можна обчислити за допомогою :func:"
"`CMSG_SPACE` або :func:`CMSG_LEN`, а елементи, які не вміщаються в буфер, "
"можуть бути скорочені або відкинуті. Аргумент *flags* за умовчанням дорівнює "
"0 і має те саме значення, що й для :meth:`recv`."

msgid ""
"The return value is a 4-tuple: ``(data, ancdata, msg_flags, address)``.  The "
"*data* item is a :class:`bytes` object holding the non-ancillary data "
"received.  The *ancdata* item is a list of zero or more tuples "
"``(cmsg_level, cmsg_type, cmsg_data)`` representing the ancillary data "
"(control messages) received: *cmsg_level* and *cmsg_type* are integers "
"specifying the protocol level and protocol-specific type respectively, and "
"*cmsg_data* is a :class:`bytes` object holding the associated data.  The "
"*msg_flags* item is the bitwise OR of various flags indicating conditions on "
"the received message; see your system documentation for details. If the "
"receiving socket is unconnected, *address* is the address of the sending "
"socket, if available; otherwise, its value is unspecified."
msgstr ""
"Повернене значення – це 4-кортеж: ``(data, ancdata, msg_flags, address)``. "
"Елемент *data* — це об’єкт :class:`bytes`, що містить отримані непобічні "
"дані. Елемент *ancdata* — це список із нуля або більше кортежів "
"``(cmsg_level, cmsg_type, cmsg_data)``, що представляють отримані допоміжні "
"дані (керуючі повідомлення): *cmsg_level* і *cmsg_type* — цілі числа, що "
"визначають рівень протоколу та протокол- певного типу відповідно, і "
"*cmsg_data* є об’єктом :class:`bytes`, що містить пов’язані дані. Елемент "
"*msg_flags* — це порозрядне АБО різних прапорів, що вказують на умови "
"отриманого повідомлення; подробиці дивіться в системній документації. Якщо "
"сокет-одержувач не підключений, *адреса* є адресою сокета-відправника, якщо "
"він доступний; інакше його значення не вказано."

msgid ""
"On some systems, :meth:`sendmsg` and :meth:`recvmsg` can be used to pass "
"file descriptors between processes over an :const:`AF_UNIX` socket.  When "
"this facility is used (it is often restricted to :const:`SOCK_STREAM` "
"sockets), :meth:`recvmsg` will return, in its ancillary data, items of the "
"form ``(socket.SOL_SOCKET, socket.SCM_RIGHTS, fds)``, where *fds* is a :"
"class:`bytes` object representing the new file descriptors as a binary array "
"of the native C :c:expr:`int` type.  If :meth:`recvmsg` raises an exception "
"after the system call returns, it will first attempt to close any file "
"descriptors received via this mechanism."
msgstr ""

msgid ""
"Some systems do not indicate the truncated length of ancillary data items "
"which have been only partially received.  If an item appears to extend "
"beyond the end of the buffer, :meth:`recvmsg` will issue a :exc:"
"`RuntimeWarning`, and will return the part of it which is inside the buffer "
"provided it has not been truncated before the start of its associated data."
msgstr ""
"Деякі системи не вказують скорочену довжину елементів допоміжних даних, які "
"були отримані лише частково. Якщо елемент виходить за кінець буфера, :meth:"
"`recvmsg` видає :exc:`RuntimeWarning` і повертає його частину, яка "
"знаходиться всередині буфера, за умови, що вона не була скорочена до початку "
"своїх пов’язаних даних."

msgid ""
"On systems which support the :const:`SCM_RIGHTS` mechanism, the following "
"function will receive up to *maxfds* file descriptors, returning the message "
"data and a list containing the descriptors (while ignoring unexpected "
"conditions such as unrelated control messages being received).  See also :"
"meth:`sendmsg`. ::"
msgstr ""
"У системах, які підтримують механізм :const:`SCM_RIGHTS`, наступна функція "
"отримає до *maxfds* файлових дескрипторів, повертаючи дані повідомлення та "
"список, що містить дескриптори (ігноруючи неочікувані умови, такі як "
"отримання непов’язаних керуючих повідомлень). Дивіться також :meth:"
"`sendmsg`. ::"

msgid ""
"Receive normal data and ancillary data from the socket, behaving as :meth:"
"`recvmsg` would, but scatter the non-ancillary data into a series of buffers "
"instead of returning a new bytes object.  The *buffers* argument must be an "
"iterable of objects that export writable buffers (e.g. :class:`bytearray` "
"objects); these will be filled with successive chunks of the non-ancillary "
"data until it has all been written or there are no more buffers.  The "
"operating system may set a limit (:func:`~os.sysconf` value ``SC_IOV_MAX``) "
"on the number of buffers that can be used.  The *ancbufsize* and *flags* "
"arguments have the same meaning as for :meth:`recvmsg`."
msgstr ""
"Отримувати звичайні дані та допоміжні дані з сокета, поводячись так, як це "
"зробив би :meth:`recvmsg`, але розкидати не допоміжні дані в ряд буферів "
"замість повернення нового об’єкта bytes. Аргумент *buffers* має бути "
"ітерованим об’єктами, які експортують записувані буфери (наприклад, об’єкти :"
"class:`bytearray`); вони будуть заповнені послідовними фрагментами "
"непоміжних даних, доки вони не будуть записані або більше не залишиться "
"буферів. Операційна система може встановити обмеження (:func:`~os.sysconf` "
"значення ``SC_IOV_MAX``) на кількість буферів, які можна використовувати. "
"Аргументи *ancbufsize* і *flags* мають те саме значення, що й для :meth:"
"`recvmsg`."

msgid ""
"The return value is a 4-tuple: ``(nbytes, ancdata, msg_flags, address)``, "
"where *nbytes* is the total number of bytes of non-ancillary data written "
"into the buffers, and *ancdata*, *msg_flags* and *address* are the same as "
"for :meth:`recvmsg`."
msgstr ""
"Повернене значення — це 4-кортеж: ``(nbytes, ancdata, msg_flags, address)``, "
"де *nbytes* — загальна кількість байтів непоміжних даних, записаних у "
"буфери, а *ancdata*, *msg_flags* і *адреса* такі самі, як і для :meth:"
"`recvmsg`."

msgid "Example::"
msgstr "Приклад::"

msgid ""
"Receive data from the socket, writing it into *buffer* instead of creating a "
"new bytestring.  The return value is a pair ``(nbytes, address)`` where "
"*nbytes* is the number of bytes received and *address* is the address of the "
"socket sending the data.  See the Unix manual page :manpage:`recv(2)` for "
"the meaning of the optional argument *flags*; it defaults to zero.  (The "
"format of *address* depends on the address family --- see above.)"
msgstr ""
"Отримувати дані з сокета, записуючи їх у *буфер* замість створення нового "
"байтового рядка. Поверненим значенням є пара ``(nbytes, address)``, де "
"*nbytes* — це кількість отриманих байтів, а *address* — це адреса сокета, "
"який надсилає дані. Перегляньте сторінку посібника Unix :manpage:`recv(2)` "
"для визначення значення необов’язкового аргументу *flags*; за замовчуванням "
"він дорівнює нулю. (Формат *адреси* залежить від групи адрес --- див. вище.)"

msgid ""
"Receive up to *nbytes* bytes from the socket, storing the data into a buffer "
"rather than creating a new bytestring.  If *nbytes* is not specified (or 0), "
"receive up to the size available in the given buffer.  Returns the number of "
"bytes received.  See the Unix manual page :manpage:`recv(2)` for the meaning "
"of the optional argument *flags*; it defaults to zero."
msgstr ""
"Отримайте до *nbytes* байт із сокета, зберігаючи дані в буфері, а не "
"створюючи новий рядок байтів. Якщо *nbytes* не вказано (або 0), отримати до "
"розміру, доступного в даному буфері. Повертає кількість отриманих байтів. "
"Перегляньте сторінку посібника Unix :manpage:`recv(2)` для визначення "
"значення необов’язкового аргументу *flags*; за замовчуванням він дорівнює "
"нулю."

msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Returns the number of bytes sent. Applications are responsible for "
"checking that all data has been sent; if only some of the data was "
"transmitted, the application needs to attempt delivery of the remaining "
"data. For further information on this topic, consult the :ref:`socket-howto`."
msgstr ""
"Надіслати дані в сокет. Розетка повинна бути підключена до віддаленої "
"розетки. Необов’язковий аргумент *flags* має те саме значення, що й для :"
"meth:`recv` вище. Повертає кількість надісланих байтів. Додатки відповідають "
"за перевірку того, що всі дані були надіслані; якщо було передано лише "
"частину даних, програма повинна спробувати доставити решту даних. Для "
"отримання додаткової інформації з цієї теми зверніться до :ref:`socket-"
"howto`."

msgid ""
"Send data to the socket.  The socket must be connected to a remote socket.  "
"The optional *flags* argument has the same meaning as for :meth:`recv` "
"above. Unlike :meth:`send`, this method continues to send data from *bytes* "
"until either all data has been sent or an error occurs.  ``None`` is "
"returned on success.  On error, an exception is raised, and there is no way "
"to determine how much data, if any, was successfully sent."
msgstr ""
"Надіслати дані в сокет. Розетка повинна бути підключена до віддаленої "
"розетки. Необов’язковий аргумент *flags* має те саме значення, що й для :"
"meth:`recv` вище. На відміну від :meth:`send`, цей метод продовжує надсилати "
"дані з *байтів*, доки не буде надіслано всі дані або не станеться помилка. "
"``None`` повертається в разі успіху. У разі помилки виникає виняток, і немає "
"способу визначити, скільки даних було успішно надіслано, якщо такі були."

msgid ""
"The socket timeout is no more reset each time data is sent successfully. The "
"socket timeout is now the maximum total duration to send all data."
msgstr ""
"Час очікування сокета більше не скидається щоразу, коли дані надсилаються "
"успішно. Час очікування сокета тепер є максимальною загальною тривалістю "
"надсилання всіх даних."

msgid ""
"Send data to the socket.  The socket should not be connected to a remote "
"socket, since the destination socket is specified by *address*.  The "
"optional *flags* argument has the same meaning as for :meth:`recv` above.  "
"Return the number of bytes sent. (The format of *address* depends on the "
"address family --- see above.)"
msgstr ""
"Надіслати дані в сокет. Сокет не слід підключати до віддаленого сокета, "
"оскільки сокет призначення вказується *адресою*. Необов’язковий аргумент "
"*flags* має те саме значення, що й для :meth:`recv` вище. Повертає кількість "
"надісланих байтів. (Формат *адреси* залежить від групи адрес --- див. вище.)"

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendto`` with arguments "
"``self``, ``address``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``socket.sendto`` з аргументами "
"``self``, ``address``."

msgid ""
"Send normal and ancillary data to the socket, gathering the non-ancillary "
"data from a series of buffers and concatenating it into a single message.  "
"The *buffers* argument specifies the non-ancillary data as an iterable of :"
"term:`bytes-like objects <bytes-like object>` (e.g. :class:`bytes` objects); "
"the operating system may set a limit (:func:`~os.sysconf` value "
"``SC_IOV_MAX``) on the number of buffers that can be used.  The *ancdata* "
"argument specifies the ancillary data (control messages) as an iterable of "
"zero or more tuples ``(cmsg_level, cmsg_type, cmsg_data)``, where "
"*cmsg_level* and *cmsg_type* are integers specifying the protocol level and "
"protocol-specific type respectively, and *cmsg_data* is a bytes-like object "
"holding the associated data.  Note that some systems (in particular, systems "
"without :func:`CMSG_SPACE`) might support sending only one control message "
"per call.  The *flags* argument defaults to 0 and has the same meaning as "
"for :meth:`send`.  If *address* is supplied and not ``None``, it sets a "
"destination address for the message.  The return value is the number of "
"bytes of non-ancillary data sent."
msgstr ""
"Надсилайте звичайні та допоміжні дані в сокет, збираючи недопоміжні дані з "
"ряду буферів і об’єднуючи їх в одне повідомлення. Аргумент *buffers* вказує "
"на не допоміжні дані як ітерацію :term:`bytes-подібних об’єктів <bytes-like "
"object>` (наприклад, :class:`bytes` об’єктів); операційна система може "
"встановити обмеження (:func:`~os.sysconf` значення ``SC_IOV_MAX``) на "
"кількість буферів, які можна використовувати. Аргумент *ancdata* визначає "
"допоміжні дані (керуючі повідомлення) як ітерацію з нуля або більше кортежів "
"``(cmsg_level, cmsg_type, cmsg_data)``, де *cmsg_level* і *cmsg_type* є "
"цілими числами, що визначають рівень протоколу та протокол- певного типу "
"відповідно, а *cmsg_data* — це байтиподібний об’єкт, що містить пов’язані "
"дані. Зверніть увагу, що деякі системи (зокрема, системи без :func:"
"`CMSG_SPACE`) можуть підтримувати надсилання лише одного керуючого "
"повідомлення на виклик. Аргумент *flags* за умовчанням дорівнює 0 і має те "
"саме значення, що й для :meth:`send`. Якщо вказано *address*, а не ``None``, "
"це встановлює адресу призначення для повідомлення. Повернене значення — це "
"кількість байтів надісланих непоміжних даних."

msgid ""
"The following function sends the list of file descriptors *fds* over an :"
"const:`AF_UNIX` socket, on systems which support the :const:`SCM_RIGHTS` "
"mechanism.  See also :meth:`recvmsg`. ::"
msgstr ""
"Наступна функція надсилає список дескрипторів файлів *fds* через сокет :"
"const:`AF_UNIX` у системах, які підтримують механізм :const:`SCM_RIGHTS`. "
"Дивіться також :meth:`recvmsg`. ::"

msgid ":ref:`Availability <availability>`: Unix, not WASI."
msgstr ""

msgid ""
"Raises an :ref:`auditing event <auditing>` ``socket.sendmsg`` with arguments "
"``self``, ``address``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``socket.sendmsg`` з аргументами "
"``self``, ``address``."

msgid ""
"Specialized version of :meth:`~socket.sendmsg` for :const:`AF_ALG` socket. "
"Set mode, IV, AEAD associated data length and flags for :const:`AF_ALG` "
"socket."
msgstr ""
"Спеціалізована версія :meth:`~socket.sendmsg` для :const:`AF_ALG` сокета. "
"Установіть довжину пов’язаних даних режиму, IV, AEAD і прапорці для сокета :"
"const:`AF_ALG`."

msgid ""
"Send a file until EOF is reached by using high-performance :mod:`os."
"sendfile` and return the total number of bytes which were sent. *file* must "
"be a regular file object opened in binary mode. If :mod:`os.sendfile` is not "
"available (e.g. Windows) or *file* is not a regular file :meth:`send` will "
"be used instead. *offset* tells from where to start reading the file. If "
"specified, *count* is the total number of bytes to transmit as opposed to "
"sending the file until EOF is reached. File position is updated on return or "
"also in case of error in which case :meth:`file.tell() <io.IOBase.tell>` can "
"be used to figure out the number of bytes which were sent. The socket must "
"be of :const:`SOCK_STREAM` type. Non-blocking sockets are not supported."
msgstr ""
"Надсилайте файл до досягнення EOF за допомогою високопродуктивного :mod:`os."
"sendfile` і повертайте загальну кількість надісланих байтів. *file* має бути "
"звичайним файловим об’єктом, відкритим у двійковому режимі. Якщо :mod:`os."
"sendfile` недоступний (наприклад, Windows) або *file* не є звичайним файлом, "
"замість нього буде використано :meth:`send`. *offset* вказує, звідки почати "
"читання файлу. Якщо вказано, *count* — це загальна кількість байтів для "
"передачі, а не надсилання файлу до досягнення EOF. Позиція файлу оновлюється "
"при поверненні або також у разі помилки, у цьому випадку :meth:`file.tell() "
"<io.IOBase.tell>` можна використовувати для визначення кількості надісланих "
"байтів. Сокет має бути типу :const:`SOCK_STREAM`. Неблокуючі сокети не "
"підтримуються."

msgid ""
"Set the :ref:`inheritable flag <fd_inheritance>` of the socket's file "
"descriptor or socket's handle."
msgstr ""
"Установіть :ref:`inheritable flag <fd_inheritance>` дескриптора файлу сокета "
"або дескриптора сокета."

msgid ""
"Set blocking or non-blocking mode of the socket: if *flag* is false, the "
"socket is set to non-blocking, else to blocking mode."
msgstr ""
"Встановіть блокуючий або неблокуючий режим сокета: якщо *flag* має значення "
"false, сокет встановлено в неблокуючий режим, інакше в режим блокування."

msgid ""
"This method is a shorthand for certain :meth:`~socket.settimeout` calls:"
msgstr "Цей метод є скороченням певних викликів :meth:`~socket.settimeout`:"

msgid "``sock.setblocking(True)`` is equivalent to ``sock.settimeout(None)``"
msgstr "``sock.setblocking(True)`` еквівалентно ``sock.settimeout(None)``"

msgid "``sock.setblocking(False)`` is equivalent to ``sock.settimeout(0.0)``"
msgstr "``sock.setblocking(False)`` еквівалентний ``sock.settimeout(0.0)``"

msgid ""
"The method no longer applies :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""
"Метод більше не застосовує прапор :const:`SOCK_NONBLOCK` до :attr:`socket."
"type`."

msgid ""
"Set a timeout on blocking socket operations.  The *value* argument can be a "
"nonnegative floating point number expressing seconds, or ``None``. If a non-"
"zero value is given, subsequent socket operations will raise a :exc:"
"`timeout` exception if the timeout period *value* has elapsed before the "
"operation has completed.  If zero is given, the socket is put in non-"
"blocking mode. If ``None`` is given, the socket is put in blocking mode."
msgstr ""
"Встановіть тайм-аут для блокування операцій сокетів. Аргументом *value* може "
"бути невід’ємне число з плаваючою комою, що виражає секунди, або ``None``. "
"Якщо задано ненульове значення, наступні операції з сокетом викличуть "
"виняток :exc:`timeout`, якщо період очікування *значення* минув до "
"завершення операції. Якщо вказано нуль, сокет переходить у неблокуючий "
"режим. Якщо задано ``None``, сокет переходить у режим блокування."

msgid ""
"For further information, please consult the :ref:`notes on socket timeouts "
"<socket-timeouts>`."
msgstr ""
"Щоб отримати додаткову інформацію, зверніться до :ref:`приміток щодо тайм-"
"аутів сокетів <socket-timeouts>`."

msgid ""
"The method no longer toggles :const:`SOCK_NONBLOCK` flag on :attr:`socket."
"type`."
msgstr ""
"Метод більше не вмикає прапор :const:`SOCK_NONBLOCK` на :attr:`socket.type`."

msgid ""
"Set the value of the given socket option (see the Unix manual page :manpage:"
"`setsockopt(2)`).  The needed symbolic constants are defined in the :mod:"
"`socket` module (:const:`SO_\\*` etc.).  The value can be an integer, "
"``None`` or a :term:`bytes-like object` representing a buffer. In the later "
"case it is up to the caller to ensure that the bytestring contains the "
"proper bits (see the optional built-in module :mod:`struct` for a way to "
"encode C structures as bytestrings). When *value* is set to ``None``, "
"*optlen* argument is required. It's equivalent to call :c:func:`setsockopt` "
"C function with ``optval=NULL`` and ``optlen=optlen``."
msgstr ""
"Встановіть значення даного параметра сокета (дивіться сторінку посібника "
"Unix :manpage:`setsockopt(2)`). Необхідні символічні константи визначені в "
"модулі :mod:`socket` (:const:`SO_\\*` тощо). Значення може бути цілим "
"числом, ``None`` або :term:`bytes-like object`, що представляє буфер. У "
"останньому випадку абонент повинен переконатися, що байтовий рядок містить "
"правильні біти (дивіться необов’язковий вбудований модуль :mod:`struct` для "
"того, щоб закодувати структури C як байтові рядки). Якщо *value* має "
"значення ``None``, аргумент *optlen* є обов’язковим. Це еквівалентно "
"виклику :c:func:`setsockopt` функції C з ``optval=NULL`` і ``optlen=optlen``."

msgid "setsockopt(level, optname, None, optlen: int) form added."
msgstr "Додано форму setsockopt(level, optname, None, optlen: int)."

msgid ""
"Shut down one or both halves of the connection.  If *how* is :const:"
"`SHUT_RD`, further receives are disallowed.  If *how* is :const:`SHUT_WR`, "
"further sends are disallowed.  If *how* is :const:`SHUT_RDWR`, further sends "
"and receives are disallowed."
msgstr ""
"Вимкніть одну або обидві половини з’єднання. Якщо *how* :const:`SHUT_RD`, "
"подальші прийоми заборонені. Якщо *how* :const:`SHUT_WR`, подальші "
"надсилання заборонені. Якщо *how* :const:`SHUT_RDWR`, подальше надсилання та "
"отримання заборонено."

msgid ""
"Duplicate a socket and prepare it for sharing with a target process.  The "
"target process must be provided with *process_id*.  The resulting bytes "
"object can then be passed to the target process using some form of "
"interprocess communication and the socket can be recreated there using :func:"
"`fromshare`. Once this method has been called, it is safe to close the "
"socket since the operating system has already duplicated it for the target "
"process."
msgstr ""
"Скопіюйте сокет і підготуйте його для спільного використання з цільовим "
"процесом. Цільовому процесу має бути надано *process_id*. Отриманий об’єкт "
"bytes потім можна передати цільовому процесу за допомогою певної форми "
"міжпроцесного зв’язку, а сокет можна відтворити там за допомогою :func:"
"`fromshare`. Після виклику цього методу можна безпечно закрити сокет, "
"оскільки операційна система вже скопіювала його для цільового процесу."

msgid ""
"Note that there are no methods :meth:`read` or :meth:`write`; use :meth:"
"`~socket.recv` and :meth:`~socket.send` without *flags* argument instead."
msgstr ""
"Зверніть увагу, що немає методів :meth:`read` або :meth:`write`; замість "
"цього використовуйте :meth:`~socket.recv` і :meth:`~socket.send` без "
"аргументу *flags*."

msgid ""
"Socket objects also have these (read-only) attributes that correspond to the "
"values given to the :class:`~socket.socket` constructor."
msgstr ""
"Об’єкти Socket також мають ці атрибути (лише для читання), які відповідають "
"значенням, наданим конструктору :class:`~socket.socket`."

msgid "The socket family."
msgstr "Сімейство розеток."

msgid "The socket type."
msgstr "Тип розетки."

msgid "The socket protocol."
msgstr "Протокол сокета."

msgid "Notes on socket timeouts"
msgstr "Примітки щодо тайм-аутів сокетів"

msgid ""
"A socket object can be in one of three modes: blocking, non-blocking, or "
"timeout.  Sockets are by default always created in blocking mode, but this "
"can be changed by calling :func:`setdefaulttimeout`."
msgstr ""
"Об’єкт сокета може бути в одному з трьох режимів: блокування, неблокування "
"або час очікування. За умовчанням сокети завжди створюються в режимі "
"блокування, але це можна змінити, викликавши :func:`setdefaulttimeout`."

msgid ""
"In *blocking mode*, operations block until complete or the system returns an "
"error (such as connection timed out)."
msgstr ""
"У *режимі блокування* операції блокуються до завершення або доки система не "
"поверне повідомлення про помилку (наприклад, час очікування підключення "
"закінчився)."

msgid ""
"In *non-blocking mode*, operations fail (with an error that is unfortunately "
"system-dependent) if they cannot be completed immediately: functions from "
"the :mod:`select` can be used to know when and whether a socket is available "
"for reading or writing."
msgstr ""
"У *неблокуючому режимі* операції не вдаються (з помилкою, яка, на жаль, "
"залежить від системи), якщо їх не можна завершити негайно: функції з :mod:"
"`select` можна використовувати, щоб дізнатися, коли та чи доступний сокет "
"для читання або письмо."

msgid ""
"In *timeout mode*, operations fail if they cannot be completed within the "
"timeout specified for the socket (they raise a :exc:`timeout` exception) or "
"if the system returns an error."
msgstr ""
"У *режимі тайм-ауту* операції завершуються невдало, якщо їх не можна "
"завершити протягом тайм-ауту, указаного для сокета (вони викликають виняток :"
"exc:`timeout`) або якщо система повертає помилку."

msgid ""
"At the operating system level, sockets in *timeout mode* are internally set "
"in non-blocking mode.  Also, the blocking and timeout modes are shared "
"between file descriptors and socket objects that refer to the same network "
"endpoint. This implementation detail can have visible consequences if e.g. "
"you decide to use the :meth:`~socket.fileno()` of a socket."
msgstr ""
"На рівні операційної системи сокети в *режимі тайм-ауту* внутрішньо "
"налаштовані на неблокуючий режим. Крім того, режими блокування та тайм-ауту "
"розподіляються між файловими дескрипторами та об’єктами сокетів, які "
"посилаються на ту саму кінцеву точку мережі. Ця деталь впровадження може "
"мати видимі наслідки, якщо, напр. ви вирішили використовувати :meth:`~socket."
"fileno()` сокета."

msgid "Timeouts and the ``connect`` method"
msgstr "Час очікування та метод ``connect``"

msgid ""
"The :meth:`~socket.connect` operation is also subject to the timeout "
"setting, and in general it is recommended to call :meth:`~socket.settimeout` "
"before calling :meth:`~socket.connect` or pass a timeout parameter to :meth:"
"`create_connection`.  However, the system network stack may also return a "
"connection timeout error of its own regardless of any Python socket timeout "
"setting."
msgstr ""
"Операція :meth:`~socket.connect` також залежить від параметра тайм-ауту, і "
"загалом рекомендується викликати :meth:`~socket.settimeout` перед викликом :"
"meth:`~socket.connect` або передати параметр часу очікування для :meth:"
"`create_connection`. Однак системний мережевий стек також може повертати "
"власну помилку очікування підключення незалежно від будь-якого параметра "
"часу очікування сокета Python."

msgid "Timeouts and the ``accept`` method"
msgstr "Час очікування та метод ``accept``"

msgid ""
"If :func:`getdefaulttimeout` is not :const:`None`, sockets returned by the :"
"meth:`~socket.accept` method inherit that timeout.  Otherwise, the behaviour "
"depends on settings of the listening socket:"
msgstr ""
"Якщо :func:`getdefaulttimeout` не :const:`None`, сокети, повернуті методом :"
"meth:`~socket.accept`, успадковують цей час очікування. В іншому випадку "
"поведінка залежить від налаштувань прослуховувального сокета:"

msgid ""
"if the listening socket is in *blocking mode* or in *timeout mode*, the "
"socket returned by :meth:`~socket.accept` is in *blocking mode*;"
msgstr ""
"якщо прослуховувальний сокет знаходиться в *режимі блокування* або в *режимі "
"очікування*, сокет, який повертає :meth:`~socket.accept`, знаходиться в "
"*режимі блокування*;"

msgid ""
"if the listening socket is in *non-blocking mode*, whether the socket "
"returned by :meth:`~socket.accept` is in blocking or non-blocking mode is "
"operating system-dependent.  If you want to ensure cross-platform behaviour, "
"it is recommended you manually override this setting."
msgstr ""
"якщо сокет, що прослуховує, знаходиться в *неблокуючому режимі*, чи є сокет, "
"повернутий :meth:`~socket.accept` у блокуючому чи неблокуючому режимі, "
"залежить від операційної системи. Якщо ви хочете забезпечити кросплатформну "
"поведінку, радимо вручну змінити це налаштування."

msgid "Example"
msgstr "приклад"

msgid ""
"Here are four minimal example programs using the TCP/IP protocol: a server "
"that echoes all data that it receives back (servicing only one client), and "
"a client using it.  Note that a server must perform the sequence :func:`."
"socket`, :meth:`~socket.bind`, :meth:`~socket.listen`, :meth:`~socket."
"accept` (possibly repeating the :meth:`~socket.accept` to service more than "
"one client), while a client only needs the sequence :func:`.socket`, :meth:"
"`~socket.connect`.  Also note that the server does not :meth:`~socket."
"sendall`/:meth:`~socket.recv` on the socket it is listening on but on the "
"new socket returned by :meth:`~socket.accept`."
msgstr ""
"Ось чотири мінімальні приклади програм, які використовують протокол TCP/IP: "
"сервер, який відтворює всі отримані дані (обслуговуючи лише одного клієнта), "
"і клієнт, який його використовує. Зауважте, що сервер повинен виконати "
"послідовність :func:`.socket`, :meth:`~socket.bind`, :meth:`~socket."
"listen`, :meth:`~socket.accept` (можливо, повторюючи :meth:`~socket.accept` "
"для обслуговування більш ніж одного клієнта), тоді як клієнту потрібна лише "
"послідовність :func:`.socket`, :meth:`~socket.connect`. Також зауважте, що "
"сервер не :meth:`~socket.sendall`/:meth:`~socket.recv` на сокет, який він "
"прослуховує, а на новий сокет, повернутий :meth:`~socket.accept`."

msgid "The first two examples support IPv4 only. ::"
msgstr "Перші два приклади підтримують лише IPv4. ::"

msgid ""
"The next two examples are identical to the above two, but support both IPv4 "
"and IPv6. The server side will listen to the first address family available "
"(it should listen to both instead). On most of IPv6-ready systems, IPv6 will "
"take precedence and the server may not accept IPv4 traffic. The client side "
"will try to connect to the all addresses returned as a result of the name "
"resolution, and sends traffic to the first one connected successfully. ::"
msgstr ""
"Наступні два приклади ідентичні наведеним вище, але підтримують як IPv4, так "
"і IPv6. Сторона сервера прослуховуватиме перше доступне сімейство адрес "
"(замість цього вона має прослуховувати обидва). У більшості систем із "
"підтримкою IPv6 IPv6 матиме пріоритет, і сервер може не приймати трафік "
"IPv4. Клієнтська сторона спробує підключитися до всіх адрес, отриманих у "
"результаті розпізнавання імен, і надсилає трафік на першу з успішно "
"підключених адрес. ::"

msgid ""
"The next example shows how to write a very simple network sniffer with raw "
"sockets on Windows. The example requires administrator privileges to modify "
"the interface::"
msgstr ""
"У наступному прикладі показано, як написати дуже простий мережевий сніфер із "
"необробленими сокетами у Windows. У прикладі потрібні права адміністратора, "
"щоб змінити інтерфейс:"

msgid ""
"The next example shows how to use the socket interface to communicate to a "
"CAN network using the raw socket protocol. To use CAN with the broadcast "
"manager protocol instead, open a socket with::"
msgstr ""
"У наступному прикладі показано, як використовувати інтерфейс сокета для "
"зв’язку з мережею CAN за допомогою необробленого протоколу сокета. Щоб "
"замість цього використовувати CAN із протоколом диспетчера трансляції, "
"відкрийте сокет за допомогою:"

msgid ""
"After binding (:const:`CAN_RAW`) or connecting (:const:`CAN_BCM`) the "
"socket, you can use the :meth:`socket.send`, and the :meth:`socket.recv` "
"operations (and their counterparts) on the socket object as usual."
msgstr ""
"Після зв’язування (:const:`CAN_RAW`) або підключення (:const:`CAN_BCM`) "
"сокета ви можете використовувати операції :meth:`socket.send` і :meth:"
"`socket.recv` (та їх аналоги) на об’єкті сокета, як зазвичай."

msgid "This last example might require special privileges::"
msgstr "Цей останній приклад може вимагати спеціальних привілеїв:"

msgid ""
"Running an example several times with too small delay between executions, "
"could lead to this error::"
msgstr ""
"Запуск прикладу кілька разів із занадто малою затримкою між виконаннями може "
"призвести до цієї помилки::"

msgid ""
"This is because the previous execution has left the socket in a "
"``TIME_WAIT`` state, and can't be immediately reused."
msgstr ""
"Це пов’язано з тим, що попереднє виконання залишило сокет у стані "
"``TIME_WAIT`` і не може бути негайно повторно використано."

msgid ""
"There is a :mod:`socket` flag to set, in order to prevent this, :data:"
"`socket.SO_REUSEADDR`::"
msgstr ""
"Існує прапорець :mod:`socket`, щоб запобігти цьому, :data:`socket."
"SO_REUSEADDR`::"

msgid ""
"the :data:`SO_REUSEADDR` flag tells the kernel to reuse a local socket in "
"``TIME_WAIT`` state, without waiting for its natural timeout to expire."
msgstr ""
"прапорець :data:`SO_REUSEADDR` повідомляє ядру повторно використовувати "
"локальний сокет у стані ``TIME_WAIT``, не чекаючи закінчення його природного "
"часу очікування."

msgid ""
"For an introduction to socket programming (in C), see the following papers:"
msgstr ""
"Для ознайомлення з програмуванням сокетів (на C) перегляньте такі документи:"

msgid ""
"*An Introductory 4.3BSD Interprocess Communication Tutorial*, by Stuart "
"Sechrest"
msgstr ""
"*Вступний навчальний посібник із взаємодії між процесами 4.3BSD*, Стюарт "
"Сехрест"

msgid ""
"*An Advanced 4.3BSD Interprocess Communication Tutorial*, by Samuel J.  "
"Leffler et al,"
msgstr ""
"*Навчальний посібник із розширеного міжпроцесного зв’язку 4.3BSD*, Семюел "
"Дж. Леффлер та інші,"

msgid ""
"both in the UNIX Programmer's Manual, Supplementary Documents 1 (sections "
"PS1:7 and PS1:8).  The platform-specific reference material for the various "
"socket-related system calls are also a valuable source of information on the "
"details of socket semantics.  For Unix, refer to the manual pages; for "
"Windows, see the WinSock (or Winsock 2) specification.  For IPv6-ready APIs, "
"readers may want to refer to :rfc:`3493` titled Basic Socket Interface "
"Extensions for IPv6."
msgstr ""
"обидва в Посібнику програміста UNIX, Додаткові документи 1 (розділи PS1:7 та "
"PS1:8). Довідковий матеріал для певної платформи для різноманітних системних "
"викликів, пов’язаних із сокетами, також є цінним джерелом інформації про "
"деталі семантики сокетів. Для Unix зверніться до сторінок посібника; для "
"Windows дивіться специфікацію WinSock (або Winsock 2). Щодо API, готових до "
"IPv6, читачі можуть звернутися до :rfc:`3493` під назвою Basic Socket "
"Interface Extensions for IPv6."
