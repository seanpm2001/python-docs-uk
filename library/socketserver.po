# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:13+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`socketserver` --- A framework for network servers"
msgstr ":mod:`socketserver` --- Фреймворк для мережевих серверів"

msgid "**Source code:** :source:`Lib/socketserver.py`"
msgstr "**Вихідний код:** :source:`Lib/socketserver.py`"

msgid ""
"The :mod:`socketserver` module simplifies the task of writing network "
"servers."
msgstr ""
"Модуль :mod:`socketserver` спрощує завдання написання мережевих серверів."

msgid ":ref:`Availability <availability>`: not Emscripten, not WASI."
msgstr ""

msgid ""
"This module does not work or is not available on WebAssembly platforms "
"``wasm32-emscripten`` and ``wasm32-wasi``. See :ref:`wasm-availability` for "
"more information."
msgstr ""

msgid "There are four basic concrete server classes:"
msgstr "Існує чотири основних класи конкретних серверів:"

msgid ""
"This uses the internet TCP protocol, which provides for continuous streams "
"of data between the client and server. If *bind_and_activate* is true, the "
"constructor automatically attempts to invoke :meth:`~BaseServer.server_bind` "
"and :meth:`~BaseServer.server_activate`.  The other parameters are passed to "
"the :class:`BaseServer` base class."
msgstr ""
"Для цього використовується інтернет-протокол TCP, який забезпечує "
"безперервні потоки даних між клієнтом і сервером. Якщо *bind_and_activate* "
"має значення true, конструктор автоматично намагається викликати :meth:"
"`~BaseServer.server_bind` і :meth:`~BaseServer.server_activate`. Інші "
"параметри передаються до базового класу :class:`BaseServer`."

msgid ""
"This uses datagrams, which are discrete packets of information that may "
"arrive out of order or be lost while in transit.  The parameters are the "
"same as for :class:`TCPServer`."
msgstr ""
"Для цього використовуються дейтаграми, які є окремими пакетами інформації, "
"які можуть надійти не в порядку або бути втраченими під час передачі. "
"Параметри такі самі, як і для :class:`TCPServer`."

msgid ""
"These more infrequently used classes are similar to the TCP and UDP classes, "
"but use Unix domain sockets; they're not available on non-Unix platforms.  "
"The parameters are the same as for :class:`TCPServer`."
msgstr ""
"Ці менш часто використовувані класи подібні до класів TCP і UDP, але "
"використовують доменні сокети Unix; вони недоступні на платформах, відмінних "
"від Unix. Параметри такі самі, як і для :class:`TCPServer`."

msgid ""
"These four classes process requests :dfn:`synchronously`; each request must "
"be completed before the next request can be started.  This isn't suitable if "
"each request takes a long time to complete, because it requires a lot of "
"computation, or because it returns a lot of data which the client is slow to "
"process.  The solution is to create a separate process or thread to handle "
"each request; the :class:`ForkingMixIn` and :class:`ThreadingMixIn` mix-in "
"classes can be used to support asynchronous behaviour."
msgstr ""
"Ці чотири класи обробляють запити :dfn:`synchronously`; кожен запит має бути "
"виконано перед початком наступного запиту. Це не підходить, якщо виконання "
"кожного запиту займає багато часу, тому що він вимагає багато обчислень або "
"тому, що він повертає багато даних, які клієнт повільно обробляє. Рішення "
"полягає у створенні окремого процесу або потоку для обробки кожного запиту; "
"змішані класи :class:`ForkingMixIn` і :class:`ThreadingMixIn` можна "
"використовувати для підтримки асинхронної поведінки."

msgid ""
"Creating a server requires several steps.  First, you must create a request "
"handler class by subclassing the :class:`BaseRequestHandler` class and "
"overriding its :meth:`~BaseRequestHandler.handle` method; this method will "
"process incoming requests.  Second, you must instantiate one of the server "
"classes, passing it the server's address and the request handler class. It "
"is recommended to use the server in a :keyword:`with` statement. Then call "
"the :meth:`~BaseServer.handle_request` or :meth:`~BaseServer.serve_forever` "
"method of the server object to process one or many requests.  Finally, call :"
"meth:`~BaseServer.server_close` to close the socket (unless you used a :"
"keyword:`!with` statement)."
msgstr ""
"Створення сервера вимагає кількох кроків. По-перше, ви повинні створити клас "
"обробника запитів, створивши підклас класу :class:`BaseRequestHandler` і "
"перевизначивши його метод :meth:`~BaseRequestHandler.handle`; цей метод "
"оброблятиме вхідні запити. По-друге, ви повинні створити екземпляр одного з "
"класів сервера, передавши йому адресу сервера та клас обробника запитів. "
"Рекомендовано використовувати сервер у операторі :keyword:`with`. Потім "
"викличте метод :meth:`~BaseServer.handle_request` або :meth:`~BaseServer."
"serve_forever` об’єкта сервера для обробки одного або кількох запитів. "
"Нарешті, викличте :meth:`~BaseServer.server_close`, щоб закрити сокет (якщо "
"ви не використали оператор :keyword:`!with`)."

msgid ""
"When inheriting from :class:`ThreadingMixIn` for threaded connection "
"behavior, you should explicitly declare how you want your threads to behave "
"on an abrupt shutdown.  The :class:`ThreadingMixIn` class defines an "
"attribute *daemon_threads*, which indicates whether or not the server should "
"wait for thread termination.  You should set the flag explicitly if you "
"would like threads to behave autonomously; the default is :const:`False`, "
"meaning that Python will not exit until all threads created by :class:"
"`ThreadingMixIn` have exited."
msgstr ""
"Успадковуючи від :class:`ThreadingMixIn` поведінку потокового з’єднання, ви "
"повинні явно оголосити, як ви хочете, щоб ваші потоки поводилися під час "
"раптового завершення роботи. Клас :class:`ThreadingMixIn` визначає атрибут "
"*daemon_threads*, який вказує, чи повинен сервер чекати завершення потоку. "
"Ви повинні встановити прапорець явно, якщо ви хочете, щоб потоки поводилися "
"автономно; за замовчуванням :const:`False`, що означає, що Python не "
"завершить роботу, доки не завершаться всі потоки, створені :class:"
"`ThreadingMixIn`."

msgid ""
"Server classes have the same external methods and attributes, no matter what "
"network protocol they use."
msgstr ""
"Класи серверів мають однакові зовнішні методи та атрибути, незалежно від "
"того, який мережевий протокол вони використовують."

msgid "Server Creation Notes"
msgstr "Примітки щодо створення сервера"

msgid ""
"There are five classes in an inheritance diagram, four of which represent "
"synchronous servers of four types::"
msgstr ""
"У діаграмі успадкування є п’ять класів, чотири з яких представляють "
"синхронні сервери чотирьох типів:"

msgid ""
"Note that :class:`UnixDatagramServer` derives from :class:`UDPServer`, not "
"from :class:`UnixStreamServer` --- the only difference between an IP and a "
"Unix stream server is the address family, which is simply repeated in both "
"Unix server classes."
msgstr ""
"Зауважте, що :class:`UnixDatagramServer` походить від :class:`UDPServer`, а "
"не від :class:`UnixStreamServer` --- єдина різниця між IP-адресою та "
"сервером потоку Unix полягає в родині адрес, яка просто повторюється в обох "
"Класи серверів Unix."

msgid ""
"Forking and threading versions of each type of server can be created using "
"these mix-in classes.  For instance, :class:`ThreadingUDPServer` is created "
"as follows::"
msgstr ""
"Розгалуження та версії потоків кожного типу сервера можна створити за "
"допомогою цих змішаних класів. Наприклад, :class:`ThreadingUDPServer` "
"створюється таким чином:"

msgid ""
"The mix-in class comes first, since it overrides a method defined in :class:"
"`UDPServer`.  Setting the various attributes also changes the behavior of "
"the underlying server mechanism."
msgstr ""
"Клас mix-in стоїть на першому місці, оскільки він замінює метод, визначений "
"у :class:`UDPServer`. Налаштування різних атрибутів також змінює поведінку "
"базового серверного механізму."

msgid ""
":class:`ForkingMixIn` and the Forking classes mentioned below are only "
"available on POSIX platforms that support :func:`~os.fork`."
msgstr ""
":class:`ForkingMixIn` і згадані нижче класи Forking доступні лише на "
"платформах POSIX, які підтримують :func:`~os.fork`."

msgid ""
":meth:`socketserver.ForkingMixIn.server_close` waits until all child "
"processes complete, except if :attr:`socketserver.ForkingMixIn."
"block_on_close` attribute is false."
msgstr ""
":meth:`socketserver.ForkingMixIn.server_close` очікує завершення всіх "
"дочірніх процесів, за винятком випадків, коли атрибут :attr:`socketserver."
"ForkingMixIn.block_on_close` має значення false."

msgid ""
":meth:`socketserver.ThreadingMixIn.server_close` waits until all non-daemon "
"threads complete, except if :attr:`socketserver.ThreadingMixIn."
"block_on_close` attribute is false. Use daemonic threads by setting :data:"
"`ThreadingMixIn.daemon_threads` to ``True`` to not wait until threads "
"complete."
msgstr ""
":meth:`socketserver.ThreadingMixIn.server_close` очікує завершення всіх "
"потоків, які не є демонами, за винятком випадків, коли атрибут :attr:"
"`socketserver.ThreadingMixIn.block_on_close` має значення false. "
"Використовуйте демонічні потоки, встановивши для :data:`ThreadingMixIn."
"daemon_threads` значення ``True``, щоб не чекати завершення потоків."

msgid ""
":meth:`socketserver.ForkingMixIn.server_close` and :meth:`socketserver."
"ThreadingMixIn.server_close` now waits until all child processes and non-"
"daemonic threads complete. Add a new :attr:`socketserver.ForkingMixIn."
"block_on_close` class attribute to opt-in for the pre-3.7 behaviour."
msgstr ""
":meth:`socketserver.ForkingMixIn.server_close` і :meth:`socketserver."
"ThreadingMixIn.server_close` тепер очікують завершення всіх дочірніх "
"процесів і недемонічних потоків. Додайте новий атрибут класу :attr:"
"`socketserver.ForkingMixIn.block_on_close`, щоб погодитися на поведінку до "
"3.7."

msgid "These classes are pre-defined using the mix-in classes."
msgstr "Ці класи попередньо визначені за допомогою змішаних класів."

msgid ""
"To implement a service, you must derive a class from :class:"
"`BaseRequestHandler` and redefine its :meth:`~BaseRequestHandler.handle` "
"method. You can then run various versions of the service by combining one of "
"the server classes with your request handler class.  The request handler "
"class must be different for datagram or stream services.  This can be hidden "
"by using the handler subclasses :class:`StreamRequestHandler` or :class:"
"`DatagramRequestHandler`."
msgstr ""
"Щоб реалізувати службу, ви повинні отримати клас від :class:"
"`BaseRequestHandler` і перевизначити його метод :meth:`~BaseRequestHandler."
"handle`. Потім ви можете запустити різні версії служби, поєднавши один із "
"класів сервера з класом обробника запитів. Клас обробника запитів має "
"відрізнятися для датаграм або потокових служб. Це можна приховати за "
"допомогою підкласів обробників :class:`StreamRequestHandler` або :class:"
"`DatagramRequestHandler`."

msgid ""
"Of course, you still have to use your head!  For instance, it makes no sense "
"to use a forking server if the service contains state in memory that can be "
"modified by different requests, since the modifications in the child process "
"would never reach the initial state kept in the parent process and passed to "
"each child.  In this case, you can use a threading server, but you will "
"probably have to use locks to protect the integrity of the shared data."
msgstr ""
"Звичайно, вам все одно доведеться використовувати свою голову! Наприклад, "
"немає сенсу використовувати сервер розгалуження, якщо служба містить стан у "
"пам’яті, який можна змінювати різними запитами, оскільки зміни в дочірньому "
"процесі ніколи не досягнуть початкового стану, який зберігається в "
"батьківському процесі та передається кожному дочірньому. . У цьому випадку "
"ви можете використовувати потоковий сервер, але вам, ймовірно, доведеться "
"використовувати блокування для захисту цілісності спільних даних."

msgid ""
"On the other hand, if you are building an HTTP server where all data is "
"stored externally (for instance, in the file system), a synchronous class "
"will essentially render the service \"deaf\" while one request is being "
"handled -- which may be for a very long time if a client is slow to receive "
"all the data it has requested.  Here a threading or forking server is "
"appropriate."
msgstr ""
"З іншого боку, якщо ви створюєте HTTP-сервер, де всі дані зберігаються зовні "
"(наприклад, у файловій системі), синхронний клас, по суті, надаватиме "
"послугу \"глухою\", поки обробляється один запит, що може бути дуже довго, "
"якщо клієнт повільно отримує всі запитувані дані. Тут підійде сервер потоків "
"або розгалуження."

msgid ""
"In some cases, it may be appropriate to process part of a request "
"synchronously, but to finish processing in a forked child depending on the "
"request data.  This can be implemented by using a synchronous server and "
"doing an explicit fork in the request handler class :meth:"
"`~BaseRequestHandler.handle` method."
msgstr ""
"У деяких випадках може бути доречним обробити частину запиту синхронно, але "
"завершити обробку в розгалуженому дочірньому файлі залежно від даних запиту. "
"Це можна реалізувати за допомогою синхронного сервера та виконання явного "
"розгалуження в методі класу обробника запитів :meth:`~BaseRequestHandler."
"handle`."

msgid ""
"Another approach to handling multiple simultaneous requests in an "
"environment that supports neither threads nor :func:`~os.fork` (or where "
"these are too expensive or inappropriate for the service) is to maintain an "
"explicit table of partially finished requests and to use :mod:`selectors` to "
"decide which request to work on next (or whether to handle a new incoming "
"request).  This is particularly important for stream services where each "
"client can potentially be connected for a long time (if threads or "
"subprocesses cannot be used).  See :mod:`asyncore` for another way to manage "
"this."
msgstr ""
"Інший підхід до обробки кількох одночасних запитів у середовищі, яке не "
"підтримує ні потоки, ні :func:`~os.fork` (або якщо вони надто дорогі або "
"невідповідні для служби), полягає у підтримці явної таблиці частково "
"завершених запитів і використання :mod:`selectors`, щоб вирішити, над яким "
"запитом працювати далі (або чи обробляти новий вхідний запит). Це особливо "
"важливо для потокових служб, де кожен клієнт потенційно може бути "
"підключений протягом тривалого часу (якщо потоки або підпроцеси не можуть "
"бути використані). Перегляньте :mod:`asyncore` для іншого способу керування "
"цим."

msgid "Server Objects"
msgstr "Серверні об’єкти"

msgid ""
"This is the superclass of all Server objects in the module.  It defines the "
"interface, given below, but does not implement most of the methods, which is "
"done in subclasses.  The two parameters are stored in the respective :attr:"
"`server_address` and :attr:`RequestHandlerClass` attributes."
msgstr ""
"Це суперклас усіх об’єктів сервера в модулі. Він визначає інтерфейс, "
"наведений нижче, але не реалізує більшість методів, що робиться в підкласах. "
"Два параметри зберігаються у відповідних атрибутах :attr:`server_address` і :"
"attr:`RequestHandlerClass`."

msgid ""
"Return an integer file descriptor for the socket on which the server is "
"listening.  This function is most commonly passed to :mod:`selectors`, to "
"allow monitoring multiple servers in the same process."
msgstr ""
"Повертає цілочисельний файловий дескриптор для сокета, який прослуховує "
"сервер. Ця функція найчастіше передається :mod:`selectors`, щоб дозволити "
"моніторинг кількох серверів в одному процесі."

msgid ""
"Process a single request.  This function calls the following methods in "
"order: :meth:`get_request`, :meth:`verify_request`, and :meth:"
"`process_request`.  If the user-provided :meth:`~BaseRequestHandler.handle` "
"method of the handler class raises an exception, the server's :meth:"
"`handle_error` method will be called.  If no request is received within :"
"attr:`timeout` seconds, :meth:`handle_timeout` will be called and :meth:"
"`handle_request` will return."
msgstr ""
"Обробити один запит. Ця функція викликає наступні методи в порядку: :meth:"
"`get_request`, :meth:`verify_request` і :meth:`process_request`. Якщо "
"наданий користувачем метод :meth:`~BaseRequestHandler.handle` класу "
"обробника викликає виняток, буде викликано метод :meth:`handle_error` "
"сервера. Якщо протягом :attr:`timeout` секунд не буде отримано жодного "
"запиту, буде викликано :meth:`handle_timeout` і :meth:`handle_request` "
"повернеться."

msgid ""
"Handle requests until an explicit :meth:`shutdown` request.  Poll for "
"shutdown every *poll_interval* seconds. Ignores the :attr:`timeout` "
"attribute.  It also calls :meth:`service_actions`, which may be used by a "
"subclass or mixin to provide actions specific to a given service.  For "
"example, the :class:`ForkingMixIn` class uses :meth:`service_actions` to "
"clean up zombie child processes."
msgstr ""
"Обробляти запити до явного запиту :meth:`shutdown`. Опитування для вимкнення "
"кожні *poll_interval* секунди. Ігнорує атрибут :attr:`timeout`. Він також "
"викликає :meth:`service_actions`, який може використовуватися підкласом або "
"міксином для виконання дій, специфічних для певної служби. Наприклад, клас :"
"class:`ForkingMixIn` використовує :meth:`service_actions` для очищення "
"дочірніх процесів-зомбі."

msgid "Added ``service_actions`` call to the ``serve_forever`` method."
msgstr "Додано виклик ``service_actions`` до методу ``serve_forever``."

msgid ""
"This is called in the :meth:`serve_forever` loop. This method can be "
"overridden by subclasses or mixin classes to perform actions specific to a "
"given service, such as cleanup actions."
msgstr ""
"Це викликається в циклі :meth:`serve_forever`. Цей метод може бути "
"перевизначений підкласами або класами mixin для виконання дій, специфічних "
"для певної служби, наприклад дій очищення."

msgid ""
"Tell the :meth:`serve_forever` loop to stop and wait until it does. :meth:"
"`shutdown` must be called while :meth:`serve_forever` is running in a "
"different thread otherwise it will deadlock."
msgstr ""
"Скажіть циклу :meth:`serve_forever` зупинитися та зачекайте, доки він "
"зупиниться. :meth:`shutdown` потрібно викликати, поки :meth:`serve_forever` "
"працює в іншому потоці, інакше він блокується."

msgid "Clean up the server. May be overridden."
msgstr "Очистити сервер. Може бути перевизначено."

msgid ""
"The family of protocols to which the server's socket belongs. Common "
"examples are :const:`socket.AF_INET` and :const:`socket.AF_UNIX`."
msgstr ""
"Сімейство протоколів, до якого належить сокет сервера. Типовими прикладами "
"є :const:`socket.AF_INET` і :const:`socket.AF_UNIX`."

msgid ""
"The user-provided request handler class; an instance of this class is "
"created for each request."
msgstr ""
"Клас обробника запитів, наданий користувачем; екземпляр цього класу "
"створюється для кожного запиту."

msgid ""
"The address on which the server is listening.  The format of addresses "
"varies depending on the protocol family; see the documentation for the :mod:"
"`socket` module for details.  For internet protocols, this is a tuple "
"containing a string giving the address, and an integer port number: "
"``('127.0.0.1', 80)``, for example."
msgstr ""
"Адреса, на якій прослуховується сервер. Формат адреси змінюється в "
"залежності від сімейства протоколів; подробиці дивіться в документації до "
"модуля :mod:`socket`. Для інтернет-протоколів це кортеж, що містить рядок, "
"що вказує адресу, і цілий номер порту: ``('127.0.0.1', 80)``, наприклад."

msgid ""
"The socket object on which the server will listen for incoming requests."
msgstr "Об’єкт сокета, на якому сервер прослуховуватиме вхідні запити."

msgid "The server classes support the following class variables:"
msgstr "Класи сервера підтримують наступні змінні класу:"

msgid ""
"Whether the server will allow the reuse of an address.  This defaults to :"
"const:`False`, and can be set in subclasses to change the policy."
msgstr ""
"Чи дозволить сервер повторне використання адреси. За умовчанням це :const:"
"`False`, і його можна встановити в підкласах, щоб змінити політику."

msgid ""
"The size of the request queue.  If it takes a long time to process a single "
"request, any requests that arrive while the server is busy are placed into a "
"queue, up to :attr:`request_queue_size` requests.  Once the queue is full, "
"further requests from clients will get a \"Connection denied\" error.  The "
"default value is usually 5, but this can be overridden by subclasses."
msgstr ""
"Розмір черги запитів. Якщо обробка одного запиту займає багато часу, будь-"
"які запити, які надходять, коли сервер зайнятий, розміщуються в черзі, до "
"запитів :attr:`request_queue_size`. Після заповнення черги подальші запити "
"від клієнтів отримуватимуть помилку \"З’єднання відмовлено\". Значення за "
"замовчуванням зазвичай дорівнює 5, але це може бути замінено підкласами."

msgid ""
"The type of socket used by the server; :const:`socket.SOCK_STREAM` and :"
"const:`socket.SOCK_DGRAM` are two common values."
msgstr ""
"Тип сокета, який використовує сервер; :const:`socket.SOCK_STREAM` і :const:"
"`socket.SOCK_DGRAM` є двома загальними значеннями."

msgid ""
"Timeout duration, measured in seconds, or :const:`None` if no timeout is "
"desired.  If :meth:`handle_request` receives no incoming requests within the "
"timeout period, the :meth:`handle_timeout` method is called."
msgstr ""
"Тривалість тайм-ауту, вимірюється в секундах, або :const:`None`, якщо тайм-"
"аут не потрібний. Якщо :meth:`handle_request` не отримує вхідних запитів "
"протягом періоду очікування, викликається метод :meth:`handle_timeout`."

msgid ""
"There are various server methods that can be overridden by subclasses of "
"base server classes like :class:`TCPServer`; these methods aren't useful to "
"external users of the server object."
msgstr ""
"Існують різні методи сервера, які можуть бути замінені підкласами базових "
"класів серверів, наприклад :class:`TCPServer`; ці методи не корисні "
"зовнішнім користувачам серверного об’єкта."

msgid ""
"Actually processes the request by instantiating :attr:`RequestHandlerClass` "
"and calling its :meth:`~BaseRequestHandler.handle` method."
msgstr ""
"Фактично обробляє запит, створюючи екземпляр :attr:`RequestHandlerClass` і "
"викликаючи його метод :meth:`~BaseRequestHandler.handle`."

msgid ""
"Must accept a request from the socket, and return a 2-tuple containing the "
"*new* socket object to be used to communicate with the client, and the "
"client's address."
msgstr ""
"Потрібно прийняти запит від сокета та повернути 2-кортеж, що містить *новий* "
"об’єкт сокета, який буде використовуватися для зв’язку з клієнтом, і адресу "
"клієнта."

msgid ""
"This function is called if the :meth:`~BaseRequestHandler.handle` method of "
"a :attr:`RequestHandlerClass` instance raises an exception.  The default "
"action is to print the traceback to standard error and continue handling "
"further requests."
msgstr ""
"Ця функція викликається, якщо метод :meth:`~BaseRequestHandler.handle` "
"примірника :attr:`RequestHandlerClass` викликає виняткову ситуацію. Дія за "
"замовчуванням полягає в тому, щоб надрукувати відстеження стандартної "
"помилки та продовжити обробку подальших запитів."

msgid "Now only called for exceptions derived from the :exc:`Exception` class."
msgstr "Тепер викликаються лише винятки, похідні від класу :exc:`Exception`."

msgid ""
"This function is called when the :attr:`timeout` attribute has been set to a "
"value other than :const:`None` and the timeout period has passed with no "
"requests being received.  The default action for forking servers is to "
"collect the status of any child processes that have exited, while in "
"threading servers this method does nothing."
msgstr ""
"Ця функція викликається, коли для атрибута :attr:`timeout` встановлено "
"значення, відмінне від :const:`None`, і період очікування минув, а запити не "
"надходили. Дія за замовчуванням для розгалужених серверів полягає в зборі "
"статусу будь-яких дочірніх процесів, які вийшли, тоді як у потокових "
"серверах цей метод не робить нічого."

msgid ""
"Calls :meth:`finish_request` to create an instance of the :attr:"
"`RequestHandlerClass`.  If desired, this function can create a new process "
"or thread to handle the request; the :class:`ForkingMixIn` and :class:"
"`ThreadingMixIn` classes do this."
msgstr ""
"Викликає :meth:`finish_request` для створення екземпляра :attr:"
"`RequestHandlerClass`. За бажання ця функція може створити новий процес або "
"потік для обробки запиту; це роблять класи :class:`ForkingMixIn` і :class:"
"`ThreadingMixIn`."

msgid ""
"Called by the server's constructor to activate the server.  The default "
"behavior for a TCP server just invokes :meth:`~socket.socket.listen` on the "
"server's socket.  May be overridden."
msgstr ""
"Викликається конструктором сервера для активації сервера. Поведінка за "
"замовчуванням для TCP-сервера просто викликає :meth:`~socket.socket.listen` "
"у сокеті сервера. Може бути перевизначено."

msgid ""
"Called by the server's constructor to bind the socket to the desired "
"address. May be overridden."
msgstr ""
"Викликається конструктором сервера, щоб прив’язати сокет до потрібної "
"адреси. Може бути перевизначено."

msgid ""
"Must return a Boolean value; if the value is :const:`True`, the request will "
"be processed, and if it's :const:`False`, the request will be denied.  This "
"function can be overridden to implement access controls for a server. The "
"default implementation always returns :const:`True`."
msgstr ""
"Має повертати логічне значення; якщо значення :const:`True`, запит буде "
"оброблено, а якщо значення :const:`False`, запит буде відхилено. Цю функцію "
"можна замінити, щоб реалізувати контроль доступу до сервера. Стандартна "
"реалізація завжди повертає :const:`True`."

msgid ""
"Support for the :term:`context manager` protocol was added.  Exiting the "
"context manager is equivalent to calling :meth:`server_close`."
msgstr ""
"Додано підтримку протоколу :term:`context manager`. Вихід із контекстного "
"менеджера еквівалентний виклику :meth:`server_close`."

msgid "Request Handler Objects"
msgstr "Об’єкти обробки запитів"

msgid ""
"This is the superclass of all request handler objects.  It defines the "
"interface, given below.  A concrete request handler subclass must define a "
"new :meth:`handle` method, and can override any of the other methods.  A new "
"instance of the subclass is created for each request."
msgstr ""
"Це суперклас усіх об’єктів обробки запитів. Він визначає інтерфейс, "
"наведений нижче. Конкретний підклас обробника запитів повинен визначати "
"новий метод :meth:`handle` і може перевизначати будь-які інші методи. Для "
"кожного запиту створюється новий екземпляр підкласу."

msgid ""
"Called before the :meth:`handle` method to perform any initialization "
"actions required.  The default implementation does nothing."
msgstr ""
"Викликається перед методом :meth:`handle` для виконання будь-яких необхідних "
"дій ініціалізації. Стандартна реалізація нічого не робить."

msgid ""
"This function must do all the work required to service a request.  The "
"default implementation does nothing.  Several instance attributes are "
"available to it; the request is available as :attr:`self.request`; the "
"client address as :attr:`self.client_address`; and the server instance as :"
"attr:`self.server`, in case it needs access to per-server information."
msgstr ""
"Ця функція повинна виконувати всю роботу, необхідну для обслуговування "
"запиту. Стандартна реалізація нічого не робить. Для нього доступні кілька "
"атрибутів екземпляра; запит доступний як :attr:`self.request`; адресу "
"клієнта як :attr:`self.client_address`; і екземпляр сервера як :attr:`self."
"server`, якщо йому потрібен доступ до інформації для кожного сервера."

msgid ""
"The type of :attr:`self.request` is different for datagram or stream "
"services.  For stream services, :attr:`self.request` is a socket object; for "
"datagram services, :attr:`self.request` is a pair of string and socket."
msgstr ""
"Тип :attr:`self.request` відрізняється для служб датаграм і потоків. Для "
"потокових служб :attr:`self.request` є об’єктом сокета; для служб дейтаграм :"
"attr:`self.request` є парою рядка та сокета."

msgid ""
"Called after the :meth:`handle` method to perform any clean-up actions "
"required.  The default implementation does nothing.  If :meth:`setup` raises "
"an exception, this function will not be called."
msgstr ""
"Викликається після методу :meth:`handle` для виконання будь-яких необхідних "
"дій очищення. Стандартна реалізація нічого не робить. Якщо :meth:`setup` "
"викликає виняток, ця функція не буде викликана."

msgid ""
"These :class:`BaseRequestHandler` subclasses override the :meth:"
"`~BaseRequestHandler.setup` and :meth:`~BaseRequestHandler.finish` methods, "
"and provide :attr:`self.rfile` and :attr:`self.wfile` attributes. The :attr:"
"`self.rfile` and :attr:`self.wfile` attributes can be read or written, "
"respectively, to get the request data or return data to the client."
msgstr ""
"Ці підкласи :class:`BaseRequestHandler` замінюють методи :meth:"
"`~BaseRequestHandler.setup` і :meth:`~BaseRequestHandler.finish` і надають :"
"attr:`self.rfile` і :attr:`self.wfile` атрибути. Атрибути :attr:`self.rfile` "
"і :attr:`self.wfile` можна читати або записувати відповідно, щоб отримати "
"дані запиту або повернути дані клієнту."

msgid ""
"The :attr:`rfile` attributes of both classes support the :class:`io."
"BufferedIOBase` readable interface, and :attr:`DatagramRequestHandler.wfile` "
"supports the :class:`io.BufferedIOBase` writable interface."
msgstr ""
"Атрибути :attr:`rfile` обох класів підтримують інтерфейс для читання :class:"
"`io.BufferedIOBase`, а :attr:`DatagramRequestHandler.wfile` підтримує "
"інтерфейс для запису :class:`io.BufferedIOBase`."

msgid ""
":attr:`StreamRequestHandler.wfile` also supports the :class:`io."
"BufferedIOBase` writable interface."
msgstr ""
":attr:`StreamRequestHandler.wfile` також підтримує записуваний інтерфейс :"
"class:`io.BufferedIOBase`."

msgid "Examples"
msgstr "Приклади"

msgid ":class:`socketserver.TCPServer` Example"
msgstr ":class:`socketserver.TCPServer` Приклад"

msgid "This is the server side::"
msgstr "Це сторона сервера::"

msgid ""
"An alternative request handler class that makes use of streams (file-like "
"objects that simplify communication by providing the standard file "
"interface)::"
msgstr ""
"Альтернативний клас обробника запитів, який використовує потоки "
"(файлоподібні об’єкти, які спрощують зв’язок, надаючи стандартний файловий "
"інтерфейс):"

msgid ""
"The difference is that the ``readline()`` call in the second handler will "
"call ``recv()`` multiple times until it encounters a newline character, "
"while the single ``recv()`` call in the first handler will just return what "
"has been sent from the client in one ``sendall()`` call."
msgstr ""
"Різниця полягає в тому, що виклик ``readline()`` у другому обробнику "
"викликає ``recv()`` кілька разів, доки не зустріне символ нового рядка, тоді "
"як один виклик ``recv()`` у першому обробнику просто поверне те, що було "
"надіслано від клієнта в одному виклику ``sendall()``."

msgid "This is the client side::"
msgstr "Це сторона клієнта::"

msgid "The output of the example should look something like this:"
msgstr "Результат прикладу має виглядати приблизно так:"

msgid "Server:"
msgstr "сервер:"

msgid "Client:"
msgstr "Клієнт:"

msgid ":class:`socketserver.UDPServer` Example"
msgstr ":class:`socketserver.UDPServer` Приклад"

msgid ""
"The output of the example should look exactly like for the TCP server "
"example."
msgstr ""
"Вихідні дані прикладу мають виглядати точно так само, як для прикладу "
"сервера TCP."

msgid "Asynchronous Mixins"
msgstr "Асинхронні міксини"

msgid ""
"To build asynchronous handlers, use the :class:`ThreadingMixIn` and :class:"
"`ForkingMixIn` classes."
msgstr ""
"Для створення асинхронних обробників використовуйте класи :class:"
"`ThreadingMixIn` і :class:`ForkingMixIn`."

msgid "An example for the :class:`ThreadingMixIn` class::"
msgstr "Приклад класу :class:`ThreadingMixIn`::"

msgid ""
"The :class:`ForkingMixIn` class is used in the same way, except that the "
"server will spawn a new process for each request. Available only on POSIX "
"platforms that support :func:`~os.fork`."
msgstr ""
"Клас :class:`ForkingMixIn` використовується так само, за винятком того, що "
"сервер створюватиме новий процес для кожного запиту. Доступно лише на "
"платформах POSIX, які підтримують :func:`~os.fork`."
