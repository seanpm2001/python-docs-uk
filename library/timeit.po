# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:15+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`timeit` --- Measure execution time of small code snippets"
msgstr ":mod:`timeit` --- Вимірювання часу виконання невеликих фрагментів коду"

msgid "**Source code:** :source:`Lib/timeit.py`"
msgstr "**Вихідний код:** :source:`Lib/timeit.py`"

msgid ""
"This module provides a simple way to time small bits of Python code. It has "
"both a :ref:`timeit-command-line-interface` as well as a :ref:`callable "
"<python-interface>` one.  It avoids a number of common traps for measuring "
"execution times. See also Tim Peters' introduction to the \"Algorithms\" "
"chapter in the second edition of *Python Cookbook*, published by O'Reilly."
msgstr ""
"Цей модуль забезпечує простий спосіб вимірювання часу невеликих фрагментів "
"коду Python. Він має як :ref:`timeit-command-line-interface`, так і :ref:"
"`callable <python-interface>`. Це дозволяє уникнути ряду типових пасток для "
"вимірювання часу виконання. Дивіться також вступ Тіма Пітерса до розділу "
"\"Алгоритми\" у другому виданні *Python Cookbook*, опублікованому O'Reilly."

msgid "Basic Examples"
msgstr "Основні приклади"

msgid ""
"The following example shows how the :ref:`timeit-command-line-interface` can "
"be used to compare three different expressions:"
msgstr ""
"У наступному прикладі показано, як :ref:`timeit-command-line-interface` "
"можна використовувати для порівняння трьох різних виразів:"

msgid "This can be achieved from the :ref:`python-interface` with::"
msgstr ""
"Цього можна досягти за допомогою :ref:`python-interface` за допомогою::"

msgid "A callable can also be passed from the :ref:`python-interface`::"
msgstr "Викликається також можна передати з :ref:`python-interface`::"

msgid ""
"Note however that :func:`.timeit` will automatically determine the number of "
"repetitions only when the command-line interface is used.  In the :ref:"
"`timeit-examples` section you can find more advanced examples."
msgstr ""
"Зауважте, однак, що :func:`.timeit` автоматично визначатиме кількість "
"повторень, лише якщо використовується інтерфейс командного рядка. У розділі :"
"ref:`timeit-examples` ви можете знайти більш складні приклади."

msgid "Python Interface"
msgstr "Інтерфейс Python"

msgid "The module defines three convenience functions and a public class:"
msgstr "Модуль визначає три зручні функції та публічний клас:"

msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code and "
"*timer* function and run its :meth:`.timeit` method with *number* "
"executions. The optional *globals* argument specifies a namespace in which "
"to execute the code."
msgstr ""
"Створіть екземпляр :class:`Timer` із заданим оператором, кодом *setup* і "
"функцією *timer* і запустіть його метод :meth:`.timeit` з *кількістю* "
"виконань. Необов’язковий аргумент *globals* визначає простір імен, у якому "
"виконуватиметься код."

msgid "The optional *globals* parameter was added."
msgstr "Додано необов’язковий параметр *globals*."

msgid ""
"Create a :class:`Timer` instance with the given statement, *setup* code and "
"*timer* function and run its :meth:`.repeat` method with the given *repeat* "
"count and *number* executions.  The optional *globals* argument specifies a "
"namespace in which to execute the code."
msgstr ""
"Створіть екземпляр :class:`Timer` із заданим оператором, кодом *setup* і "
"функцією *timer* і запустіть його метод :meth:`.repeat` із заданою кількістю "
"*repeat* і *кількістю* виконань. Необов’язковий аргумент *globals* визначає "
"простір імен, у якому виконуватиметься код."

msgid "Default value of *repeat* changed from 3 to 5."
msgstr "Значення *repeat* за замовчуванням змінено з 3 на 5."

msgid "The default timer, which is always :func:`time.perf_counter`."
msgstr "Таймер за умовчанням, яким завжди є :func:`time.perf_counter`."

msgid ":func:`time.perf_counter` is now the default timer."
msgstr ":func:`time.perf_counter` тепер є таймером за умовчанням."

msgid "Class for timing execution speed of small code snippets."
msgstr "Клас швидкості виконання невеликих фрагментів коду."

msgid ""
"The constructor takes a statement to be timed, an additional statement used "
"for setup, and a timer function.  Both statements default to ``'pass'``; the "
"timer function is platform-dependent (see the module doc string). *stmt* and "
"*setup* may also contain multiple statements separated by ``;`` or newlines, "
"as long as they don't contain multi-line string literals.  The statement "
"will by default be executed within timeit's namespace; this behavior can be "
"controlled by passing a namespace to *globals*."
msgstr ""
"Конструктор приймає інструкцію для визначення часу, додаткову інструкцію, "
"яка використовується для налаштування, і функцію таймера. Обидва оператори "
"за замовчуванням ``'pass'``; функція таймера залежить від платформи "
"(дивіться рядок документа модуля). *stmt* і *setup* також можуть містити "
"кілька операторів, розділених символами ``;`` або символами нового рядка, за "
"умови, що вони не містять багаторядкових рядкових літералів. Оператор за "
"замовчуванням виконуватиметься в межах простору імен timeit; цією поведінкою "
"можна керувати, передавши простір імен у *globals*."

msgid ""
"To measure the execution time of the first statement, use the :meth:`."
"timeit` method.  The :meth:`.repeat` and :meth:`.autorange` methods are "
"convenience methods to call :meth:`.timeit` multiple times."
msgstr ""
"Щоб виміряти час виконання першого оператора, використовуйте метод :meth:`."
"timeit`. Методи :meth:`.repeat` і :meth:`.autorange` є зручними для виклику :"
"meth:`.timeit` кілька разів."

msgid ""
"The execution time of *setup* is excluded from the overall timed execution "
"run."
msgstr "Час виконання *setup* виключається із загального часу виконання."

msgid ""
"The *stmt* and *setup* parameters can also take objects that are callable "
"without arguments.  This will embed calls to them in a timer function that "
"will then be executed by :meth:`.timeit`.  Note that the timing overhead is "
"a little larger in this case because of the extra function calls."
msgstr ""
"Параметри *stmt* і *setup* також можуть приймати об’єкти, які можна "
"викликати без аргументів. Це вбудує виклики до них у функцію таймера, яка "
"потім буде виконана :meth:`.timeit`. Зверніть увагу, що накладні витрати "
"часу трохи більші в цьому випадку через додаткові виклики функцій."

msgid ""
"Time *number* executions of the main statement.  This executes the setup "
"statement once, and then returns the time it takes to execute the main "
"statement a number of times, measured in seconds as a float. The argument is "
"the number of times through the loop, defaulting to one million.  The main "
"statement, the setup statement and the timer function to be used are passed "
"to the constructor."
msgstr ""
"Час *кількість* виконання основного оператора. Це виконує оператор "
"налаштування один раз, а потім повертає час, необхідний для виконання "
"основного оператора кілька разів, виміряний у секундах як число з плаваючою "
"точкою. Аргументом є кількість проходжень циклу, за замовчуванням один "
"мільйон. Основний оператор, оператор налаштування та функція таймера, які "
"будуть використані, передаються конструктору."

msgid ""
"By default, :meth:`.timeit` temporarily turns off :term:`garbage collection` "
"during the timing.  The advantage of this approach is that it makes "
"independent timings more comparable.  The disadvantage is that GC may be an "
"important component of the performance of the function being measured.  If "
"so, GC can be re-enabled as the first statement in the *setup* string.  For "
"example::"
msgstr ""
"За замовчуванням :meth:`.timeit` тимчасово вимикає :term:`garbage "
"collection` протягом часу. Перевага цього підходу полягає в тому, що він "
"робить незалежні таймінги більш порівнянними. Недоліком є те, що GC може "
"бути важливим компонентом продуктивності вимірюваної функції. Якщо так, GC "
"можна повторно ввімкнути як перший оператор у рядку *setup*. Наприклад::"

msgid "Automatically determine how many times to call :meth:`.timeit`."
msgstr "Автоматично визначати, скільки разів викликати :meth:`.timeit`."

msgid ""
"This is a convenience function that calls :meth:`.timeit` repeatedly so that "
"the total time >= 0.2 second, returning the eventual (number of loops, time "
"taken for that number of loops). It calls :meth:`.timeit` with increasing "
"numbers from the sequence 1, 2, 5, 10, 20, 50, ... until the time taken is "
"at least 0.2 second."
msgstr ""
"Це зручна функція, яка викликає :meth:`.timeit` неодноразово, щоб загальний "
"час становив >= 0,2 секунди, повертаючи остаточне значення (кількість "
"циклів, час, витрачений на цю кількість циклів). Він викликає :meth:`."
"timeit` із зростаючими числами з послідовності 1, 2, 5, 10, 20, 50, ... до "
"тих пір, поки витрачений час не становитиме принаймні 0,2 секунди."

msgid ""
"If *callback* is given and is not ``None``, it will be called after each "
"trial with two arguments: ``callback(number, time_taken)``."
msgstr ""
"Якщо надано *callback*, а не ``None``, його буде викликано після кожного "
"випробування з двома аргументами: ``callback(number, time_taken)``."

msgid "Call :meth:`.timeit` a few times."
msgstr "Викличте :meth:`.timeit` кілька разів."

msgid ""
"This is a convenience function that calls the :meth:`.timeit` repeatedly, "
"returning a list of results.  The first argument specifies how many times to "
"call :meth:`.timeit`.  The second argument specifies the *number* argument "
"for :meth:`.timeit`."
msgstr ""
"Це зручна функція, яка багаторазово викликає :meth:`.timeit`, повертаючи "
"список результатів. Перший аргумент визначає, скільки разів викликати :meth:"
"`.timeit`. Другий аргумент визначає аргумент *число* для :meth:`.timeit`."

msgid ""
"It's tempting to calculate mean and standard deviation from the result "
"vector and report these.  However, this is not very useful. In a typical "
"case, the lowest value gives a lower bound for how fast your machine can run "
"the given code snippet; higher values in the result vector are typically not "
"caused by variability in Python's speed, but by other processes interfering "
"with your timing accuracy. So the :func:`min` of the result is probably the "
"only number you should be interested in.  After that, you should look at the "
"entire vector and apply common sense rather than statistics."
msgstr ""
"Спокусливо обчислити середнє та стандартне відхилення від вектора результату "
"та повідомити про це. Однак це не дуже корисно. У типовому випадку найнижче "
"значення дає нижню межу того, наскільки швидко ваша машина може запускати "
"заданий фрагмент коду; більш високі значення у векторі результату зазвичай "
"спричинені не мінливістю швидкості Python, а іншими процесами, які заважають "
"вашій точності синхронізації. Тож :func:`min` результату, ймовірно, єдине "
"число, яке вас має цікавити. Після цього вам слід переглянути весь вектор і "
"застосувати здоровий глузд, а не статистику."

msgid "Helper to print a traceback from the timed code."
msgstr "Помічник для друку зворотного відстеження з часового коду."

msgid "Typical use::"
msgstr "Типове використання::"

msgid ""
"The advantage over the standard traceback is that source lines in the "
"compiled template will be displayed.  The optional *file* argument directs "
"where the traceback is sent; it defaults to :data:`sys.stderr`."
msgstr ""
"Перевага перед стандартним трасуванням полягає в тому, що вихідні рядки у "
"скомпільованому шаблоні відображатимуться. Необов'язковий аргумент *file* "
"вказує, куди надсилається відстеження; за замовчуванням :data:`sys.stderr`."

msgid "Command-Line Interface"
msgstr "Інтерфейс командного рядка"

msgid ""
"When called as a program from the command line, the following form is used::"
msgstr "При виклику програми з командного рядка використовується така форма:"

msgid "Where the following options are understood:"
msgstr "Де розуміються такі варіанти:"

msgid "how many times to execute 'statement'"
msgstr "скільки разів виконати 'оператор'"

msgid "how many times to repeat the timer (default 5)"
msgstr "скільки разів повторити таймер (за замовчуванням 5)"

msgid "statement to be executed once initially (default ``pass``)"
msgstr "оператор, який буде виконано один раз (за замовчуванням ``pass``)"

msgid ""
"measure process time, not wallclock time, using :func:`time.process_time` "
"instead of :func:`time.perf_counter`, which is the default"
msgstr ""
"вимірювати час процесу, а не час настінного годинника, використовуючи :func:"
"`time.process_time` замість :func:`time.perf_counter`, який є типовим"

msgid ""
"specify a time unit for timer output; can select ``nsec``, ``usec``, "
"``msec``, or ``sec``"
msgstr ""

msgid "print raw timing results; repeat for more digits precision"
msgstr ""
"друк необроблених результатів синхронізації; повторіть для більшої точності "
"цифр"

msgid "print a short usage message and exit"
msgstr "надрукувати коротке повідомлення про використання та вийти"

msgid ""
"A multi-line statement may be given by specifying each line as a separate "
"statement argument; indented lines are possible by enclosing an argument in "
"quotes and using leading spaces.  Multiple :option:`-s` options are treated "
"similarly."
msgstr ""
"Багаторядковий оператор може бути заданий шляхом визначення кожного рядка як "
"окремого аргументу оператора; рядки з відступом можливі, якщо взяти аргумент "
"у лапки та використовувати пробіли на початку. Кілька параметрів :option:`-"
"s` обробляються аналогічно."

msgid ""
"If :option:`-n` is not given, a suitable number of loops is calculated by "
"trying increasing numbers from the sequence 1, 2, 5, 10, 20, 50, ... until "
"the total time is at least 0.2 seconds."
msgstr ""
"Якщо :option:`-n` не вказано, відповідна кількість циклів обчислюється "
"шляхом спроб збільшення чисел із послідовності 1, 2, 5, 10, 20, 50, ... доки "
"загальний час не становитиме принаймні 0,2 секунди ."

msgid ""
":func:`default_timer` measurements can be affected by other programs running "
"on the same machine, so the best thing to do when accurate timing is "
"necessary is to repeat the timing a few times and use the best time.  The :"
"option:`-r` option is good for this; the default of 5 repetitions is "
"probably enough in most cases.  You can use :func:`time.process_time` to "
"measure CPU time."
msgstr ""
" На вимірювання  :func:`default_timer` можуть впливати інші програми, "
"запущені на тій же машині, тому найкраще, що можна зробити, коли потрібен "
"точний час, це повторити відлік часу кілька разів і використовувати "
"найкращий час. Опція :option:`-r` підходить для цього; 5 повторень за "
"замовчуванням, ймовірно, достатньо в більшості випадків. Ви можете "
"використовувати :func:`time.process_time` для вимірювання часу ЦП."

msgid ""
"There is a certain baseline overhead associated with executing a pass "
"statement. The code here doesn't try to hide it, but you should be aware of "
"it.  The baseline overhead can be measured by invoking the program without "
"arguments, and it might differ between Python versions."
msgstr ""
"Існує певна базова накладна вартість, пов’язана з виконанням оператора "
"проходу. Код тут не намагається це приховати, але ви повинні про це знати. "
"Базові накладні витрати можна виміряти, викликавши програму без аргументів, "
"і вони можуть відрізнятися в різних версіях Python."

msgid "Examples"
msgstr "Приклади"

msgid ""
"It is possible to provide a setup statement that is executed only once at "
"the beginning:"
msgstr ""
"Можна надати оператор налаштування, який виконується лише один раз на "
"початку:"

msgid ""
"In the output, there are three fields. The loop count, which tells you how "
"many times the statement body was run per timing loop repetition. The "
"repetition count ('best of 5') which tells you how many times the timing "
"loop was repeated, and finally the time the statement body took on average "
"within the best repetition of the timing loop. That is, the time the fastest "
"repetition took divided by the loop count."
msgstr ""
"У вихідних даних є три поля. Кількість циклів, яка повідомляє вам, скільки "
"разів було виконано тіло оператора за повторення циклу синхронізації. "
"Кількість повторів (\"найкраще з 5\"), яка повідомляє вам, скільки разів "
"цикл синхронізації повторювався, і, нарешті, час, який у середньому "
"витрачено на тіло оператора протягом найкращого повторення циклу "
"синхронізації. Тобто час найшвидшого повторення, поділений на кількість "
"циклів."

msgid "The same can be done using the :class:`Timer` class and its methods::"
msgstr ""
"Те саме можна зробити за допомогою класу :class:`Timer` та його методів:"

msgid ""
"The following examples show how to time expressions that contain multiple "
"lines. Here we compare the cost of using :func:`hasattr` vs. :keyword:`try`/:"
"keyword:`except` to test for missing and present object attributes:"
msgstr ""
"У наведених нижче прикладах показано, як визначити час для виразів, які "
"містять кілька рядків. Тут ми порівнюємо вартість використання :func:"
"`hasattr` і :keyword:`try`/:keyword:`except` для перевірки відсутніх і "
"присутніх атрибутів об’єкта:"

msgid ""
"To give the :mod:`timeit` module access to functions you define, you can "
"pass a *setup* parameter which contains an import statement::"
msgstr ""
"Щоб надати модулю :mod:`timeit` доступ до визначених вами функцій, ви можете "
"передати параметр *setup*, який містить оператор імпорту::"

msgid ""
"Another option is to pass :func:`globals` to the  *globals* parameter, which "
"will cause the code to be executed within your current global namespace.  "
"This can be more convenient than individually specifying imports::"
msgstr ""
"Іншим варіантом є передача :func:`globals` у параметр *globals*, що "
"спричинить виконання коду у вашому поточному глобальному просторі імен. Це "
"може бути зручніше, ніж індивідуальне визначення імпорту:"
