# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:08+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`imp` --- Access the :ref:`import <importsystem>` internals"
msgstr ""
":mod:`imp` --- Доступ до внутрішніх елементів :ref:`import <importsystem>`"

msgid "**Source code:** :source:`Lib/imp.py`"
msgstr "**Вихідний код:** :source:`Lib/imp.py`"

msgid "The :mod:`imp` module is deprecated in favor of :mod:`importlib`."
msgstr "Модуль :mod:`imp` застарів на користь :mod:`importlib`."

msgid ""
"This module provides an interface to the mechanisms used to implement the :"
"keyword:`import` statement.  It defines the following constants and "
"functions:"
msgstr ""
"Цей модуль надає інтерфейс для механізмів, що використовуються для "
"реалізації оператора :keyword:`import`. Він визначає такі константи та "
"функції:"

msgid ""
"Return the magic string value used to recognize byte-compiled code files (:"
"file:`.pyc` files).  (This value may be different for each Python version.)"
msgstr ""
"Повертає магічне значення рядка, яке використовується для розпізнавання "
"файлів зі скомпільованим кодом (:file:`.pyc` файли). (Це значення може "
"відрізнятися для кожної версії Python.)"

msgid "Use :attr:`importlib.util.MAGIC_NUMBER` instead."
msgstr "Натомість використовуйте :attr:`importlib.util.MAGIC_NUMBER`."

msgid ""
"Return a list of 3-element tuples, each describing a particular type of "
"module. Each triple has the form ``(suffix, mode, type)``, where *suffix* is "
"a string to be appended to the module name to form the filename to search "
"for, *mode* is the mode string to pass to the built-in :func:`open` function "
"to open the file (this can be ``'r'`` for text files or ``'rb'`` for binary "
"files), and *type* is the file type, which has one of the values :const:"
"`PY_SOURCE`, :const:`PY_COMPILED`, or :const:`C_EXTENSION`, described below."
msgstr ""
"Повертає список 3-елементних кортежів, кожен з яких описує певний тип "
"модуля. Кожна трійка має вигляд ``(суфікс, режим, тип)``, де *суфікс* — це "
"рядок, який додається до назви модуля, щоб сформувати назву файлу для "
"пошуку, *mode* — це рядок режиму, який передається до вбудована функція :"
"func:`open` для відкриття файлу (це може бути ``'r'`` для текстових файлів "
"або ``'rb'`` для бінарних файлів), а *type* — це тип файлу, який має одне зі "
"значень :const:`PY_SOURCE`, :const:`PY_COMPILED` або :const:`C_EXTENSION`, "
"описаних нижче."

msgid "Use the constants defined on :mod:`importlib.machinery` instead."
msgstr ""
"Натомість використовуйте константи, визначені в :mod:`importlib.machinery`."

msgid ""
"Try to find the module *name*.  If *path* is omitted or ``None``, the list "
"of directory names given by ``sys.path`` is searched, but first a few "
"special places are searched: the function tries to find a built-in module "
"with the given name (:const:`C_BUILTIN`), then a frozen module (:const:"
"`PY_FROZEN`), and on some systems some other places are looked in as well "
"(on Windows, it looks in the registry which may point to a specific file)."
msgstr ""
"Спробуйте знайти *ім’я* модуля. Якщо *path* пропущено або ``None``, пошук "
"здійснюється за списком імен каталогів, наданим ``sys.path``, але спочатку "
"виконується пошук у кількох спеціальних місцях: функція намагається знайти "
"вбудований модуль за допомогою дане ім’я (:const:`C_BUILTIN`), потім "
"заморожений модуль (:const:`PY_FROZEN`), а в деяких системах також "
"переглядаються деякі інші місця (у Windows шукається в реєстрі, який може "
"вказувати на певний файл)."

msgid ""
"Otherwise, *path* must be a list of directory names; each directory is "
"searched for files with any of the suffixes returned by :func:`get_suffixes` "
"above.  Invalid names in the list are silently ignored (but all list items "
"must be strings)."
msgstr ""
"В іншому випадку *path* має бути списком імен каталогів; у кожному каталозі "
"шукаються файли з будь-якими суфіксами, які повертає :func:`get_suffixes` "
"вище. Недійсні імена в списку мовчки ігноруються (але всі елементи списку "
"мають бути рядками)."

msgid ""
"If search is successful, the return value is a 3-element tuple ``(file, "
"pathname, description)``:"
msgstr ""
"Якщо пошук пройшов успішно, повертається значення 3-елементного кортежу "
"``(файл, шлях, опис)``:"

msgid ""
"*file* is an open :term:`file object` positioned at the beginning, "
"*pathname* is the pathname of the file found, and *description* is a 3-"
"element tuple as contained in the list returned by :func:`get_suffixes` "
"describing the kind of module found."
msgstr ""
"*file* — це відкритий :term:`file object`, розташований на початку, "
"*pathname* — це шлях до знайденого файлу, а *description* — це 3-елементний "
"кортеж, який міститься у списку, який повертає :func:`get_suffixes`, що "
"описує вид знайденого модуля."

msgid ""
"If the module is built-in or frozen then *file* and *pathname* are both "
"``None`` and the *description* tuple contains empty strings for its suffix "
"and mode; the module type is indicated as given in parentheses above.  If "
"the search is unsuccessful, :exc:`ImportError` is raised.  Other exceptions "
"indicate problems with the arguments or environment."
msgstr ""
"Якщо модуль вбудований або заморожений, тоді *file* і *pathname* мають "
"значення ``None``, а кортеж *description* містить порожні рядки для свого "
"суфікса та режиму; тип модуля вказано у дужках вище. Якщо пошук невдалий, "
"виникає :exc:`ImportError`. Інші винятки вказують на проблеми з аргументами "
"або середовищем."

msgid ""
"If the module is a package, *file* is ``None``, *pathname* is the package "
"path and the last item in the *description* tuple is :const:`PKG_DIRECTORY`."
msgstr ""
"Якщо модуль є пакетом, *file* має значення ``None``, *pathname* — це шлях до "
"пакета, а останнім елементом у кортежі *description* є :const:"
"`PKG_DIRECTORY`."

msgid ""
"This function does not handle hierarchical module names (names containing "
"dots).  In order to find *P.M*, that is, submodule *M* of package *P*, use :"
"func:`find_module` and :func:`load_module` to find and load package *P*, and "
"then use :func:`find_module` with the *path* argument set to ``P.__path__``. "
"When *P* itself has a dotted name, apply this recipe recursively."
msgstr ""
"Ця функція не обробляє ієрархічні імена модулів (імена, що містять крапки). "
"Щоб знайти *P.M*, тобто підмодуль *M* пакета *P*, використовуйте :func:"
"`find_module` і :func:`load_module`, щоб знайти та завантажити пакет *P*, а "
"потім використовуйте :func:`find_module` з аргументом *path*, встановленим "
"на ``P.__path__``. Якщо *P* має назву з крапками, застосовуйте цей рецепт "
"рекурсивно."

msgid ""
"Use :func:`importlib.util.find_spec` instead unless Python 3.3 compatibility "
"is required, in which case use :func:`importlib.find_loader`. For example "
"usage of the former case, see the :ref:`importlib-examples` section of the :"
"mod:`importlib` documentation."
msgstr ""
"Використовуйте :func:`importlib.util.find_spec` замість цього, якщо не "
"потрібна сумісність з Python 3.3, у такому випадку використовуйте :func:"
"`importlib.find_loader`. Для прикладу використання першого випадку дивіться "
"розділ :ref:`importlib-examples` документації :mod:`importlib`."

msgid ""
"Load a module that was previously found by :func:`find_module` (or by an "
"otherwise conducted search yielding compatible results).  This function does "
"more than importing the module: if the module was already imported, it will "
"reload the module!  The *name* argument indicates the full module name "
"(including the package name, if this is a submodule of a package).  The "
"*file* argument is an open file, and *pathname* is the corresponding file "
"name; these can be ``None`` and ``''``, respectively, when the module is a "
"package or not being loaded from a file.  The *description* argument is a "
"tuple, as would be returned by :func:`get_suffixes`, describing what kind of "
"module must be loaded."
msgstr ""
"Завантажте модуль, який раніше було знайдено за допомогою :func:"
"`find_module` (або за допомогою іншого здійсненого пошуку, що дає сумісні "
"результати). Ця функція робить більше, ніж імпорт модуля: якщо модуль уже "
"було імпортовано, він перезавантажить модуль! Аргумент *name* вказує на "
"повну назву модуля (включно з назвою пакета, якщо це підмодуль пакета). "
"Аргумент *file* — це відкритий файл, а *pathname* — ім’я відповідного файлу; "
"вони можуть бути ``None`` і ``''`` відповідно, якщо модуль є пакетом або не "
"завантажується з файлу. Аргумент *description* є кортежем, який повертає :"
"func:`get_suffixes`, описуючи тип модуля, який потрібно завантажити."

msgid ""
"If the load is successful, the return value is the module object; otherwise, "
"an exception (usually :exc:`ImportError`) is raised."
msgstr ""
"Якщо завантаження пройшло успішно, повертається значення об’єкта модуля; "
"інакше виникає виняток (зазвичай :exc:`ImportError`)."

msgid ""
"**Important:** the caller is responsible for closing the *file* argument, if "
"it was not ``None``, even when an exception is raised.  This is best done "
"using a :keyword:`try` ... :keyword:`finally` statement."
msgstr ""
"**Важливо:** абонент, що викликає, відповідає за закриття аргументу *file*, "
"якщо він не був ``None``, навіть якщо виникає виняток. Найкраще це зробити "
"за допомогою оператора :keyword:`try` ... :keyword:`finally`."

msgid ""
"If previously used in conjunction with :func:`imp.find_module` then consider "
"using :func:`importlib.import_module`, otherwise use the loader returned by "
"the replacement you chose for :func:`imp.find_module`. If you called :func:"
"`imp.load_module` and related functions directly with file path arguments "
"then use a combination of :func:`importlib.util.spec_from_file_location` "
"and :func:`importlib.util.module_from_spec`. See the :ref:`importlib-"
"examples` section of the :mod:`importlib` documentation for details of the "
"various approaches."
msgstr ""
"Якщо раніше використовувався в поєднанні з :func:`imp.find_module`, "
"розгляньте можливість використання :func:`importlib.import_module`, інакше "
"використовуйте завантажувач, повернутий заміною, яку ви вибрали для :func:"
"`imp.find_module`. Якщо ви викликали :func:`imp.load_module` та пов’язані "
"функції безпосередньо з аргументами шляху до файлу, тоді використовуйте "
"комбінацію :func:`importlib.util.spec_from_file_location` та :func:"
"`importlib.util.module_from_spec`. Перегляньте розділ :ref:`importlib-"
"examples` документації :mod:`importlib` для детальної інформації про різні "
"підходи."

msgid ""
"Return a new empty module object called *name*.  This object is *not* "
"inserted in ``sys.modules``."
msgstr ""
"Повертає новий порожній об’єкт модуля під назвою *name*. Цей об’єкт *не* "
"вставляється в ``sys.modules``."

msgid "Use :func:`importlib.util.module_from_spec` instead."
msgstr "Натомість використовуйте :func:`importlib.util.module_from_spec`."

msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is useful "
"if you have edited the module source file using an external editor and want "
"to try out the new version without leaving the Python interpreter.  The "
"return value is the module object (the same as the *module* argument)."
msgstr ""
"Перезавантажте раніше імпортований *модуль*. Аргумент має бути об’єктом "
"модуля, тому він має бути успішно імпортований раніше. Це корисно, якщо ви "
"відредагували вихідний файл модуля за допомогою зовнішнього редактора і "
"хочете випробувати нову версію, не виходячи з інтерпретатора Python. "
"Поверненим значенням є об’єкт модуля (те саме, що аргумент *module*)."

msgid "When ``reload(module)`` is executed:"
msgstr "Коли виконується ``reload(module)``:"

msgid ""
"Python modules' code is recompiled and the module-level code reexecuted, "
"defining a new set of objects which are bound to names in the module's "
"dictionary.  The ``init`` function of extension modules is not called a "
"second time."
msgstr ""
"Код модулів Python перекомпілюється, а код рівня модуля повторно "
"виконується, визначаючи новий набір об’єктів, які прив’язані до імен у "
"словнику модуля. Функція ``init`` модулів розширення не викликається вдруге."

msgid ""
"As with all other objects in Python the old objects are only reclaimed after "
"their reference counts drop to zero."
msgstr ""
"Як і у випадку з усіма іншими об’єктами в Python, старі об’єкти "
"відновлюються лише після того, як їх кількість посилань зменшується до нуля."

msgid ""
"The names in the module namespace are updated to point to any new or changed "
"objects."
msgstr ""
"Імена в просторі імен модуля оновлюються, щоб вказувати на будь-які нові або "
"змінені об’єкти."

msgid ""
"Other references to the old objects (such as names external to the module) "
"are not rebound to refer to the new objects and must be updated in each "
"namespace where they occur if that is desired."
msgstr ""
"Інші посилання на старі об’єкти (наприклад, імена, зовнішні по відношенню до "
"модуля) не повертаються до нових об’єктів і повинні бути оновлені в кожному "
"просторі імен, де вони зустрічаються, якщо це потрібно."

msgid "There are a number of other caveats:"
msgstr "Існує ряд інших застережень:"

msgid ""
"When a module is reloaded, its dictionary (containing the module's global "
"variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a "
"module does not define a name that was defined by the old version, the old "
"definition remains.  This feature can be used to the module's advantage if "
"it maintains a global table or cache of objects --- with a :keyword:`try` "
"statement it can test for the table's presence and skip its initialization "
"if desired::"
msgstr ""
"Коли модуль перезавантажується, його словник (що містить глобальні змінні "
"модуля) зберігається. Перевизначення імен замінить старі визначення, тому "
"це, як правило, не проблема. Якщо нова версія модуля не визначає назву, яка "
"була визначена старою версією, старе визначення залишається. Цю функцію "
"можна використати на користь модуля, якщо він підтримує глобальну таблицю "
"або кеш об’єктів --- за допомогою оператора :keyword:`try` він може "
"перевіряти наявність таблиці та пропускати її ініціалізацію, якщо потрібно:"

msgid ""
"It is legal though generally not very useful to reload built-in or "
"dynamically loaded modules, except for :mod:`sys`, :mod:`__main__` and :mod:"
"`builtins`. In many cases, however, extension modules are not designed to be "
"initialized more than once, and may fail in arbitrary ways when reloaded."
msgstr ""
"Перезавантажувати вбудовані або динамічно завантажувані модулі, за винятком :"
"mod:`sys`, :mod:`__main__` і :mod:`builtins`, є законним, хоча загалом не "
"дуже корисно. Однак у багатьох випадках модулі розширення не призначені для "
"ініціалізації більше ніж один раз і можуть виходити з ладу довільним чином "
"під час перезавантаження."

msgid ""
"If a module imports objects from another module using :keyword:`from` ... :"
"keyword:`import` ..., calling :func:`reload` for the other module does not "
"redefine the objects imported from it --- one way around this is to re-"
"execute the :keyword:`!from` statement, another is to use :keyword:`!import` "
"and qualified names (*module*.*name*) instead."
msgstr ""
"Якщо модуль імпортує об’єкти з іншого модуля за допомогою :keyword:"
"`from` ... :keyword:`import` ..., виклик :func:`reload` для іншого модуля не "
"перевизначає об’єкти, імпортовані з нього --- один спосіб обійти це — "
"повторно виконати оператор :keyword:`!from`, інший — використати замість "
"нього :keyword:`!import` і кваліфіковані імена (*module*.*name*)."

msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances "
"--- they continue to use the old class definition.  The same is true for "
"derived classes."
msgstr ""
"Якщо модуль створює екземпляри класу, перезавантаження модуля, який визначає "
"клас, не впливає на визначення методів екземплярів --- вони продовжують "
"використовувати старе визначення класу. Те саме стосується похідних класів."

msgid ""
"Relies on both ``__name__`` and ``__loader__`` being defined on the module "
"being reloaded instead of just ``__name__``."
msgstr ""
"Покладається на те, що ``__name__`` і ``__loader__`` визначені в модулі, "
"який перезавантажується, а не просто ``__name__``."

msgid "Use :func:`importlib.reload` instead."
msgstr "Натомість використовуйте :func:`importlib.reload`."

msgid ""
"The following functions are conveniences for handling :pep:`3147` byte-"
"compiled file paths."
msgstr ""
"Наступні функції є зручними для обробки шляхів :pep:`3147` скомпільованих "
"файлів."

msgid ""
"Return the :pep:`3147` path to the byte-compiled file associated with the "
"source *path*.  For example, if *path* is ``/foo/bar/baz.py`` the return "
"value would be ``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python 3.2. "
"The ``cpython-32`` string comes from the current magic tag (see :func:"
"`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined then :exc:"
"`NotImplementedError` will be raised). By passing in ``True`` or ``False`` "
"for *debug_override* you can override the system's value for ``__debug__``, "
"leading to optimized bytecode."
msgstr ""
"Поверніть шлях :pep:`3147` до скомпільованого файлу, пов’язаного з вихідним "
"*шляхом*. Наприклад, якщо *path* є ``/foo/bar/baz.py``, значення, що "
"повертається, буде ``/foo/bar/__pycache__/baz.cpython-32.pyc`` для Python "
"3.2. Рядок ``cpython-32`` походить від поточного магічного тегу (див. :func:"
"`get_tag`; якщо :attr:`sys.implementation.cache_tag` не визначено, тоді буде "
"викликана :exc:`NotImplementedError`). Передаючи ``True`` або ``False`` для "
"*debug_override*, ви можете змінити системне значення для ``__debug__``, що "
"призведе до оптимізації байт-коду."

msgid "*path* need not exist."
msgstr "*шлях* не повинен існувати."

msgid ""
"If :attr:`sys.implementation.cache_tag` is ``None``, then :exc:"
"`NotImplementedError` is raised."
msgstr ""
"Якщо :attr:`sys.implementation.cache_tag` має значення ``None``, тоді "
"виникає :exc:`NotImplementedError`."

msgid "Use :func:`importlib.util.cache_from_source` instead."
msgstr "Натомість використовуйте :func:`importlib.util.cache_from_source`."

msgid "The *debug_override* parameter no longer creates a ``.pyo`` file."
msgstr "Параметр *debug_override* більше не створює файл ``.pyo``."

msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source "
"code file path.  For example, if *path* is ``/foo/bar/__pycache__/baz."
"cpython-32.pyc`` the returned path would be ``/foo/bar/baz.py``.  *path* "
"need not exist, however if it does not conform to :pep:`3147` format, a :exc:"
"`ValueError` is raised. If :attr:`sys.implementation.cache_tag` is not "
"defined, :exc:`NotImplementedError` is raised."
msgstr ""
"Враховуючи *шлях* до імені файлу :pep:`3147`, поверніть пов’язаний шлях до "
"файлу вихідного коду. Наприклад, якщо *шлях* є ``/foo/bar/__pycache__/baz."
"cpython-32.pyc``, повернутий шлях буде ``/foo/bar/baz.py``. *path* не "
"обов’язково існує, однак, якщо він не відповідає формату :pep:`3147`, "
"виникає :exc:`ValueError`. Якщо :attr:`sys.implementation.cache_tag` не "
"визначено, виникає :exc:`NotImplementedError`."

msgid ""
"Raise :exc:`NotImplementedError` when :attr:`sys.implementation.cache_tag` "
"is not defined."
msgstr ""
"Викликати :exc:`NotImplementedError`, коли :attr:`sys.implementation."
"cache_tag` не визначено."

msgid "Use :func:`importlib.util.source_from_cache` instead."
msgstr "Натомість використовуйте :func:`importlib.util.source_from_cache`."

msgid ""
"Return the :pep:`3147` magic tag string matching this version of Python's "
"magic number, as returned by :func:`get_magic`."
msgstr ""
"Повертає рядок магічного тегу :pep:`3147`, що відповідає цій версії "
"магічного числа Python, яке повертає :func:`get_magic`."

msgid ""
"Use :attr:`sys.implementation.cache_tag` directly starting in Python 3.3."
msgstr ""
"Використовуйте :attr:`sys.implementation.cache_tag` безпосередньо, починаючи "
"з Python 3.3."

msgid ""
"The following functions help interact with the import system's internal "
"locking mechanism.  Locking semantics of imports are an implementation "
"detail which may vary from release to release.  However, Python ensures that "
"circular imports work without any deadlocks."
msgstr ""
"Наступні функції допомагають взаємодіяти з внутрішнім механізмом блокування "
"системи імпорту. Семантика блокування імпорту є деталлю реалізації, яка може "
"відрізнятися від випуску до випуску. Однак Python гарантує, що циклічний "
"імпорт працює без будь-яких взаємоблокувань."

msgid ""
"Return ``True`` if the global import lock is currently held, else ``False``. "
"On platforms without threads, always return ``False``."
msgstr ""
"Повертає ``True``, якщо наразі утримується глобальне блокування імпорту, "
"інакше ``False``. На платформах без потоків завжди повертайте ``False``."

msgid ""
"On platforms with threads, a thread executing an import first holds a global "
"import lock, then sets up a per-module lock for the rest of the import.  "
"This blocks other threads from importing the same module until the original "
"import completes, preventing other threads from seeing incomplete module "
"objects constructed by the original thread.  An exception is made for "
"circular imports, which by construction have to expose an incomplete module "
"object at some point."
msgstr ""
"На платформах із потоками потік, який виконує імпорт, спочатку утримує "
"глобальне блокування імпорту, а потім встановлює блокування кожного модуля "
"для решти імпорту. Це блокує інші потоки від імпорту того самого модуля до "
"завершення оригінального імпорту, не даючи іншим потокам побачити "
"незавершені об’єкти модуля, створені вихідним потоком. Виняток зроблено для "
"циклічного імпорту, який за своєю конструкцією в певний момент має відкрити "
"незавершений об’єкт модуля."

msgid ""
"The locking scheme has changed to per-module locks for the most part.  A "
"global import lock is kept for some critical tasks, such as initializing the "
"per-module locks."
msgstr ""
"Схема блокування здебільшого змінена на помодульні блокування. Глобальне "
"блокування імпорту зберігається для деяких критичних завдань, таких як "
"ініціалізація блокувань для кожного модуля."

msgid ""
"Acquire the interpreter's global import lock for the current thread. This "
"lock should be used by import hooks to ensure thread-safety when importing "
"modules."
msgstr ""
"Отримати глобальне блокування імпорту інтерпретатора для поточного потоку. "
"Це блокування має використовуватися гаками імпорту, щоб забезпечити безпеку "
"потоків під час імпорту модулів."

msgid ""
"Once a thread has acquired the import lock, the same thread may acquire it "
"again without blocking; the thread must release it once for each time it has "
"acquired it."
msgstr ""
"Як тільки потік отримав блокування імпорту, той самий потік може отримати "
"його знову без блокування; потік повинен звільнити його один раз за кожен "
"раз, коли він його отримав."

msgid "On platforms without threads, this function does nothing."
msgstr "На платформах без потоків ця функція нічого не робить."

msgid ""
"Release the interpreter's global import lock. On platforms without threads, "
"this function does nothing."
msgstr ""
"Звільніть глобальне блокування імпорту інтерпретатора. На платформах без "
"потоків ця функція нічого не робить."

msgid ""
"The following constants with integer values, defined in this module, are "
"used to indicate the search result of :func:`find_module`."
msgstr ""
"Наступні константи з цілими значеннями, визначені в цьому модулі, "
"використовуються для позначення результату пошуку :func:`find_module`."

msgid "The module was found as a source file."
msgstr "Модуль знайдено як вихідний файл."

msgid "The module was found as a compiled code object file."
msgstr "Модуль знайдено як скомпільований об’єктний файл коду."

msgid "The module was found as dynamically loadable shared library."
msgstr ""
"Модуль було знайдено як спільну бібліотеку, що динамічно завантажується."

msgid "The module was found as a package directory."
msgstr "Модуль знайдено як каталог пакунків."

msgid "The module was found as a built-in module."
msgstr "Модуль знайдено як вбудований модуль."

msgid "The module was found as a frozen module."
msgstr "Модуль було знайдено як заморожений."

msgid ""
"The :class:`NullImporter` type is a :pep:`302` import hook that handles non-"
"directory path strings by failing to find any modules.  Calling this type "
"with an existing directory or empty string raises :exc:`ImportError`. "
"Otherwise, a :class:`NullImporter` instance is returned."
msgstr ""
"Тип :class:`NullImporter` — це :pep:`302` хук імпорту, який обробляє рядки "
"шляху, не пов’язані з каталогом, не знаходячи жодного модуля. Виклик цього "
"типу з наявним каталогом або порожнім рядком викликає :exc:`ImportError`. В "
"іншому випадку повертається екземпляр :class:`NullImporter`."

msgid "Instances have only one method:"
msgstr "Примірники мають лише один метод:"

msgid ""
"This method always returns ``None``, indicating that the requested module "
"could not be found."
msgstr ""
"Цей метод завжди повертає ``None``, вказуючи, що запитуваний модуль не "
"вдалося знайти."

msgid ""
"``None`` is inserted into ``sys.path_importer_cache`` instead of an instance "
"of :class:`NullImporter`."
msgstr ""
"``None`` вставляється в ``sys.path_importer_cache`` замість екземпляра :"
"class:`NullImporter`."

msgid "Insert ``None`` into ``sys.path_importer_cache`` instead."
msgstr "Натомість вставте ``None`` у ``sys.path_importer_cache``."

msgid "Examples"
msgstr "Приклади"

msgid ""
"The following function emulates what was the standard import statement up to "
"Python 1.4 (no hierarchical module names).  (This *implementation* wouldn't "
"work in that version, since :func:`find_module` has been extended and :func:"
"`load_module` has been added in 1.4.) ::"
msgstr ""
"Наступна функція емулює те, що було стандартним оператором імпорту до Python "
"1.4 (без ієрархічних імен модулів). (Ця *реалізація* не працюватиме в цій "
"версії, оскільки :func:`find_module` було розширено, а :func:`load_module` "
"додано у 1.4.) ::"
