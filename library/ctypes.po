# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:03+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`ctypes` --- A foreign function library for Python"
msgstr ":mod:`ctypes` --- Інша бібліотека функцій для Python"

msgid ""
":mod:`ctypes` is a foreign function library for Python.  It provides C "
"compatible data types, and allows calling functions in DLLs or shared "
"libraries.  It can be used to wrap these libraries in pure Python."
msgstr ""
":mod:`ctypes` — це бібліотека зовнішніх функцій для Python. Він надає C-"
"сумісні типи даних і дозволяє викликати функції в DLL або спільних "
"бібліотеках. Його можна використовувати, щоб обернути ці бібліотеки в чистий "
"Python."

msgid "ctypes tutorial"
msgstr "підручник ctypes"

msgid ""
"Note: The code samples in this tutorial use :mod:`doctest` to make sure that "
"they actually work.  Since some code samples behave differently under Linux, "
"Windows, or macOS, they contain doctest directives in comments."
msgstr ""
"Примітка: зразки коду в цьому підручнику використовують :mod:`doctest`, щоб "
"переконатися, що вони справді працюють. Оскільки деякі зразки коду "
"поводяться по-різному в Linux, Windows або macOS, вони містять директиви "
"doctest у коментарях."

msgid ""
"Note: Some code samples reference the ctypes :class:`c_int` type.  On "
"platforms where ``sizeof(long) == sizeof(int)`` it is an alias to :class:"
"`c_long`. So, you should not be confused if :class:`c_long` is printed if "
"you would expect :class:`c_int` --- they are actually the same type."
msgstr ""
"Примітка. Деякі зразки коду посилаються на тип ctypes :class:`c_int`. На "
"платформах, де ``sizeof(long) == sizeof(int)``, це псевдонім :class:"
"`c_long`. Отже, вас не повинно бентежити, якщо надруковано :class:`c_long`, "
"якщо ви очікуєте :class:`c_int` --- вони насправді одного типу."

msgid "Loading dynamic link libraries"
msgstr "Завантаження бібліотек динамічних посилань"

msgid ""
":mod:`ctypes` exports the *cdll*, and on Windows *windll* and *oledll* "
"objects, for loading dynamic link libraries."
msgstr ""
":mod:`ctypes` експортує *cdll*, а в Windows об’єкти *windll* і *oledll* для "
"завантаження бібліотек динамічних посилань."

msgid ""
"You load libraries by accessing them as attributes of these objects. *cdll* "
"loads libraries which export functions using the standard ``cdecl`` calling "
"convention, while *windll* libraries call functions using the ``stdcall`` "
"calling convention. *oledll* also uses the ``stdcall`` calling convention, "
"and assumes the functions return a Windows :c:type:`HRESULT` error code. The "
"error code is used to automatically raise an :class:`OSError` exception when "
"the function call fails."
msgstr ""
"Ви завантажуєте бібліотеки, звертаючись до них як до атрибутів цих об’єктів. "
"*cdll* завантажує бібліотеки, які експортують функції за допомогою "
"стандартної угоди про виклики ``cdecl``, тоді як бібліотеки *windll* "
"викликають функції за допомогою угоди про виклики ``stdcall``. *oledll* "
"також використовує угоду про виклики ``stdcall`` і передбачає, що функції "
"повертають код помилки Windows :c:type:`HRESULT`. Код помилки "
"використовується для автоматичного виклику винятку :class:`OSError`, коли "
"виклик функції не вдається."

msgid ""
"Windows errors used to raise :exc:`WindowsError`, which is now an alias of :"
"exc:`OSError`."
msgstr ""
"Помилки Windows викликали :exc:`WindowsError`, який тепер є псевдонімом :exc:"
"`OSError`."

msgid ""
"Here are some examples for Windows. Note that ``msvcrt`` is the MS standard "
"C library containing most standard C functions, and uses the cdecl calling "
"convention::"
msgstr ""
"Ось кілька прикладів для Windows. Зауважте, що msvcrt — це стандартна "
"бібліотека C MS, яка містить більшість стандартних функцій C і використовує "
"угоду про виклик cdecl:"

msgid "Windows appends the usual ``.dll`` file suffix automatically."
msgstr "Windows автоматично додає звичайний суфікс файлу ``.dll``."

msgid ""
"Accessing the standard C library through ``cdll.msvcrt`` will use an "
"outdated version of the library that may be incompatible with the one being "
"used by Python. Where possible, use native Python functionality, or else "
"import and use the ``msvcrt`` module."
msgstr ""
"Доступ до стандартної бібліотеки C через ``cdll.msvcrt`` використовуватиме "
"застарілу версію бібліотеки, яка може бути несумісною з тією, що "
"використовується Python. Якщо можливо, використовуйте власні функції Python "
"або імпортуйте та використовуйте модуль ``msvcrt``."

msgid ""
"On Linux, it is required to specify the filename *including* the extension "
"to load a library, so attribute access can not be used to load libraries. "
"Either the :meth:`LoadLibrary` method of the dll loaders should be used, or "
"you should load the library by creating an instance of CDLL by calling the "
"constructor::"
msgstr ""
"У Linux для завантаження бібліотеки потрібно вказати назву файлу *включаючи* "
"розширення, тому доступ до атрибутів не можна використовувати для "
"завантаження бібліотек. Слід використовувати або метод :meth:`LoadLibrary` "
"завантажувачів dll, або ви повинні завантажити бібліотеку, створивши "
"екземпляр CDLL, викликавши конструктор::"

msgid "Accessing functions from loaded dlls"
msgstr "Доступ до функцій із завантажених dll"

msgid "Functions are accessed as attributes of dll objects::"
msgstr "Доступ до функцій здійснюється як атрибути об’єктів dll::"

msgid ""
"Note that win32 system dlls like ``kernel32`` and ``user32`` often export "
"ANSI as well as UNICODE versions of a function. The UNICODE version is "
"exported with an ``W`` appended to the name, while the ANSI version is "
"exported with an ``A`` appended to the name. The win32 ``GetModuleHandle`` "
"function, which returns a *module handle* for a given module name, has the "
"following C prototype, and a macro is used to expose one of them as "
"``GetModuleHandle`` depending on whether UNICODE is defined or not::"
msgstr ""
"Зауважте, що системні бібліотеки win32, такі як ``kernel32`` і ``user32``, "
"часто експортують версії функції ANSI, а також UNICODE. Версія UNICODE "
"експортується з буквою ``W``, доданою до назви, тоді як версія ANSI "
"експортується з ``A``, доданою до назви. Функція ``GetModuleHandle`` win32, "
"яка повертає *дескриптор модуля* для даного імені модуля, має наступний "
"прототип C, і макрос використовується для надання одного з них як "
"``GetModuleHandle`` залежно від того, чи визначено UNICODE чи ні::"

msgid ""
"*windll* does not try to select one of them by magic, you must access the "
"version you need by specifying ``GetModuleHandleA`` or ``GetModuleHandleW`` "
"explicitly, and then call it with bytes or string objects respectively."
msgstr ""
"*windll* не намагається вибрати одну з них магією, ви повинні отримати "
"доступ до потрібної вам версії, явно вказавши ``GetModuleHandleA`` або "
"``GetModuleHandleW``, а потім викликати його за допомогою байтів або "
"рядкових об’єктів відповідно."

msgid ""
"Sometimes, dlls export functions with names which aren't valid Python "
"identifiers, like ``\"??2@YAPAXI@Z\"``. In this case you have to use :func:"
"`getattr` to retrieve the function::"
msgstr ""
"Іноді бібліотеки dll експортують функції з іменами, які не є дійсними "
"ідентифікаторами Python, наприклад ``\"??2@YAPAXI@Z\"``. У цьому випадку ви "
"повинні використовувати :func:`getattr`, щоб отримати функцію::"

msgid ""
"On Windows, some dlls export functions not by name but by ordinal. These "
"functions can be accessed by indexing the dll object with the ordinal "
"number::"
msgstr ""
"У Windows деякі бібліотеки DLL експортують функції не за назвою, а за "
"порядковим номером. Доступ до цих функцій можна отримати, проіндексувавши "
"об’єкт dll з порядковим номером::"

msgid "Calling functions"
msgstr "Функції виклику"

msgid ""
"You can call these functions like any other Python callable. This example "
"uses the ``time()`` function, which returns system time in seconds since the "
"Unix epoch, and the ``GetModuleHandleA()`` function, which returns a win32 "
"module handle."
msgstr ""
"Ви можете викликати ці функції, як і будь-які інші виклики Python. У цьому "
"прикладі використовується функція ``time()``, яка повертає системний час у "
"секундах з епохи Unix, і ``GetModuleHandleA()`` функція, яка повертає "
"дескриптор модуля win32."

msgid ""
"This example calls both functions with a ``NULL`` pointer (``None`` should "
"be used as the ``NULL`` pointer)::"
msgstr ""
"У цьому прикладі обидві функції викликаються за допомогою вказівника "
"``NULL`` (``None`` слід використовувати як вказівник ``NULL``):"

msgid ""
":exc:`ValueError` is raised when you call an ``stdcall`` function with the "
"``cdecl`` calling convention, or vice versa::"
msgstr ""
":exc:`ValueError` виникає, коли ви викликаєте функцію ``stdcall`` за угодою "
"про виклик ``cdecl``, або навпаки::"

msgid ""
"To find out the correct calling convention you have to look into the C "
"header file or the documentation for the function you want to call."
msgstr ""
"Щоб дізнатися правильну умову виклику, вам потрібно переглянути файл "
"заголовка C або документацію для функції, яку ви хочете викликати."

msgid ""
"On Windows, :mod:`ctypes` uses win32 structured exception handling to "
"prevent crashes from general protection faults when functions are called "
"with invalid argument values::"
msgstr ""
"У Windows :mod:`ctypes` використовує структуровану обробку винятків win32, "
"щоб запобігти збоям через загальні помилки захисту, коли функції "
"викликаються з недійсними значеннями аргументів:"

msgid ""
"There are, however, enough ways to crash Python with :mod:`ctypes`, so you "
"should be careful anyway.  The :mod:`faulthandler` module can be helpful in "
"debugging crashes (e.g. from segmentation faults produced by erroneous C "
"library calls)."
msgstr ""
"Однак існує достатньо способів аварійно завершити роботу Python за "
"допомогою :mod:`ctypes`, тому будьте обережні. Модуль :mod:`faulthandler` "
"може бути корисним для усунення збоїв (наприклад, через помилки сегментації, "
"спричинені помилковими викликами бібліотеки C)."

msgid ""
"``None``, integers, bytes objects and (unicode) strings are the only native "
"Python objects that can directly be used as parameters in these function "
"calls. ``None`` is passed as a C ``NULL`` pointer, bytes objects and strings "
"are passed as pointer to the memory block that contains their data (:c:expr:"
"`char *` or :c:expr:`wchar_t *`).  Python integers are passed as the "
"platforms default C :c:expr:`int` type, their value is masked to fit into "
"the C type."
msgstr ""

msgid ""
"Before we move on calling functions with other parameter types, we have to "
"learn more about :mod:`ctypes` data types."
msgstr ""
"Перш ніж перейти до виклику функцій з іншими типами параметрів, ми повинні "
"дізнатися більше про типи даних :mod:`ctypes`."

msgid "Fundamental data types"
msgstr "Основні типи даних"

msgid ":mod:`ctypes` defines a number of primitive C compatible data types:"
msgstr ":mod:`ctypes` визначає ряд примітивних C-сумісних типів даних:"

msgid "ctypes type"
msgstr "тип ctypes"

msgid "C type"
msgstr "тип С"

msgid "Python type"
msgstr "Тип Python"

msgid ":class:`c_bool`"
msgstr ":class:`c_bool`"

msgid ":c:expr:`_Bool`"
msgstr ""

msgid "bool (1)"
msgstr "bool (1)"

msgid ":class:`c_char`"
msgstr ":class:`c_char`"

msgid ":c:expr:`char`"
msgstr ""

msgid "1-character bytes object"
msgstr "1-символьний об'єкт байтів"

msgid ":class:`c_wchar`"
msgstr ":class:`c_wchar`"

msgid ":c:expr:`wchar_t`"
msgstr ""

msgid "1-character string"
msgstr "1-символьний рядок"

msgid ":class:`c_byte`"
msgstr ":class:`c_byte`"

msgid "int"
msgstr "внутр"

msgid ":class:`c_ubyte`"
msgstr ":class:`c_ubyte`"

msgid ":c:expr:`unsigned char`"
msgstr ""

msgid ":class:`c_short`"
msgstr ":class:`c_short`"

msgid ":c:expr:`short`"
msgstr ""

msgid ":class:`c_ushort`"
msgstr ":class:`c_ushort`"

msgid ":c:expr:`unsigned short`"
msgstr ""

msgid ":class:`c_int`"
msgstr ":class:`c_int`"

msgid ":c:expr:`int`"
msgstr ""

msgid ":class:`c_uint`"
msgstr ":class:`c_uint`"

msgid ":c:expr:`unsigned int`"
msgstr ""

msgid ":class:`c_long`"
msgstr ":class:`c_long`"

msgid ":c:expr:`long`"
msgstr ""

msgid ":class:`c_ulong`"
msgstr ":class:`c_ulong`"

msgid ":c:expr:`unsigned long`"
msgstr ""

msgid ":class:`c_longlong`"
msgstr ":class:`c_longlong`"

msgid ":c:expr:`__int64` or :c:expr:`long long`"
msgstr ""

msgid ":class:`c_ulonglong`"
msgstr ":class:`c_ulonglong`"

msgid ":c:expr:`unsigned __int64` or :c:expr:`unsigned long long`"
msgstr ""

msgid ":class:`c_size_t`"
msgstr ":class:`c_size_t`"

msgid ":c:expr:`size_t`"
msgstr ""

msgid ":class:`c_ssize_t`"
msgstr ":class:`c_ssize_t`"

msgid ":c:expr:`ssize_t` or :c:expr:`Py_ssize_t`"
msgstr ""

msgid ":class:`c_float`"
msgstr ":class:`c_float`"

msgid ":c:expr:`float`"
msgstr ""

msgid "float"
msgstr "плавати"

msgid ":class:`c_double`"
msgstr ":class:`c_double`"

msgid ":c:expr:`double`"
msgstr ""

msgid ":class:`c_longdouble`"
msgstr ":class:`c_longdouble`"

msgid ":c:expr:`long double`"
msgstr ""

msgid ":class:`c_char_p`"
msgstr ":class:`c_char_p`"

msgid ":c:expr:`char *` (NUL terminated)"
msgstr ""

msgid "bytes object or ``None``"
msgstr "bytes або ``None``"

msgid ":class:`c_wchar_p`"
msgstr ":class:`c_wchar_p`"

msgid ":c:expr:`wchar_t *` (NUL terminated)"
msgstr ""

msgid "string or ``None``"
msgstr "рядок або ``None``"

msgid ":class:`c_void_p`"
msgstr ":class:`c_void_p`"

msgid ":c:expr:`void *`"
msgstr ""

msgid "int or ``None``"
msgstr "int або ``None``"

msgid "The constructor accepts any object with a truth value."
msgstr "Конструктор приймає будь-який об’єкт зі значенням істинності."

msgid ""
"All these types can be created by calling them with an optional initializer "
"of the correct type and value::"
msgstr ""
"Усі ці типи можна створити, викликавши їх із необов’язковим ініціалізатором "
"правильного типу та значення::"

msgid ""
"Since these types are mutable, their value can also be changed afterwards::"
msgstr "Оскільки ці типи є змінними, їх значення також можна змінити пізніше:"

msgid ""
"Assigning a new value to instances of the pointer types :class:`c_char_p`, :"
"class:`c_wchar_p`, and :class:`c_void_p` changes the *memory location* they "
"point to, *not the contents* of the memory block (of course not, because "
"Python bytes objects are immutable)::"
msgstr ""
"Присвоєння нового значення екземплярам типів покажчиків :class:`c_char_p`, :"
"class:`c_wchar_p` і :class:`c_void_p` змінює *місце пам’яті*, на яке вони "
"вказують, *не вміст* блоку пам’яті (звичайно, ні, оскільки об’єкти Python "
"bytes незмінні)::"

msgid ""
"You should be careful, however, not to pass them to functions expecting "
"pointers to mutable memory. If you need mutable memory blocks, ctypes has a :"
"func:`create_string_buffer` function which creates these in various ways.  "
"The current memory block contents can be accessed (or changed) with the "
"``raw`` property; if you want to access it as NUL terminated string, use the "
"``value`` property::"
msgstr ""
"Однак ви повинні бути обережними, щоб не передавати їх функціям, які "
"очікують покажчиків на змінну пам’ять. Якщо вам потрібні змінні блоки "
"пам’яті, ctypes має функцію :func:`create_string_buffer`, яка створює їх "
"різними способами. Доступ до поточного вмісту блоку пам’яті можна отримати "
"(або змінити) за допомогою властивості ``raw``; якщо ви бажаєте отримати до "
"нього доступ як до рядка з закінченням NUL, використовуйте властивість "
"``value``::"

msgid ""
"The :func:`create_string_buffer` function replaces the old :func:`c_buffer` "
"function (which is still available as an alias).  To create a mutable memory "
"block containing unicode characters of the C type :c:expr:`wchar_t`, use "
"the :func:`create_unicode_buffer` function."
msgstr ""

msgid "Calling functions, continued"
msgstr "Функції виклику, продовження"

msgid ""
"Note that printf prints to the real standard output channel, *not* to :data:"
"`sys.stdout`, so these examples will only work at the console prompt, not "
"from within *IDLE* or *PythonWin*::"
msgstr ""
"Зауважте, що printf друкує на справжній стандартний канал виводу, *а не* на :"
"data:`sys.stdout`, тому ці приклади працюватимуть лише у підказці консолі, а "
"не з *IDLE* або *PythonWin*::"

msgid ""
"As has been mentioned before, all Python types except integers, strings, and "
"bytes objects have to be wrapped in their corresponding :mod:`ctypes` type, "
"so that they can be converted to the required C data type::"
msgstr ""
"Як уже згадувалося раніше, усі типи Python, окрім цілих, рядкових і байтових "
"об’єктів, мають бути загорнуті у відповідний тип :mod:`ctypes`, щоб їх можна "
"було перетворити на необхідний тип даних C::"

msgid "Calling functions with your own custom data types"
msgstr "Виклик функцій із власними типами даних"

msgid ""
"You can also customize :mod:`ctypes` argument conversion to allow instances "
"of your own classes be used as function arguments.  :mod:`ctypes` looks for "
"an :attr:`_as_parameter_` attribute and uses this as the function argument.  "
"Of course, it must be one of integer, string, or bytes::"
msgstr ""
"Ви також можете налаштувати перетворення аргументів :mod:`ctypes`, щоб "
"екземпляри ваших власних класів могли використовуватися як аргументи "
"функції. :mod:`ctypes` шукає атрибут :attr:`_as_parameter_` і використовує "
"його як аргумент функції. Звичайно, це має бути ціле число, рядок або байти::"

msgid ""
"If you don't want to store the instance's data in the :attr:`_as_parameter_` "
"instance variable, you could define a :class:`property` which makes the "
"attribute available on request."
msgstr ""
"Якщо ви не хочете зберігати дані екземпляра в змінній екземпляра :attr:"
"`_as_parameter_`, ви можете визначити :class:`property`, що робить атрибут "
"доступним за запитом."

msgid "Specifying the required argument types (function prototypes)"
msgstr "Вказівка необхідних типів аргументів (прототипів функцій)"

msgid ""
"It is possible to specify the required argument types of functions exported "
"from DLLs by setting the :attr:`argtypes` attribute."
msgstr ""
"Можна вказати необхідні типи аргументів функцій, експортованих із DLL, "
"установивши атрибут :attr:`argtypes`."

msgid ""
":attr:`argtypes` must be a sequence of C data types (the ``printf`` function "
"is probably not a good example here, because it takes a variable number and "
"different types of parameters depending on the format string, on the other "
"hand this is quite handy to experiment with this feature)::"
msgstr ""
":attr:`argtypes` має бути послідовністю типів даних C (функція ``printf`` "
"тут, ймовірно, не є хорошим прикладом, оскільки вона приймає змінне число та "
"різні типи параметрів залежно від рядка формату, з іншого боку це дуже "
"зручно, щоб експериментувати з цією функцією)::"

msgid ""
"Specifying a format protects against incompatible argument types (just as a "
"prototype for a C function), and tries to convert the arguments to valid "
"types::"
msgstr ""
"Зазначення формату захищає від несумісних типів аргументів (як прототип для "
"функції C) і намагається перетворити аргументи на дійсні типи:"

msgid ""
"If you have defined your own classes which you pass to function calls, you "
"have to implement a :meth:`from_param` class method for them to be able to "
"use them in the :attr:`argtypes` sequence. The :meth:`from_param` class "
"method receives the Python object passed to the function call, it should do "
"a typecheck or whatever is needed to make sure this object is acceptable, "
"and then return the object itself, its :attr:`_as_parameter_` attribute, or "
"whatever you want to pass as the C function argument in this case. Again, "
"the result should be an integer, string, bytes, a :mod:`ctypes` instance, or "
"an object with an :attr:`_as_parameter_` attribute."
msgstr ""
"Якщо ви визначили власні класи, які передаєте до викликів функцій, вам "
"потрібно реалізувати метод класу :meth:`from_param`, щоб вони могли "
"використовувати їх у послідовності :attr:`argtypes`. Метод класу :meth:"
"`from_param` отримує об’єкт Python, переданий у виклик функції, він повинен "
"виконати перевірку типу або щось інше, щоб переконатися, що цей об’єкт "
"прийнятний, а потім повернути сам об’єкт, його :attr:`_as_parameter_` "
"атрибут або те, що ви хочете передати як аргумент функції C у цьому випадку. "
"Знову ж таки, результатом має бути ціле число, рядок, байти, екземпляр :mod:"
"`ctypes` або об’єкт з атрибутом :attr:`_as_parameter_`."

msgid "Return types"
msgstr "Типи повернення"

msgid ""
"By default functions are assumed to return the C :c:expr:`int` type.  Other "
"return types can be specified by setting the :attr:`restype` attribute of "
"the function object."
msgstr ""

msgid ""
"Here is a more advanced example, it uses the ``strchr`` function, which "
"expects a string pointer and a char, and returns a pointer to a string::"
msgstr ""
"Ось більш складний приклад, він використовує функцію ``strchr``, яка очікує "
"вказівник на рядок і char і повертає вказівник на рядок::"

msgid ""
"If you want to avoid the ``ord(\"x\")`` calls above, you can set the :attr:"
"`argtypes` attribute, and the second argument will be converted from a "
"single character Python bytes object into a C char::"
msgstr ""
"Якщо ви хочете уникнути викликів ``ord(\"x\")`` вище, ви можете встановити "
"атрибут :attr:`argtypes`, і другий аргумент буде перетворено з "
"односимвольного об’єкта Python bytes у C char: :"

msgid ""
"You can also use a callable Python object (a function or a class for "
"example) as the :attr:`restype` attribute, if the foreign function returns "
"an integer.  The callable will be called with the *integer* the C function "
"returns, and the result of this call will be used as the result of your "
"function call. This is useful to check for error return values and "
"automatically raise an exception::"
msgstr ""
"Ви також можете використовувати об’єкт Python, який можна викликати "
"(наприклад, функцію або клас) як атрибут :attr:`restype`, якщо зовнішня "
"функція повертає ціле число. Об’єкт, який викликається, буде викликано за "
"допомогою *цілого*, яке повертає функція C, і результат цього виклику буде "
"використано як результат виклику вашої функції. Це корисно для перевірки "
"значень, які повертаються помилки, і автоматичного виклику винятку::"

msgid ""
"``WinError`` is a function which will call Windows ``FormatMessage()`` api "
"to get the string representation of an error code, and *returns* an "
"exception. ``WinError`` takes an optional error code parameter, if no one is "
"used, it calls :func:`GetLastError` to retrieve it."
msgstr ""
"``WinError`` — це функція, яка викликає Windows ``FormatMessage()`` API, щоб "
"отримати рядкове представлення коду помилки, і *повертає* виняткову "
"ситуацію. ``WinError`` приймає додатковий параметр коду помилки, якщо ніхто "
"не використовується, він викликає :func:`GetLastError`, щоб отримати його."

msgid ""
"Please note that a much more powerful error checking mechanism is available "
"through the :attr:`errcheck` attribute; see the reference manual for details."
msgstr ""
"Зауважте, що набагато потужніший механізм перевірки помилок доступний через "
"атрибут :attr:`errcheck`; подробиці див. у довідковому посібнику."

msgid "Passing pointers (or: passing parameters by reference)"
msgstr "Передача покажчиків (або: передача параметрів за посиланням)"

msgid ""
"Sometimes a C api function expects a *pointer* to a data type as parameter, "
"probably to write into the corresponding location, or if the data is too "
"large to be passed by value. This is also known as *passing parameters by "
"reference*."
msgstr ""
"Іноді функція C API очікує *вказівника* на тип даних як параметр, ймовірно, "
"для запису у відповідне розташування або якщо дані завеликі для передачі за "
"значенням. Це також відомо як *передача параметрів за посиланням*."

msgid ""
":mod:`ctypes` exports the :func:`byref` function which is used to pass "
"parameters by reference.  The same effect can be achieved with the :func:"
"`pointer` function, although :func:`pointer` does a lot more work since it "
"constructs a real pointer object, so it is faster to use :func:`byref` if "
"you don't need the pointer object in Python itself::"
msgstr ""
":mod:`ctypes` експортує функцію :func:`byref`, яка використовується для "
"передачі параметрів за посиланням. Такого ж ефекту можна досягти за "
"допомогою функції :func:`pointer`, хоча :func:`pointer` виконує набагато "
"більше роботи, оскільки створює справжній об’єкт-вказівник, тому "
"використовувати :func:`byref` швидше не потрібен об’єкт покажчика в самому "
"Python::"

msgid "Structures and unions"
msgstr "Структури та спілки"

msgid ""
"Structures and unions must derive from the :class:`Structure` and :class:"
"`Union` base classes which are defined in the :mod:`ctypes` module. Each "
"subclass must define a :attr:`_fields_` attribute.  :attr:`_fields_` must be "
"a list of *2-tuples*, containing a *field name* and a *field type*."
msgstr ""
"Структури та об’єднання мають походити від базових класів :class:`Structure` "
"і :class:`Union`, які визначені в модулі :mod:`ctypes`. Кожен підклас "
"повинен визначати атрибут :attr:`_fields_`. :attr:`_fields_` має бути "
"списком *2-кортежів*, що містить *ім’я поля* та *тип поля*."

msgid ""
"The field type must be a :mod:`ctypes` type like :class:`c_int`, or any "
"other derived :mod:`ctypes` type: structure, union, array, pointer."
msgstr ""
"Тип поля має бути типу :mod:`ctypes`, наприклад :class:`c_int`, або будь-"
"якого іншого похідного типу :mod:`ctypes`: структура, об’єднання, масив, "
"покажчик."

msgid ""
"Here is a simple example of a POINT structure, which contains two integers "
"named *x* and *y*, and also shows how to initialize a structure in the "
"constructor::"
msgstr ""
"Ось простий приклад структури POINT, яка містить два цілі числа з іменами "
"*x* і *y*, а також показує, як ініціалізувати структуру в конструкторі::"

msgid ""
"You can, however, build much more complicated structures.  A structure can "
"itself contain other structures by using a structure as a field type."
msgstr ""
"Однак можна будувати набагато складніші конструкції. Структура може сама "
"містити інші структури, використовуючи структуру як тип поля."

msgid ""
"Here is a RECT structure which contains two POINTs named *upperleft* and "
"*lowerright*::"
msgstr ""
"Ось структура RECT, яка містить дві ТОЧКИ з іменами *upperleft* і "
"*lowerright*::"

msgid ""
"Nested structures can also be initialized in the constructor in several "
"ways::"
msgstr ""
"Вкладені структури також можна ініціалізувати в конструкторі кількома "
"способами:"

msgid ""
"Field :term:`descriptor`\\s can be retrieved from the *class*, they are "
"useful for debugging because they can provide useful information::"
msgstr ""
"Поля :term:`descriptor`\\s можна отримати з *класу*, вони корисні для "
"налагодження, оскільки можуть надати корисну інформацію::"

msgid ""
":mod:`ctypes` does not support passing unions or structures with bit-fields "
"to functions by value.  While this may work on 32-bit x86, it's not "
"guaranteed by the library to work in the general case.  Unions and "
"structures with bit-fields should always be passed to functions by pointer."
msgstr ""
":mod:`ctypes` не підтримує передачу об’єднань або структур із бітовими "
"полями функціям за значенням. Хоча це може працювати на 32-розрядних x86, "
"бібліотека не гарантує роботу в загальному випадку. Об’єднання та структури "
"з бітовими полями слід завжди передавати функціям за вказівником."

msgid "Structure/union alignment and byte order"
msgstr "Вирівнювання структури/об'єднання та порядок байтів"

msgid ""
"By default, Structure and Union fields are aligned in the same way the C "
"compiler does it. It is possible to override this behavior by specifying a :"
"attr:`_pack_` class attribute in the subclass definition. This must be set "
"to a positive integer and specifies the maximum alignment for the fields. "
"This is what ``#pragma pack(n)`` also does in MSVC."
msgstr ""
"За замовчуванням поля Structure і Union вирівнюються так само, як це робить "
"компілятор C. Цю поведінку можна перевизначити, вказавши атрибут класу :attr:"
"`_pack_` у визначенні підкласу. Для цього має бути встановлено додатне ціле "
"число та вказано максимальне вирівнювання для полів. Це те, що ``#pragma "
"pack(n)`` також робить у MSVC."

msgid ""
":mod:`ctypes` uses the native byte order for Structures and Unions.  To "
"build structures with non-native byte order, you can use one of the :class:"
"`BigEndianStructure`, :class:`LittleEndianStructure`, :class:"
"`BigEndianUnion`, and :class:`LittleEndianUnion` base classes.  These "
"classes cannot contain pointer fields."
msgstr ""
":mod:`ctypes` використовує власний порядок байтів для структур і об’єднань. "
"Щоб створити структури з невласним порядком байтів, ви можете "
"використовувати один із базових класів :class:`BigEndianStructure`, :class:"
"`LittleEndianStructure`, :class:`BigEndianUnion` і :class:"
"`LittleEndianUnion`. Ці класи не можуть містити поля вказівників."

msgid "Bit fields in structures and unions"
msgstr "Бітові поля в структурах і об'єднаннях"

msgid ""
"It is possible to create structures and unions containing bit fields. Bit "
"fields are only possible for integer fields, the bit width is specified as "
"the third item in the :attr:`_fields_` tuples::"
msgstr ""
"Можна створювати структури та об'єднання, що містять бітові поля. Бітові "
"поля можливі лише для цілочисельних полів, бітова ширина вказується як "
"третій елемент у кортежах :attr:`_fields_`::"

msgid "Arrays"
msgstr "Масиви"

msgid ""
"Arrays are sequences, containing a fixed number of instances of the same "
"type."
msgstr ""
"Масиви - це послідовності, що містять фіксовану кількість екземплярів одного "
"типу."

msgid ""
"The recommended way to create array types is by multiplying a data type with "
"a positive integer::"
msgstr ""
"Рекомендований спосіб створення типів масивів – це множення типу даних на "
"додатне ціле:"

msgid ""
"Here is an example of a somewhat artificial data type, a structure "
"containing 4 POINTs among other stuff::"
msgstr ""
"Ось приклад дещо штучного типу даних, структура, яка містить 4 ТОЧКИ серед "
"іншого:"

msgid "Instances are created in the usual way, by calling the class::"
msgstr "Екземпляри створюються звичайним способом за допомогою виклику класу::"

msgid ""
"The above code print a series of ``0 0`` lines, because the array contents "
"is initialized to zeros."
msgstr ""
"Наведений вище код друкує серію рядків ``0 0``, оскільки вміст масиву "
"ініціалізовано нулями."

msgid "Initializers of the correct type can also be specified::"
msgstr "Також можна вказати ініціалізатори правильного типу:"

msgid "Pointers"
msgstr "Покажчики"

msgid ""
"Pointer instances are created by calling the :func:`pointer` function on a :"
"mod:`ctypes` type::"
msgstr ""
"Екземпляри вказівника створюються шляхом виклику функції :func:`pointer` для "
"типу :mod:`ctypes`::"

msgid ""
"Pointer instances have a :attr:`~_Pointer.contents` attribute which returns "
"the object to which the pointer points, the ``i`` object above::"
msgstr ""
"Екземпляри вказівника мають атрибут :attr:`~_Pointer.contents`, який "
"повертає об’єкт, на який вказує вказівник, об’єкт ``i`` вище::"

msgid ""
"Note that :mod:`ctypes` does not have OOR (original object return), it "
"constructs a new, equivalent object each time you retrieve an attribute::"
msgstr ""
"Зауважте, що :mod:`ctypes` не має OOR (повернення вихідного об’єкта), він "
"створює новий, еквівалентний об’єкт кожного разу, коли ви отримуєте атрибут::"

msgid ""
"Assigning another :class:`c_int` instance to the pointer's contents "
"attribute would cause the pointer to point to the memory location where this "
"is stored::"
msgstr ""
"Призначення іншого екземпляра :class:`c_int` атрибуту contents вказівника "
"призведе до того, що вказівник вказуватиме на місце пам’яті, де це "
"зберігається::"

msgid "Pointer instances can also be indexed with integers::"
msgstr "Екземпляри вказівників також можна індексувати цілими числами::"

msgid "Assigning to an integer index changes the pointed to value::"
msgstr "Присвоєння цілочисельному індексу змінює вказане значення::"

msgid ""
"It is also possible to use indexes different from 0, but you must know what "
"you're doing, just as in C: You can access or change arbitrary memory "
"locations. Generally you only use this feature if you receive a pointer from "
"a C function, and you *know* that the pointer actually points to an array "
"instead of a single item."
msgstr ""
"Також можна використовувати індекси, відмінні від 0, але ви повинні знати, "
"що ви робите, так само як у C: ви можете отримати доступ або змінити "
"довільні місця пам'яті. Зазвичай ви використовуєте цю функцію, лише якщо "
"отримуєте вказівник від функції C і *знаєте*, що вказівник насправді вказує "
"на масив, а не на один елемент."

msgid ""
"Behind the scenes, the :func:`pointer` function does more than simply create "
"pointer instances, it has to create pointer *types* first. This is done with "
"the :func:`POINTER` function, which accepts any :mod:`ctypes` type, and "
"returns a new type::"
msgstr ""
"За лаштунками функція :func:`pointer` робить більше, ніж просто створює "
"екземпляри вказівників, вона повинна спочатку створити *типи* вказівників. "
"Це робиться за допомогою функції :func:`POINTER`, яка приймає будь-який тип :"
"mod:`ctypes` і повертає новий тип::"

msgid ""
"Calling the pointer type without an argument creates a ``NULL`` pointer. "
"``NULL`` pointers have a ``False`` boolean value::"
msgstr ""
"Виклик типу покажчика без аргументу створює покажчик ``NULL``. Покажчики "
"``NULL`` мають логічне значення ``False``::"

msgid ""
":mod:`ctypes` checks for ``NULL`` when dereferencing pointers (but "
"dereferencing invalid non-\\ ``NULL`` pointers would crash Python)::"
msgstr ""
":mod:`ctypes` перевіряє ``NULL`` під час розіменування вказівників (але "
"розіменування недійсних не\\ ``NULL`` вказівників призведе до збою Python)::"

msgid "Type conversions"
msgstr "Перетворення типів"

msgid ""
"Usually, ctypes does strict type checking.  This means, if you have "
"``POINTER(c_int)`` in the :attr:`argtypes` list of a function or as the type "
"of a member field in a structure definition, only instances of exactly the "
"same type are accepted.  There are some exceptions to this rule, where "
"ctypes accepts other objects.  For example, you can pass compatible array "
"instances instead of pointer types.  So, for ``POINTER(c_int)``, ctypes "
"accepts an array of c_int::"
msgstr ""
"Зазвичай ctypes виконує сувору перевірку типів. Це означає, що якщо у вас є "
"``POINTER(c_int)`` у списку :attr:`argtypes` функції або як тип поля-члена у "
"визначенні структури, приймаються лише екземпляри точно такого ж типу. З "
"цього правила є деякі винятки, коли ctypes приймає інші об’єкти. Наприклад, "
"ви можете передати сумісні екземпляри масиву замість типів покажчиків. Отже, "
"для ``POINTER(c_int)`` ctypes приймає масив c_int::"

msgid ""
"In addition, if a function argument is explicitly declared to be a pointer "
"type (such as ``POINTER(c_int)``) in :attr:`argtypes`, an object of the "
"pointed type (``c_int`` in this case) can be passed to the function.  ctypes "
"will apply the required :func:`byref` conversion in this case automatically."
msgstr ""
"Крім того, якщо аргумент функції явно оголошено як тип вказівника "
"(наприклад, ``POINTER(c_int)``) у :attr:`argtypes`, об’єкт вказівного типу "
"(``c_int`` у цьому випадку ) можна передати у функцію. У цьому випадку "
"ctypes автоматично застосує необхідне перетворення :func:`byref`."

msgid "To set a POINTER type field to ``NULL``, you can assign ``None``::"
msgstr ""
"Щоб встановити для поля типу POINTER значення ``NULL``, ви можете призначити "
"``None``::"

msgid ""
"Sometimes you have instances of incompatible types.  In C, you can cast one "
"type into another type.  :mod:`ctypes` provides a :func:`cast` function "
"which can be used in the same way.  The ``Bar`` structure defined above "
"accepts ``POINTER(c_int)`` pointers or :class:`c_int` arrays for its "
"``values`` field, but not instances of other types::"
msgstr ""
"Іноді у вас є екземпляри несумісних типів. У C ви можете привести один тип "
"до іншого. :mod:`ctypes` надає функцію :func:`cast`, яку можна "
"використовувати таким же чином. Структура ``Bar``, визначена вище, приймає "
"покажчики ``POINTER(c_int)`` або :class:`c_int` масиви для свого поля "
"``values``, але не примірники інших типів::"

msgid "For these cases, the :func:`cast` function is handy."
msgstr "Для цих випадків зручна функція :func:`cast`."

msgid ""
"The :func:`cast` function can be used to cast a ctypes instance into a "
"pointer to a different ctypes data type.  :func:`cast` takes two parameters, "
"a ctypes object that is or can be converted to a pointer of some kind, and a "
"ctypes pointer type.  It returns an instance of the second argument, which "
"references the same memory block as the first argument::"
msgstr ""
"Функцію :func:`cast` можна використати для приведення екземпляра ctypes до "
"покажчика на інший тип даних ctypes. :func:`cast` приймає два параметри: "
"об’єкт ctypes, який є чи може бути перетворений на певний вказівник, і тип "
"вказівника ctypes. Він повертає екземпляр другого аргументу, який "
"посилається на той самий блок пам’яті, що й перший аргумент::"

msgid ""
"So, :func:`cast` can be used to assign to the ``values`` field of ``Bar`` "
"the structure::"
msgstr ""
"Отже, :func:`cast` можна використовувати для призначення полю ``values`` "
"``Bar`` структури::"

msgid "Incomplete Types"
msgstr "Неповні типи"

msgid ""
"*Incomplete Types* are structures, unions or arrays whose members are not "
"yet specified. In C, they are specified by forward declarations, which are "
"defined later::"
msgstr ""
"*Неповні типи* — це структури, об’єднання або масиви, члени яких ще не "
"визначено. У C вони визначені прямими оголошеннями, які визначені пізніше:"

msgid ""
"The straightforward translation into ctypes code would be this, but it does "
"not work::"
msgstr "Прямий переклад у код ctypes буде таким, але він не працює:"

msgid ""
"because the new ``class cell`` is not available in the class statement "
"itself. In :mod:`ctypes`, we can define the ``cell`` class and set the :attr:"
"`_fields_` attribute later, after the class statement::"
msgstr ""
"оскільки нова ``комірка класу`` недоступна в самому операторі класу. У :mod:"
"`ctypes` ми можемо визначити клас ``cell`` і встановити атрибут :attr:"
"`_fields_` пізніше, після оператора class::"

msgid ""
"Let's try it. We create two instances of ``cell``, and let them point to "
"each other, and finally follow the pointer chain a few times::"
msgstr ""
"Давайте спробуємо. Ми створюємо два екземпляри ``cell`` і дозволяємо їм "
"вказувати один на одного, і, нарешті, слідуємо за ланцюжком вказівників "
"кілька разів::"

msgid "Callback functions"
msgstr "Функції зворотного виклику"

msgid ""
":mod:`ctypes` allows creating C callable function pointers from Python "
"callables. These are sometimes called *callback functions*."
msgstr ""
":mod:`ctypes` дозволяє створювати вказівники на функції C із викликів "
"Python. Іноді їх називають *функціями зворотного виклику*."

msgid ""
"First, you must create a class for the callback function. The class knows "
"the calling convention, the return type, and the number and types of "
"arguments this function will receive."
msgstr ""
"По-перше, ви повинні створити клас для функції зворотного виклику. Клас знає "
"угоду про виклики, тип повернення, а також кількість і типи аргументів, які "
"ця функція отримає."

msgid ""
"The :func:`CFUNCTYPE` factory function creates types for callback functions "
"using the ``cdecl`` calling convention. On Windows, the :func:`WINFUNCTYPE` "
"factory function creates types for callback functions using the ``stdcall`` "
"calling convention."
msgstr ""
"Фабрична функція :func:`CFUNCTYPE` створює типи для функцій зворотного "
"виклику за допомогою угоди про виклики ``cdecl``. У Windows фабрична "
"функція :func:`WINFUNCTYPE` створює типи для функцій зворотного виклику за "
"допомогою угоди про виклики ``stdcall``."

msgid ""
"Both of these factory functions are called with the result type as first "
"argument, and the callback functions expected argument types as the "
"remaining arguments."
msgstr ""
"Обидві ці фабричні функції викликаються з типом результату як першим "
"аргументом, а функції зворотного виклику – очікуваними типами аргументів як "
"рештою аргументів."

msgid ""
"I will present an example here which uses the standard C library's :c:func:"
"`qsort` function, that is used to sort items with the help of a callback "
"function.  :c:func:`qsort` will be used to sort an array of integers::"
msgstr ""
"Я наведу тут приклад, який використовує функцію :c:func:`qsort` стандартної "
"бібліотеки C, яка використовується для сортування елементів за допомогою "
"функції зворотного виклику. :c:func:`qsort` використовуватиметься для "
"сортування масиву цілих чисел::"

msgid ""
":func:`qsort` must be called with a pointer to the data to sort, the number "
"of items in the data array, the size of one item, and a pointer to the "
"comparison function, the callback. The callback will then be called with two "
"pointers to items, and it must return a negative integer if the first item "
"is smaller than the second, a zero if they are equal, and a positive integer "
"otherwise."
msgstr ""
":func:`qsort` потрібно викликати з вказівником на дані для сортування, "
"кількістю елементів у масиві даних, розміром одного елемента та вказівником "
"на функцію порівняння, зворотний виклик. Зворотний виклик буде викликано з "
"двома покажчиками на елементи, і він повинен повернути від’ємне ціле число, "
"якщо перший елемент менший за другий, нуль, якщо вони рівні, і додатне ціле "
"число в іншому випадку."

msgid ""
"So our callback function receives pointers to integers, and must return an "
"integer. First we create the ``type`` for the callback function::"
msgstr ""
"Таким чином, наша функція зворотного виклику отримує покажчики на цілі числа "
"та повинна повертати ціле число. Спочатку ми створюємо ``type`` для функції "
"зворотного виклику::"

msgid ""
"To get started, here is a simple callback that shows the values it gets "
"passed::"
msgstr ""
"Щоб почати, ось простий зворотний виклик, який показує значення, які він "
"отримує:"

msgid "The result::"
msgstr "Результат::"

msgid "Now we can actually compare the two items and return a useful result::"
msgstr ""
"Тепер ми фактично можемо порівняти два елементи та повернути корисний "
"результат:"

msgid "As we can easily check, our array is sorted now::"
msgstr "Як ми можемо легко перевірити, наш масив зараз відсортовано::"

msgid ""
"The function factories can be used as decorator factories, so we may as well "
"write::"
msgstr ""
"Фабрики функцій можна використовувати як фабрики декораторів, тому ми також "
"можемо написати::"

msgid ""
"Make sure you keep references to :func:`CFUNCTYPE` objects as long as they "
"are used from C code. :mod:`ctypes` doesn't, and if you don't, they may be "
"garbage collected, crashing your program when a callback is made."
msgstr ""
"Переконайтеся, що ви зберігаєте посилання на об’єкти :func:`CFUNCTYPE`, доки "
"вони використовуються з коду C. :mod:`ctypes` не працює, і якщо ви цього не "
"зробите, вони можуть збиратися як сміття, що призведе до збою вашої програми "
"під час зворотного виклику."

msgid ""
"Also, note that if the callback function is called in a thread created "
"outside of Python's control (e.g. by the foreign code that calls the "
"callback), ctypes creates a new dummy Python thread on every invocation. "
"This behavior is correct for most purposes, but it means that values stored "
"with :class:`threading.local` will *not* survive across different callbacks, "
"even when those calls are made from the same C thread."
msgstr ""
"Також зауважте, що якщо функція зворотнього виклику викликається в потоці, "
"створеному поза контролем Python (наприклад, зовнішнім кодом, який викликає "
"зворотній виклик), ctypes створює новий фіктивний потік Python під час "
"кожного виклику. Така поведінка є правильною для більшості цілей, але це "
"означає, що значення, збережені в :class:`threading.local` *не* збережуться "
"в різних зворотних викликах, навіть якщо ці виклики здійснюються з того "
"самого потоку C."

msgid "Accessing values exported from dlls"
msgstr "Доступ до значень, експортованих із dll"

msgid ""
"Some shared libraries not only export functions, they also export variables. "
"An example in the Python library itself is the :c:data:`Py_OptimizeFlag`, an "
"integer set to 0, 1, or 2, depending on the :option:`-O` or :option:`-OO` "
"flag given on startup."
msgstr ""
"Деякі спільні бібліотеки експортують не лише функції, але й змінні. "
"Прикладом у самій бібліотеці Python є :c:data:`Py_OptimizeFlag`, ціле число "
"зі значенням 0, 1 або 2, залежно від прапора :option:`-O` або :option:`-OO`, "
"заданого на стартап."

msgid ""
":mod:`ctypes` can access values like this with the :meth:`in_dll` class "
"methods of the type.  *pythonapi* is a predefined symbol giving access to "
"the Python C api::"
msgstr ""
":mod:`ctypes` може отримати доступ до таких значень за допомогою методів "
"класу :meth:`in_dll` типу. *pythonapi* — це попередньо визначений символ, "
"який надає доступ до Python C api::"

msgid ""
"If the interpreter would have been started with :option:`-O`, the sample "
"would have printed ``c_long(1)``, or ``c_long(2)`` if :option:`-OO` would "
"have been specified."
msgstr ""
"Якби інтерпретатор був запущений з :option:`-O`, зразок надрукував би "
"``c_long(1)`` або ``c_long(2)``, якщо :option:`-OO` було б зазначено."

msgid ""
"An extended example which also demonstrates the use of pointers accesses "
"the :c:data:`PyImport_FrozenModules` pointer exported by Python."
msgstr ""
"Розширений приклад, який також демонструє використання покажчиків, "
"звертається до покажчика :c:data:`PyImport_FrozenModules`, експортованого "
"Python."

msgid "Quoting the docs for that value:"
msgstr "Цитування документів для цього значення:"

msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""

msgid ""
"So manipulating this pointer could even prove useful. To restrict the "
"example size, we show only how this table can be read with :mod:`ctypes`::"
msgstr ""
"Тож маніпулювання цим покажчиком може навіть виявитися корисним. Щоб "
"обмежити розмір прикладу, ми показуємо лише те, як цю таблицю можна "
"прочитати за допомогою :mod:`ctypes`::"

msgid ""
"We have defined the :c:struct:`_frozen` data type, so we can get the pointer "
"to the table::"
msgstr ""

msgid ""
"Since ``table`` is a ``pointer`` to the array of ``struct_frozen`` records, "
"we can iterate over it, but we just have to make sure that our loop "
"terminates, because pointers have no size. Sooner or later it would probably "
"crash with an access violation or whatever, so it's better to break out of "
"the loop when we hit the ``NULL`` entry::"
msgstr ""
"Оскільки ``table`` є ``покажчиком`` на масив ``struct_frozen`` записів, ми "
"можемо перебирати його, але нам просто потрібно переконатися, що наш цикл "
"завершується, оскільки покажчики не мають розміру. Рано чи пізно він, "
"ймовірно, вийде з ладу через порушення прав доступу чи щось інше, тому краще "
"вийти з циклу, коли ми натиснемо запис ``NULL``::"

msgid ""
"The fact that standard Python has a frozen module and a frozen package "
"(indicated by the negative ``size`` member) is not well known, it is only "
"used for testing. Try it out with ``import __hello__`` for example."
msgstr ""
"Той факт, що стандартний Python має заморожений модуль і заморожений пакет "
"(позначений від’ємним елементом ``size``), невідомий, він використовується "
"лише для тестування. Спробуйте, наприклад, ``import __hello__``."

msgid "Surprises"
msgstr "Сюрпризи"

msgid ""
"There are some edges in :mod:`ctypes` where you might expect something other "
"than what actually happens."
msgstr ""
"У :mod:`ctypes` є деякі переваги, де ви можете очікувати щось інше, ніж те, "
"що відбувається насправді."

msgid "Consider the following example::"
msgstr "Розглянемо такий приклад:"

msgid ""
"Hm. We certainly expected the last statement to print ``3 4 1 2``. What "
"happened? Here are the steps of the ``rc.a, rc.b = rc.b, rc.a`` line above::"
msgstr ""
"Хм Ми, безумовно, очікували, що останній оператор виведе ``3 4 1 2``. Що "
"трапилось? Ось кроки рядка ``rc.a, rc.b = rc.b, rc.a``:"

msgid ""
"Note that ``temp0`` and ``temp1`` are objects still using the internal "
"buffer of the ``rc`` object above. So executing ``rc.a = temp0`` copies the "
"buffer contents of ``temp0`` into ``rc`` 's buffer.  This, in turn, changes "
"the contents of ``temp1``. So, the last assignment ``rc.b = temp1``, doesn't "
"have the expected effect."
msgstr ""
"Зауважте, що ``temp0`` і ``temp1`` є об’єктами, які все ще використовують "
"внутрішній буфер об’єкта ``rc`` вище. Отже, виконання ``rc.a = temp0`` "
"копіює вміст буфера ``temp0`` у буфер ``rc``. Це, у свою чергу, змінює вміст "
"``temp1``. Отже, останнє призначення ``rc.b = temp1`` не має очікуваного "
"ефекту."

msgid ""
"Keep in mind that retrieving sub-objects from Structure, Unions, and Arrays "
"doesn't *copy* the sub-object, instead it retrieves a wrapper object "
"accessing the root-object's underlying buffer."
msgstr ""
"Майте на увазі, що отримання підоб’єктів зі структур, об’єднань і масивів не "
"*копіює* підоб’єкт, натомість отримує обгортку об’єкта, який отримує доступ "
"до основного буфера кореневого об’єкта."

msgid ""
"Another example that may behave differently from what one would expect is "
"this::"
msgstr "Інший приклад, який може поводитися інакше, ніж очікувалося, це:"

msgid ""
"Objects instantiated from :class:`c_char_p` can only have their value set to "
"bytes or integers."
msgstr ""
"Об’єкти, створені з :class:`c_char_p`, можуть мати значення лише байтів або "
"цілих чисел."

msgid ""
"Why is it printing ``False``?  ctypes instances are objects containing a "
"memory block plus some :term:`descriptor`\\s accessing the contents of the "
"memory. Storing a Python object in the memory block does not store the "
"object itself, instead the ``contents`` of the object is stored.  Accessing "
"the contents again constructs a new Python object each time!"
msgstr ""
"Чому він друкує ``False``? Екземпляри ctypes — це об’єкти, що містять блок "
"пам’яті плюс деякі :term:`descriptor`\\, що мають доступ до вмісту пам’яті. "
"Зберігання об’єкта Python у блоці пам’яті не зберігає сам об’єкт, натомість "
"зберігається ``вміст`` об’єкта. Повторний доступ до вмісту щоразу створює "
"новий об’єкт Python!"

msgid "Variable-sized data types"
msgstr "Типи даних змінного розміру"

msgid ""
":mod:`ctypes` provides some support for variable-sized arrays and structures."
msgstr ""
":mod:`ctypes` забезпечує деяку підтримку для масивів і структур змінного "
"розміру."

msgid ""
"The :func:`resize` function can be used to resize the memory buffer of an "
"existing ctypes object.  The function takes the object as first argument, "
"and the requested size in bytes as the second argument.  The memory block "
"cannot be made smaller than the natural memory block specified by the "
"objects type, a :exc:`ValueError` is raised if this is tried::"
msgstr ""
"Функцію :func:`resize` можна використовувати для зміни розміру буфера "
"пам’яті існуючого об’єкта ctypes. Функція приймає об’єкт як перший аргумент, "
"а запитуваний розмір у байтах як другий аргумент. Блок пам’яті не може бути "
"меншим, ніж природний блок пам’яті, визначений типом об’єкта, :exc:"
"`ValueError` виникає, якщо це спробувати::"

msgid ""
"This is nice and fine, but how would one access the additional elements "
"contained in this array?  Since the type still only knows about 4 elements, "
"we get errors accessing other elements::"
msgstr ""
"Це гарно і добре, але як отримати доступ до додаткових елементів, що "
"містяться в цьому масиві? Оскільки тип все ще знає лише про 4 елементи, ми "
"отримуємо помилки під час доступу до інших елементів::"

msgid ""
"Another way to use variable-sized data types with :mod:`ctypes` is to use "
"the dynamic nature of Python, and (re-)define the data type after the "
"required size is already known, on a case by case basis."
msgstr ""
"Інший спосіб використання типів даних змінного розміру з :mod:`ctypes` — це "
"використання динамічної природи Python і (повторне) визначення типу даних "
"після того, як потрібний розмір уже відомий, у кожному конкретному випадку."

msgid "ctypes reference"
msgstr "посилання на ctypes"

msgid "Finding shared libraries"
msgstr "Пошук спільних бібліотек"

msgid ""
"When programming in a compiled language, shared libraries are accessed when "
"compiling/linking a program, and when the program is run."
msgstr ""
"Під час програмування скомпільованою мовою доступ до спільних бібліотек "
"здійснюється під час компіляції/зв’язування програми та під час виконання "
"програми."

msgid ""
"The purpose of the :func:`find_library` function is to locate a library in a "
"way similar to what the compiler or runtime loader does (on platforms with "
"several versions of a shared library the most recent should be loaded), "
"while the ctypes library loaders act like when a program is run, and call "
"the runtime loader directly."
msgstr ""
"Метою функції :func:`find_library` є пошук бібліотеки у спосіб, подібний до "
"того, що робить компілятор або завантажувач середовища виконання (на "
"платформах із кількома версіями спільної бібліотеки має бути завантажена "
"остання), тоді як бібліотека ctypes завантажувачі діють так само, як коли "
"виконується програма, і безпосередньо викликають завантажувач часу виконання."

msgid ""
"The :mod:`ctypes.util` module provides a function which can help to "
"determine the library to load."
msgstr ""
"Модуль :mod:`ctypes.util` надає функцію, яка може допомогти визначити "
"бібліотеку для завантаження."

msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like *lib*, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"Спробуйте знайти бібліотеку та повернути шлях. *name* — це назва бібліотеки "
"без будь-якого префікса, як-от *lib*, суфікса, як-от ``.so``, ``.dylib`` або "
"номера версії (це форма, яка використовується для параметра компонування "
"posix :option:`!- l`). Якщо бібліотеки не знайдено, повертає ``None``."

msgid "The exact functionality is system dependent."
msgstr "Точна функція залежить від системи."

msgid ""
"On Linux, :func:`find_library` tries to run external programs (``/sbin/"
"ldconfig``, ``gcc``, ``objdump`` and ``ld``) to find the library file. It "
"returns the filename of the library file."
msgstr ""
"У Linux :func:`find_library` намагається запустити зовнішні програми (``/"
"sbin/ldconfig``, ``gcc``, ``objdump`` і ``ld``), щоб знайти файл бібліотеки. "
"Він повертає ім’я файлу бібліотеки."

msgid ""
"On Linux, the value of the environment variable ``LD_LIBRARY_PATH`` is used "
"when searching for libraries, if a library cannot be found by any other "
"means."
msgstr ""
"У Linux значення змінної середовища ``LD_LIBRARY_PATH`` використовується під "
"час пошуку бібліотек, якщо бібліотеку неможливо знайти будь-яким іншим "
"способом."

msgid "Here are some examples::"
msgstr "Ось кілька прикладів:"

msgid ""
"On macOS, :func:`find_library` tries several predefined naming schemes and "
"paths to locate the library, and returns a full pathname if successful::"
msgstr ""
"У macOS :func:`find_library` намагається знайти бібліотеку за допомогою "
"кількох попередньо визначених схем іменування та шляхів, і в разі успіху "
"повертає повний шлях::"

msgid ""
"On Windows, :func:`find_library` searches along the system search path, and "
"returns the full pathname, but since there is no predefined naming scheme a "
"call like ``find_library(\"c\")`` will fail and return ``None``."
msgstr ""
"У Windows :func:`find_library` шукає вздовж шляху системного пошуку та "
"повертає повний шлях, але оскільки попередньо визначеної схеми іменування "
"немає, виклик на кшталт ``find_library(\"c\")`` завершиться помилкою та "
"поверне ``None``."

msgid ""
"If wrapping a shared library with :mod:`ctypes`, it *may* be better to "
"determine the shared library name at development time, and hardcode that "
"into the wrapper module instead of using :func:`find_library` to locate the "
"library at runtime."
msgstr ""
"Якщо огортати спільну бібліотеку за допомогою :mod:`ctypes`, *може* краще "
"визначити назву спільної бібліотеки під час розробки та жорстко закодувати "
"її в модуль оболонки замість використання :func:`find_library` для пошуку "
"бібліотеки за адресою час виконання."

msgid "Loading shared libraries"
msgstr "Завантаження спільних бібліотек"

msgid ""
"There are several ways to load shared libraries into the Python process.  "
"One way is to instantiate one of the following classes:"
msgstr ""
"Є кілька способів завантажити спільні бібліотеки в процес Python. Одним із "
"способів є створення екземпляра одного з наступних класів:"

msgid ""
"Instances of this class represent loaded shared libraries. Functions in "
"these libraries use the standard C calling convention, and are assumed to "
"return :c:expr:`int`."
msgstr ""

msgid ""
"On Windows creating a :class:`CDLL` instance may fail even if the DLL name "
"exists. When a dependent DLL of the loaded DLL is not found, a :exc:"
"`OSError` error is raised with the message *\"[WinError 126] The specified "
"module could not be found\".* This error message does not contain the name "
"of the missing DLL because the Windows API does not return this information "
"making this error hard to diagnose. To resolve this error and determine "
"which DLL is not found, you need to find the list of dependent DLLs and "
"determine which one is not found using Windows debugging and tracing tools."
msgstr ""
"У Windows створення екземпляра :class:`CDLL` може завершитися помилкою, "
"навіть якщо ім’я DLL існує. Якщо залежну DLL від завантаженої DLL не "
"знайдено, виникає помилка :exc:`OSError` із повідомленням *\"[WinError 126] "
"Не вдалося знайти вказаний модуль\".* Це повідомлення про помилку не містить "
"назви відсутня DLL, оскільки Windows API не повертає цю інформацію, що "
"ускладнює діагностику цієї помилки. Щоб усунути цю помилку та визначити, яку "
"DLL не знайдено, потрібно знайти список залежних DLL і визначити, яка з них "
"не знайдена, за допомогою засобів налагодження та трасування Windows."

msgid ""
"`Microsoft DUMPBIN tool <https://docs.microsoft.com/cpp/build/reference/"
"dependents>`_ -- A tool to find DLL dependents."
msgstr ""
"`Інструмент Microsoft DUMPBIN <https://docs.microsoft.com/cpp/build/"
"reference/dependents>`_ -- Інструмент для пошуку залежних DLL."

msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return the windows specific :class:`HRESULT` code.  :class:"
"`HRESULT` values contain information specifying whether the function call "
"failed or succeeded, together with additional error code.  If the return "
"value signals a failure, an :class:`OSError` is automatically raised."
msgstr ""
"Лише для Windows: екземпляри цього класу представляють завантажені спільні "
"бібліотеки, функції в цих бібліотеках використовують угоду про виклики "
"``stdcall`` і припускається, що вони повертають специфічний для Windows код :"
"class:`HRESULT`. Значення :class:`HRESULT` містять інформацію про те, чи "
"виклик функції завершився невдало чи успішно, а також додатковий код "
"помилки. Якщо повернуте значення сигналізує про помилку, автоматично "
"виникає :class:`OSError`."

msgid ":exc:`WindowsError` used to be raised."
msgstr ":exc:`WindowsError` раніше виникало."

msgid ""
"Windows only: Instances of this class represent loaded shared libraries, "
"functions in these libraries use the ``stdcall`` calling convention, and are "
"assumed to return :c:expr:`int` by default."
msgstr ""

msgid ""
"The Python :term:`global interpreter lock` is released before calling any "
"function exported by these libraries, and reacquired afterwards."
msgstr ""
":term:`global interpreter lock` Python знімається перед викликом будь-якої "
"функції, експортованої цими бібліотеками, і знову отримується після цього."

msgid ""
"Instances of this class behave like :class:`CDLL` instances, except that the "
"Python GIL is *not* released during the function call, and after the "
"function execution the Python error flag is checked. If the error flag is "
"set, a Python exception is raised."
msgstr ""
"Екземпляри цього класу поводяться як екземпляри :class:`CDLL`, за винятком "
"того, що GIL Python *не* звільняється під час виклику функції, а після "
"виконання функції перевіряється позначка помилки Python. Якщо встановлено "
"позначку помилки, виникає виняток Python."

msgid "Thus, this is only useful to call Python C api functions directly."
msgstr "Таким чином, це корисно лише для прямого виклику API-функцій Python C."

msgid ""
"All these classes can be instantiated by calling them with at least one "
"argument, the pathname of the shared library.  If you have an existing "
"handle to an already loaded shared library, it can be passed as the "
"``handle`` named parameter, otherwise the underlying platforms ``dlopen`` or "
"``LoadLibrary`` function is used to load the library into the process, and "
"to get a handle to it."
msgstr ""
"Усі ці класи можна створити, викликавши їх принаймні з одним аргументом, "
"шляхом до спільної бібліотеки. Якщо у вас є існуючий дескриптор уже "
"завантаженої спільної бібліотеки, його можна передати як іменований параметр "
"``handle``, інакше для завантаження бібліотеки в використовується функція "
"``dlopen`` або ``LoadLibrary`` базової платформи процес і впоратися з ним."

msgid ""
"The *mode* parameter can be used to specify how the library is loaded.  For "
"details, consult the :manpage:`dlopen(3)` manpage.  On Windows, *mode* is "
"ignored.  On posix systems, RTLD_NOW is always added, and is not "
"configurable."
msgstr ""
"Параметр *mode* можна використовувати для визначення способу завантаження "
"бібліотеки. Додаткову інформацію див. на сторінці довідки :manpage:"
"`dlopen(3)`. У Windows *режим* ігнорується. У системах posix RTLD_NOW завжди "
"додається та не налаштовується."

msgid ""
"The *use_errno* parameter, when set to true, enables a ctypes mechanism that "
"allows accessing the system :data:`errno` error number in a safe way. :mod:"
"`ctypes` maintains a thread-local copy of the systems :data:`errno` "
"variable; if you call foreign functions created with ``use_errno=True`` then "
"the :data:`errno` value before the function call is swapped with the ctypes "
"private copy, the same happens immediately after the function call."
msgstr ""
"Параметр *use_errno*, якщо встановлено значення true, увімкне механізм "
"ctypes, який дозволяє безпечно отримати доступ до системного номера помилки :"
"data:`errno`. :mod:`ctypes` підтримує локальну копію системної змінної :data:"
"`errno`; якщо ви викликаєте сторонні функції, створені за допомогою "
"``use_errno=True``, тоді значення :data:`errno` перед викликом функції "
"замінюється приватною копією ctypes, те саме відбувається відразу після "
"виклику функції."

msgid ""
"The function :func:`ctypes.get_errno` returns the value of the ctypes "
"private copy, and the function :func:`ctypes.set_errno` changes the ctypes "
"private copy to a new value and returns the former value."
msgstr ""
"Функція :func:`ctypes.get_errno` повертає значення приватної копії ctypes, а "
"функція :func:`ctypes.set_errno` змінює приватну копію ctypes на нове "
"значення та повертає попереднє значення."

msgid ""
"The *use_last_error* parameter, when set to true, enables the same mechanism "
"for the Windows error code which is managed by the :func:`GetLastError` and :"
"func:`SetLastError` Windows API functions; :func:`ctypes.get_last_error` "
"and :func:`ctypes.set_last_error` are used to request and change the ctypes "
"private copy of the windows error code."
msgstr ""
"Параметр *use_last_error*, якщо встановлено значення true, увімкне той самий "
"механізм для коду помилки Windows, яким керують функції Windows API :func:"
"`GetLastError` і :func:`SetLastError`; :func:`ctypes.get_last_error` і :func:"
"`ctypes.set_last_error` використовуються для запиту та зміни приватної копії "
"ctypes коду помилки Windows."

msgid ""
"The *winmode* parameter is used on Windows to specify how the library is "
"loaded (since *mode* is ignored). It takes any value that is valid for the "
"Win32 API ``LoadLibraryEx`` flags parameter. When omitted, the default is to "
"use the flags that result in the most secure DLL load to avoiding issues "
"such as DLL hijacking. Passing the full path to the DLL is the safest way to "
"ensure the correct library and dependencies are loaded."
msgstr ""
"Параметр *winmode* використовується в Windows, щоб указати спосіб "
"завантаження бібліотеки (оскільки *mode* ігнорується). Він приймає будь-яке "
"значення, дійсне для параметра прапорців API Win32 ``LoadLibraryEx``. Якщо "
"опущено, за замовчуванням використовуються позначки, які забезпечують "
"найбільш безпечне завантаження DLL, щоб уникнути таких проблем, як "
"викрадення DLL. Передача повного шляху до DLL є найбезпечнішим способом "
"переконатися, що завантажено правильну бібліотеку та залежності."

msgid "Added *winmode* parameter."
msgstr "Додано параметр *winmode*."

msgid ""
"Flag to use as *mode* parameter.  On platforms where this flag is not "
"available, it is defined as the integer zero."
msgstr ""
"Прапор для використання як параметр *mode*. На платформах, де цей прапорець "
"недоступний, він визначається як цілий нуль."

msgid ""
"Flag to use as *mode* parameter.  On platforms where this is not available, "
"it is the same as *RTLD_GLOBAL*."
msgstr ""
"Прапор для використання як параметр *mode*. На платформах, де це недоступно, "
"це те саме, що *RTLD_GLOBAL*."

msgid ""
"The default mode which is used to load shared libraries.  On OSX 10.3, this "
"is *RTLD_GLOBAL*, otherwise it is the same as *RTLD_LOCAL*."
msgstr ""
"Типовий режим, який використовується для завантаження спільних бібліотек. В "
"OSX 10.3 це *RTLD_GLOBAL*, інакше це те саме, що *RTLD_LOCAL*."

msgid ""
"Instances of these classes have no public methods.  Functions exported by "
"the shared library can be accessed as attributes or by index.  Please note "
"that accessing the function through an attribute caches the result and "
"therefore accessing it repeatedly returns the same object each time.  On the "
"other hand, accessing it through an index returns a new object each time::"
msgstr ""
"Екземпляри цих класів не мають відкритих методів. Доступ до функцій, "
"експортованих спільною бібліотекою, можна отримати як за атрибутами або за "
"індексом. Будь ласка, зверніть увагу, що доступ до функції через атрибут "
"кешує результат, тому повторний доступ повертає той самий об’єкт щоразу. З "
"іншого боку, доступ до нього через індекс кожного разу повертає новий "
"об’єкт::"

msgid ""
"The following public attributes are available, their name starts with an "
"underscore to not clash with exported function names:"
msgstr ""
"Доступні такі загальнодоступні атрибути, їх імена починаються з "
"підкреслення, щоб не суперечити ім’ям експортованих функцій:"

msgid "The system handle used to access the library."
msgstr "Системний дескриптор, який використовується для доступу до бібліотеки."

msgid "The name of the library passed in the constructor."
msgstr "Ім'я бібліотеки, передане в конструктор."

msgid ""
"Shared libraries can also be loaded by using one of the prefabricated "
"objects, which are instances of the :class:`LibraryLoader` class, either by "
"calling the :meth:`LoadLibrary` method, or by retrieving the library as "
"attribute of the loader instance."
msgstr ""
"Спільні бібліотеки також можна завантажити за допомогою одного зі готових "
"об’єктів, які є екземплярами класу :class:`LibraryLoader`, викликавши метод :"
"meth:`LoadLibrary` або отримавши бібліотеку як атрибут екземпляра "
"завантажувача ."

msgid ""
"Class which loads shared libraries.  *dlltype* should be one of the :class:"
"`CDLL`, :class:`PyDLL`, :class:`WinDLL`, or :class:`OleDLL` types."
msgstr ""
"Клас, який завантажує спільні бібліотеки. *dlltype* має бути одним із типів :"
"class:`CDLL`, :class:`PyDLL`, :class:`WinDLL` або :class:`OleDLL`."

msgid ""
":meth:`__getattr__` has special behavior: It allows loading a shared library "
"by accessing it as attribute of a library loader instance.  The result is "
"cached, so repeated attribute accesses return the same library each time."
msgstr ""
":meth:`__getattr__` має особливу поведінку: він дозволяє завантажувати "
"спільну бібліотеку, звертаючись до неї як до атрибута екземпляра "
"завантажувача бібліотеки. Результат кешується, тому повторні звернення до "
"атрибутів щоразу повертають ту саму бібліотеку."

msgid ""
"Load a shared library into the process and return it.  This method always "
"returns a new instance of the library."
msgstr ""
"Завантажте спільну бібліотеку в процес і поверніть її. Цей метод завжди "
"повертає новий екземпляр бібліотеки."

msgid "These prefabricated library loaders are available:"
msgstr "Ці збірні бібліотечні завантажувачі доступні:"

msgid "Creates :class:`CDLL` instances."
msgstr "Створює екземпляри :class:`CDLL`."

msgid "Windows only: Creates :class:`WinDLL` instances."
msgstr "Лише для Windows: створює екземпляри :class:`WinDLL`."

msgid "Windows only: Creates :class:`OleDLL` instances."
msgstr "Лише для Windows: створює екземпляри :class:`OleDLL`."

msgid "Creates :class:`PyDLL` instances."
msgstr "Створює екземпляри :class:`PyDLL`."

msgid ""
"For accessing the C Python api directly, a ready-to-use Python shared "
"library object is available:"
msgstr ""
"Для прямого доступу до API C Python доступний готовий до використання об’єкт "
"спільної бібліотеки Python:"

msgid ""
"An instance of :class:`PyDLL` that exposes Python C API functions as "
"attributes.  Note that all these functions are assumed to return C :c:expr:"
"`int`, which is of course not always the truth, so you have to assign the "
"correct :attr:`restype` attribute to use these functions."
msgstr ""

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlopen`` with argument "
"``name``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``ctypes.dlopen`` з аргументом "
"``name``."

msgid ""
"Loading a library through any of these objects raises an :ref:`auditing "
"event <auditing>` ``ctypes.dlopen`` with string argument ``name``, the name "
"used to load the library."
msgstr ""
"Завантаження бібліотеки через будь-який із цих об’єктів викликає :ref:`подію "
"аудиту <auditing>` ``ctypes.dlopen`` з рядковим аргументом ``name``, іменем, "
"яке використовується для завантаження бібліотеки."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlsym`` with arguments "
"``library``, ``name``."
msgstr ""

msgid ""
"Accessing a function on a loaded library raises an auditing event ``ctypes."
"dlsym`` with arguments ``library`` (the library object) and ``name`` (the "
"symbol's name as a string or integer)."
msgstr ""
"Доступ до функції у завантаженій бібліотеці викликає подію аудиту ``ctypes."
"dlsym`` з аргументами ``library`` (об’єкт бібліотеки) і ``name`` (ім’я "
"символу у вигляді рядка або цілого числа)."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.dlsym/handle`` with "
"arguments ``handle``, ``name``."
msgstr ""

msgid ""
"In cases when only the library handle is available rather than the object, "
"accessing a function raises an auditing event ``ctypes.dlsym/handle`` with "
"arguments ``handle`` (the raw library handle) and ``name``."
msgstr ""
"У випадках, коли доступний лише дескриптор бібліотеки, а не об’єкт, доступ "
"до функції викликає подію аудиту ``ctypes.dlsym/handle`` з аргументами "
"``handle`` (необроблений дескриптор бібліотеки) і ``name``."

msgid "Foreign functions"
msgstr "Іноземні функції"

msgid ""
"As explained in the previous section, foreign functions can be accessed as "
"attributes of loaded shared libraries.  The function objects created in this "
"way by default accept any number of arguments, accept any ctypes data "
"instances as arguments, and return the default result type specified by the "
"library loader. They are instances of a private class:"
msgstr ""
"Як пояснювалося в попередньому розділі, сторонні функції можна отримати як "
"атрибути завантажених спільних бібліотек. Функціональні об’єкти, створені "
"таким чином, за замовчуванням приймають будь-яку кількість аргументів, "
"приймають будь-які екземпляри даних ctypes як аргументи та повертають тип "
"результату за замовчуванням, указаний завантажувачем бібліотеки. Вони є "
"екземплярами приватного класу:"

msgid "Base class for C callable foreign functions."
msgstr "Базовий клас для зовнішніх функцій C, що викликаються."

msgid ""
"Instances of foreign functions are also C compatible data types; they "
"represent C function pointers."
msgstr ""
"Примірники сторонніх функцій також є C-сумісними типами даних; вони "
"представляють покажчики функцій C."

msgid ""
"This behavior can be customized by assigning to special attributes of the "
"foreign function object."
msgstr ""
"Цю поведінку можна налаштувати шляхом призначення спеціальних атрибутів "
"стороннього функціонального об’єкта."

msgid ""
"Assign a ctypes type to specify the result type of the foreign function. Use "
"``None`` for :c:expr:`void`, a function not returning anything."
msgstr ""

msgid ""
"It is possible to assign a callable Python object that is not a ctypes type, "
"in this case the function is assumed to return a C :c:expr:`int`, and the "
"callable will be called with this integer, allowing further processing or "
"error checking.  Using this is deprecated, for more flexible post processing "
"or error checking use a ctypes data type as :attr:`restype` and assign a "
"callable to the :attr:`errcheck` attribute."
msgstr ""

msgid ""
"Assign a tuple of ctypes types to specify the argument types that the "
"function accepts.  Functions using the ``stdcall`` calling convention can "
"only be called with the same number of arguments as the length of this "
"tuple; functions using the C calling convention accept additional, "
"unspecified arguments as well."
msgstr ""
"Призначте кортеж типів ctypes, щоб указати типи аргументів, які приймає "
"функція. Функції, які використовують угоду про виклики ``stdcall``, можуть "
"бути викликані лише з тією ж кількістю аргументів, що й довжина цього "
"кортежу; функції, що використовують угоду про виклики C, також приймають "
"додаткові, невизначені аргументи."

msgid ""
"When a foreign function is called, each actual argument is passed to the :"
"meth:`from_param` class method of the items in the :attr:`argtypes` tuple, "
"this method allows adapting the actual argument to an object that the "
"foreign function accepts.  For example, a :class:`c_char_p` item in the :"
"attr:`argtypes` tuple will convert a string passed as argument into a bytes "
"object using ctypes conversion rules."
msgstr ""
"Коли викликається стороння функція, кожен фактичний аргумент передається в "
"метод класу :meth:`from_param` елементів у кортежі :attr:`argtypes`, цей "
"метод дозволяє адаптувати фактичний аргумент до об’єкта, який приймає "
"зовнішня функція . Наприклад, елемент :class:`c_char_p` у кортежі :attr:"
"`argtypes` перетворить рядок, переданий як аргумент, на об’єкт bytes за "
"допомогою правил перетворення ctypes."

msgid ""
"New: It is now possible to put items in argtypes which are not ctypes types, "
"but each item must have a :meth:`from_param` method which returns a value "
"usable as argument (integer, string, ctypes instance).  This allows defining "
"adapters that can adapt custom objects as function parameters."
msgstr ""
"Нове: тепер можна розміщувати елементи в argtypes, які не є типами ctypes, "
"але кожен елемент повинен мати метод :meth:`from_param`, який повертає "
"значення, яке можна використовувати як аргумент (ціле число, рядок, "
"екземпляр ctypes). Це дозволяє визначати адаптери, які можуть адаптувати "
"власні об’єкти як параметри функції."

msgid ""
"Assign a Python function or another callable to this attribute. The callable "
"will be called with three or more arguments:"
msgstr ""
"Призначте цьому атрибуту функцію Python або інший виклик. Викликається з "
"трьома або більше аргументами:"

msgid ""
"*result* is what the foreign function returns, as specified by the :attr:"
"`restype` attribute."
msgstr ""
"*result* – це те, що повертає стороння функція, як зазначено в атрибуті :"
"attr:`restype`."

msgid ""
"*func* is the foreign function object itself, this allows reusing the same "
"callable object to check or post process the results of several functions."
msgstr ""
"*func* — це сам зовнішній об’єкт функції, це дозволяє повторно "
"використовувати той самий об’єкт, що викликається, для перевірки або "
"постобробки результатів кількох функцій."

msgid ""
"*arguments* is a tuple containing the parameters originally passed to the "
"function call, this allows specializing the behavior on the arguments used."
msgstr ""
"*Аргументи* — це кортеж, що містить параметри, спочатку передані до виклику "
"функції, що дозволяє спеціалізувати поведінку на використовуваних аргументах."

msgid ""
"The object that this function returns will be returned from the foreign "
"function call, but it can also check the result value and raise an exception "
"if the foreign function call failed."
msgstr ""
"Об’єкт, який повертає ця функція, буде повернено з виклику зовнішньої "
"функції, але він також може перевірити значення результату та викликати "
"виняток, якщо виклик зовнішньої функції не вдався."

msgid ""
"This exception is raised when a foreign function call cannot convert one of "
"the passed arguments."
msgstr ""
"Цей виняток виникає, коли зовнішній виклик функції не може перетворити один "
"із переданих аргументів."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.seh_exception`` with "
"argument ``code``."
msgstr ""

msgid ""
"On Windows, when a foreign function call raises a system exception (for "
"example, due to an access violation), it will be captured and replaced with "
"a suitable Python exception. Further, an auditing event ``ctypes."
"seh_exception`` with argument ``code`` will be raised, allowing an audit "
"hook to replace the exception with its own."
msgstr ""
"У Windows, коли зовнішній виклик функції викликає системний виняток "
"(наприклад, через порушення доступу), він буде перехоплений і замінений "
"відповідним винятком Python. Крім того, буде викликана подія аудиту ``ctypes."
"seh_exception`` з аргументом ``code``, що дозволить перевіряючому хуку "
"замінити виняток власним."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.call_function`` with "
"arguments ``func_pointer``, ``arguments``."
msgstr ""

msgid ""
"Some ways to invoke foreign function calls may raise an auditing event "
"``ctypes.call_function`` with arguments ``function pointer`` and "
"``arguments``."
msgstr ""
"Деякі способи виклику зовнішніх викликів функцій можуть викликати подію "
"аудиту ``ctypes.call_function`` з аргументами ``вказівник функції`` і "
"``аргументи``."

msgid "Function prototypes"
msgstr "Прототипи функцій"

msgid ""
"Foreign functions can also be created by instantiating function prototypes. "
"Function prototypes are similar to function prototypes in C; they describe a "
"function (return type, argument types, calling convention) without defining "
"an implementation.  The factory functions must be called with the desired "
"result type and the argument types of the function, and can be used as "
"decorator factories, and as such, be applied to functions through the "
"``@wrapper`` syntax. See :ref:`ctypes-callback-functions` for examples."
msgstr ""
"Сторонні функції також можуть бути створені шляхом інстанціювання прототипів "
"функцій. Прототипи функцій подібні до прототипів функцій у C; вони описують "
"функцію (тип повернення, типи аргументів, угоду про виклики) без визначення "
"реалізації. Фабричні функції мають викликатися з потрібним типом результату "
"та типами аргументів функції, і їх можна використовувати як фабрики "
"декораторів, і як такі застосовувати до функцій за допомогою синтаксису "
"``@wrapper``. Перегляньте :ref:`ctypes-callback-functions` для прикладів."

msgid ""
"The returned function prototype creates functions that use the standard C "
"calling convention.  The function will release the GIL during the call.  If "
"*use_errno* is set to true, the ctypes private copy of the system :data:"
"`errno` variable is exchanged with the real :data:`errno` value before and "
"after the call; *use_last_error* does the same for the Windows error code."
msgstr ""
"Повернений прототип функції створює функції, які використовують стандартну "
"угоду про виклик C. Функція звільнить GIL під час виклику. Якщо *use_errno* "
"має значення true, приватна копія ctypes системної змінної :data:`errno` "
"обмінюється справжнім значенням :data:`errno` до і після виклику; "
"*use_last_error* робить те саме для коду помилки Windows."

msgid ""
"Windows only: The returned function prototype creates functions that use the "
"``stdcall`` calling convention.  The function will release the GIL during "
"the call.  *use_errno* and *use_last_error* have the same meaning as above."
msgstr ""
"Лише для Windows: повернутий прототип функції створює функції, які "
"використовують угоду про виклики ``stdcall``. Функція звільнить GIL під час "
"виклику. *use_errno* і *use_last_error* мають те саме значення, що й вище."

msgid ""
"The returned function prototype creates functions that use the Python "
"calling convention.  The function will *not* release the GIL during the call."
msgstr ""
"Повернений прототип функції створює функції, які використовують угоду про "
"виклики Python. Функція *не* звільняє GIL під час виклику."

msgid ""
"Function prototypes created by these factory functions can be instantiated "
"in different ways, depending on the type and number of the parameters in the "
"call:"
msgstr ""
"Прототипи функцій, створені цими фабричними функціями, можуть бути створені "
"різними способами, залежно від типу та кількості параметрів у виклику:"

msgid ""
"Returns a foreign function at the specified address which must be an integer."
msgstr ""
"Повертає зовнішню функцію за вказаною адресою, яка має бути цілим числом."

msgid ""
"Create a C callable function (a callback function) from a Python *callable*."
msgstr ""
"Створіть функцію виклику C (функцію зворотного виклику) з Python *callable*."

msgid ""
"Returns a foreign function exported by a shared library. *func_spec* must be "
"a 2-tuple ``(name_or_ordinal, library)``. The first item is the name of the "
"exported function as string, or the ordinal of the exported function as "
"small integer.  The second item is the shared library instance."
msgstr ""
"Повертає зовнішню функцію, експортовану спільною бібліотекою. *func_spec* "
"має бути 2-кортежем ``(name_or_ordinal, library)``. Перший елемент — це ім’я "
"експортованої функції у вигляді рядка або порядковий номер експортованої "
"функції у вигляді малого цілого числа. Другий елемент — екземпляр спільної "
"бібліотеки."

msgid ""
"Returns a foreign function that will call a COM method. *vtbl_index* is the "
"index into the virtual function table, a small non-negative integer. *name* "
"is name of the COM method. *iid* is an optional pointer to the interface "
"identifier which is used in extended error reporting."
msgstr ""
"Повертає зовнішню функцію, яка викликає метод COM. *vtbl_index* — це індекс "
"у таблиці віртуальних функцій, мале невід’ємне ціле число. *ім’я* — це ім’я "
"методу COM. *iid* — це додатковий покажчик на ідентифікатор інтерфейсу, який "
"використовується в розширеному звіті про помилки."

msgid ""
"COM methods use a special calling convention: They require a pointer to the "
"COM interface as first argument, in addition to those parameters that are "
"specified in the :attr:`argtypes` tuple."
msgstr ""
"Методи COM використовують спеціальну угоду про виклики: їм потрібен покажчик "
"на інтерфейс COM як перший аргумент, на додаток до тих параметрів, які "
"вказані в кортежі :attr:`argtypes`."

msgid ""
"The optional *paramflags* parameter creates foreign function wrappers with "
"much more functionality than the features described above."
msgstr ""
"Необов’язковий параметр *paramflags* створює зовнішні обгортки функцій із "
"набагато більшою функціональністю, ніж функції, описані вище."

msgid "*paramflags* must be a tuple of the same length as :attr:`argtypes`."
msgstr "*paramflags* має бути кортежем такої ж довжини, що й :attr:`argtypes`."

msgid ""
"Each item in this tuple contains further information about a parameter, it "
"must be a tuple containing one, two, or three items."
msgstr ""
"Кожен елемент у цьому кортежі містить додаткову інформацію про параметр, це "
"має бути кортеж, що містить один, два або три елементи."

msgid ""
"The first item is an integer containing a combination of direction flags for "
"the parameter:"
msgstr ""
"Перший елемент є цілим числом, що містить комбінацію прапорів напрямку для "
"параметра:"

msgid "1"
msgstr "1"

msgid "Specifies an input parameter to the function."
msgstr "Визначає вхідний параметр для функції."

msgid "2"
msgstr "2"

msgid "Output parameter.  The foreign function fills in a value."
msgstr "Вихідний параметр. Стороння функція заповнює значення."

msgid "4"
msgstr "4"

msgid "Input parameter which defaults to the integer zero."
msgstr "Вхідний параметр, який за умовчанням дорівнює нулю."

msgid ""
"The optional second item is the parameter name as string.  If this is "
"specified, the foreign function can be called with named parameters."
msgstr ""
"Другим необов’язковим елементом є назва параметра у вигляді рядка. Якщо це "
"вказано, зовнішня функція може бути викликана з іменованими параметрами."

msgid "The optional third item is the default value for this parameter."
msgstr ""
"Додатковий третій елемент є значенням за замовчуванням для цього параметра."

msgid ""
"This example demonstrates how to wrap the Windows ``MessageBoxW`` function "
"so that it supports default parameters and named arguments. The C "
"declaration from the windows header file is this::"
msgstr ""
"У цьому прикладі показано, як обернути функцію Windows ``MessageBoxW``, щоб "
"вона підтримувала параметри за замовчуванням та іменовані аргументи. "
"Оголошення C із файлу заголовка Windows таке::"

msgid "Here is the wrapping with :mod:`ctypes`::"
msgstr "Ось обгортка за допомогою :mod:`ctypes`::"

msgid "The ``MessageBox`` foreign function can now be called in these ways::"
msgstr ""
"Сторонню функцію ``MessageBox`` тепер можна викликати такими способами:"

msgid ""
"A second example demonstrates output parameters.  The win32 "
"``GetWindowRect`` function retrieves the dimensions of a specified window by "
"copying them into ``RECT`` structure that the caller has to supply.  Here is "
"the C declaration::"
msgstr ""
"Другий приклад демонструє вихідні параметри. Функція ``GetWindowRect`` win32 "
"отримує розміри вказаного вікна шляхом копіювання їх у структуру ``RECT``, "
"яку має надати абонент. Ось оголошення C::"

msgid ""
"Functions with output parameters will automatically return the output "
"parameter value if there is a single one, or a tuple containing the output "
"parameter values when there are more than one, so the GetWindowRect function "
"now returns a RECT instance, when called."
msgstr ""
"Функції з вихідними параметрами автоматично повертатимуть значення вихідного "
"параметра, якщо є одне, або кортеж, що містить значення вихідних параметрів, "
"якщо їх декілька, тому функція GetWindowRect тепер повертає екземпляр RECT "
"під час виклику."

msgid ""
"Output parameters can be combined with the :attr:`errcheck` protocol to do "
"further output processing and error checking.  The win32 ``GetWindowRect`` "
"api function returns a ``BOOL`` to signal success or failure, so this "
"function could do the error checking, and raises an exception when the api "
"call failed::"
msgstr ""
"Параметри виводу можна поєднати з протоколом :attr:`errcheck` для подальшої "
"обробки виводу та перевірки помилок. API-функція ``GetWindowRect`` win32 "
"повертає ``BOOL``, щоб сигналізувати про успіх або невдачу, тому ця функція "
"може виконувати перевірку помилок і створює виняток, коли виклик API не "
"вдається:"

msgid ""
"If the :attr:`errcheck` function returns the argument tuple it receives "
"unchanged, :mod:`ctypes` continues the normal processing it does on the "
"output parameters.  If you want to return a tuple of window coordinates "
"instead of a ``RECT`` instance, you can retrieve the fields in the function "
"and return them instead, the normal processing will no longer take place::"
msgstr ""
"Якщо функція :attr:`errcheck` повертає отриманий кортеж аргументів без "
"змін, :mod:`ctypes` продовжує звичайну обробку вихідних параметрів. Якщо ви "
"хочете повернути кортеж координат вікна замість екземпляра ``RECT``, ви "
"можете отримати поля у функції та повернути їх натомість, звичайна обробка "
"більше не відбуватиметься::"

msgid "Utility functions"
msgstr "Функції корисності"

msgid ""
"Returns the address of the memory buffer as integer.  *obj* must be an "
"instance of a ctypes type."
msgstr ""
"Повертає адресу буфера пам'яті як ціле число. *obj* має бути екземпляром "
"типу ctypes."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.addressof`` with "
"argument ``obj``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``ctypes.addressof`` з аргументом "
"``obj``."

msgid ""
"Returns the alignment requirements of a ctypes type. *obj_or_type* must be a "
"ctypes type or instance."
msgstr ""
"Повертає вимоги до вирівнювання типу ctypes. *obj_or_type* має бути типом "
"або екземпляром ctypes."

msgid ""
"Returns a light-weight pointer to *obj*, which must be an instance of a "
"ctypes type.  *offset* defaults to zero, and must be an integer that will be "
"added to the internal pointer value."
msgstr ""
"Повертає легкий вказівник на *obj*, який має бути екземпляром типу ctypes. "
"*offset* за замовчуванням дорівнює нулю і має бути цілим числом, яке буде "
"додано до значення внутрішнього покажчика."

msgid "``byref(obj, offset)`` corresponds to this C code::"
msgstr "``byref(obj, offset)`` відповідає цьому коду C::"

msgid ""
"The returned object can only be used as a foreign function call parameter. "
"It behaves similar to ``pointer(obj)``, but the construction is a lot faster."
msgstr ""
"Повернений об’єкт можна використовувати лише як параметр виклику зовнішньої "
"функції. Він поводиться подібно до ``pointer(obj)``, але будівництво "
"відбувається набагато швидше."

msgid ""
"This function is similar to the cast operator in C. It returns a new "
"instance of *type* which points to the same memory block as *obj*.  *type* "
"must be a pointer type, and *obj* must be an object that can be interpreted "
"as a pointer."
msgstr ""
"Ця функція схожа на оператор приведення в C. Вона повертає новий екземпляр "
"*type*, який вказує на той самий блок пам’яті, що й *obj*. *type* має бути "
"типом покажчика, а *obj* має бути об’єктом, який можна інтерпретувати як "
"покажчик."

msgid ""
"This function creates a mutable character buffer. The returned object is a "
"ctypes array of :class:`c_char`."
msgstr ""
"Ця функція створює змінний символьний буфер. Повернений об’єкт є масивом "
"ctypes :class:`c_char`."

msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a bytes object which will be used to initialize the array items."
msgstr ""
"*init_or_size* має бути цілим числом, яке визначає розмір масиву, або "
"об’єктом bytes, який використовуватиметься для ініціалізації елементів "
"масиву."

msgid ""
"If a bytes object is specified as first argument, the buffer is made one "
"item larger than its length so that the last element in the array is a NUL "
"termination character. An integer can be passed as second argument which "
"allows specifying the size of the array if the length of the bytes should "
"not be used."
msgstr ""
"Якщо в якості першого аргументу вказано об’єкт bytes, буфер стає на один "
"елемент більшим, ніж його довжина, так що останній елемент у масиві є "
"завершальним символом NUL. Ціле число може бути передане як другий аргумент, "
"що дозволяє вказати розмір масиву, якщо довжина байтів не повинна "
"використовуватися."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_string_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``ctypes.create_string_buffer`` з "
"аргументами ``init``, ``size``."

msgid ""
"This function creates a mutable unicode character buffer. The returned "
"object is a ctypes array of :class:`c_wchar`."
msgstr ""
"Ця функція створює змінний буфер символів Unicode. Повернений об’єкт є "
"масивом ctypes :class:`c_wchar`."

msgid ""
"*init_or_size* must be an integer which specifies the size of the array, or "
"a string which will be used to initialize the array items."
msgstr ""
"*init_or_size* має бути цілим числом, що вказує розмір масиву, або рядком, "
"який використовуватиметься для ініціалізації елементів масиву."

msgid ""
"If a string is specified as first argument, the buffer is made one item "
"larger than the length of the string so that the last element in the array "
"is a NUL termination character. An integer can be passed as second argument "
"which allows specifying the size of the array if the length of the string "
"should not be used."
msgstr ""
"Якщо рядок вказано як перший аргумент, буфер робиться на один елемент "
"більшим, ніж довжина рядка, так що останній елемент у масиві є завершальним "
"символом NUL. Ціле число може бути передане як другий аргумент, що дозволяє "
"вказати розмір масиву, якщо довжина рядка не повинна використовуватися."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.create_unicode_buffer`` "
"with arguments ``init``, ``size``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``ctypes.create_unicode_buffer`` з "
"аргументами ``init``, ``size``."

msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllCanUnloadNow function "
"that the _ctypes extension dll exports."
msgstr ""
"Лише для Windows: ця функція є хуком, який дозволяє реалізувати COM-сервери "
"в процесі за допомогою ctypes. Він викликається з функції DllCanUnloadNow, "
"яку експортує dll розширення _ctypes."

msgid ""
"Windows only: This function is a hook which allows implementing in-process "
"COM servers with ctypes.  It is called from the DllGetClassObject function "
"that the ``_ctypes`` extension dll exports."
msgstr ""
"Лише для Windows: ця функція є хуком, який дозволяє реалізувати COM-сервери "
"в процесі за допомогою ctypes. Він викликається з функції DllGetClassObject, "
"яку експортує dll розширення ``_ctypes``."

msgid ""
"Try to find a library and return a pathname.  *name* is the library name "
"without any prefix like ``lib``, suffix like ``.so``, ``.dylib`` or version "
"number (this is the form used for the posix linker option :option:`!-l`).  "
"If no library can be found, returns ``None``."
msgstr ""
"Спробуйте знайти бібліотеку та повернути шлях. *ім’я* — це ім’я бібліотеки "
"без будь-яких префіксів, як-от ``lib``, суфіксів, як-от ``.so``, ``.dylib`` "
"або номера версії (це форма, яка використовується для параметра "
"компонувальника posix :option:`!-l`). Якщо бібліотеки не знайдено, повертає "
"``None``."

msgid ""
"Windows only: return the filename of the VC runtime library used by Python, "
"and by the extension modules.  If the name of the library cannot be "
"determined, ``None`` is returned."
msgstr ""
"Лише для Windows: повертає назву файлу бібліотеки середовища виконання VC, "
"яка використовується Python, і модулями розширення. Якщо назва бібліотеки не "
"може бути визначена, повертається ``None``."

msgid ""
"If you need to free memory, for example, allocated by an extension module "
"with a call to the ``free(void *)``, it is important that you use the "
"function in the same library that allocated the memory."
msgstr ""
"Якщо вам потрібно звільнити пам’ять, наприклад, виділену модулем розширення "
"за допомогою виклику ``free(void *)``, важливо, щоб ви використовували "
"функцію в тій самій бібліотеці, яка виділила пам’ять."

msgid ""
"Windows only: Returns a textual description of the error code *code*.  If no "
"error code is specified, the last error code is used by calling the Windows "
"api function GetLastError."
msgstr ""
"Лише для Windows: повертає текстовий опис коду помилки *code*. Якщо код "
"помилки не вказано, останній код помилки використовується під час виклику "
"функції Windows API GetLastError."

msgid ""
"Windows only: Returns the last error code set by Windows in the calling "
"thread. This function calls the Windows ``GetLastError()`` function "
"directly, it does not return the ctypes-private copy of the error code."
msgstr ""

msgid ""
"Returns the current value of the ctypes-private copy of the system :data:"
"`errno` variable in the calling thread."
msgstr ""
"Повертає поточне значення ctypes-private копії системної змінної :data:"
"`errno` у потоці виклику."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_errno`` with no "
"arguments."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``ctypes.get_errno`` без аргументів."

msgid ""
"Windows only: returns the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread."
msgstr ""
"Лише для Windows: повертає поточне значення ctypes-private копії системної "
"змінної :data:`LastError` у потоці виклику."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.get_last_error`` with no "
"arguments."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``ctypes.get_last_error`` без "
"аргументів."

msgid ""
"Same as the standard C memmove library function: copies *count* bytes from "
"*src* to *dst*. *dst* and *src* must be integers or ctypes instances that "
"can be converted to pointers."
msgstr ""
"Те саме, що стандартна функція бібліотеки C memmove: копіює *count* байти з "
"*src* до *dst*. *dst* і *src* мають бути цілими числами або екземплярами "
"ctypes, які можна перетворити на покажчики."

msgid ""
"Same as the standard C memset library function: fills the memory block at "
"address *dst* with *count* bytes of value *c*. *dst* must be an integer "
"specifying an address, or a ctypes instance."
msgstr ""
"Те саме, що стандартна функція бібліотеки memset C: заповнює блок пам’яті за "
"адресою *dst* *count* байтами зі значенням *c*. *dst* має бути цілим числом, "
"що визначає адресу, або екземпляр ctypes."

msgid ""
"This factory function creates and returns a new ctypes pointer type. Pointer "
"types are cached and reused internally, so calling this function repeatedly "
"is cheap. *type* must be a ctypes type."
msgstr ""
"Ця фабрична функція створює та повертає новий тип покажчика ctypes. Типи "
"вказівників кешуються та повторно використовуються внутрішньо, тому "
"повторний виклик цієї функції є дешевим. *type* має бути типом ctypes."

msgid ""
"This function creates a new pointer instance, pointing to *obj*. The "
"returned object is of the type ``POINTER(type(obj))``."
msgstr ""
"Ця функція створює новий екземпляр покажчика, що вказує на *obj*. Повернений "
"об’єкт має тип ``POINTER(type(obj))``."

msgid ""
"Note: If you just want to pass a pointer to an object to a foreign function "
"call, you should use ``byref(obj)`` which is much faster."
msgstr ""
"Примітка. Якщо ви просто хочете передати вказівник на об’єкт у зовнішній "
"виклик функції, вам слід використовувати ``byref(obj)``, що набагато швидше."

msgid ""
"This function resizes the internal memory buffer of *obj*, which must be an "
"instance of a ctypes type.  It is not possible to make the buffer smaller "
"than the native size of the objects type, as given by ``sizeof(type(obj))``, "
"but it is possible to enlarge the buffer."
msgstr ""
"Ця функція змінює розмір буфера внутрішньої пам’яті *obj*, який має бути "
"екземпляром типу ctypes. Неможливо зробити буфер меншим, ніж власний розмір "
"типу об’єктів, як задано ``sizeof(type(obj))``, але можна збільшити буфер."

msgid ""
"Set the current value of the ctypes-private copy of the system :data:`errno` "
"variable in the calling thread to *value* and return the previous value."
msgstr ""
"Установіть поточне значення ctypes-private копії системної змінної :data:"
"`errno` у викликаючому потоці на *value* і поверніть попереднє значення."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_errno`` with "
"argument ``errno``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``ctypes.set_errno`` з аргументом "
"``errno``."

msgid ""
"Windows only: set the current value of the ctypes-private copy of the "
"system :data:`LastError` variable in the calling thread to *value* and "
"return the previous value."
msgstr ""
"Лише для Windows: установіть поточне значення ctypes-private копії системної "
"змінної :data:`LastError` у викликаючому потоці на *value* і поверніть "
"попереднє значення."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.set_last_error`` with "
"argument ``error``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``ctypes.set_last_error`` з "
"аргументом ``помилка``."

msgid ""
"Returns the size in bytes of a ctypes type or instance memory buffer. Does "
"the same as the C ``sizeof`` operator."
msgstr ""
"Повертає розмір у байтах типу ctypes або буфера пам’яті примірника. Діє так "
"само, як і оператор C ``sizeof``."

msgid ""
"This function returns the C string starting at memory address *address* as a "
"bytes object. If size is specified, it is used as size, otherwise the string "
"is assumed to be zero-terminated."
msgstr ""
"Ця функція повертає рядок C, починаючи з адреси пам’яті *address*, як об’єкт "
"bytes. Якщо вказано розмір, він використовується як розмір, інакше рядок "
"вважається закінченим нулем."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.string_at`` with "
"arguments ``address``, ``size``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``ctypes.string_at`` з аргументами "
"``address``, ``size``."

msgid ""
"Windows only: this function is probably the worst-named thing in ctypes. It "
"creates an instance of OSError.  If *code* is not specified, "
"``GetLastError`` is called to determine the error code. If *descr* is not "
"specified, :func:`FormatError` is called to get a textual description of the "
"error."
msgstr ""
"Лише для Windows: ця функція є, мабуть, найгіршою назвою в ctypes. Він "
"створює екземпляр OSError. Якщо *код* не вказано, для визначення коду "
"помилки викликається GetLastError. Якщо *descr* не вказано, :func:"
"`FormatError` викликається для отримання текстового опису помилки."

msgid "An instance of :exc:`WindowsError` used to be created."
msgstr "Раніше створювався екземпляр :exc:`WindowsError`."

msgid ""
"This function returns the wide character string starting at memory address "
"*address* as a string.  If *size* is specified, it is used as the number of "
"characters of the string, otherwise the string is assumed to be zero-"
"terminated."
msgstr ""
"Ця функція повертає широкий рядок символів, починаючи з адреси пам’яті "
"*address*, як рядок. Якщо вказано *size*, він використовується як кількість "
"символів у рядку, інакше рядок вважається закінченим нулем."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.wstring_at`` with "
"arguments ``address``, ``size``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``ctypes.wstring_at`` з аргументами "
"``адреса``, ``розмір``."

msgid "Data types"
msgstr "Типи даних"

msgid ""
"This non-public class is the common base class of all ctypes data types. "
"Among other things, all ctypes type instances contain a memory block that "
"hold C compatible data; the address of the memory block is returned by the :"
"func:`addressof` helper function. Another instance variable is exposed as :"
"attr:`_objects`; this contains other Python objects that need to be kept "
"alive in case the memory block contains pointers."
msgstr ""
"Цей непублічний клас є загальним базовим класом для всіх типів даних ctypes. "
"Серед іншого, усі екземпляри типу ctypes містять блок пам’яті, який містить "
"C-сумісні дані; адреса блоку пам'яті повертається допоміжною функцією :func:"
"`addressof`. Інша змінна екземпляра представлена як :attr:`_objects`; це "
"містить інші об’єкти Python, які потрібно підтримувати в активному стані, "
"якщо блок пам’яті містить покажчики."

msgid ""
"Common methods of ctypes data types, these are all class methods (to be "
"exact, they are methods of the :term:`metaclass`):"
msgstr ""
"Загальні методи типів даних ctypes, це всі методи класу (точніше, це методи :"
"term:`metaclass`):"

msgid ""
"This method returns a ctypes instance that shares the buffer of the *source* "
"object.  The *source* object must support the writeable buffer interface.  "
"The optional *offset* parameter specifies an offset into the source buffer "
"in bytes; the default is zero.  If the source buffer is not large enough a :"
"exc:`ValueError` is raised."
msgstr ""
"Цей метод повертає екземпляр ctypes, який спільно використовує буфер об’єкта "
"*source*. Об'єкт *джерело* має підтримувати інтерфейс буфера з можливістю "
"запису. Необов'язковий параметр *offset* визначає зсув у вихідному буфері в "
"байтах; за замовчуванням дорівнює нулю. Якщо вихідний буфер недостатньо "
"великий, виникає :exc:`ValueError`."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata/buffer`` with "
"arguments ``pointer``, ``size``, ``offset``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``ctypes.cdata/buffer`` з "
"аргументами ``pointer``, ``size``, ``offset``."

msgid ""
"This method creates a ctypes instance, copying the buffer from the *source* "
"object buffer which must be readable.  The optional *offset* parameter "
"specifies an offset into the source buffer in bytes; the default is zero.  "
"If the source buffer is not large enough a :exc:`ValueError` is raised."
msgstr ""
"Цей метод створює екземпляр ctypes, копіюючи буфер із буфера *джерельного* "
"об’єкта, який має бути читабельним. Необов'язковий параметр *offset* "
"визначає зсув у вихідному буфері в байтах; за замовчуванням дорівнює нулю. "
"Якщо вихідний буфер недостатньо великий, виникає :exc:`ValueError`."

msgid ""
"This method returns a ctypes type instance using the memory specified by "
"*address* which must be an integer."
msgstr ""
"Цей метод повертає екземпляр типу ctypes, використовуючи пам’ять, визначену "
"*адресою*, яка має бути цілим числом."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``ctypes.cdata`` with argument "
"``address``."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``ctypes.cdata`` з аргументом "
"``адреса``."

msgid ""
"This method, and others that indirectly call this method, raises an :ref:"
"`auditing event <auditing>` ``ctypes.cdata`` with argument ``address``."
msgstr ""
"Цей метод та інші, які опосередковано викликають цей метод, викликають :ref:"
"`подію аудиту <auditing>` ``ctypes.cdata`` з аргументом ``адреса``."

msgid ""
"This method adapts *obj* to a ctypes type.  It is called with the actual "
"object used in a foreign function call when the type is present in the "
"foreign function's :attr:`argtypes` tuple; it must return an object that can "
"be used as a function call parameter."
msgstr ""
"Цей метод адаптує *obj* до типу ctypes. Він викликається з фактичним "
"об’єктом, який використовується у виклику зовнішньої функції, коли тип "
"присутній у кортежі :attr:`argtypes` зовнішньої функції; він повинен "
"повертати об'єкт, який можна використовувати як параметр виклику функції."

msgid ""
"All ctypes data types have a default implementation of this classmethod that "
"normally returns *obj* if that is an instance of the type.  Some types "
"accept other objects as well."
msgstr ""
"Усі типи даних ctypes мають стандартну реалізацію цього методу класу, який "
"зазвичай повертає *obj*, якщо це екземпляр типу. Деякі типи також приймають "
"інші об’єкти."

msgid ""
"This method returns a ctypes type instance exported by a shared library. "
"*name* is the name of the symbol that exports the data, *library* is the "
"loaded shared library."
msgstr ""
"Цей метод повертає екземпляр типу ctypes, експортований спільною "
"бібліотекою. *name* — це ім’я символу, який експортує дані, *library* — це "
"завантажена спільна бібліотека."

msgid "Common instance variables of ctypes data types:"
msgstr "Загальні змінні екземплярів типів даних ctypes:"

msgid ""
"Sometimes ctypes data instances do not own the memory block they contain, "
"instead they share part of the memory block of a base object.  The :attr:"
"`_b_base_` read-only member is the root ctypes object that owns the memory "
"block."
msgstr ""
"Іноді екземпляри даних ctypes не володіють блоком пам’яті, який вони "
"містять, натомість вони спільно використовують частину блоку пам’яті "
"базового об’єкта. Член :attr:`_b_base_` лише для читання є кореневим "
"об’єктом ctypes, якому належить блок пам’яті."

msgid ""
"This read-only variable is true when the ctypes data instance has allocated "
"the memory block itself, false otherwise."
msgstr ""
"Ця змінна лише для читання є істиною, коли екземпляр даних ctypes сам "
"виділив блок пам’яті, інакше – false."

msgid ""
"This member is either ``None`` or a dictionary containing Python objects "
"that need to be kept alive so that the memory block contents is kept valid.  "
"This object is only exposed for debugging; never modify the contents of this "
"dictionary."
msgstr ""
"Цей член або ``None``, або словник, що містить об’єкти Python, які потрібно "
"підтримувати в активному стані, щоб вміст блоку пам’яті залишався дійсним. "
"Цей об’єкт доступний лише для налагодження; ніколи не змінюйте вміст цього "
"словника."

msgid ""
"This non-public class is the base class of all fundamental ctypes data "
"types. It is mentioned here because it contains the common attributes of the "
"fundamental ctypes data types.  :class:`_SimpleCData` is a subclass of :"
"class:`_CData`, so it inherits their methods and attributes. ctypes data "
"types that are not and do not contain pointers can now be pickled."
msgstr ""
"Цей закритий клас є базовим класом усіх основних типів даних ctypes. Він "
"згадується тут, оскільки він містить загальні атрибути основних типів даних "
"ctypes. :class:`_SimpleCData` є підкласом :class:`_CData`, тому він "
"успадковує їхні методи та атрибути. Типи даних ctypes, які не є та не "
"містять покажчиків, тепер можна маринувати."

msgid "Instances have a single attribute:"
msgstr "Екземпляри мають один атрибут:"

msgid ""
"This attribute contains the actual value of the instance. For integer and "
"pointer types, it is an integer, for character types, it is a single "
"character bytes object or string, for character pointer types it is a Python "
"bytes object or string."
msgstr ""
"Цей атрибут містить фактичне значення екземпляра. Для цілочисельних типів і "
"типів покажчиків це ціле число, для типів символів – об’єкт або рядок із "
"одним символом у байтах, для типів покажчиків на символи – це об’єкт або "
"рядок Python bytes."

msgid ""
"When the ``value`` attribute is retrieved from a ctypes instance, usually a "
"new object is returned each time.  :mod:`ctypes` does *not* implement "
"original object return, always a new object is constructed.  The same is "
"true for all other ctypes object instances."
msgstr ""
"Коли атрибут ``value`` отримується з екземпляра ctypes, зазвичай щоразу "
"повертається новий об’єкт. :mod:`ctypes` *не* реалізує повернення "
"оригінального об’єкта, завжди створюється новий об’єкт. Те саме стосується "
"всіх інших екземплярів об’єктів ctypes."

msgid ""
"Fundamental data types, when returned as foreign function call results, or, "
"for example, by retrieving structure field members or array items, are "
"transparently converted to native Python types.  In other words, if a "
"foreign function has a :attr:`restype` of :class:`c_char_p`, you will always "
"receive a Python bytes object, *not* a :class:`c_char_p` instance."
msgstr ""
"Фундаментальні типи даних, коли повертаються як результати виклику "
"зовнішньої функції або, наприклад, шляхом отримання членів полів структури "
"чи елементів масиву, прозоро перетворюються на рідні типи Python. Іншими "
"словами, якщо стороння функція має :attr:`restype` :class:`c_char_p`, ви "
"завжди отримуватимете об’єкт Python bytes, *а не* екземпляр :class:"
"`c_char_p`."

msgid ""
"Subclasses of fundamental data types do *not* inherit this behavior. So, if "
"a foreign functions :attr:`restype` is a subclass of :class:`c_void_p`, you "
"will receive an instance of this subclass from the function call. Of course, "
"you can get the value of the pointer by accessing the ``value`` attribute."
msgstr ""
"Підкласи фундаментальних типів даних *не* успадковують цю поведінку. Отже, "
"якщо зовнішня функція :attr:`restype` є підкласом :class:`c_void_p`, ви "
"отримаєте екземпляр цього підкласу під час виклику функції. Звичайно, ви "
"можете отримати значення вказівника, звернувшись до атрибута ``value``."

msgid "These are the fundamental ctypes data types:"
msgstr "Ось основні типи даних ctypes:"

msgid ""
"Represents the C :c:expr:`signed char` datatype, and interprets the value as "
"small integer.  The constructor accepts an optional integer initializer; no "
"overflow checking is done."
msgstr ""

msgid ""
"Represents the C :c:expr:`char` datatype, and interprets the value as a "
"single character.  The constructor accepts an optional string initializer, "
"the length of the string must be exactly one character."
msgstr ""

msgid ""
"Represents the C :c:expr:`char *` datatype when it points to a zero-"
"terminated string.  For a general character pointer that may also point to "
"binary data, ``POINTER(c_char)`` must be used.  The constructor accepts an "
"integer address, or a bytes object."
msgstr ""

msgid ""
"Represents the C :c:expr:`double` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""

msgid ""
"Represents the C :c:expr:`long double` datatype.  The constructor accepts an "
"optional float initializer.  On platforms where ``sizeof(long double) == "
"sizeof(double)`` it is an alias to :class:`c_double`."
msgstr ""

msgid ""
"Represents the C :c:expr:`float` datatype.  The constructor accepts an "
"optional float initializer."
msgstr ""

msgid ""
"Represents the C :c:expr:`signed int` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias to :class:`c_long`."
msgstr ""

msgid ""
"Represents the C 8-bit :c:expr:`signed int` datatype.  Usually an alias for :"
"class:`c_byte`."
msgstr ""

msgid ""
"Represents the C 16-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_short`."
msgstr ""

msgid ""
"Represents the C 32-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_int`."
msgstr ""

msgid ""
"Represents the C 64-bit :c:expr:`signed int` datatype.  Usually an alias "
"for :class:`c_longlong`."
msgstr ""

msgid ""
"Represents the C :c:expr:`signed long` datatype.  The constructor accepts an "
"optional integer initializer; no overflow checking is done."
msgstr ""

msgid ""
"Represents the C :c:expr:`signed long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""

msgid ""
"Represents the C :c:expr:`signed short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""

msgid "Represents the C :c:type:`size_t` datatype."
msgstr "Представляє тип даних C :c:type:`size_t`."

msgid "Represents the C :c:type:`ssize_t` datatype."
msgstr "Представляє тип даних C :c:type:`ssize_t`."

msgid ""
"Represents the C :c:expr:`unsigned char` datatype, it interprets the value "
"as small integer.  The constructor accepts an optional integer initializer; "
"no overflow checking is done."
msgstr ""

msgid ""
"Represents the C :c:expr:`unsigned int` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done.  On platforms "
"where ``sizeof(int) == sizeof(long)`` it is an alias for :class:`c_ulong`."
msgstr ""

msgid ""
"Represents the C 8-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ubyte`."
msgstr ""

msgid ""
"Represents the C 16-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ushort`."
msgstr ""

msgid ""
"Represents the C 32-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_uint`."
msgstr ""

msgid ""
"Represents the C 64-bit :c:expr:`unsigned int` datatype.  Usually an alias "
"for :class:`c_ulonglong`."
msgstr ""

msgid ""
"Represents the C :c:expr:`unsigned long` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""

msgid ""
"Represents the C :c:expr:`unsigned long long` datatype.  The constructor "
"accepts an optional integer initializer; no overflow checking is done."
msgstr ""

msgid ""
"Represents the C :c:expr:`unsigned short` datatype.  The constructor accepts "
"an optional integer initializer; no overflow checking is done."
msgstr ""

msgid ""
"Represents the C :c:expr:`void *` type.  The value is represented as "
"integer. The constructor accepts an optional integer initializer."
msgstr ""

msgid ""
"Represents the C :c:expr:`wchar_t` datatype, and interprets the value as a "
"single character unicode string.  The constructor accepts an optional string "
"initializer, the length of the string must be exactly one character."
msgstr ""

msgid ""
"Represents the C :c:expr:`wchar_t *` datatype, which must be a pointer to a "
"zero-terminated wide character string.  The constructor accepts an integer "
"address, or a string."
msgstr ""

msgid ""
"Represent the C :c:expr:`bool` datatype (more accurately, :c:expr:`_Bool` "
"from C99).  Its value can be ``True`` or ``False``, and the constructor "
"accepts any object that has a truth value."
msgstr ""

msgid ""
"Windows only: Represents a :c:type:`HRESULT` value, which contains success "
"or error information for a function or method call."
msgstr ""
"Лише для Windows: представляє значення :c:type:`HRESULT`, яке містить "
"інформацію про успіх або помилку для виклику функції чи методу."

msgid ""
"Represents the C :c:expr:`PyObject *` datatype.  Calling this without an "
"argument creates a ``NULL`` :c:expr:`PyObject *` pointer."
msgstr ""

msgid ""
"The :mod:`ctypes.wintypes` module provides quite some other Windows specific "
"data types, for example :c:type:`HWND`, :c:type:`WPARAM`, or :c:type:"
"`DWORD`.  Some useful structures like :c:type:`MSG` or :c:type:`RECT` are "
"also defined."
msgstr ""
"Модуль :mod:`ctypes.wintypes` надає деякі інші специфічні типи даних "
"Windows, наприклад :c:type:`HWND`, :c:type:`WPARAM` або :c:type:`DWORD`. "
"Деякі корисні структури, такі як :c:type:`MSG` або :c:type:`RECT`, також "
"визначені."

msgid "Structured data types"
msgstr "Структуровані типи даних"

msgid "Abstract base class for unions in native byte order."
msgstr "Абстрактний базовий клас для об’єднань у рідному порядку байтів."

msgid "Abstract base class for unions in *big endian* byte order."
msgstr ""

msgid "Abstract base class for unions in *little endian* byte order."
msgstr ""

msgid "Abstract base class for structures in *big endian* byte order."
msgstr "Абстрактний базовий клас для структур у *великому порядку байтів*."

msgid "Abstract base class for structures in *little endian* byte order."
msgstr ""
"Абстрактний базовий клас для структур у порядку байтів *little endian*."

msgid ""
"Structures and unions with non-native byte order cannot contain pointer type "
"fields, or any other data types containing pointer type fields."
msgstr ""

msgid "Abstract base class for structures in *native* byte order."
msgstr "Абстрактний базовий клас для структур у *власному* порядку байтів."

msgid ""
"Concrete structure and union types must be created by subclassing one of "
"these types, and at least define a :attr:`_fields_` class variable. :mod:"
"`ctypes` will create :term:`descriptor`\\s which allow reading and writing "
"the fields by direct attribute accesses.  These are the"
msgstr ""
"Конкретні типи структури та об’єднання мають бути створені шляхом створення "
"підкласу одного з цих типів і принаймні визначення змінної класу :attr:"
"`_fields_`. :mod:`ctypes` створить :term:`descriptor`\\s, які дозволяють "
"читати та записувати поля за допомогою прямого доступу до атрибутів. Це"

msgid ""
"A sequence defining the structure fields.  The items must be 2-tuples or 3-"
"tuples.  The first item is the name of the field, the second item specifies "
"the type of the field; it can be any ctypes data type."
msgstr ""
"Послідовність, що визначає поля структури. Елементи мають бути 2-кортежними "
"або 3-кортежними. Перший пункт – ім’я поля, другий – тип поля; це може бути "
"будь-який тип даних ctypes."

msgid ""
"For integer type fields like :class:`c_int`, a third optional item can be "
"given.  It must be a small positive integer defining the bit width of the "
"field."
msgstr ""
"Для полів цілого типу, таких як :class:`c_int`, можна вказати третій "
"необов’язковий елемент. Це має бути маленьке позитивне ціле число, що "
"визначає розрядність поля."

msgid ""
"Field names must be unique within one structure or union.  This is not "
"checked, only one field can be accessed when names are repeated."
msgstr ""
"Імена полів мають бути унікальними в межах однієї структури чи об’єднання. "
"Це не позначено, лише одне поле доступне, якщо імена повторюються."

msgid ""
"It is possible to define the :attr:`_fields_` class variable *after* the "
"class statement that defines the Structure subclass, this allows creating "
"data types that directly or indirectly reference themselves::"
msgstr ""
"Можна визначити змінну класу :attr:`_fields_` *після* оператора класу, який "
"визначає підклас Structure, це дозволяє створювати типи даних, які прямо чи "
"опосередковано посилаються на себе::"

msgid ""
"The :attr:`_fields_` class variable must, however, be defined before the "
"type is first used (an instance is created, :func:`sizeof` is called on it, "
"and so on).  Later assignments to the :attr:`_fields_` class variable will "
"raise an AttributeError."
msgstr ""
"Однак змінну класу :attr:`_fields_` потрібно визначити перед першим "
"використанням типу (створюється екземпляр, для нього викликається :func:"
"`sizeof` і так далі). Пізніше призначення змінній класу :attr:`_fields_` "
"призведе до помилки AttributeError."

msgid ""
"It is possible to define sub-subclasses of structure types, they inherit the "
"fields of the base class plus the :attr:`_fields_` defined in the sub-"
"subclass, if any."
msgstr ""
"Можна визначити під-підкласи структурних типів, вони успадковують поля "
"базового класу плюс :attr:`_fields_`, визначені в під-підкласі, якщо такі є."

msgid ""
"An optional small integer that allows overriding the alignment of structure "
"fields in the instance.  :attr:`_pack_` must already be defined when :attr:"
"`_fields_` is assigned, otherwise it will have no effect."
msgstr ""
"Необов’язкове мале ціле число, яке дозволяє змінити вирівнювання полів "
"структури в екземплярі. :attr:`_pack_` має бути вже визначено, коли :attr:"
"`_fields_` призначено, інакше це не матиме ефекту."

msgid ""
"An optional sequence that lists the names of unnamed (anonymous) fields. :"
"attr:`_anonymous_` must be already defined when :attr:`_fields_` is "
"assigned, otherwise it will have no effect."
msgstr ""
"Необов’язкова послідовність, яка містить імена безіменних (анонімних) "
"полів. :attr:`_anonymous_` має бути вже визначено під час призначення :attr:"
"`_fields_`, інакше це не матиме ефекту."

msgid ""
"The fields listed in this variable must be structure or union type fields. :"
"mod:`ctypes` will create descriptors in the structure type that allows "
"accessing the nested fields directly, without the need to create the "
"structure or union field."
msgstr ""
"Поля, перелічені в цій змінній, мають бути структурними або об’єднаними. :"
"mod:`ctypes` створить дескриптори у структурному типі, що дозволяє отримати "
"доступ до вкладених полів безпосередньо, без необхідності створювати "
"структуру чи поле об’єднання."

msgid "Here is an example type (Windows)::"
msgstr "Ось приклад типу (Windows):"

msgid ""
"The ``TYPEDESC`` structure describes a COM data type, the ``vt`` field "
"specifies which one of the union fields is valid.  Since the ``u`` field is "
"defined as anonymous field, it is now possible to access the members "
"directly off the TYPEDESC instance. ``td.lptdesc`` and ``td.u.lptdesc`` are "
"equivalent, but the former is faster since it does not need to create a "
"temporary union instance::"
msgstr ""
"Структура ``TYPEDESC`` описує тип даних COM, поле ``vt`` визначає, яке з "
"полів об’єднання є дійсним. Оскільки поле ``u`` визначено як анонімне поле, "
"тепер можна отримати доступ до членів безпосередньо з примірника TYPEDESC. "
"``td.lptdesc`` і ``td.u.lptdesc`` еквівалентні, але перший швидший, оскільки "
"йому не потрібно створювати тимчасовий екземпляр об’єднання::"

msgid ""
"It is possible to define sub-subclasses of structures, they inherit the "
"fields of the base class.  If the subclass definition has a separate :attr:"
"`_fields_` variable, the fields specified in this are appended to the fields "
"of the base class."
msgstr ""
"Є можливість визначення суб-підкласів структур, вони успадковують поля "
"базового класу. Якщо визначення підкласу має окрему змінну :attr:`_fields_`, "
"поля, зазначені в ній, додаються до полів базового класу."

msgid ""
"Structure and union constructors accept both positional and keyword "
"arguments.  Positional arguments are used to initialize member fields in the "
"same order as they are appear in :attr:`_fields_`.  Keyword arguments in the "
"constructor are interpreted as attribute assignments, so they will "
"initialize :attr:`_fields_` with the same name, or create new attributes for "
"names not present in :attr:`_fields_`."
msgstr ""
"Конструктори структури та об’єднання приймають як позиційні, так і ключові "
"аргументи. Позиційні аргументи використовуються для ініціалізації полів-"
"членів у такому самому порядку, як вони з’являються в :attr:`_fields_`. "
"Аргументи ключових слів у конструкторі інтерпретуються як призначення "
"атрибутів, тому вони ініціалізують :attr:`_fields_` з тим же іменем або "
"створять нові атрибути для імен, яких немає в :attr:`_fields_`."

msgid "Arrays and pointers"
msgstr "Масиви та покажчики"

msgid "Abstract base class for arrays."
msgstr "Абстрактний базовий клас для масивів."

msgid ""
"The recommended way to create concrete array types is by multiplying any :"
"mod:`ctypes` data type with a non-negative integer.  Alternatively, you can "
"subclass this type and define :attr:`_length_` and :attr:`_type_` class "
"variables. Array elements can be read and written using standard subscript "
"and slice accesses; for slice reads, the resulting object is *not* itself "
"an :class:`Array`."
msgstr ""
"Рекомендований спосіб створення конкретних типів масивів — це множення будь-"
"якого типу даних :mod:`ctypes` на невід’ємне ціле число. Крім того, ви "
"можете створити підклас цього типу та визначити змінні класу :attr:"
"`_length_` і :attr:`_type_`. Елементи масиву можна читати та записувати за "
"допомогою стандартного підрядкового і зрізного доступу; для зчитування "
"фрагментів результуючий об’єкт *не* сам є :class:`Array`."

msgid ""
"A positive integer specifying the number of elements in the array. Out-of-"
"range subscripts result in an :exc:`IndexError`. Will be returned by :func:"
"`len`."
msgstr ""
"Додатне ціле число, що визначає кількість елементів у масиві. Індекси поза "
"діапазоном призводять до :exc:`IndexError`. Буде повернено :func:`len`."

msgid "Specifies the type of each element in the array."
msgstr "Визначає тип кожного елемента в масиві."

msgid ""
"Array subclass constructors accept positional arguments, used to initialize "
"the elements in order."
msgstr ""
"Конструктори підкласу масиву приймають позиційні аргументи, які "
"використовуються для ініціалізації елементів у порядку."

msgid "Private, abstract base class for pointers."
msgstr "Приватний, абстрактний базовий клас для вказівників."

msgid ""
"Concrete pointer types are created by calling :func:`POINTER` with the type "
"that will be pointed to; this is done automatically by :func:`pointer`."
msgstr ""
"Конкретні типи вказівників створюються шляхом виклику :func:`POINTER` із "
"типом, на який буде вказувати; це робиться автоматично за допомогою :func:"
"`pointer`."

msgid ""
"If a pointer points to an array, its elements can be read and written using "
"standard subscript and slice accesses.  Pointer objects have no size, so :"
"func:`len` will raise :exc:`TypeError`.  Negative subscripts will read from "
"the memory *before* the pointer (as in C), and out-of-range subscripts will "
"probably crash with an access violation (if you're lucky)."
msgstr ""
"Якщо вказівник вказує на масив, його елементи можна читати та записувати за "
"допомогою стандартного підрядкового і зрізного доступу. Об’єкти-вказівники "
"не мають розміру, тому :func:`len` викличе :exc:`TypeError`. Негативні "
"індекси читатимуться з пам’яті *перед* вказівником (як у C), а індекси поза "
"межами діапазону, ймовірно, впадуть із порушенням доступу (якщо вам "
"пощастить)."

msgid "Specifies the type pointed to."
msgstr "Визначає тип, на який вказується."

msgid ""
"Returns the object to which to pointer points.  Assigning to this attribute "
"changes the pointer to point to the assigned object."
msgstr ""
"Повертає об’єкт, на який вказує вказівник. Призначення цьому атрибуту змінює "
"вказівник на призначений об’єкт."
