# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:57+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ""
":mod:`!contextlib` --- Utilities for :keyword:`!with`\\ -statement contexts"
msgstr ""
":mod:`!contextlib` --- Утиліти для контекстів операторів :keyword:`!with`\\"

msgid "**Source code:** :source:`Lib/contextlib.py`"
msgstr "**Вихідний код:** :source:`Lib/contextlib.py`"

msgid ""
"This module provides utilities for common tasks involving the :keyword:"
"`with` statement. For more information see also :ref:`typecontextmanager` "
"and :ref:`context-managers`."
msgstr ""
"Цей модуль надає утиліти для типових завдань, пов’язаних із оператором :"
"keyword:`with`. Для отримання додаткової інформації див. також :ref:"
"`typecontextmanager` і :ref:`context-managers`."

msgid "Utilities"
msgstr "Комунальні послуги"

msgid "Functions and classes provided:"
msgstr "Надані функції та класи:"

msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__enter__` and :meth:`object.__exit__`. A default implementation for :meth:"
"`object.__enter__` is provided which returns ``self`` while :meth:`object."
"__exit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`typecontextmanager`."
msgstr ""
":term:`abstract base class` для класів, які реалізують :meth:`object."
"__enter__` і :meth:`object.__exit__`. Надається реалізація за замовчуванням "
"для :meth:`object.__enter__`, яка повертає ``self``, тоді як :meth:`object."
"__exit__` є абстрактним методом, який за замовчуванням повертає ``None``. "
"Дивіться також визначення :ref:`typecontextmanager`."

msgid ""
"An :term:`abstract base class` for classes that implement :meth:`object."
"__aenter__` and :meth:`object.__aexit__`. A default implementation for :meth:"
"`object.__aenter__` is provided which returns ``self`` while :meth:`object."
"__aexit__` is an abstract method which by default returns ``None``. See also "
"the definition of :ref:`async-context-managers`."
msgstr ""
":term:`abstract base class` для класів, які реалізують :meth:`object."
"__aenter__` і :meth:`object.__aexit__`. Надається реалізація за "
"замовчуванням для :meth:`object.__aenter__`, яка повертає ``self``, тоді як :"
"meth:`object.__aexit__` є абстрактним методом, який за замовчуванням "
"повертає ``None``. Дивіться також визначення :ref:`async-context-managers`."

msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`with` statement context managers, without needing to "
"create a class or separate :meth:`__enter__` and :meth:`__exit__` methods."
msgstr ""
"Ця функція є :term:`decorator`, який можна використовувати для визначення "
"фабричної функції для менеджерів контексту операторів :keyword:`with`, без "
"необхідності створювати клас або розділяти :meth:`__enter__` і :meth:"
"`__exit__` методи."

msgid ""
"While many objects natively support use in with statements, sometimes a "
"resource needs to be managed that isn't a context manager in its own right, "
"and doesn't implement a ``close()`` method for use with ``contextlib."
"closing``"
msgstr ""
"Хоча багато об’єктів нативно підтримують використання операторів in with, "
"інколи необхідно керувати ресурсом, який сам по собі не є менеджером "
"контексту та не реалізує метод ``close()`` для використання з ``contextlib. "
"закриття``"

msgid ""
"An abstract example would be the following to ensure correct resource "
"management::"
msgstr ""
"Абстрактним прикладом може бути наступне, щоб забезпечити правильне "
"керування ресурсами:"

msgid "The function can then be used like this::"
msgstr ""

msgid ""
"The function being decorated must return a :term:`generator`-iterator when "
"called. This iterator must yield exactly one value, which will be bound to "
"the targets in the :keyword:`with` statement's :keyword:`!as` clause, if any."
msgstr ""
"Функція, яка декорується, має повертати :term:`generator`-ітератор під час "
"виклику. Цей ітератор має давати рівно одне значення, яке буде прив’язано до "
"цілей у пропозиції :keyword:`!as` інструкції :keyword:`with`, якщо така є."

msgid ""
"At the point where the generator yields, the block nested in the :keyword:"
"`with` statement is executed.  The generator is then resumed after the block "
"is exited. If an unhandled exception occurs in the block, it is reraised "
"inside the generator at the point where the yield occurred.  Thus, you can "
"use a :keyword:`try`...\\ :keyword:`except`...\\ :keyword:`finally` "
"statement to trap the error (if any), or ensure that some cleanup takes "
"place. If an exception is trapped merely in order to log it or to perform "
"some action (rather than to suppress it entirely), the generator must "
"reraise that exception. Otherwise the generator context manager will "
"indicate to the :keyword:`!with` statement that the exception has been "
"handled, and execution will resume with the statement immediately following "
"the :keyword:`!with` statement."
msgstr ""
"У точці, де генератор поступається, виконується блок, вкладений у оператор :"
"keyword:`with`. Потім генератор відновлюється після виходу з блоку. Якщо в "
"блоці виникає необроблена виняткова ситуація, вона повторно створюється "
"всередині генератора в точці, де відбувся вихід. Таким чином, ви можете "
"використовувати оператор :keyword:`try`...\\ :keyword:`except`...\\ :keyword:"
"`finally`, щоб перехопити помилку (якщо така є) або забезпечити виконання "
"певного очищення. Якщо виняток перехоплюється лише для того, щоб "
"зареєструвати його або виконати певну дію (а не повністю його придушити), "
"генератор повинен повторно викликати цей виняток. В іншому випадку менеджер "
"контексту генератора вкаже оператору :keyword:`!with`, що виняток було "
"оброблено, і виконання буде відновлено оператором, що слідує безпосередньо "
"за оператором :keyword:`!with`."

msgid ""
":func:`contextmanager` uses :class:`ContextDecorator` so the context "
"managers it creates can be used as decorators as well as in :keyword:`with` "
"statements. When used as a decorator, a new generator instance is implicitly "
"created on each function call (this allows the otherwise \"one-shot\" "
"context managers created by :func:`contextmanager` to meet the requirement "
"that context managers support multiple invocations in order to be used as "
"decorators)."
msgstr ""
":func:`contextmanager` використовує :class:`ContextDecorator`, тому створені "
"ним менеджери контексту можна використовувати як декоратори, а також у "
"операторах :keyword:`with`. Коли використовується як декоратор, новий "
"екземпляр генератора неявно створюється під час кожного виклику функції (це "
"дозволяє \"одноразовим\" контекстним менеджерам, створеним :func:"
"`contextmanager`, відповідати вимогам, щоб контекстні менеджери підтримували "
"кілька викликів, щоб використовувати як декоратори)."

msgid "Use of :class:`ContextDecorator`."
msgstr "Використання :class:`ContextDecorator`."

msgid ""
"Similar to :func:`~contextlib.contextmanager`, but creates an :ref:"
"`asynchronous context manager <async-context-managers>`."
msgstr ""
"Подібно до :func:`~contextlib.contextmanager`, але створює :ref:`асинхронний "
"менеджер контексту <async-context-managers>`."

msgid ""
"This function is a :term:`decorator` that can be used to define a factory "
"function for :keyword:`async with` statement asynchronous context managers, "
"without needing to create a class or separate :meth:`__aenter__` and :meth:"
"`__aexit__` methods. It must be applied to an :term:`asynchronous generator` "
"function."
msgstr ""
"Ця функція є :term:`decorator`, який можна використовувати для визначення "
"фабричної функції для :keyword:`async with` менеджерів асинхронного "
"контексту без необхідності створювати клас або розділяти Методи :meth:"
"`__aenter__` і :meth:`__aexit__`. Його потрібно застосувати до функції :term:"
"`asynchronous generator`."

msgid "A simple example::"
msgstr "Простий приклад::"

msgid ""
"Context managers defined with :func:`asynccontextmanager` can be used either "
"as decorators or with :keyword:`async with` statements::"
msgstr ""
"Менеджери контексту, визначені за допомогою :func:`asynccontextmanager`, "
"можна використовувати як декоратори або за допомогою операторів :keyword:"
"`async with`::"

msgid ""
"When used as a decorator, a new generator instance is implicitly created on "
"each function call. This allows the otherwise \"one-shot\" context managers "
"created by :func:`asynccontextmanager` to meet the requirement that context "
"managers support multiple invocations in order to be used as decorators."
msgstr ""
"При використанні як декоратора новий екземпляр генератора неявно створюється "
"під час кожного виклику функції. Це дозволяє \"одноразовим\" контекстним "
"менеджерам, створеним :func:`asynccontextmanager`, відповідати вимогам, щоб "
"контекстні менеджери підтримували кілька викликів, щоб використовувати їх як "
"декоратори."

msgid ""
"Async context managers created with :func:`asynccontextmanager` can be used "
"as decorators."
msgstr ""
"Менеджери асинхронного контексту, створені за допомогою :func:"
"`asynccontextmanager`, можна використовувати як декоратори."

msgid ""
"Return a context manager that closes *thing* upon completion of the block.  "
"This is basically equivalent to::"
msgstr ""
"Повертає контекстний менеджер, який закриває *річ* після завершення блоку. "
"Це в основному еквівалентно:"

msgid "And lets you write code like this::"
msgstr "І дозволяє писати такий код::"

msgid ""
"without needing to explicitly close ``page``.  Even if an error occurs, "
"``page.close()`` will be called when the :keyword:`with` block is exited."
msgstr ""
"без необхідності явного закриття ``сторінки``. Навіть якщо станеться "
"помилка, ``page.close()`` буде викликано під час виходу з блоку :keyword:"
"`with`."

msgid ""
"Return an async context manager that calls the ``aclose()`` method of "
"*thing* upon completion of the block.  This is basically equivalent to::"
msgstr ""
"Повертає менеджер асинхронного контексту, який викликає метод ``aclose()`` "
"*thing* після завершення блоку. Це в основному еквівалентно:"

msgid ""
"Significantly, ``aclosing()`` supports deterministic cleanup of async "
"generators when they happen to exit early by :keyword:`break` or an "
"exception.  For example::"
msgstr ""
"Важливо, що ``aclosing()`` підтримує детерміноване очищення асинхронних "
"генераторів, коли вони виходять раніше через :keyword:`break` або виняток. "
"Наприклад::"

msgid ""
"This pattern ensures that the generator's async exit code is executed in the "
"same context as its iterations (so that exceptions and context variables "
"work as expected, and the exit code isn't run after the lifetime of some "
"task it depends on)."
msgstr ""
"Цей шаблон гарантує, що асинхронний код виходу генератора виконується в тому "
"самому контексті, що й його ітерації (щоб винятки та контекстні змінні "
"працювали належним чином, а код виходу не запускався після закінчення часу "
"існування певного завдання, від якого він залежить)."

msgid ""
"Return a context manager that returns *enter_result* from ``__enter__``, but "
"otherwise does nothing. It is intended to be used as a stand-in for an "
"optional context manager, for example::"
msgstr ""
"Повертає контекстний менеджер, який повертає *enter_result* із "
"``__enter__``, але в іншому випадку нічого не робить. Він призначений для "
"використання як резервний для додаткового контекстного менеджера, наприклад:"

msgid "An example using *enter_result*::"
msgstr "Приклад використання *enter_result*::"

msgid ""
"It can also be used as a stand-in for :ref:`asynchronous context managers "
"<async-context-managers>`::"
msgstr ""
"Його також можна використовувати як заміну для :ref:`асинхронних контекстних "
"менеджерів <async-context-managers>`::"

msgid ":term:`asynchronous context manager` support was added."
msgstr "Додано підтримку :term:`asynchronous context manager`."

msgid ""
"Return a context manager that suppresses any of the specified exceptions if "
"they occur in the body of a :keyword:`!with` statement and then resumes "
"execution with the first statement following the end of the :keyword:`!with` "
"statement."
msgstr ""
"Повертає диспетчер контексту, який пригнічує будь-які з указаних винятків, "
"якщо вони трапляються в тілі оператора :keyword:`!with`, а потім відновлює "
"виконання з першим оператором, що йде після кінця оператора :keyword:`!with`."

msgid ""
"As with any other mechanism that completely suppresses exceptions, this "
"context manager should be used only to cover very specific errors where "
"silently continuing with program execution is known to be the right thing to "
"do."
msgstr ""
"Як і будь-який інший механізм, який повністю пригнічує винятки, цей менеджер "
"контексту слід використовувати лише для покриття дуже конкретних помилок, "
"коли, як відомо, правильно продовжувати виконання програми."

msgid "For example::"
msgstr "Наприклад::"

msgid "This code is equivalent to::"
msgstr "Цей код еквівалентний:"

msgid "This context manager is :ref:`reentrant <reentrant-cms>`."
msgstr "Цей контекстний менеджер є :ref:`reentrant <reentrant-cms>`."

msgid ""
"Context manager for temporarily redirecting :data:`sys.stdout` to another "
"file or file-like object."
msgstr ""
"Менеджер контексту для тимчасового переспрямування :data:`sys.stdout` на "
"інший файл або файлоподібний об’єкт."

msgid ""
"This tool adds flexibility to existing functions or classes whose output is "
"hardwired to stdout."
msgstr ""
"Цей інструмент додає гнучкості існуючим функціям або класам, вихід яких "
"підключено до стандартного виводу."

msgid ""
"For example, the output of :func:`help` normally is sent to *sys.stdout*. "
"You can capture that output in a string by redirecting the output to an :"
"class:`io.StringIO` object. The replacement stream is returned from the "
"``__enter__`` method and so is available as the target of the :keyword:"
"`with` statement::"
msgstr ""
"Наприклад, вихід :func:`help` зазвичай надсилається до *sys.stdout*. Ви "
"можете записати цей вивід у рядок, перенаправивши вивід на об’єкт :class:`io."
"StringIO`. Потік заміни повертається з методу ``__enter__`` і тому доступний "
"як ціль оператора :keyword:`with`::"

msgid ""
"To send the output of :func:`help` to a file on disk, redirect the output to "
"a regular file::"
msgstr ""
"Щоб надіслати вивід :func:`help` у файл на диску, перенаправте вивід у "
"звичайний файл::"

msgid "To send the output of :func:`help` to *sys.stderr*::"
msgstr "Щоб надіслати результат :func:`help` до *sys.stderr*::"

msgid ""
"Note that the global side effect on :data:`sys.stdout` means that this "
"context manager is not suitable for use in library code and most threaded "
"applications. It also has no effect on the output of subprocesses. However, "
"it is still a useful approach for many utility scripts."
msgstr ""
"Зауважте, що глобальний побічний ефект :data:`sys.stdout` означає, що цей "
"контекстний менеджер не підходить для використання в бібліотечному коді та "
"більшості потокових програм. Це також не впливає на вихідні дані "
"підпроцесів. Однак це все ще корисний підхід для багатьох службових "
"сценаріїв."

msgid ""
"Similar to :func:`~contextlib.redirect_stdout` but redirecting :data:`sys."
"stderr` to another file or file-like object."
msgstr ""
"Подібно до :func:`~contextlib.redirect_stdout`, але перенаправляє :data:`sys."
"stderr` до іншого файлу або файлоподібного об’єкта."

msgid ""
"Non parallel-safe context manager to change the current working directory. "
"As this changes a global state, the working directory, it is not suitable "
"for use in most threaded or async contexts. It is also not suitable for most "
"non-linear code execution, like generators, where the program execution is "
"temporarily relinquished -- unless explicitly desired, you should not yield "
"when this context manager is active."
msgstr ""

msgid ""
"This is a simple wrapper around :func:`~os.chdir`, it changes the current "
"working directory upon entering and restores the old one on exit."
msgstr ""

msgid ""
"A base class that enables a context manager to also be used as a decorator."
msgstr ""
"Базовий клас, який дозволяє менеджеру контексту також використовуватися як "
"декоратор."

msgid ""
"Context managers inheriting from ``ContextDecorator`` have to implement "
"``__enter__`` and ``__exit__`` as normal. ``__exit__`` retains its optional "
"exception handling even when used as a decorator."
msgstr ""
"Менеджери контексту, успадковані від ``ContextDecorator``, мають реалізувати "
"``__enter__`` і ``__exit__`` як зазвичай. ``__exit__`` зберігає "
"необов'язкову обробку винятків, навіть якщо використовується як декоратор."

msgid ""
"``ContextDecorator`` is used by :func:`contextmanager`, so you get this "
"functionality automatically."
msgstr ""
"``ContextDecorator`` використовується :func:`contextmanager`, тому ви "
"отримуєте цю функціональність автоматично."

msgid "Example of ``ContextDecorator``::"
msgstr "Приклад ``ContextDecorator``::"

msgid "The class can then be used like this::"
msgstr ""

msgid ""
"This change is just syntactic sugar for any construct of the following form::"
msgstr ""
"Ця зміна є просто синтаксичним цукром для будь-якої конструкції наступної "
"форми::"

msgid "``ContextDecorator`` lets you instead write::"
msgstr "``ContextDecorator`` дозволяє замість цього писати::"

msgid ""
"It makes it clear that the ``cm`` applies to the whole function, rather than "
"just a piece of it (and saving an indentation level is nice, too)."
msgstr ""
"Це дає зрозуміти, що ``cm`` застосовується до всієї функції, а не лише до її "
"частини (і зберегти рівень відступу теж добре)."

msgid ""
"Existing context managers that already have a base class can be extended by "
"using ``ContextDecorator`` as a mixin class::"
msgstr ""
"Існуючі контекстні менеджери, які вже мають базовий клас, можна розширити за "
"допомогою ``ContextDecorator`` як класу mixin::"

msgid ""
"As the decorated function must be able to be called multiple times, the "
"underlying context manager must support use in multiple :keyword:`with` "
"statements. If this is not the case, then the original construct with the "
"explicit :keyword:`!with` statement inside the function should be used."
msgstr ""
"Оскільки декорована функція повинна мати можливість викликатися кілька "
"разів, базовий менеджер контексту повинен підтримувати використання в "
"кількох операторах :keyword:`with`. Якщо це не так, тоді слід "
"використовувати оригінальну конструкцію з явним оператором :keyword:`!with` "
"усередині функції."

msgid ""
"Similar to :class:`ContextDecorator` but only for asynchronous functions."
msgstr ""
"Подібно до :class:`ContextDecorator`, але лише для асинхронних функцій."

msgid "Example of ``AsyncContextDecorator``::"
msgstr "Приклад ``AsyncContextDecorator``::"

msgid ""
"A context manager that is designed to make it easy to programmatically "
"combine other context managers and cleanup functions, especially those that "
"are optional or otherwise driven by input data."
msgstr ""
"Менеджер контексту, розроблений для полегшення програмного поєднання інших "
"менеджерів контексту та функцій очищення, особливо тих, які є "
"необов’язковими або іншим чином керуються вхідними даними."

msgid ""
"For example, a set of files may easily be handled in a single with statement "
"as follows::"
msgstr ""
"Наприклад, набір файлів можна легко обробити в одному операторі with "
"наступним чином:"

msgid ""
"The :meth:`__enter__` method returns the :class:`ExitStack` instance, and "
"performs no additional operations."
msgstr ""
"Метод :meth:`__enter__` повертає екземпляр :class:`ExitStack` і не виконує "
"додаткових операцій."

msgid ""
"Each instance maintains a stack of registered callbacks that are called in "
"reverse order when the instance is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement). Note that callbacks are *not* "
"invoked implicitly when the context stack instance is garbage collected."
msgstr ""
"Кожен екземпляр підтримує стек зареєстрованих зворотних викликів, які "
"викликаються у зворотному порядку, коли екземпляр закривається (явно чи "
"неявно в кінці оператора :keyword:`with`). Зауважте, що зворотні виклики "
"*не* викликаються неявно, коли примірник стеку контексту збирається сміттям."

msgid ""
"This stack model is used so that context managers that acquire their "
"resources in their ``__init__`` method (such as file objects) can be handled "
"correctly."
msgstr ""
"Ця модель стеку використовується для того, щоб контекстні менеджери, які "
"отримують свої ресурси у своєму методі ``__init__`` (наприклад, файлові "
"об’єкти), могли оброблятися правильно."

msgid ""
"Since registered callbacks are invoked in the reverse order of registration, "
"this ends up behaving as if multiple nested :keyword:`with` statements had "
"been used with the registered set of callbacks. This even extends to "
"exception handling - if an inner callback suppresses or replaces an "
"exception, then outer callbacks will be passed arguments based on that "
"updated state."
msgstr ""
"Оскільки зареєстровані зворотні виклики викликаються в порядку, зворотному "
"реєстрації, це в кінцевому підсумку поводиться так, ніби декілька вкладених "
"операторів :keyword:`with` використовувалися із зареєстрованим набором "
"зворотних викликів. Це навіть поширюється на обробку винятків - якщо "
"внутрішній зворотний виклик пригнічує або замінює виняток, то зовнішнім "
"зворотним викликам будуть передані аргументи на основі цього оновленого "
"стану."

msgid ""
"This is a relatively low level API that takes care of the details of "
"correctly unwinding the stack of exit callbacks. It provides a suitable "
"foundation for higher level context managers that manipulate the exit stack "
"in application specific ways."
msgstr ""
"Це API відносно низького рівня, який піклується про деталі правильного "
"розгортання стека зворотних викликів виходу. Він забезпечує відповідну "
"основу для контекстних менеджерів вищого рівня, які маніпулюють стеком "
"виходу у специфічних для програми способах."

msgid ""
"Enters a new context manager and adds its :meth:`__exit__` method to the "
"callback stack. The return value is the result of the context manager's own :"
"meth:`__enter__` method."
msgstr ""
"Вводить новий менеджер контексту та додає його метод :meth:`__exit__` до "
"стеку зворотних викликів. Повернене значення є результатом власного методу "
"менеджера контексту :meth:`__enter__`."

msgid ""
"These context managers may suppress exceptions just as they normally would "
"if used directly as part of a :keyword:`with` statement."
msgstr ""
"Ці контекстні менеджери можуть придушувати винятки так само, як вони "
"зазвичай робили б, якщо використовувати безпосередньо як частину оператора :"
"keyword:`with`."

msgid ""
"Raises :exc:`TypeError` instead of :exc:`AttributeError` if *cm* is not a "
"context manager."
msgstr ""

msgid "Adds a context manager's :meth:`__exit__` method to the callback stack."
msgstr ""
"Додає метод :meth:`__exit__` менеджера контексту до стеку зворотних викликів."

msgid ""
"As ``__enter__`` is *not* invoked, this method can be used to cover part of "
"an :meth:`__enter__` implementation with a context manager's own :meth:"
"`__exit__` method."
msgstr ""
"Оскільки ``__enter__`` *не* викликається, цей метод можна використовувати "
"для покриття частини реалізації :meth:`__enter__` власним методом :meth:"
"`__exit__` менеджера контексту."

msgid ""
"If passed an object that is not a context manager, this method assumes it is "
"a callback with the same signature as a context manager's :meth:`__exit__` "
"method and adds it directly to the callback stack."
msgstr ""
"Якщо передано об’єкт, який не є диспетчером контексту, цей метод припускає, "
"що це зворотній виклик із тією самою сигнатурою, що й метод :meth:`__exit__` "
"менеджера контексту, і додає його безпосередньо до стеку зворотних викликів."

msgid ""
"By returning true values, these callbacks can suppress exceptions the same "
"way context manager :meth:`__exit__` methods can."
msgstr ""
"Повертаючи істинні значення, ці зворотні виклики можуть придушувати винятки "
"так само, як і методи контекстного менеджера :meth:`__exit__`."

msgid ""
"The passed in object is returned from the function, allowing this method to "
"be used as a function decorator."
msgstr ""
"Переданий об’єкт повертається функцією, що дозволяє використовувати цей "
"метод як декоратор функції."

msgid ""
"Accepts an arbitrary callback function and arguments and adds it to the "
"callback stack."
msgstr ""
"Приймає довільну функцію зворотного виклику та аргументи та додає їх до "
"стеку зворотного виклику."

msgid ""
"Unlike the other methods, callbacks added this way cannot suppress "
"exceptions (as they are never passed the exception details)."
msgstr ""
"На відміну від інших методів, зворотні виклики, додані таким чином, не "
"можуть придушувати винятки (оскільки їм ніколи не передаються деталі "
"винятку)."

msgid ""
"The passed in callback is returned from the function, allowing this method "
"to be used as a function decorator."
msgstr ""
"Переданий зворотний виклик повертається функцією, що дозволяє "
"використовувати цей метод як декоратор функції."

msgid ""
"Transfers the callback stack to a fresh :class:`ExitStack` instance and "
"returns it. No callbacks are invoked by this operation - instead, they will "
"now be invoked when the new stack is closed (either explicitly or implicitly "
"at the end of a :keyword:`with` statement)."
msgstr ""
"Передає стек зворотних викликів до нового екземпляра :class:`ExitStack` і "
"повертає його. Жодні зворотні виклики не викликаються цією операцією - "
"замість цього вони тепер будуть викликані, коли новий стек закривається "
"(явно чи неявно в кінці оператора :keyword:`with`)."

msgid ""
"For example, a group of files can be opened as an \"all or nothing\" "
"operation as follows::"
msgstr ""
"Наприклад, групу файлів можна відкрити за допомогою операції \"все або "
"нічого\" наступним чином:"

msgid ""
"Immediately unwinds the callback stack, invoking callbacks in the reverse "
"order of registration. For any context managers and exit callbacks "
"registered, the arguments passed in will indicate that no exception occurred."
msgstr ""
"Негайно розгортає стек зворотних викликів, викликаючи зворотні виклики в "
"порядку, зворотному реєстрації. Для будь-яких менеджерів контексту та "
"зареєстрованих зворотних викликів виходу передані аргументи вказуватимуть, "
"що винятків не сталося."

msgid ""
"An :ref:`asynchronous context manager <async-context-managers>`, similar to :"
"class:`ExitStack`, that supports combining both synchronous and asynchronous "
"context managers, as well as having coroutines for cleanup logic."
msgstr ""
":ref:`асинхронний контекстний менеджер <async-context-managers>`, подібний "
"до :class:`ExitStack`, який підтримує поєднання синхронних і асинхронних "
"контекстних менеджерів, а також має співпрограми для логіки очищення."

msgid ""
"The :meth:`close` method is not implemented, :meth:`aclose` must be used "
"instead."
msgstr ""
"Метод :meth:`close` не реалізовано, замість нього потрібно використовувати :"
"meth:`aclose`."

msgid ""
"Similar to :meth:`enter_context` but expects an asynchronous context manager."
msgstr ""
"Подібно до :meth:`enter_context`, але передбачає асинхронний менеджер "
"контексту."

msgid ""
"Raises :exc:`TypeError` instead of :exc:`AttributeError` if *cm* is not an "
"asynchronous context manager."
msgstr ""

msgid ""
"Similar to :meth:`push` but expects either an asynchronous context manager "
"or a coroutine function."
msgstr ""
"Подібно до :meth:`push`, але передбачає або асинхронний менеджер контексту, "
"або функцію співпрограми."

msgid "Similar to :meth:`callback` but expects a coroutine function."
msgstr "Подібно до :meth:`callback`, але очікує функцію співпрограми."

msgid "Similar to :meth:`close` but properly handles awaitables."
msgstr "Подібно до :meth:`close`, але належним чином обробляє очікування."

msgid "Continuing the example for :func:`asynccontextmanager`::"
msgstr "Продовжуємо приклад для :func:`asynccontextmanager`::"

msgid "Examples and Recipes"
msgstr "Приклади та рецепти"

msgid ""
"This section describes some examples and recipes for making effective use of "
"the tools provided by :mod:`contextlib`."
msgstr ""
"У цьому розділі описано деякі приклади та рецепти ефективного використання "
"інструментів, наданих :mod:`contextlib`."

msgid "Supporting a variable number of context managers"
msgstr "Підтримка змінної кількості контекстних менеджерів"

msgid ""
"The primary use case for :class:`ExitStack` is the one given in the class "
"documentation: supporting a variable number of context managers and other "
"cleanup operations in a single :keyword:`with` statement. The variability "
"may come from the number of context managers needed being driven by user "
"input (such as opening a user specified collection of files), or from some "
"of the context managers being optional::"
msgstr ""
"Основний варіант використання :class:`ExitStack` — це той, який наведено в "
"документації класу: підтримка змінної кількості контекстних менеджерів та "
"інших операцій очищення в одному операторі :keyword:`with`. Варіативність "
"може виникати через кількість необхідних менеджерів контексту, які керуються "
"введенням користувача (наприклад, відкриття вказаної користувачем колекції "
"файлів), або через те, що деякі менеджери контексту є необов’язковими:"

msgid ""
"As shown, :class:`ExitStack` also makes it quite easy to use :keyword:`with` "
"statements to manage arbitrary resources that don't natively support the "
"context management protocol."
msgstr ""
"Як показано, :class:`ExitStack` також дозволяє досить легко використовувати "
"оператори :keyword:`with` для керування довільними ресурсами, які спочатку "
"не підтримують протокол керування контекстом."

msgid "Catching exceptions from ``__enter__`` methods"
msgstr "Перехоплення винятків із методів ``__enter__``"

msgid ""
"It is occasionally desirable to catch exceptions from an ``__enter__`` "
"method implementation, *without* inadvertently catching exceptions from the :"
"keyword:`with` statement body or the context manager's ``__exit__`` method. "
"By using :class:`ExitStack` the steps in the context management protocol can "
"be separated slightly in order to allow this::"
msgstr ""
"Час від часу бажано перехоплювати винятки з реалізації методу ``__enter__``, "
"*без* випадкового перехоплення винятків з тіла оператора :keyword:`with` або "
"методу ``__exit__`` контекстного менеджера. За допомогою :class:`ExitStack` "
"кроки в протоколі керування контекстом можна трохи розділити, щоб дозволити "
"це:"

msgid ""
"Actually needing to do this is likely to indicate that the underlying API "
"should be providing a direct resource management interface for use with :"
"keyword:`try`/:keyword:`except`/:keyword:`finally` statements, but not all "
"APIs are well designed in that regard. When a context manager is the only "
"resource management API provided, then :class:`ExitStack` can make it easier "
"to handle various situations that can't be handled directly in a :keyword:"
"`with` statement."
msgstr ""
"Насправді необхідність зробити це означає, що основний API має надавати "
"інтерфейс прямого керування ресурсами для використання з операторами :"
"keyword:`try`/:keyword:`except`/:keyword:`finally`, але не з усіма API добре "
"розроблені в цьому плані. Коли контекстний менеджер є єдиним наданим API "
"керування ресурсами, тоді :class:`ExitStack` може полегшити обробку "
"різноманітних ситуацій, які не можна обробити безпосередньо в операторі :"
"keyword:`with`."

msgid "Cleaning up in an ``__enter__`` implementation"
msgstr "Очищення в реалізації ``__enter__``"

msgid ""
"As noted in the documentation of :meth:`ExitStack.push`, this method can be "
"useful in cleaning up an already allocated resource if later steps in the :"
"meth:`__enter__` implementation fail."
msgstr ""
"Як зазначено в документації :meth:`ExitStack.push`, цей метод може бути "
"корисним для очищення вже виділеного ресурсу, якщо наступні кроки в "
"реалізації :meth:`__enter__` завершаться невдачею."

msgid ""
"Here's an example of doing this for a context manager that accepts resource "
"acquisition and release functions, along with an optional validation "
"function, and maps them to the context management protocol::"
msgstr ""
"Ось приклад виконання цього для контекстного менеджера, який приймає функції "
"отримання та звільнення ресурсів разом із додатковою функцією перевірки та "
"відображає їх у протоколі керування контекстом::"

msgid "Replacing any use of ``try-finally`` and flag variables"
msgstr "Заміна будь-якого використання змінних ``try-finally`` і прапорців"

msgid ""
"A pattern you will sometimes see is a ``try-finally`` statement with a flag "
"variable to indicate whether or not the body of the ``finally`` clause "
"should be executed. In its simplest form (that can't already be handled just "
"by using an ``except`` clause instead), it looks something like this::"
msgstr ""
"Зразок, який ви іноді побачите, — це інструкція ``try-finally`` зі змінною-"
"прапором, яка вказує, чи має бути виконано тіло пропозиції ``finally``. У "
"своїй найпростішій формі (з якою вже не можна впоратися лише за допомогою "
"пропозиції ``except``), це виглядає приблизно так:"

msgid ""
"As with any ``try`` statement based code, this can cause problems for "
"development and review, because the setup code and the cleanup code can end "
"up being separated by arbitrarily long sections of code."
msgstr ""
"Як і у випадку з будь-яким кодом, заснованим на інструкціях ``try``, це може "
"спричинити проблеми з розробкою та переглядом, оскільки код налаштування та "
"код очищення можуть бути розділені довільно довгими частинами коду."

msgid ""
":class:`ExitStack` makes it possible to instead register a callback for "
"execution at the end of a ``with`` statement, and then later decide to skip "
"executing that callback::"
msgstr ""
":class:`ExitStack` дає змогу замість цього зареєструвати зворотний виклик "
"для виконання в кінці оператора ``with``, а потім вирішити пропустити "
"виконання цього зворотного виклику::"

msgid ""
"This allows the intended cleanup up behaviour to be made explicit up front, "
"rather than requiring a separate flag variable."
msgstr ""
"Це дозволяє чітко визначити заплановану поведінку очищення, а не вимагати "
"окремої змінної прапора."

msgid ""
"If a particular application uses this pattern a lot, it can be simplified "
"even further by means of a small helper class::"
msgstr ""
"Якщо певна програма часто використовує цей шаблон, його можна ще більше "
"спростити за допомогою невеликого допоміжного класу:"

msgid ""
"If the resource cleanup isn't already neatly bundled into a standalone "
"function, then it is still possible to use the decorator form of :meth:"
"`ExitStack.callback` to declare the resource cleanup in advance::"
msgstr ""
"Якщо очищення ресурсу ще не акуратно об’єднано в окрему функцію, то все ще "
"можна використовувати форму декоратора :meth:`ExitStack.callback`, щоб "
"оголосити очищення ресурсу заздалегідь::"

msgid ""
"Due to the way the decorator protocol works, a callback function declared "
"this way cannot take any parameters. Instead, any resources to be released "
"must be accessed as closure variables."
msgstr ""
"Через те, як працює протокол декоратора, функція зворотного виклику, "
"оголошена таким чином, не може приймати жодних параметрів. Натомість доступ "
"до будь-яких ресурсів, які потрібно звільнити, має здійснюватися як змінні "
"закриття."

msgid "Using a context manager as a function decorator"
msgstr "Використання контекстного менеджера як декоратора функції"

msgid ""
":class:`ContextDecorator` makes it possible to use a context manager in both "
"an ordinary ``with`` statement and also as a function decorator."
msgstr ""
":class:`ContextDecorator` дає змогу використовувати менеджер контексту як у "
"звичайному операторі ``with``, так і як декоратор функції."

msgid ""
"For example, it is sometimes useful to wrap functions or groups of "
"statements with a logger that can track the time of entry and time of exit.  "
"Rather than writing both a function decorator and a context manager for the "
"task, inheriting from :class:`ContextDecorator` provides both capabilities "
"in a single definition::"
msgstr ""
"Наприклад, іноді корисно обернути функції або групи операторів за допомогою "
"реєстратора, який може відстежувати час входу та час виходу. Замість "
"написання як декоратора функції, так і менеджера контексту для завдання, "
"успадкування від :class:`ContextDecorator` надає обидві можливості в одному "
"визначенні::"

msgid "Instances of this class can be used as both a context manager::"
msgstr "Екземпляри цього класу можна використовувати і як менеджер контексту:"

msgid "And also as a function decorator::"
msgstr "А також як декоратор функцій::"

msgid ""
"Note that there is one additional limitation when using context managers as "
"function decorators: there's no way to access the return value of :meth:"
"`__enter__`. If that value is needed, then it is still necessary to use an "
"explicit ``with`` statement."
msgstr ""
"Зауважте, що існує одне додаткове обмеження під час використання менеджерів "
"контексту як декораторів функцій: немає можливості отримати доступ до "
"значення, яке повертає :meth:`__enter__`. Якщо це значення потрібне, все "
"одно необхідно використовувати явний оператор with."

msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - оператор \"з\"."

msgid ""
"The specification, background, and examples for the Python :keyword:`with` "
"statement."
msgstr "Специфікація, передумови та приклади оператора Python :keyword:`with`."

msgid "Single use, reusable and reentrant context managers"
msgstr ""
"Менеджери контексту для одноразового, багаторазового та повторного входу"

msgid ""
"Most context managers are written in a way that means they can only be used "
"effectively in a :keyword:`with` statement once. These single use context "
"managers must be created afresh each time they're used - attempting to use "
"them a second time will trigger an exception or otherwise not work correctly."
msgstr ""
"Більшість контекстних менеджерів написані таким чином, що вони можуть бути "
"ефективно використані в операторі :keyword:`with` лише один раз. Ці "
"одноразові контекстні менеджери потрібно створювати заново кожного разу, "
"коли вони використовуються — спроба використати їх вдруге призведе до "
"виключення або іншим чином не працюватиме належним чином."

msgid ""
"This common limitation means that it is generally advisable to create "
"context managers directly in the header of the :keyword:`with` statement "
"where they are used (as shown in all of the usage examples above)."
msgstr ""
"Це загальне обмеження означає, що загалом доцільно створювати менеджери "
"контексту безпосередньо в заголовку оператора :keyword:`with`, де вони "
"використовуються (як показано в усіх наведених вище прикладах використання)."

msgid ""
"Files are an example of effectively single use context managers, since the "
"first :keyword:`with` statement will close the file, preventing any further "
"IO operations using that file object."
msgstr ""
"Файли є прикладом ефективних одноразових контекстних менеджерів, оскільки "
"перший оператор :keyword:`with` закриває файл, запобігаючи будь-яким "
"подальшим операціям вводу-виводу з використанням цього файлового об’єкта."

msgid ""
"Context managers created using :func:`contextmanager` are also single use "
"context managers, and will complain about the underlying generator failing "
"to yield if an attempt is made to use them a second time::"
msgstr ""
"Менеджери контексту, створені за допомогою :func:`contextmanager`, також є "
"одноразовими менеджерами контексту, і вони скаржаться на те, що базовий "
"генератор не працює, якщо буде зроблена спроба використати їх вдруге:"

msgid "Reentrant context managers"
msgstr "Реентерабельні контекстні менеджери"

msgid ""
"More sophisticated context managers may be \"reentrant\". These context "
"managers can not only be used in multiple :keyword:`with` statements, but "
"may also be used *inside* a :keyword:`!with` statement that is already using "
"the same context manager."
msgstr ""
"Більш складні контекстні менеджери можуть бути \"реентерабельними\". Ці "
"менеджери контексту можна використовувати не лише в кількох операторах :"
"keyword:`with`, але також *всередині* оператора :keyword:`!with`, який уже "
"використовує той самий менеджер контексту."

msgid ""
":class:`threading.RLock` is an example of a reentrant context manager, as "
"are :func:`suppress`, :func:`redirect_stdout`, and :func:`chdir`. Here's a "
"very simple example of reentrant use::"
msgstr ""

msgid ""
"Real world examples of reentrancy are more likely to involve multiple "
"functions calling each other and hence be far more complicated than this "
"example."
msgstr ""
"Приклади повторного входу в реальному світі, швидше за все, включають кілька "
"функцій, які викликають одна одну, і, отже, вони набагато складніші, ніж цей "
"приклад."

msgid ""
"Note also that being reentrant is *not* the same thing as being thread "
"safe. :func:`redirect_stdout`, for example, is definitely not thread safe, "
"as it makes a global modification to the system state by binding :data:`sys."
"stdout` to a different stream."
msgstr ""
"Зауважте також, що реентерабельність — це *не* те саме, що бути "
"потокобезпечною. :func:`redirect_stdout`, наприклад, точно небезпечний для "
"потоків, оскільки він робить глобальну модифікацію стану системи шляхом "
"прив’язки :data:`sys.stdout` до іншого потоку."

msgid "Reusable context managers"
msgstr "Багаторазові контекстні менеджери"

msgid ""
"Distinct from both single use and reentrant context managers are "
"\"reusable\" context managers (or, to be completely explicit, \"reusable, "
"but not reentrant\" context managers, since reentrant context managers are "
"also reusable). These context managers support being used multiple times, "
"but will fail (or otherwise not work correctly) if the specific context "
"manager instance has already been used in a containing with statement."
msgstr ""
"Від одноразових і повторних контекстних менеджерів відрізняються \"повторно "
"використовувані\" контекстні менеджери (або, якщо бути повністю явними, "
"\"повторно використовувані, але не повторні\" контекстні менеджери, оскільки "
"повторні контекстні менеджери також багаторазові). Ці контекстні менеджери "
"підтримують багаторазове використання, але не працюватимуть (або не "
"працюватимуть належним чином), якщо конкретний екземпляр контекстного "
"менеджера вже використовувався в операторі containing with."

msgid ""
":class:`threading.Lock` is an example of a reusable, but not reentrant, "
"context manager (for a reentrant lock, it is necessary to use :class:"
"`threading.RLock` instead)."
msgstr ""
":class:`threading.Lock` є прикладом повторно використовуваного, але не "
"реентрантного, контекстного менеджера (для повторного вхідного блокування "
"замість цього необхідно використовувати :class:`threading.RLock`)."

msgid ""
"Another example of a reusable, but not reentrant, context manager is :class:"
"`ExitStack`, as it invokes *all* currently registered callbacks when leaving "
"any with statement, regardless of where those callbacks were added::"
msgstr ""
"Іншим прикладом повторно використовуваного, але не реентрантного "
"контекстного менеджера є :class:`ExitStack`, оскільки він викликає *всі* "
"зареєстровані наразі зворотні виклики, коли залишає будь-який оператор with, "
"незалежно від того, де ці зворотні виклики було додано::"

msgid ""
"As the output from the example shows, reusing a single stack object across "
"multiple with statements works correctly, but attempting to nest them will "
"cause the stack to be cleared at the end of the innermost with statement, "
"which is unlikely to be desirable behaviour."
msgstr ""
"Як показує вихід із прикладу, повторне використання одного об’єкта стека в "
"кількох інструкціях with працює правильно, але спроба їх вкладення "
"спричинить очищення стека в кінці внутрішнього оператора with, що навряд чи "
"буде бажаною поведінкою."

msgid ""
"Using separate :class:`ExitStack` instances instead of reusing a single "
"instance avoids that problem::"
msgstr ""
"Використання окремих екземплярів :class:`ExitStack` замість повторного "
"використання одного екземпляра дозволяє уникнути цієї проблеми:"
