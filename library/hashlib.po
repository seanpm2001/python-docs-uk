# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:07+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`hashlib` --- Secure hashes and message digests"
msgstr ":mod:`hashlib` --- Захищені хеші та дайджести повідомлень"

msgid "**Source code:** :source:`Lib/hashlib.py`"
msgstr "**Вихідний код:** :source:`Lib/hashlib.py`"

msgid ""
"This module implements a common interface to many different secure hash and "
"message digest algorithms.  Included are the FIPS secure hash algorithms "
"SHA1, SHA224, SHA256, SHA384, and SHA512 (defined in FIPS 180-2) as well as "
"RSA's MD5 algorithm (defined in internet :rfc:`1321`).  The terms \"secure "
"hash\" and \"message digest\" are interchangeable.  Older algorithms were "
"called message digests.  The modern term is secure hash."
msgstr ""
"Цей модуль реалізує загальний інтерфейс для багатьох різних безпечних "
"алгоритмів хешування та дайджесту повідомлень. Включено безпечні хеш-"
"алгоритми FIPS SHA1, SHA224, SHA256, SHA384 і SHA512 (визначені в FIPS "
"180-2), а також алгоритм RSA MD5 (визначений в Інтернеті :rfc:`1321`). "
"Терміни \"безпечний хеш\" і \"дайджест повідомлення\" взаємозамінні. Старіші "
"алгоритми називалися дайджестами повідомлень. Сучасний термін - безпечний "
"хеш."

msgid ""
"If you want the adler32 or crc32 hash functions, they are available in the :"
"mod:`zlib` module."
msgstr ""
"Якщо вам потрібні хеш-функції adler32 або crc32, вони доступні в модулі :mod:"
"`zlib`."

msgid ""
"Some algorithms have known hash collision weaknesses, refer to the \"See "
"also\" section at the end."
msgstr ""
"Деякі алгоритми мають відомі недоліки хеш-колізій, зверніться до розділу "
"\"Див. також\" у кінці."

msgid "Hash algorithms"
msgstr "Хеш-алгоритми"

msgid ""
"There is one constructor method named for each type of :dfn:`hash`.  All "
"return a hash object with the same simple interface. For example: use :func:"
"`sha256` to create a SHA-256 hash object. You can now feed this object with :"
"term:`bytes-like objects <bytes-like object>` (normally :class:`bytes`) "
"using the :meth:`update` method. At any point you can ask it for the :dfn:"
"`digest` of the concatenation of the data fed to it so far using the :meth:"
"`digest` or :meth:`hexdigest` methods."
msgstr ""
"Для кожного типу :dfn:`hash` існує один метод конструктора. Усі повертають "
"хеш-об’єкт із однаковим простим інтерфейсом. Наприклад: використовуйте :func:"
"`sha256`, щоб створити хеш-об’єкт SHA-256. Тепер ви можете завантажувати цей "
"об’єкт :term:`bytes-подібними об’єктами <bytes-like object>` (зазвичай :"
"class:`bytes`) за допомогою методу :meth:`update`. У будь-який момент ви "
"можете попросити його :dfn:`digest` конкатенації даних, переданих йому до "
"цього моменту за допомогою методів :meth:`digest` або :meth:`hexdigest`."

msgid ""
"For better multithreading performance, the Python :term:`GIL` is released "
"for data larger than 2047 bytes at object creation or on update."
msgstr ""
"Для кращої продуктивності багатопоточності Python :term:`GIL` випускається "
"для даних розміром понад 2047 байт під час створення об’єкта або оновлення."

msgid ""
"Feeding string objects into :meth:`update` is not supported, as hashes work "
"on bytes, not on characters."
msgstr ""
"Подача рядкових об’єктів у :meth:`update` не підтримується, оскільки хеші "
"працюють з байтами, а не з символами."

msgid ""
"Constructors for hash algorithms that are always present in this module are :"
"func:`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, :func:"
"`sha512`, :func:`blake2b`, and :func:`blake2s`. :func:`md5` is normally "
"available as well, though it may be missing or blocked if you are using a "
"rare \"FIPS compliant\" build of Python. Additional algorithms may also be "
"available depending upon the OpenSSL library that Python uses on your "
"platform. On most platforms the :func:`sha3_224`, :func:`sha3_256`, :func:"
"`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256` are also "
"available."
msgstr ""
"Конструктори для хеш-алгоритмів, які завжди присутні в цьому модулі: :func:"
"`sha1`, :func:`sha224`, :func:`sha256`, :func:`sha384`, :func:`sha512`, :"
"func:`blake2b` і :func:`blake2s`. :func:`md5` також зазвичай доступний, хоча "
"він може бути відсутнім або заблокованим, якщо ви використовуєте рідкісну "
"\"FIPS-сумісну\" збірку Python. Також можуть бути доступні додаткові "
"алгоритми залежно від бібліотеки OpenSSL, яку Python використовує на вашій "
"платформі. На більшості платформ також доступні :func:`sha3_224`, :func:"
"`sha3_256`, :func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:"
"`shake_256`."

msgid ""
"SHA3 (Keccak) and SHAKE constructors :func:`sha3_224`, :func:`sha3_256`, :"
"func:`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256`."
msgstr ""
"Конструктори SHA3 (Keccak) і SHAKE :func:`sha3_224`, :func:`sha3_256`, :func:"
"`sha3_384`, :func:`sha3_512`, :func:`shake_128`, :func:`shake_256`."

msgid ":func:`blake2b` and :func:`blake2s` were added."
msgstr "Додано :func:`blake2b` і :func:`blake2s`."

msgid ""
"All hashlib constructors take a keyword-only argument *usedforsecurity* with "
"default value ``True``. A false value allows the use of insecure and blocked "
"hashing algorithms in restricted environments. ``False`` indicates that the "
"hashing algorithm is not used in a security context, e.g. as a non-"
"cryptographic one-way compression function."
msgstr ""
"Усі конструктори хешлібів приймають лише ключовий аргумент *usedforsecurity* "
"зі значенням за замовчуванням ``True``. Помилкове значення дозволяє "
"використовувати небезпечні та заблоковані алгоритми хешування в обмежених "
"середовищах. ``False`` вказує на те, що алгоритм хешування не "
"використовується в контексті безпеки, напр. як некриптографічна функція "
"одностороннього стиснення."

msgid "Hashlib now uses SHA3 and SHAKE from OpenSSL 1.1.1 and newer."
msgstr ""
"Hashlib тепер використовує SHA3 і SHAKE з OpenSSL 1.1.1 і новіших версій."

msgid ""
"For example, to obtain the digest of the byte string ``b\"Nobody inspects "
"the spammish repetition\"``::"
msgstr ""

msgid "More condensed:"
msgstr "Більш стисло:"

msgid ""
"Is a generic constructor that takes the string *name* of the desired "
"algorithm as its first parameter.  It also exists to allow access to the "
"above listed hashes as well as any other algorithms that your OpenSSL "
"library may offer.  The named constructors are much faster than :func:`new` "
"and should be preferred."
msgstr ""
"Це загальний конструктор, який приймає рядок *ім’я* потрібного алгоритму як "
"перший параметр. Він також існує, щоб дозволити доступ до перерахованих вище "
"хешів, а також до будь-яких інших алгоритмів, які може запропонувати ваша "
"бібліотека OpenSSL. Названі конструктори набагато швидші, ніж :func:`new`, і "
"їм слід віддавати перевагу."

msgid "Using :func:`new` with an algorithm provided by OpenSSL:"
msgstr "Використання :func:`new` з алгоритмом OpenSSL:"

msgid "Hashlib provides the following constant attributes:"
msgstr "Hashlib надає такі постійні атрибути:"

msgid ""
"A set containing the names of the hash algorithms guaranteed to be supported "
"by this module on all platforms.  Note that 'md5' is in this list despite "
"some upstream vendors offering an odd \"FIPS compliant\" Python build that "
"excludes it."
msgstr ""
"Набір, що містить назви геш-алгоритмів, які гарантовано підтримуватимуться "
"цим модулем на всіх платформах. Зауважте, що \"md5\" є в цьому списку, "
"незважаючи на те, що деякі постачальники вищого рівня пропонують дивну "
"\"FIPS-сумісну\" збірку Python, яка виключає його."

msgid ""
"A set containing the names of the hash algorithms that are available in the "
"running Python interpreter.  These names will be recognized when passed to :"
"func:`new`.  :attr:`algorithms_guaranteed` will always be a subset.  The "
"same algorithm may appear multiple times in this set under different names "
"(thanks to OpenSSL)."
msgstr ""
"Набір, що містить імена геш-алгоритмів, доступних у запущеному "
"інтерпретаторі Python. Ці назви буде розпізнано, коли передано :func:`new`. :"
"attr:`algorithms_guaranteed` завжди буде підмножиною. Той самий алгоритм "
"може з’являтися кілька разів у цьому наборі під різними назвами (завдяки "
"OpenSSL)."

msgid ""
"The following values are provided as constant attributes of the hash objects "
"returned by the constructors:"
msgstr ""
"Наступні значення надаються як постійні атрибути хеш-об’єктів, які "
"повертаються конструкторами:"

msgid "The size of the resulting hash in bytes."
msgstr "Розмір отриманого хешу в байтах."

msgid "The internal block size of the hash algorithm in bytes."
msgstr "Розмір внутрішнього блоку хеш-алгоритму в байтах."

msgid "A hash object has the following attributes:"
msgstr "Хеш-об’єкт має такі атрибути:"

msgid ""
"The canonical name of this hash, always lowercase and always suitable as a "
"parameter to :func:`new` to create another hash of this type."
msgstr ""
"Канонічна назва цього хешу, завжди в нижньому регістрі та завжди підходить "
"як параметр для :func:`new` для створення іншого хешу цього типу."

msgid ""
"The name attribute has been present in CPython since its inception, but "
"until Python 3.4 was not formally specified, so may not exist on some "
"platforms."
msgstr ""
"Атрибут name був присутній у CPython з моменту його створення, але до Python "
"3.4 не було офіційно визначено, тому може не існувати на деяких платформах."

msgid "A hash object has the following methods:"
msgstr "Хеш-об’єкт має такі методи:"

msgid ""
"Update the hash object with the :term:`bytes-like object`. Repeated calls "
"are equivalent to a single call with the concatenation of all the arguments: "
"``m.update(a); m.update(b)`` is equivalent to ``m.update(a+b)``."
msgstr ""
"Оновіть хеш-об’єкт за допомогою :term:`bytes-like object`. Повторні виклики "
"еквівалентні одному виклику з конкатенацією всіх аргументів: ``m.update(a); "
"m.update(b)`` еквівалентно ``m.update(a+b)``."

msgid ""
"The Python GIL is released to allow other threads to run while hash updates "
"on data larger than 2047 bytes is taking place when using hash algorithms "
"supplied by OpenSSL."
msgstr ""
"Python GIL випущено, щоб дозволити іншим потокам працювати під час оновлення "
"хешів даних, розмір яких перевищує 2047 байт, за допомогою хеш-алгоритмів, "
"наданих OpenSSL."

msgid ""
"Return the digest of the data passed to the :meth:`update` method so far. "
"This is a bytes object of size :attr:`digest_size` which may contain bytes "
"in the whole range from 0 to 255."
msgstr ""
"Повертає дайджест даних, переданих до цього моменту методу :meth:`update`. "
"Це байтовий об’єкт розміром :attr:`digest_size`, який може містити байти в "
"усьому діапазоні від 0 до 255."

msgid ""
"Like :meth:`digest` except the digest is returned as a string object of "
"double length, containing only hexadecimal digits.  This may be used to "
"exchange the value safely in email or other non-binary environments."
msgstr ""
"Подібно до :meth:`digest`, за винятком того, що дайджест повертається як "
"рядковий об’єкт подвійної довжини, що містить лише шістнадцяткові цифри. Це "
"можна використовувати для безпечного обміну значенням в електронній пошті чи "
"в інших небінарних середовищах."

msgid ""
"Return a copy (\"clone\") of the hash object.  This can be used to "
"efficiently compute the digests of data sharing a common initial substring."
msgstr ""
"Повертає копію (\"клон\") хеш-об'єкта. Це можна використовувати для "
"ефективного обчислення дайджестів даних, які спільно використовують "
"загальний початковий підрядок."

msgid "SHAKE variable length digests"
msgstr "Дайджести змінної довжини SHAKE"

msgid ""
"The :func:`shake_128` and :func:`shake_256` algorithms provide variable "
"length digests with length_in_bits//2 up to 128 or 256 bits of security. As "
"such, their digest methods require a length. Maximum length is not limited "
"by the SHAKE algorithm."
msgstr ""
"Алгоритми :func:`shake_128` і :func:`shake_256` забезпечують дайджести "
"змінної довжини з length_in_bits//2 до 128 або 256 біт безпеки. Таким чином, "
"їх методи дайджесту вимагають довжини. Максимальна довжина не обмежена "
"алгоритмом SHAKE."

msgid ""
"Return the digest of the data passed to the :meth:`update` method so far. "
"This is a bytes object of size *length* which may contain bytes in the whole "
"range from 0 to 255."
msgstr ""
"Повертає дайджест даних, переданих до цього моменту методу :meth:`update`. "
"Це байтовий об’єкт розміром *length*, який може містити байти в усьому "
"діапазоні від 0 до 255."

msgid "File hashing"
msgstr ""

msgid ""
"The hashlib module provides a helper function for efficient hashing of a "
"file or file-like object."
msgstr ""

msgid ""
"Return a digest object that has been updated with contents of file object."
msgstr ""

msgid ""
"*fileobj* must be a file-like object opened for reading in binary mode. It "
"accepts file objects from  builtin :func:`open`, :class:`~io.BytesIO` "
"instances, SocketIO objects from :meth:`socket.socket.makefile`, and "
"similar. The function may bypass Python's I/O and use the file descriptor "
"from :meth:`~io.IOBase.fileno` directly. *fileobj* must be assumed to be in "
"an unknown state after this function returns or raises. It is up to the "
"caller to close *fileobj*."
msgstr ""

msgid ""
"*digest* must either be a hash algorithm name as a *str*, a hash "
"constructor, or a callable that returns a hash object."
msgstr ""

msgid "Example:"
msgstr "приклад:"

msgid "Key derivation"
msgstr "Виведення ключів"

msgid ""
"Key derivation and key stretching algorithms are designed for secure "
"password hashing. Naive algorithms such as ``sha1(password)`` are not "
"resistant against brute-force attacks. A good password hashing function must "
"be tunable, slow, and include a `salt <https://en.wikipedia.org/wiki/"
"Salt_%28cryptography%29>`_."
msgstr ""
"Алгоритми виведення та розтягування ключа створені для безпечного хешування "
"паролів. Наївні алгоритми, такі як ``sha1(password)``, не стійкі до атак "
"грубої сили. Хороша функція хешування пароля має бути настроюваною, "
"повільною та містити `salt <https://en.wikipedia.org/wiki/"
"Salt_%28cryptography%29>`_."

msgid ""
"The function provides PKCS#5 password-based key derivation function 2. It "
"uses HMAC as pseudorandom function."
msgstr ""
"Ця функція забезпечує функцію виведення ключа на основі пароля PKCS#5 2. "
"Вона використовує HMAC як псевдовипадкову функцію."

msgid ""
"The string *hash_name* is the desired name of the hash digest algorithm for "
"HMAC, e.g. 'sha1' or 'sha256'. *password* and *salt* are interpreted as "
"buffers of bytes. Applications and libraries should limit *password* to a "
"sensible length (e.g. 1024). *salt* should be about 16 or more bytes from a "
"proper source, e.g. :func:`os.urandom`."
msgstr ""
"Рядок *hash_name* є бажаною назвою алгоритму хеш-дайджесту для HMAC, "
"наприклад. \"sha1\" або \"sha256\". *password* і *salt* інтерпретуються як "
"буфери байтів. Програми та бібліотеки мають обмежувати *пароль* розумною "
"довжиною (наприклад, 1024). *salt* має бути приблизно 16 або більше байтів "
"із належного джерела, напр. :func:`os.urandom`."

msgid ""
"The number of *iterations* should be chosen based on the hash algorithm and "
"computing power. As of 2022, hundreds of thousands of iterations of SHA-256 "
"are suggested. For rationale as to why and how to choose what is best for "
"your application, read *Appendix A.2.2* of NIST-SP-800-132_. The answers on "
"the `stackexchange pbkdf2 iterations question`_ explain in detail."
msgstr ""
"Кількість *ітерацій* слід вибирати, виходячи з алгоритму хешування та "
"обчислювальної потужності. Станом на 2022 рік пропонуються сотні тисяч "
"ітерацій SHA-256. Для обґрунтування того, чому та як вибрати те, що найкраще "
"підходить для вашої програми, прочитайте *Додаток A.2.2* NIST-SP-800-132_. "
"Відповіді на `stackexchange pbkdf2 iterations question`_ пояснюють детально."

msgid ""
"*dklen* is the length of the derived key. If *dklen* is ``None`` then the "
"digest size of the hash algorithm *hash_name* is used, e.g. 64 for SHA-512."
msgstr ""
"*dklen* — довжина похідного ключа. Якщо *dklen* має значення ``None``, тоді "
"використовується розмір дайджесту геш-алгоритму *hash_name*, наприклад. 64 "
"для SHA-512."

msgid ""
"A fast implementation of *pbkdf2_hmac* is available with OpenSSL.  The "
"Python implementation uses an inline version of :mod:`hmac`. It is about "
"three times slower and doesn't release the GIL."
msgstr ""
"Швидка реалізація *pbkdf2_hmac* доступна з OpenSSL. Реалізація Python "
"використовує вбудовану версію :mod:`hmac`. Це приблизно втричі повільніше та "
"не випускає GIL."

msgid ""
"Slow Python implementation of *pbkdf2_hmac* is deprecated. In the future the "
"function will only be available when Python is compiled with OpenSSL."
msgstr ""
"Повільна реалізація *pbkdf2_hmac* на Python застаріла. У майбутньому функція "
"буде доступна лише тоді, коли Python скомпільовано з OpenSSL."

msgid ""
"The function provides scrypt password-based key derivation function as "
"defined in :rfc:`7914`."
msgstr ""
"Функція забезпечує функцію виведення ключа на основі пароля scrypt, як "
"визначено в :rfc:`7914`."

msgid ""
"*password* and *salt* must be :term:`bytes-like objects <bytes-like "
"object>`.  Applications and libraries should limit *password* to a sensible "
"length (e.g. 1024).  *salt* should be about 16 or more bytes from a proper "
"source, e.g. :func:`os.urandom`."
msgstr ""
"*пароль* і *соль* мають бути :term:`байтоподібними об’єктами <bytes-like "
"object>`. Програми та бібліотеки повинні обмежувати *пароль* розумною "
"довжиною (наприклад, 1024). *salt* має бути приблизно 16 або більше байтів "
"із належного джерела, напр. :func:`os.urandom`."

msgid ""
"*n* is the CPU/Memory cost factor, *r* the block size, *p* parallelization "
"factor and *maxmem* limits memory (OpenSSL 1.1.0 defaults to 32 MiB). "
"*dklen* is the length of the derived key."
msgstr ""
"*n* — це коефіцієнт вартості ЦП/пам’яті, *r* — розмір блоку, *p* — "
"коефіцієнт розпаралелювання, а *maxmem* обмежує пам’ять (OpenSSL 1.1.0 за "
"замовчуванням становить 32 МБ). *dklen* — довжина похідного ключа."

msgid "BLAKE2"
msgstr "БЛЕЙК2"

msgid ""
"BLAKE2_ is a cryptographic hash function defined in :rfc:`7693` that comes "
"in two flavors:"
msgstr ""
"BLAKE2_ — це криптографічна хеш-функція, визначена в :rfc:`7693`, яка має "
"два варіанти:"

msgid ""
"**BLAKE2b**, optimized for 64-bit platforms and produces digests of any size "
"between 1 and 64 bytes,"
msgstr ""
"**BLAKE2b**, оптимізований для 64-розрядних платформ і створює дайджести "
"будь-якого розміру від 1 до 64 байтів,"

msgid ""
"**BLAKE2s**, optimized for 8- to 32-bit platforms and produces digests of "
"any size between 1 and 32 bytes."
msgstr ""
"**BLAKE2s**, оптимізований для платформ від 8 до 32 біт і створює дайджести "
"будь-якого розміру від 1 до 32 байтів."

msgid ""
"BLAKE2 supports **keyed mode** (a faster and simpler replacement for HMAC_), "
"**salted hashing**, **personalization**, and **tree hashing**."
msgstr ""
"BLAKE2 підтримує **ключовий режим** (швидша та простіша заміна HMAC_), "
"**солі хешування**, **персоналізацію** та **хешування дерева**."

msgid ""
"Hash objects from this module follow the API of standard library's :mod:"
"`hashlib` objects."
msgstr ""
"Хеш-об’єкти з цього модуля відповідають API об’єктів :mod:`hashlib` "
"стандартної бібліотеки."

msgid "Creating hash objects"
msgstr "Створення хеш-об'єктів"

msgid "New hash objects are created by calling constructor functions:"
msgstr "Нові хеш-об’єкти створюються шляхом виклику функцій конструктора:"

msgid ""
"These functions return the corresponding hash objects for calculating "
"BLAKE2b or BLAKE2s. They optionally take these general parameters:"
msgstr ""
"Ці функції повертають відповідні хеш-об’єкти для обчислення BLAKE2b або "
"BLAKE2s. Вони необов'язково приймають такі загальні параметри:"

msgid ""
"*data*: initial chunk of data to hash, which must be :term:`bytes-like "
"object`.  It can be passed only as positional argument."
msgstr ""
"*data*: початкова частина даних для хешування, яка має бути :term:`bytes-"
"like object`. Його можна передати лише як позиційний аргумент."

msgid "*digest_size*: size of output digest in bytes."
msgstr "*digest_size*: розмір вихідного дайджесту в байтах."

msgid ""
"*key*: key for keyed hashing (up to 64 bytes for BLAKE2b, up to 32 bytes for "
"BLAKE2s)."
msgstr ""
"*key*: ключ для хешування з ключем (до 64 байтів для BLAKE2b, до 32 байтів "
"для BLAKE2s)."

msgid ""
"*salt*: salt for randomized hashing (up to 16 bytes for BLAKE2b, up to 8 "
"bytes for BLAKE2s)."
msgstr ""
"*salt*: сіль для рандомізованого хешування (до 16 байт для BLAKE2b, до 8 "
"байт для BLAKE2s)."

msgid ""
"*person*: personalization string (up to 16 bytes for BLAKE2b, up to 8 bytes "
"for BLAKE2s)."
msgstr ""
"*особа*: рядок персоналізації (до 16 байт для BLAKE2b, до 8 байт для "
"BLAKE2s)."

msgid "The following table shows limits for general parameters (in bytes):"
msgstr ""
"У наступній таблиці показано обмеження для загальних параметрів (у байтах):"

msgid "Hash"
msgstr "Хеш"

msgid "digest_size"
msgstr "digest_size"

msgid "len(key)"
msgstr "len (ключ)"

msgid "len(salt)"
msgstr "лен (сіль)"

msgid "len(person)"
msgstr "len (особа)"

msgid "BLAKE2b"
msgstr "BLAKE2b"

msgid "64"
msgstr "64"

msgid "16"
msgstr "16"

msgid "BLAKE2s"
msgstr "BLAKE2s"

msgid "32"
msgstr "32"

msgid "8"
msgstr "8"

msgid ""
"BLAKE2 specification defines constant lengths for salt and personalization "
"parameters, however, for convenience, this implementation accepts byte "
"strings of any size up to the specified length. If the length of the "
"parameter is less than specified, it is padded with zeros, thus, for "
"example, ``b'salt'`` and ``b'salt\\x00'`` is the same value. (This is not "
"the case for *key*.)"
msgstr ""
"Специфікація BLAKE2 визначає постійну довжину параметрів солі та "
"персоналізації, однак для зручності ця реалізація приймає рядки байтів будь-"
"якого розміру до вказаної довжини. Якщо довжина параметра менша за вказану, "
"вона доповнюється нулями, таким чином, наприклад, ``b'salt`` і "
"``b'salt\\x00`` є однаковими значеннями. (Це не стосується *ключа*.)"

msgid "These sizes are available as module `constants`_ described below."
msgstr "Ці розміри доступні як `constants`_ модуля, описані нижче."

msgid ""
"Constructor functions also accept the following tree hashing parameters:"
msgstr "Функції конструктора також приймають такі параметри хешування дерева:"

msgid "*fanout*: fanout (0 to 255, 0 if unlimited, 1 in sequential mode)."
msgstr ""
"*fanout*: розхід (від 0 до 255, 0, якщо необмежений, 1 у послідовному "
"режимі)."

msgid ""
"*depth*: maximal depth of tree (1 to 255, 255 if unlimited, 1 in sequential "
"mode)."
msgstr ""
"*depth*: максимальна глибина дерева (від 1 до 255, 255, якщо необмежено, 1 у "
"послідовному режимі)."

msgid ""
"*leaf_size*: maximal byte length of leaf (0 to ``2**32-1``, 0 if unlimited "
"or in sequential mode)."
msgstr ""
"*leaf_size*: максимальна довжина листа в байтах (від 0 до ``2**32-1``, 0, "
"якщо необмежений або в послідовному режимі)."

msgid ""
"*node_offset*: node offset (0 to ``2**64-1`` for BLAKE2b, 0 to ``2**48-1`` "
"for BLAKE2s, 0 for the first, leftmost, leaf, or in sequential mode)."
msgstr ""
"*node_offset*: зміщення вузла (від 0 до ``2**64-1`` для BLAKE2b, від 0 до "
"``2**48-1`` для BLAKE2s, 0 для першого, крайнього лівого листа, або в "
"послідовному режимі )."

msgid ""
"*node_depth*: node depth (0 to 255, 0 for leaves, or in sequential mode)."
msgstr ""
"*node_depth*: глибина вузла (від 0 до 255, 0 для листів або в послідовному "
"режимі)."

msgid ""
"*inner_size*: inner digest size (0 to 64 for BLAKE2b, 0 to 32 for BLAKE2s, 0 "
"in sequential mode)."
msgstr ""
"*inner_size*: розмір внутрішнього дайджесту (від 0 до 64 для BLAKE2b, від 0 "
"до 32 для BLAKE2s, 0 у послідовному режимі)."

msgid ""
"*last_node*: boolean indicating whether the processed node is the last one "
"(``False`` for sequential mode)."
msgstr ""

msgid "Explanation of tree mode parameters."
msgstr ""

msgid ""
"See section 2.10 in `BLAKE2 specification <https://blake2.net/"
"blake2_20130129.pdf>`_ for comprehensive review of tree hashing."
msgstr ""
"Перегляньте розділ 2.10 у `BLAKE2 специфікації <https://blake2.net/"
"blake2_20130129.pdf>`_ для повного огляду хешування дерева."

msgid "Constants"
msgstr "Константи"

msgid "Salt length (maximum length accepted by constructors)."
msgstr "Довжина солі (максимальна довжина, прийнята конструкторами)."

msgid ""
"Personalization string length (maximum length accepted by constructors)."
msgstr ""
"Довжина рядка персоналізації (максимальна довжина, прийнята конструкторами)."

msgid "Maximum key size."
msgstr "Максимальний розмір ключа."

msgid "Maximum digest size that the hash function can output."
msgstr "Максимальний розмір дайджесту, який може вивести хеш-функція."

msgid "Examples"
msgstr "Приклади"

msgid "Simple hashing"
msgstr "Просте хешування"

msgid ""
"To calculate hash of some data, you should first construct a hash object by "
"calling the appropriate constructor function (:func:`blake2b` or :func:"
"`blake2s`), then update it with the data by calling :meth:`update` on the "
"object, and, finally, get the digest out of the object by calling :meth:"
"`digest` (or :meth:`hexdigest` for hex-encoded string)."
msgstr ""
"Щоб обчислити хеш деяких даних, вам слід спочатку створити хеш-об’єкт, "
"викликавши відповідну функцію-конструктор (:func:`blake2b` або :func:"
"`blake2s`), а потім оновити його даними, викликавши :meth:`update` на "
"об’єкті, і, нарешті, отримати дайджест з об’єкта, викликавши :meth:`digest` "
"(або :meth:`hexdigest` для рядка з шістнадцятковим кодуванням)."

msgid ""
"As a shortcut, you can pass the first chunk of data to update directly to "
"the constructor as the positional argument:"
msgstr ""
"Як ярлик, ви можете передати перший фрагмент даних для оновлення "
"безпосередньо в конструктор як позиційний аргумент:"

msgid ""
"You can call :meth:`hash.update` as many times as you need to iteratively "
"update the hash:"
msgstr ""
"Ви можете викликати :meth:`hash.update` стільки разів, скільки потрібно для "
"повторного оновлення хешу:"

msgid "Using different digest sizes"
msgstr "Використання різних розмірів дайджесту"

msgid ""
"BLAKE2 has configurable size of digests up to 64 bytes for BLAKE2b and up to "
"32 bytes for BLAKE2s. For example, to replace SHA-1 with BLAKE2b without "
"changing the size of output, we can tell BLAKE2b to produce 20-byte digests:"
msgstr ""
"BLAKE2 має настроюваний розмір дайджестів до 64 байтів для BLAKE2b і до 32 "
"байтів для BLAKE2s. Наприклад, щоб замінити SHA-1 на BLAKE2b без зміни "
"розміру виведення, ми можемо наказати BLAKE2b створювати 20-байтові "
"дайджести:"

msgid ""
"Hash objects with different digest sizes have completely different outputs "
"(shorter hashes are *not* prefixes of longer hashes); BLAKE2b and BLAKE2s "
"produce different outputs even if the output length is the same:"
msgstr ""
"Хеш-об’єкти з різними розмірами дайджестів мають абсолютно різні результати "
"(коротші хеші *не* є префіксами більш довгих хешів); BLAKE2b і BLAKE2s "
"створюють різні результати, навіть якщо довжина виводу однакова:"

msgid "Keyed hashing"
msgstr "Ключове хешування"

msgid ""
"Keyed hashing can be used for authentication as a faster and simpler "
"replacement for `Hash-based message authentication code <https://en."
"wikipedia.org/wiki/HMAC>`_ (HMAC). BLAKE2 can be securely used in prefix-MAC "
"mode thanks to the indifferentiability property inherited from BLAKE."
msgstr ""
"Хешування з ключем можна використовувати для автентифікації як швидшу та "
"простішу заміну `коду автентифікації повідомлення на основі хешу <https://en."
"wikipedia.org/wiki/HMAC>`_ (HMAC). BLAKE2 можна безпечно використовувати в "
"режимі prefix-MAC завдяки властивості індиференційованості, успадкованій від "
"BLAKE."

msgid ""
"This example shows how to get a (hex-encoded) 128-bit authentication code "
"for message ``b'message data'`` with key ``b'pseudorandom key'``::"
msgstr ""
"У цьому прикладі показано, як отримати (в шістнадцятковому кодуванні) 128-"
"бітний код автентифікації для повідомлення ``b'message data`` з ключем "
"``b'pseudorandom key``::"

msgid ""
"As a practical example, a web application can symmetrically sign cookies "
"sent to users and later verify them to make sure they weren't tampered with::"
msgstr ""
"Як практичний приклад, веб-додаток може симетрично підписувати файли cookie, "
"надіслані користувачам, а потім перевіряти їх, щоб переконатися, що вони не "
"були змінені:"

msgid ""
"Even though there's a native keyed hashing mode, BLAKE2 can, of course, be "
"used in HMAC construction with :mod:`hmac` module::"
msgstr ""
"Незважаючи на те, що існує режим хешування з рідним ключем, BLAKE2, "
"звичайно, можна використовувати в конструкції HMAC за допомогою модуля :mod:"
"`hmac`::"

msgid "Randomized hashing"
msgstr "Рандомізоване хешування"

msgid ""
"By setting *salt* parameter users can introduce randomization to the hash "
"function. Randomized hashing is useful for protecting against collision "
"attacks on the hash function used in digital signatures."
msgstr ""
"Установивши параметр *salt*, користувачі можуть запровадити рандомізацію хеш-"
"функції. Рандомізоване хешування корисне для захисту від колізійних атак на "
"хеш-функцію, яка використовується в цифрових підписах."

msgid ""
"Randomized hashing is designed for situations where one party, the message "
"preparer, generates all or part of a message to be signed by a second party, "
"the message signer. If the message preparer is able to find cryptographic "
"hash function collisions (i.e., two messages producing the same hash value), "
"then they might prepare meaningful versions of the message that would "
"produce the same hash value and digital signature, but with different "
"results (e.g., transferring $1,000,000 to an account, rather than $10). "
"Cryptographic hash functions have been designed with collision resistance as "
"a major goal, but the current concentration on attacking cryptographic hash "
"functions may result in a given cryptographic hash function providing less "
"collision resistance than expected. Randomized hashing offers the signer "
"additional protection by reducing the likelihood that a preparer can "
"generate two or more messages that ultimately yield the same hash value "
"during the digital signature generation process --- even if it is practical "
"to find collisions for the hash function. However, the use of randomized "
"hashing may reduce the amount of security provided by a digital signature "
"when all portions of the message are prepared by the signer."
msgstr ""
"Рандомізоване хешування призначене для ситуацій, коли одна сторона, яка "
"готує повідомлення, створює все або частину повідомлення для підпису другою "
"стороною, особою, яка підписує повідомлення. Якщо готувач повідомлення може "
"знайти колізії криптографічної хеш-функції (тобто два повідомлення, що "
"створюють однакове хеш-значення), тоді він може підготувати значущі версії "
"повідомлення, які створять те саме хеш-значення та цифровий підпис, але з "
"різними результатами (наприклад, , переказуючи на рахунок 1 000 000 доларів "
"США, а не 10 доларів США). Основною метою криптографічних хеш-функцій було "
"розроблено стійкість до зіткнень, але поточна концентрація на атакуючих "
"криптографічних хеш-функціях може призвести до того, що дана криптографічна "
"хеш-функція забезпечить меншу стійкість до зіткнень, ніж очікувалося. "
"Рандомізоване хешування пропонує підписувачу додатковий захист, зменшуючи "
"ймовірність того, що підготовник зможе згенерувати два або більше "
"повідомлень, які в кінцевому підсумку дають однакове хеш-значення під час "
"процесу генерації цифрового підпису --- навіть якщо практично знайти колізії "
"для хеш-функції. Однак використання рандомізованого хешування може знизити "
"рівень безпеки, який забезпечує цифровий підпис, коли всі частини "
"повідомлення готуються підписувачем."

msgid ""
"(`NIST SP-800-106 \"Randomized Hashing for Digital Signatures\" <https://"
"csrc.nist.gov/publications/detail/sp/800-106/final>`_)"
msgstr ""
"(`NIST SP-800-106 \"Випадкове хешування для цифрових підписів\" <https://"
"csrc.nist.gov/publications/detail/sp/800-106/final>`_)"

msgid ""
"In BLAKE2 the salt is processed as a one-time input to the hash function "
"during initialization, rather than as an input to each compression function."
msgstr ""
"У BLAKE2 сіль обробляється як одноразовий вхід до хеш-функції під час "
"ініціалізації, а не як вхід для кожної функції стиснення."

msgid ""
"*Salted hashing* (or just hashing) with BLAKE2 or any other general-purpose "
"cryptographic hash function, such as SHA-256, is not suitable for hashing "
"passwords.  See `BLAKE2 FAQ <https://blake2.net/#qa>`_ for more information."
msgstr ""
"*Солоне хешування* (або просто хешування) за допомогою BLAKE2 або будь-якої "
"іншої криптографічної хеш-функції загального призначення, наприклад SHA-256, "
"не підходить для хешування паролів. Перегляньте `FAQ BLAKE2 <https://blake2."
"net/#qa>`_ для отримання додаткової інформації."

msgid "Personalization"
msgstr "Персоналізація"

msgid ""
"Sometimes it is useful to force hash function to produce different digests "
"for the same input for different purposes. Quoting the authors of the Skein "
"hash function:"
msgstr ""
"Іноді корисно змусити хеш-функцію виробляти різні дайджести для одного "
"введення для різних цілей. Цитую авторів хеш-функції Skein:"

msgid ""
"We recommend that all application designers seriously consider doing this; "
"we have seen many protocols where a hash that is computed in one part of the "
"protocol can be used in an entirely different part because two hash "
"computations were done on similar or related data, and the attacker can "
"force the application to make the hash inputs the same. Personalizing each "
"hash function used in the protocol summarily stops this type of attack."
msgstr ""
"Ми рекомендуємо всім розробникам додатків серйозно подумати про це; ми "
"бачили багато протоколів, де хеш, який обчислюється в одній частині "
"протоколу, може використовуватися в зовсім іншій частині, оскільки два хеш-"
"обчислення були виконані на подібних або пов’язаних даних, і зловмисник може "
"змусити програму зробити вхідні дані хешу те саме. Персоналізація кожної хеш-"
"функції, яка використовується в протоколі, швидко зупиняє цей тип атаки."

msgid ""
"(`The Skein Hash Function Family <https://www.schneier.com/wp-content/"
"uploads/2016/02/skein.pdf>`_, p. 21)"
msgstr ""

msgid "BLAKE2 can be personalized by passing bytes to the *person* argument::"
msgstr "BLAKE2 можна персоналізувати, передаючи байти в аргумент *person*::"

msgid ""
"Personalization together with the keyed mode can also be used to derive "
"different keys from a single one."
msgstr ""
"Персоналізацію разом із режимом ключа також можна використовувати для "
"отримання різних ключів з одного."

msgid "Tree mode"
msgstr "Режим дерева"

msgid "Here's an example of hashing a minimal tree with two leaf nodes::"
msgstr "Ось приклад хешування мінімального дерева з двома листовими вузлами:"

msgid ""
"This example uses 64-byte internal digests, and returns the 32-byte final "
"digest::"
msgstr ""
"У цьому прикладі використовуються 64-байтові внутрішні дайджести та "
"повертається 32-байтовий остаточний дайджест:"

msgid "Credits"
msgstr "Кредити"

msgid ""
"BLAKE2_ was designed by *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko "
"Wilcox-O'Hearn*, and *Christian Winnerlein* based on SHA-3_ finalist BLAKE_ "
"created by *Jean-Philippe Aumasson*, *Luca Henzen*, *Willi Meier*, and "
"*Raphael C.-W. Phan*."
msgstr ""
"BLAKE2_ був розроблений *Jean-Philippe Aumasson*, *Samuel Neves*, *Zooko "
"Wilcox-O'Hearn* і *Christian Winnerlein* на основі фіналіста SHA-3_ BLAKE_, "
"створеного *Jean-Philippe Aumasson*, *Luca Henzen*, *Willi Meier* і*Raphael "
"C.-W. Phan*."

msgid ""
"It uses core algorithm from ChaCha_ cipher designed by *Daniel J.  "
"Bernstein*."
msgstr ""
"Він використовує основний алгоритм із шифру ChaCha_, розробленого *Daniel J. "
"Bernstein*."

msgid ""
"The stdlib implementation is based on pyblake2_ module. It was written by "
"*Dmitry Chestnykh* based on C implementation written by *Samuel Neves*. The "
"documentation was copied from pyblake2_ and written by *Dmitry Chestnykh*."
msgstr ""
"Реалізація stdlib базується на модулі pyblake2_. Його написав *Dmitry "
"Chestnykh* на основі реалізації C, написаної *Samuel Neves*. Документація "
"була скопійована з pyblake2_ і написана *Дмитром Честних*."

msgid "The C code was partly rewritten for Python by *Christian Heimes*."
msgstr "Код C був частково переписаний для Python *Christian Heimes*."

msgid ""
"The following public domain dedication applies for both C hash function "
"implementation, extension code, and this documentation:"
msgstr ""
"Наведені нижче правила загальнодоступного домену застосовуються до "
"реалізації хеш-функції C, коду розширення та цієї документації:"

msgid ""
"To the extent possible under law, the author(s) have dedicated all copyright "
"and related and neighboring rights to this software to the public domain "
"worldwide. This software is distributed without any warranty."
msgstr ""
"Наскільки це можливо згідно із законодавством, автор(и) передали всі "
"авторські права, суміжні та суміжні права на це програмне забезпечення у "
"суспільне надбання в усьому світі. Це програмне забезпечення "
"розповсюджується без будь-яких гарантій."

msgid ""
"You should have received a copy of the CC0 Public Domain Dedication along "
"with this software. If not, see https://creativecommons.org/publicdomain/"
"zero/1.0/."
msgstr ""
"Ви повинні були отримати копію CC0 Public Domain Dedication разом із цим "
"програмним забезпеченням. Якщо ні, перегляньте https://creativecommons.org/"
"publicdomain/zero/1.0/."

msgid ""
"The following people have helped with development or contributed their "
"changes to the project and the public domain according to the Creative "
"Commons Public Domain Dedication 1.0 Universal:"
msgstr ""
"Наступні люди допомогли з розробкою або внесли свої зміни до проекту та "
"суспільного надбання відповідно до Creative Commons Public Domain Dedication "
"1.0 Universal:"

msgid "*Alexandr Sokolovskiy*"
msgstr "*Олександр Соколовський*"

msgid "Module :mod:`hmac`"
msgstr "Модуль :mod:`hmac`"

msgid "A module to generate message authentication codes using hashes."
msgstr ""
"Модуль для створення кодів автентифікації повідомлень за допомогою хешів."

msgid "Module :mod:`base64`"
msgstr "Модуль :mod:`base64`"

msgid "Another way to encode binary hashes for non-binary environments."
msgstr "Інший спосіб кодування двійкових хешів для небінарних середовищ."

msgid "https://blake2.net"
msgstr "https://blake2.net"

msgid "Official BLAKE2 website."
msgstr "Офіційний сайт BLAKE2."

msgid ""
"https://csrc.nist.gov/csrc/media/publications/fips/180/2/archive/2002-08-01/"
"documents/fips180-2.pdf"
msgstr ""
"https://csrc.nist.gov/csrc/media/publications/fips/180/2/archive/2002-08-01/"
"documents/fips180-2.pdf"

msgid "The FIPS 180-2 publication on Secure Hash Algorithms."
msgstr "Публікація FIPS 180-2 про безпечні алгоритми хешування."

msgid ""
"https://en.wikipedia.org/wiki/"
"Cryptographic_hash_function#Cryptographic_hash_algorithms"
msgstr ""
"https://en.wikipedia.org/wiki/"
"Cryptographic_hash_function#Cryptographic_hash_algorithms"

msgid ""
"Wikipedia article with information on which algorithms have known issues and "
"what that means regarding their use."
msgstr ""
"Стаття у Вікіпедії з інформацією про те, які алгоритми мають відомі проблеми "
"та що це означає щодо їх використання."

msgid "https://www.ietf.org/rfc/rfc8018.txt"
msgstr "https://www.ietf.org/rfc/rfc8018.txt"

msgid "PKCS #5: Password-Based Cryptography Specification Version 2.1"
msgstr "PKCS #5: Специфікація криптографії на основі пароля, версія 2.1"

msgid ""
"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf"
msgstr ""
"https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf"

msgid "NIST Recommendation for Password-Based Key Derivation."
msgstr "Рекомендації NIST щодо виведення ключів на основі пароля."
