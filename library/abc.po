# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:54+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`abc` --- Abstract Base Classes"
msgstr ":mod:`abc` --- Абстрактні базові класи"

msgid "**Source code:** :source:`Lib/abc.py`"
msgstr "**Вихідний код:** :source:`Lib/abc.py`"

msgid ""
"This module provides the infrastructure for defining :term:`abstract base "
"classes <abstract base class>` (ABCs) in Python, as outlined in :pep:`3119`; "
"see the PEP for why this was added to Python. (See also :pep:`3141` and the :"
"mod:`numbers` module regarding a type hierarchy for numbers based on ABCs.)"
msgstr ""
"Цей модуль забезпечує інфраструктуру для визначення :term:`абстрактних "
"базових класів <abstract base class>` (ABC) у Python, як описано в :pep:"
"`3119`; див. PEP, чому це було додано до Python. (Див. також :pep:`3141` і "
"модуль :mod:`numbers` щодо ієрархії типів для чисел на основі ABC.)"

msgid ""
"The :mod:`collections` module has some concrete classes that derive from "
"ABCs; these can, of course, be further derived. In addition, the :mod:"
"`collections.abc` submodule has some ABCs that can be used to test whether a "
"class or instance provides a particular interface, for example, if it is "
"hashable or if it is a mapping."
msgstr ""
"Модуль :mod:`collections` має деякі конкретні класи, які походять від ABC; "
"вони, звичайно, можуть бути отримані далі. Крім того, субмодуль :mod:"
"`collections.abc` має деякі азбуки, які можна використовувати, щоб "
"перевірити, чи надає клас або примірник певний інтерфейс, наприклад, чи є "
"він хешованим або чи є це відображенням."

msgid ""
"This module provides the metaclass :class:`ABCMeta` for defining ABCs and a "
"helper class :class:`ABC` to alternatively define ABCs through inheritance:"
msgstr ""
"Цей модуль надає метаклас :class:`ABCMeta` для визначення ABC і допоміжний "
"клас :class:`ABC` для альтернативного визначення ABC через успадкування:"

msgid ""
"A helper class that has :class:`ABCMeta` as its metaclass.  With this class, "
"an abstract base class can be created by simply deriving from :class:`ABC` "
"avoiding sometimes confusing metaclass usage, for example::"
msgstr ""
"Допоміжний клас, який має метаклас :class:`ABCMeta`. За допомогою цього "
"класу можна створити абстрактний базовий клас, просто похідним від :class:"
"`ABC`, уникаючи інколи заплутаного використання метакласу, наприклад::"

msgid ""
"Note that the type of :class:`ABC` is still :class:`ABCMeta`, therefore "
"inheriting from :class:`ABC` requires the usual precautions regarding "
"metaclass usage, as multiple inheritance may lead to metaclass conflicts. "
"One may also define an abstract base class by passing the metaclass keyword "
"and using :class:`ABCMeta` directly, for example::"
msgstr ""
"Зауважте, що тип :class:`ABC` все ще :class:`ABCMeta`, тому успадкування "
"від :class:`ABC` вимагає звичайних запобіжних заходів щодо використання "
"метакласу, оскільки множинне успадкування може призвести до конфліктів "
"метакласів. Можна також визначити абстрактний базовий клас, передавши "
"ключове слово metaclass і безпосередньо використовуючи :class:`ABCMeta`, "
"наприклад::"

msgid "Metaclass for defining Abstract Base Classes (ABCs)."
msgstr "Метаклас для визначення абстрактних базових класів (ABC)."

msgid ""
"Use this metaclass to create an ABC.  An ABC can be subclassed directly, and "
"then acts as a mix-in class.  You can also register unrelated concrete "
"classes (even built-in classes) and unrelated ABCs as \"virtual subclasses\" "
"-- these and their descendants will be considered subclasses of the "
"registering ABC by the built-in :func:`issubclass` function, but the "
"registering ABC won't show up in their MRO (Method Resolution Order) nor "
"will method implementations defined by the registering ABC be callable (not "
"even via :func:`super`). [#]_"
msgstr ""
"Використовуйте цей метаклас для створення ABC. ABC може бути безпосередньо "
"підкласом, а потім діяти як змішаний клас. Ви також можете зареєструвати "
"непов’язані конкретні класи (навіть вбудовані) і непов’язані ABC як "
"\"віртуальні підкласи\" — ці та їхні нащадки вважатимуться підкласами "
"реєструючого ABC вбудованою функцією :func:`issubclass`, але реєструючий ABC "
"не відображатиметься в їхньому MRO (Method Resolution Order), а також "
"реалізації методів, визначені реєструючим ABC, не можна буде викликати "
"(навіть через :func:`super`). [#]_"

msgid ""
"Classes created with a metaclass of :class:`ABCMeta` have the following "
"method:"
msgstr ""
"Класи, створені за допомогою метакласу :class:`ABCMeta`, мають такий метод:"

msgid ""
"Register *subclass* as a \"virtual subclass\" of this ABC. For example::"
msgstr ""
"Зареєструйте *підклас* як \"віртуальний підклас\" цього ABC. Наприклад::"

msgid "Returns the registered subclass, to allow usage as a class decorator."
msgstr ""
"Повертає зареєстрований підклас, щоб дозволити використання як декоратор "
"класу."

msgid ""
"To detect calls to :meth:`register`, you can use the :func:`get_cache_token` "
"function."
msgstr ""
"Щоб виявити виклики :meth:`register`, ви можете використати функцію :func:"
"`get_cache_token`."

msgid "You can also override this method in an abstract base class:"
msgstr "Ви також можете перевизначити цей метод в абстрактному базовому класі:"

msgid "(Must be defined as a class method.)"
msgstr "(Повинен бути визначений як метод класу.)"

msgid ""
"Check whether *subclass* is considered a subclass of this ABC.  This means "
"that you can customize the behavior of ``issubclass`` further without the "
"need to call :meth:`register` on every class you want to consider a subclass "
"of the ABC.  (This class method is called from the :meth:`__subclasscheck__` "
"method of the ABC.)"
msgstr ""
"Перевірте, чи вважається *підклас* підкласом цього ABC. Це означає, що ви "
"можете налаштувати поведінку ``issubclass`` без необхідності викликати :meth:"
"`register` для кожного класу, який ви хочете вважати підкласом ABC. (Цей "
"метод класу викликається з методу :meth:`__subclasscheck__` ABC.)"

msgid ""
"This method should return ``True``, ``False`` or ``NotImplemented``.  If it "
"returns ``True``, the *subclass* is considered a subclass of this ABC. If it "
"returns ``False``, the *subclass* is not considered a subclass of this ABC, "
"even if it would normally be one.  If it returns ``NotImplemented``, the "
"subclass check is continued with the usual mechanism."
msgstr ""
"Цей метод має повертати ``True``, ``False`` або ``NotImplemented``. Якщо він "
"повертає ``True``, *підклас* вважається підкласом цього ABC. Якщо він "
"повертає ``False``, *підклас* не вважається підкласом цього ABC, навіть якщо "
"він зазвичай є ним. Якщо він повертає ``NotImplemented``, перевірка підкласу "
"продовжується за звичайним механізмом."

msgid ""
"For a demonstration of these concepts, look at this example ABC definition::"
msgstr ""
"Для демонстрації цих концепцій подивіться на цей приклад визначення ABC:"

msgid ""
"The ABC ``MyIterable`` defines the standard iterable method, :meth:"
"`~iterator.__iter__`, as an abstract method.  The implementation given here "
"can still be called from subclasses.  The :meth:`get_iterator` method is "
"also part of the ``MyIterable`` abstract base class, but it does not have to "
"be overridden in non-abstract derived classes."
msgstr ""
"ABC ``MyIterable`` визначає стандартний ітераційний метод, :meth:`~iterator."
"__iter__`, як абстрактний метод. Наведену тут реалізацію все ще можна "
"викликати з підкласів. Метод :meth:`get_iterator` також є частиною "
"абстрактного базового класу ``MyIterable``, але його не потрібно "
"перевизначати в неабстрактних похідних класах."

msgid ""
"The :meth:`__subclasshook__` class method defined here says that any class "
"that has an :meth:`~iterator.__iter__` method in its :attr:`~object."
"__dict__` (or in that of one of its base classes, accessed via the :attr:"
"`~class.__mro__` list) is considered a ``MyIterable`` too."
msgstr ""
"Метод класу :meth:`__subclasshook__`, визначений тут, говорить, що будь-який "
"клас, який має метод :meth:`~iterator.__iter__` у своєму :attr:`~object."
"__dict__` (або в одному зі своїх базових класів, доступ через список :attr:"
"`~class.__mro__` також вважається ``MyIterable``."

msgid ""
"Finally, the last line makes ``Foo`` a virtual subclass of ``MyIterable``, "
"even though it does not define an :meth:`~iterator.__iter__` method (it uses "
"the old-style iterable protocol, defined in terms of :meth:`__len__` and :"
"meth:`__getitem__`).  Note that this will not make ``get_iterator`` "
"available as a method of ``Foo``, so it is provided separately."
msgstr ""
"Нарешті, останній рядок робить ``Foo`` віртуальним підкласом ``MyIterable``, "
"навіть якщо він не визначає метод :meth:`~iterator.__iter__` (він "
"використовує старий ітераційний протокол, визначений у умови :meth:`__len__` "
"і :meth:`__getitem__`). Зверніть увагу, що це не зробить ``get_iterator`` "
"доступним як метод ``Foo``, тому він надається окремо."

msgid "The :mod:`abc` module also provides the following decorator:"
msgstr "Модуль :mod:`abc` також надає наступний декоратор:"

msgid "A decorator indicating abstract methods."
msgstr "Декоратор, що вказує на абстрактні методи."

msgid ""
"Using this decorator requires that the class's metaclass is :class:`ABCMeta` "
"or is derived from it.  A class that has a metaclass derived from :class:"
"`ABCMeta` cannot be instantiated unless all of its abstract methods and "
"properties are overridden.  The abstract methods can be called using any of "
"the normal 'super' call mechanisms.  :func:`abstractmethod` may be used to "
"declare abstract methods for properties and descriptors."
msgstr ""
"Використання цього декоратора вимагає, щоб метаклас класу був :class:"
"`ABCMeta` або був похідним від нього. Клас, який має метаклас, похідний від :"
"class:`ABCMeta`, не може бути створений, якщо всі його абстрактні методи та "
"властивості не перевизначено. Абстрактні методи можна викликати за допомогою "
"будь-якого звичайних механізмів \"супер\" виклику. :func:`abstractmethod` "
"можна використовувати для оголошення абстрактних методів властивостей і "
"дескрипторів."

msgid ""
"Dynamically adding abstract methods to a class, or attempting to modify the "
"abstraction status of a method or class once it is created, are only "
"supported using the :func:`update_abstractmethods` function.  The :func:"
"`abstractmethod` only affects subclasses derived using regular inheritance; "
"\"virtual subclasses\" registered with the ABC's :meth:`register` method are "
"not affected."
msgstr ""
"Динамічне додавання абстрактних методів до класу або спроба змінити стан "
"абстракції методу чи класу після його створення підтримується лише за "
"допомогою функції :func:`update_abstractmethods`. :func:`abstractmethod` "
"впливає лише на підкласи, отримані за допомогою звичайного успадкування; "
"\"віртуальні підкласи\", зареєстровані за допомогою методу :meth:`register` "
"ABC, не впливають."

msgid ""
"When :func:`abstractmethod` is applied in combination with other method "
"descriptors, it should be applied as the innermost decorator, as shown in "
"the following usage examples::"
msgstr ""
"Коли :func:`abstractmethod` застосовано в поєднанні з іншими дескрипторами "
"методу, його слід застосовувати як внутрішній декоратор, як показано в "
"наведених нижче прикладах використання:"

msgid ""
"In order to correctly interoperate with the abstract base class machinery, "
"the descriptor must identify itself as abstract using :attr:"
"`__isabstractmethod__`. In general, this attribute should be ``True`` if any "
"of the methods used to compose the descriptor are abstract. For example, "
"Python's built-in :class:`property` does the equivalent of::"
msgstr ""
"Щоб правильно взаємодіяти з механізмом абстрактного базового класу, "
"дескриптор повинен ідентифікувати себе як абстрактний за допомогою :attr:"
"`__isabstractmethod__`. Загалом цей атрибут має бути ``True``, якщо будь-"
"який із методів, використаних для складання дескриптора, є абстрактним. "
"Наприклад, вбудована властивість Python :class:`property` виконує еквівалент:"

msgid ""
"Unlike Java abstract methods, these abstract methods may have an "
"implementation. This implementation can be called via the :func:`super` "
"mechanism from the class that overrides it.  This could be useful as an end-"
"point for a super-call in a framework that uses cooperative multiple-"
"inheritance."
msgstr ""
"На відміну від абстрактних методів Java, ці абстрактні методи можуть мати "
"реалізацію. Цю реалізацію можна викликати через механізм :func:`super` з "
"класу, який її замінює. Це може бути корисним як кінцева точка для "
"супервиклику в структурі, яка використовує кооперативне множинне "
"успадкування."

msgid "The :mod:`abc` module also supports the following legacy decorators:"
msgstr "Модуль :mod:`abc` також підтримує наступні застарілі декоратори:"

msgid ""
"It is now possible to use :class:`classmethod` with :func:`abstractmethod`, "
"making this decorator redundant."
msgstr ""
"Тепер можна використовувати :class:`classmethod` з :func:`abstractmethod`, "
"що робить цей декоратор зайвим."

msgid ""
"A subclass of the built-in :func:`classmethod`, indicating an abstract "
"classmethod. Otherwise it is similar to :func:`abstractmethod`."
msgstr ""
"Підклас вбудованого :func:`classmethod`, що вказує на абстрактний метод "
"класу. В іншому він схожий на :func:`abstractmethod`."

msgid ""
"This special case is deprecated, as the :func:`classmethod` decorator is now "
"correctly identified as abstract when applied to an abstract method::"
msgstr ""
"Цей спеціальний випадок застарів, оскільки декоратор :func:`classmethod` "
"тепер правильно ідентифікується як абстрактний, коли застосовується до "
"абстрактного методу::"

msgid ""
"It is now possible to use :class:`staticmethod` with :func:`abstractmethod`, "
"making this decorator redundant."
msgstr ""
"Тепер можна використовувати :class:`staticmethod` з :func:`abstractmethod`, "
"що робить цей декоратор зайвим."

msgid ""
"A subclass of the built-in :func:`staticmethod`, indicating an abstract "
"staticmethod. Otherwise it is similar to :func:`abstractmethod`."
msgstr ""
"Підклас вбудованого :func:`staticmethod`, що вказує на абстрактний статичний "
"метод. В іншому він схожий на :func:`abstractmethod`."

msgid ""
"This special case is deprecated, as the :func:`staticmethod` decorator is "
"now correctly identified as abstract when applied to an abstract method::"
msgstr ""
"Цей окремий випадок застарів, оскільки декоратор :func:`staticmethod` тепер "
"правильно ідентифікується як абстрактний, коли застосовується до "
"абстрактного методу::"

msgid ""
"It is now possible to use :class:`property`, :meth:`property.getter`, :meth:"
"`property.setter` and :meth:`property.deleter` with :func:`abstractmethod`, "
"making this decorator redundant."
msgstr ""
"Тепер можна використовувати :class:`property`, :meth:`property.getter`, :"
"meth:`property.setter` і :meth:`property.deleter` з :func:`abstractmethod`, "
"створюючи цей декоратор надлишковий."

msgid ""
"A subclass of the built-in :func:`property`, indicating an abstract property."
msgstr ""
"Підклас вбудованої :func:`property`, що вказує на абстрактну властивість."

msgid ""
"This special case is deprecated, as the :func:`property` decorator is now "
"correctly identified as abstract when applied to an abstract method::"
msgstr ""
"Цей окремий випадок застарів, оскільки декоратор :func:`property` тепер "
"правильно ідентифікується як абстрактний, коли застосовується до "
"абстрактного методу::"

msgid ""
"The above example defines a read-only property; you can also define a read-"
"write abstract property by appropriately marking one or more of the "
"underlying methods as abstract::"
msgstr ""
"Наведений вище приклад визначає властивість лише для читання; ви також "
"можете визначити абстрактну властивість читання-запису, відповідним чином "
"позначивши один або більше основних методів як абстрактні:"

msgid ""
"If only some components are abstract, only those components need to be "
"updated to create a concrete property in a subclass::"
msgstr ""
"Якщо лише деякі компоненти є абстрактними, лише ці компоненти потрібно "
"оновити, щоб створити конкретну властивість у підкласі::"

msgid "The :mod:`abc` module also provides the following functions:"
msgstr "Модуль :mod:`abc` також надає такі функції:"

msgid "Returns the current abstract base class cache token."
msgstr "Повертає поточний маркер кешу абстрактного базового класу."

msgid ""
"The token is an opaque object (that supports equality testing) identifying "
"the current version of the abstract base class cache for virtual subclasses. "
"The token changes with every call to :meth:`ABCMeta.register` on any ABC."
msgstr ""
"Маркер — це непрозорий об’єкт (який підтримує перевірку рівності), що "
"ідентифікує поточну версію кешу абстрактного базового класу для віртуальних "
"підкласів. Маркер змінюється з кожним викликом :meth:`ABCMeta.register` на "
"будь-якому ABC."

msgid ""
"A function to recalculate an abstract class's abstraction status. This "
"function should be called if a class's abstract methods have been "
"implemented or changed after it was created. Usually, this function should "
"be called from within a class decorator."
msgstr ""
"Функція для повторного обчислення статусу абстракції абстрактного класу. Цю "
"функцію слід викликати, якщо абстрактні методи класу були реалізовані або "
"змінені після його створення. Зазвичай цю функцію слід викликати з "
"декоратора класу."

msgid "Returns *cls*, to allow usage as a class decorator."
msgstr "Повертає *cls*, щоб дозволити використання як декоратора класу."

msgid "If *cls* is not an instance of :class:`ABCMeta`, does nothing."
msgstr "Якщо *cls* не є екземпляром :class:`ABCMeta`, нічого не робить."

msgid ""
"This function assumes that *cls*'s superclasses are already updated. It does "
"not update any subclasses."
msgstr ""
"Ця функція передбачає, що суперкласи *cls* вже оновлені. Він не оновлює "
"жодних підкласів."

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"C++ programmers should note that Python's virtual base class concept is not "
"the same as C++'s."
msgstr ""
"Програмісти на C++ повинні мати на увазі, що концепція віртуального базового "
"класу Python не збігається з концепцією C++."
