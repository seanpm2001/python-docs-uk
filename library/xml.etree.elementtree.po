# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-29 17:18+0300\n"
"PO-Revision-Date: 2022-07-05 15:37+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`xml.etree.ElementTree` --- The ElementTree XML API"
msgstr ":mod:`xml.etree.ElementTree` --- XML API ElementTree"

msgid "**Source code:** :source:`Lib/xml/etree/ElementTree.py`"
msgstr "**Вихідний код:** :source:`Lib/xml/etree/ElementTree.py`"

msgid ""
"The :mod:`xml.etree.ElementTree` module implements a simple and efficient "
"API for parsing and creating XML data."
msgstr ""
"Модуль :mod:`xml.etree.ElementTree` реалізує простий і ефективний API для "
"аналізу та створення даних XML."

msgid "This module will use a fast implementation whenever available."
msgstr "Цей модуль використовуватиме швидку реалізацію, якщо вона доступна."

msgid "The :mod:`xml.etree.cElementTree` module is deprecated."
msgstr "Модуль :mod:`xml.etree.cElementTree` застарів."

msgid ""
"The :mod:`xml.etree.ElementTree` module is not secure against maliciously "
"constructed data.  If you need to parse untrusted or unauthenticated data "
"see :ref:`xml-vulnerabilities`."
msgstr ""
"Модуль :mod:`xml.etree.ElementTree` не захищений від зловмисно створених "
"даних. Якщо вам потрібно проаналізувати ненадійні або неавтентифіковані "
"дані, перегляньте :ref:`xml-vulnerabilities`."

msgid "Tutorial"
msgstr "Підручник"

msgid ""
"This is a short tutorial for using :mod:`xml.etree.ElementTree` (``ET`` in "
"short).  The goal is to demonstrate some of the building blocks and basic "
"concepts of the module."
msgstr ""
"Це короткий посібник із використання :mod:`xml.etree.ElementTree` (коротко "
"``ET``). Мета полягає в тому, щоб продемонструвати деякі будівельні блоки та "
"основні концепції модуля."

msgid "XML tree and elements"
msgstr "Дерево та елементи XML"

msgid ""
"XML is an inherently hierarchical data format, and the most natural way to "
"represent it is with a tree.  ``ET`` has two classes for this purpose - :"
"class:`ElementTree` represents the whole XML document as a tree, and :class:"
"`Element` represents a single node in this tree.  Interactions with the "
"whole document (reading and writing to/from files) are usually done on the :"
"class:`ElementTree` level.  Interactions with a single XML element and its "
"sub-elements are done on the :class:`Element` level."
msgstr ""
"XML за своєю суттю є ієрархічним форматом даних, і найприроднішим способом "
"його представлення є дерево. ``ET`` має два класи для цієї мети - :class:"
"`ElementTree` представляє весь XML-документ у вигляді дерева, а :class:"
"`Element` представляє окремий вузол у цьому дереві. Взаємодія з усім "
"документом (читання та запис до/з файлів) зазвичай здійснюється на рівні :"
"class:`ElementTree`. Взаємодія з одним елементом XML і його піделементами "
"здійснюється на рівні :class:`Element`."

msgid "Parsing XML"
msgstr "Розбір XML"

msgid ""
"We'll be using the following XML document as the sample data for this "
"section:"
msgstr ""
"Ми будемо використовувати такий XML-документ як зразки даних для цього "
"розділу:"

msgid "We can import this data by reading from a file::"
msgstr "Ми можемо імпортувати ці дані, зчитуючи з файлу::"

msgid "Or directly from a string::"
msgstr "Або безпосередньо з рядка::"

msgid ""
":func:`fromstring` parses XML from a string directly into an :class:"
"`Element`, which is the root element of the parsed tree.  Other parsing "
"functions may create an :class:`ElementTree`.  Check the documentation to be "
"sure."
msgstr ""
":func:`fromstring` аналізує XML із рядка безпосередньо в :class:`Element`, "
"який є кореневим елементом проаналізованого дерева. Інші функції аналізу "
"можуть створити :class:`ElementTree`. Перевірте документацію, щоб "
"переконатися."

msgid ""
"As an :class:`Element`, ``root`` has a tag and a dictionary of attributes::"
msgstr "Як :class:`Element`, ``root`` має тег і словник атрибутів::"

msgid "It also has children nodes over which we can iterate::"
msgstr "Він також має дочірні вузли, по яких ми можемо повторювати:"

msgid "Children are nested, and we can access specific child nodes by index::"
msgstr ""
"Дочірні вузли є вкладеними, і ми можемо отримати доступ до певних дочірніх "
"вузлів за індексом::"

msgid ""
"Not all elements of the XML input will end up as elements of the parsed "
"tree. Currently, this module skips over any XML comments, processing "
"instructions, and document type declarations in the input. Nevertheless, "
"trees built using this module's API rather than parsing from XML text can "
"have comments and processing instructions in them; they will be included "
"when generating XML output. A document type declaration may be accessed by "
"passing a custom :class:`TreeBuilder` instance to the :class:`XMLParser` "
"constructor."
msgstr ""
"Не всі елементи XML-введення стануть елементами проаналізованого дерева. "
"Наразі цей модуль пропускає будь-які коментарі XML, інструкції з обробки та "
"оголошення типу документів у вхідних даних. Тим не менш, дерева, створені за "
"допомогою API цього модуля, а не синтаксичного аналізу тексту XML, можуть "
"містити коментарі та інструкції з обробки; вони будуть включені під час "
"генерації вихідних даних XML. Оголошення типу документа можна отримати, "
"передавши спеціальний екземпляр :class:`TreeBuilder` конструктору :class:"
"`XMLParser`."

msgid "Pull API for non-blocking parsing"
msgstr "Pull API для неблокуючого аналізу"

msgid ""
"Most parsing functions provided by this module require the whole document to "
"be read at once before returning any result.  It is possible to use an :"
"class:`XMLParser` and feed data into it incrementally, but it is a push API "
"that calls methods on a callback target, which is too low-level and "
"inconvenient for most needs.  Sometimes what the user really wants is to be "
"able to parse XML incrementally, without blocking operations, while enjoying "
"the convenience of fully constructed :class:`Element` objects."
msgstr ""
"Більшість функцій синтаксичного аналізу, наданих цим модулем, вимагають "
"одночасного читання всього документа перед поверненням будь-якого "
"результату. Можна використовувати :class:`XMLParser` і подавати дані в нього "
"поступово, але це API push, який викликає методи в цілі зворотного виклику, "
"що є надто низьким рівнем і незручним для більшості потреб. Іноді користувач "
"справді хоче мати можливість поступово аналізувати XML без блокування "
"операцій, насолоджуючись при цьому зручністю повністю сконструйованих "
"об’єктів :class:`Element`."

msgid ""
"The most powerful tool for doing this is :class:`XMLPullParser`.  It does "
"not require a blocking read to obtain the XML data, and is instead fed with "
"data incrementally with :meth:`XMLPullParser.feed` calls.  To get the parsed "
"XML elements, call :meth:`XMLPullParser.read_events`.  Here is an example::"
msgstr ""
"Найпотужнішим інструментом для цього є :class:`XMLPullParser`. Він не "
"потребує блокуючого читання для отримання XML-даних, натомість дані "
"подаються поступово за допомогою викликів :meth:`XMLPullParser.feed`. Щоб "
"отримати проаналізовані елементи XML, викличте :meth:`XMLPullParser."
"read_events`. Ось приклад::"

msgid ""
"The obvious use case is applications that operate in a non-blocking fashion "
"where the XML data is being received from a socket or read incrementally "
"from some storage device.  In such cases, blocking reads are unacceptable."
msgstr ""
"Очевидним варіантом використання є додатки, які працюють без блокування, "
"коли XML-дані надходять із сокета або зчитуються поступово з якогось "
"пристрою зберігання даних. У таких випадках блокування читання неприпустимо."

msgid ""
"Because it's so flexible, :class:`XMLPullParser` can be inconvenient to use "
"for simpler use-cases.  If you don't mind your application blocking on "
"reading XML data but would still like to have incremental parsing "
"capabilities, take a look at :func:`iterparse`.  It can be useful when "
"you're reading a large XML document and don't want to hold it wholly in "
"memory."
msgstr ""
"Оскільки він дуже гнучкий, :class:`XMLPullParser` може бути незручним у "
"використанні для простіших випадків використання. Якщо ви не заперечуєте, що "
"ваша програма блокує читання XML-даних, але все одно хочете мати можливості "
"поступового аналізу, подивіться на :func:`iterparse`. Це може бути корисно, "
"коли ви читаєте великий XML-документ і не хочете повністю тримати його в "
"пам’яті."

msgid "Finding interesting elements"
msgstr "Пошук цікавих елементів"

msgid ""
":class:`Element` has some useful methods that help iterate recursively over "
"all the sub-tree below it (its children, their children, and so on).  For "
"example, :meth:`Element.iter`::"
msgstr ""
":class:`Element` має кілька корисних методів, які допомагають рекурсивно "
"перебирати все піддерево під ним (його дочірні елементи, їхні дочірні "
"елементи тощо). Наприклад, :meth:`Element.iter`::"

msgid ""
":meth:`Element.findall` finds only elements with a tag which are direct "
"children of the current element.  :meth:`Element.find` finds the *first* "
"child with a particular tag, and :attr:`Element.text` accesses the element's "
"text content.  :meth:`Element.get` accesses the element's attributes::"
msgstr ""
":meth:`Element.findall` знаходить лише елементи з тегом, які є прямими "
"дочірніми елементами поточного елемента. :meth:`Element.find` знаходить "
"*перший* дочірній елемент із певним тегом, а :attr:`Element.text` отримує "
"доступ до текстового вмісту елемента. :meth:`Element.get` отримує доступ до "
"атрибутів елемента::"

msgid ""
"More sophisticated specification of which elements to look for is possible "
"by using :ref:`XPath <elementtree-xpath>`."
msgstr ""
"Більш складна специфікація того, які елементи шукати, можлива за допомогою :"
"ref:`XPath <elementtree-xpath>`."

msgid "Modifying an XML File"
msgstr "Змінення файлу XML"

msgid ""
":class:`ElementTree` provides a simple way to build XML documents and write "
"them to files. The :meth:`ElementTree.write` method serves this purpose."
msgstr ""
":class:`ElementTree` забезпечує простий спосіб створювати XML-документи та "
"записувати їх у файли. Метод :meth:`ElementTree.write` служить для цієї мети."

msgid ""
"Once created, an :class:`Element` object may be manipulated by directly "
"changing its fields (such as :attr:`Element.text`), adding and modifying "
"attributes (:meth:`Element.set` method), as well as adding new children (for "
"example with :meth:`Element.append`)."
msgstr ""
"Після створення об’єктом :class:`Element` можна маніпулювати, безпосередньо "
"змінюючи його поля (наприклад, :attr:`Element.text`), додаючи та змінюючи "
"атрибути (метод :meth:`Element.set`), а також як додавання нових дітей "
"(наприклад, за допомогою :meth:`Element.append`)."

msgid ""
"Let's say we want to add one to each country's rank, and add an ``updated`` "
"attribute to the rank element::"
msgstr ""
"Припустімо, ми хочемо додати один до рейтингу кожної країни та додати "
"атрибут ``updated`` до елемента rank:"

msgid "Our XML now looks like this:"
msgstr "Тепер наш XML виглядає так:"

msgid ""
"We can remove elements using :meth:`Element.remove`.  Let's say we want to "
"remove all countries with a rank higher than 50::"
msgstr ""
"Ми можемо видалити елементи за допомогою :meth:`Element.remove`. Скажімо, ми "
"хочемо видалити всі країни з рейтингом вище 50::"

msgid ""
"Note that concurrent modification while iterating can lead to problems, just "
"like when iterating and modifying Python lists or dicts. Therefore, the "
"example first collects all matching elements with ``root.findall()``, and "
"only then iterates over the list of matches."
msgstr ""
"Зверніть увагу, що одночасна модифікація під час ітерації може призвести до "
"проблем, як і під час ітерації та модифікації списків Python або dicts. "
"Таким чином, приклад спочатку збирає всі відповідні елементи за допомогою "
"``root.findall()``, а лише потім повторює список збігів."

msgid "Building XML documents"
msgstr "Створення документів XML"

msgid ""
"The :func:`SubElement` function also provides a convenient way to create new "
"sub-elements for a given element::"
msgstr ""
"Функція :func:`SubElement` також забезпечує зручний спосіб створення нових "
"піделементів для певного елемента:"

msgid "Parsing XML with Namespaces"
msgstr "Розбір XML з просторами імен"

msgid ""
"If the XML input has `namespaces <https://en.wikipedia.org/wiki/"
"XML_namespace>`__, tags and attributes with prefixes in the form ``prefix:"
"sometag`` get expanded to ``{uri}sometag`` where the *prefix* is replaced by "
"the full *URI*. Also, if there is a `default namespace <https://www.w3.org/"
"TR/xml-names/#defaulting>`__, that full URI gets prepended to all of the non-"
"prefixed tags."
msgstr ""
"Якщо вхідні дані XML містять `простори імен <https://en.wikipedia.org/wiki/"
"XML_namespace>`__, теги й атрибути з префіксами у формі ``prefix:sometag`` "
"розширюються до ``{uri}sometag``, де *префікс* замінюється повним *URI* . "
"Крім того, якщо існує `простір імен за замовчуванням <https://www.w3.org/TR/"
"xml-names/#defaulting>`__, цей повний URI додається до всіх тегів без "
"префіксів."

msgid ""
"Here is an XML example that incorporates two namespaces, one with the prefix "
"\"fictional\" and the other serving as the default namespace:"
msgstr ""
"Ось приклад XML, який містить два простори імен, один із префіксом "
"\"вигаданий\", а інший — простір імен за умовчанням:"

msgid ""
"One way to search and explore this XML example is to manually add the URI to "
"every tag or attribute in the xpath of a :meth:`~Element.find` or :meth:"
"`~Element.findall`::"
msgstr ""
"Один із способів пошуку та вивчення цього прикладу XML — це вручну додати "
"URI до кожного тегу чи атрибута в xpath :meth:`~Element.find` або :meth:"
"`~Element.findall`::"

msgid ""
"A better way to search the namespaced XML example is to create a dictionary "
"with your own prefixes and use those in the search functions::"
msgstr ""
"Кращий спосіб пошуку у прикладі XML із простором імен — створити словник із "
"власними префіксами та використовувати їх у функціях пошуку:"

msgid "These two approaches both output::"
msgstr "Ці два підходи виводять:"

msgid "XPath support"
msgstr "Підтримка XPath"

msgid ""
"This module provides limited support for `XPath expressions <https://www.w3."
"org/TR/xpath>`_ for locating elements in a tree.  The goal is to support a "
"small subset of the abbreviated syntax; a full XPath engine is outside the "
"scope of the module."
msgstr ""
"Цей модуль забезпечує обмежену підтримку `виразів XPath <https://www.w3.org/"
"TR/xpath>`_ для пошуку елементів у дереві. Метою є підтримка невеликої "
"підмножини скороченого синтаксису; повний механізм XPath виходить за рамки "
"модуля."

msgid "Example"
msgstr "приклад"

msgid ""
"Here's an example that demonstrates some of the XPath capabilities of the "
"module.  We'll be using the ``countrydata`` XML document from the :ref:"
"`Parsing XML <elementtree-parsing-xml>` section::"
msgstr ""
"Ось приклад, який демонструє деякі можливості модуля XPath. Ми будемо "
"використовувати XML-документ ``countrydata`` з розділу :ref:`Parsing XML "
"<elementtree-parsing-xml>`::"

msgid ""
"For XML with namespaces, use the usual qualified ``{namespace}tag`` "
"notation::"
msgstr ""
"Для XML із просторами імен використовуйте звичайну нотацію ``{namespace}"
"tag``::"

msgid "Supported XPath syntax"
msgstr "Підтримуваний синтаксис XPath"

msgid "Syntax"
msgstr "Синтаксис"

msgid "Meaning"
msgstr "Значення"

msgid "``tag``"
msgstr "``тег``"

msgid ""
"Selects all child elements with the given tag. For example, ``spam`` selects "
"all child elements named ``spam``, and ``spam/egg`` selects all "
"grandchildren named ``egg`` in all children named ``spam``.  ``{namespace}"
"*`` selects all tags in the given namespace, ``{*}spam`` selects tags named "
"``spam`` in any (or no) namespace, and ``{}*`` only selects tags that are "
"not in a namespace."
msgstr ""
"Вибирає всі дочірні елементи з заданим тегом. Наприклад, ``spam`` вибирає "
"всі дочірні елементи з іменем ``spam``, а ``spam/egg`` вибирає всіх онуків з "
"іменем ``egg`` у всіх дочірніх елементах з іменем ``spam``. ``{namespace}*`` "
"вибирає всі теги в заданому просторі імен, ``{*}spam`` вибирає теги з назвою "
"``spam`` у будь-якому просторі імен (або без нього), а ``{}*`` лише вибирає "
"теги, які не знаходяться в просторі імен."

msgid "Support for star-wildcards was added."
msgstr "Додано підтримку символів підстановки зірок."

msgid "``*``"
msgstr "``*``"

msgid ""
"Selects all child elements, including comments and processing instructions.  "
"For example, ``*/egg`` selects all grandchildren named ``egg``."
msgstr ""
"Вибирає всі дочірні елементи, включаючи коментарі та інструкції з обробки. "
"Наприклад, ``*/egg`` вибирає всіх онуків з іменем ``egg``."

msgid "``.``"
msgstr "``.``"

msgid ""
"Selects the current node.  This is mostly useful at the beginning of the "
"path, to indicate that it's a relative path."
msgstr ""
"Вибирає поточний вузол. Це здебільшого корисно на початку шляху, щоб "
"вказати, що це відносний шлях."

msgid "``//``"
msgstr "``//``"

msgid ""
"Selects all subelements, on all levels beneath the current  element.  For "
"example, ``.//egg`` selects all ``egg`` elements in the entire tree."
msgstr ""
"Вибирає всі піделементи на всіх рівнях під поточним елементом. Наприклад, "
"``.//egg`` вибирає всі елементи ``egg`` у всьому дереві."

msgid "``..``"
msgstr "``..``"

msgid ""
"Selects the parent element.  Returns ``None`` if the path attempts to reach "
"the ancestors of the start element (the element ``find`` was called on)."
msgstr ""
"Вибирає батьківський елемент. Повертає ``None``, якщо шлях намагається "
"досягти предків початкового елемента (був викликаний елемент ``find``)."

msgid "``[@attrib]``"
msgstr "``[@attrib]``"

msgid "Selects all elements that have the given attribute."
msgstr "Вибирає всі елементи, які мають заданий атрибут."

msgid "``[@attrib='value']``"
msgstr "``[@attrib='value']``"

msgid ""
"Selects all elements for which the given attribute has the given value.  The "
"value cannot contain quotes."
msgstr ""
"Вибирає всі елементи, для яких даний атрибут має задане значення. Значення "
"не може містити лапки."

msgid "``[@attrib!='value']``"
msgstr "``[@attrib!='value']``"

msgid ""
"Selects all elements for which the given attribute does not have the given "
"value. The value cannot contain quotes."
msgstr ""
"Вибирає всі елементи, для яких даний атрибут не має заданого значення. "
"Значення не може містити лапки."

msgid "``[tag]``"
msgstr "``[тег]``"

msgid ""
"Selects all elements that have a child named ``tag``.  Only immediate "
"children are supported."
msgstr ""
"Вибирає всі елементи, які мають дочірні елементи з іменем ``tag``. "
"Утримуються лише найближчі діти."

msgid "``[.='text']``"
msgstr "``[.='текст']``"

msgid ""
"Selects all elements whose complete text content, including descendants, "
"equals the given ``text``."
msgstr ""
"Вибирає всі елементи, повний текстовий вміст яких, включаючи нащадків, "
"дорівнює заданому ``тексту``."

msgid "``[.!='text']``"
msgstr "``[.!='текст']``"

msgid ""
"Selects all elements whose complete text content, including descendants, "
"does not equal the given ``text``."
msgstr ""
"Вибирає всі елементи, повний текстовий вміст яких, включно з нащадками, не "
"відповідає заданому ``тексту``."

msgid "``[tag='text']``"
msgstr "``[tag='text']``"

msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, equals the given ``text``."
msgstr ""
"Вибирає всі елементи, які мають дочірні елементи з назвою ``tag``, повний "
"текстовий вміст яких, включаючи нащадків, дорівнює заданому ``text``."

msgid "``[tag!='text']``"
msgstr "``[tag!='text']``"

msgid ""
"Selects all elements that have a child named ``tag`` whose complete text "
"content, including descendants, does not equal the given ``text``."
msgstr ""
"Вибирає всі елементи, які мають дочірні елементи з іменем ``tag``, повний "
"текстовий вміст яких, включаючи нащадків, не збігається з заданим ``text``."

msgid "``[position]``"
msgstr "``[позиція]``"

msgid ""
"Selects all elements that are located at the given position.  The position "
"can be either an integer (1 is the first position), the expression "
"``last()`` (for the last position), or a position relative to the last "
"position (e.g. ``last()-1``)."
msgstr ""
"Вибирає всі елементи, які розташовані на заданій позиції. Позиція може бути "
"цілим числом (1 — перша позиція), виразом ``last()`` (для останньої позиції) "
"або позицією відносно останньої позиції (наприклад, ``last()-1`` )."

msgid ""
"Predicates (expressions within square brackets) must be preceded by a tag "
"name, an asterisk, or another predicate.  ``position`` predicates must be "
"preceded by a tag name."
msgstr ""
"Предикати (вирази в квадратних дужках) мають передувати назві тегу, зірочці "
"або іншому предикату. Предикатам ``position`` має передувати ім’я тегу."

msgid "Reference"
msgstr "довідка"

msgid "Functions"
msgstr "Функції"

msgid "`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ transformation function."
msgstr "`C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ функція перетворення."

msgid ""
"Canonicalization is a way to normalise XML output in a way that allows byte-"
"by-byte comparisons and digital signatures.  It reduced the freedom that XML "
"serializers have and instead generates a more constrained XML "
"representation.  The main restrictions regard the placement of namespace "
"declarations, the ordering of attributes, and ignorable whitespace."
msgstr ""
"Канонізація — це спосіб нормалізації XML-виводу таким чином, щоб уможливити "
"побайтове порівняння та цифрові підписи. Це зменшило свободу, яку мають "
"серіалізатори XML, і натомість генерувало більш обмежене представлення XML. "
"Основні обмеження стосуються розміщення оголошень простору імен, "
"упорядкування атрибутів і пропусків, які можна ігнорувати."

msgid ""
"This function takes an XML data string (*xml_data*) or a file path or file-"
"like object (*from_file*) as input, converts it to the canonical form, and "
"writes it out using the *out* file(-like) object, if provided, or returns it "
"as a text string if not.  The output file receives text, not bytes.  It "
"should therefore be opened in text mode with ``utf-8`` encoding."
msgstr ""
"Ця функція приймає рядок XML-даних (*xml_data*) або шлях до файлу або "
"файлоподібний об’єкт (*from_file*) як вхідні дані, перетворює їх у канонічну "
"форму та записує за допомогою *out* file(-like) об’єкт, якщо він наданий, "
"або повертає його як текстовий рядок, якщо ні. Вихідний файл отримує текст, "
"а не байти. Тому його слід відкривати в текстовому режимі з кодуванням "
"``utf-8``."

msgid "Typical uses::"
msgstr "Типове використання::"

msgid "The configuration *options* are as follows:"
msgstr "*Параметри* конфігурації такі:"

msgid "*with_comments*: set to true to include comments (default: false)"
msgstr ""
"*with_comments*: установіть значення true, щоб включити коментарі (за "
"замовчуванням: false)"

msgid ""
"*strip_text*: set to true to strip whitespace before and after text content"
msgstr ""
"*strip_text*: установіть значення true, щоб видалити пробіли перед і після "
"текстового вмісту"

msgid "(default: false)"
msgstr "(за замовчуванням: false)"

msgid ""
"*rewrite_prefixes*: set to true to replace namespace prefixes by "
"\"n{number}\""
msgstr ""
"*rewrite_prefixes*: встановлено значення true, щоб замінити префікси "
"простору імен на \"n{number}\""

msgid "*qname_aware_tags*: a set of qname aware tag names in which prefixes"
msgstr "*qname_aware_tags*: набір імен тегів qname, у яких префікси"

msgid "should be replaced in text content (default: empty)"
msgstr "слід замінити в текстовому вмісті (за замовчуванням: пусто)"

msgid ""
"*qname_aware_attrs*: a set of qname aware attribute names in which prefixes"
msgstr ""
"*qname_aware_attrs*: набір імен атрибутів, що підтримують qname, у яких "
"префікси"

msgid "*exclude_attrs*: a set of attribute names that should not be serialised"
msgstr ""
"*exclude_attrs*: набір імен атрибутів, які не повинні бути серіалізовані"

msgid "*exclude_tags*: a set of tag names that should not be serialised"
msgstr "*exclude_tags*: набір імен тегів, які не повинні бути серіалізовані"

msgid ""
"In the option list above, \"a set\" refers to any collection or iterable of "
"strings, no ordering is expected."
msgstr ""
"У наведеному вище списку параметрів \"набір\" відноситься до будь-якої "
"колекції або ітерації рядків, упорядкування не очікується."

msgid ""
"Comment element factory.  This factory function creates a special element "
"that will be serialized as an XML comment by the standard serializer.  The "
"comment string can be either a bytestring or a Unicode string.  *text* is a "
"string containing the comment string.  Returns an element instance "
"representing a comment."
msgstr ""
"Фабрика елементів коментарів. Ця фабрична функція створює спеціальний "
"елемент, який буде серіалізовано як коментар XML стандартним серіалізатором. "
"Рядок коментаря може бути байтовим рядком або рядком Unicode. *text* – це "
"рядок, що містить рядок коментаря. Повертає екземпляр елемента, що "
"представляє коментар."

msgid ""
"Note that :class:`XMLParser` skips over comments in the input instead of "
"creating comment objects for them. An :class:`ElementTree` will only contain "
"comment nodes if they have been inserted into to the tree using one of the :"
"class:`Element` methods."
msgstr ""
"Зауважте, що :class:`XMLParser` пропускає коментарі у вхідних даних замість "
"того, щоб створювати для них об’єкти коментарів. :class:`ElementTree` "
"міститиме лише вузли коментарів, якщо вони були вставлені в дерево за "
"допомогою одного з методів :class:`Element`."

msgid ""
"Writes an element tree or element structure to sys.stdout.  This function "
"should be used for debugging only."
msgstr ""
"Записує дерево елементів або структуру елементів у sys.stdout. Цю функцію "
"слід використовувати лише для налагодження."

msgid ""
"The exact output format is implementation dependent.  In this version, it's "
"written as an ordinary XML file."
msgstr ""
"Точний вихідний формат залежить від реалізації. У цій версії він написаний "
"як звичайний файл XML."

msgid "*elem* is an element tree or an individual element."
msgstr "*elem* — дерево елементів або окремий елемент."

msgid ""
"The :func:`dump` function now preserves the attribute order specified by the "
"user."
msgstr ""
"Функція :func:`dump` тепер зберігає порядок атрибутів, указаний користувачем."

msgid ""
"Parses an XML section from a string constant.  Same as :func:`XML`.  *text* "
"is a string containing XML data.  *parser* is an optional parser instance. "
"If not given, the standard :class:`XMLParser` parser is used. Returns an :"
"class:`Element` instance."
msgstr ""
"Розбирає розділ XML із константи рядка. Те саме, що :func:`XML`. *текст* — "
"це рядок, що містить дані XML. *parser* є необов’язковим екземпляром "
"парсера. Якщо не вказано, використовується стандартний аналізатор :class:"
"`XMLParser`. Повертає екземпляр :class:`Element`."

msgid ""
"Parses an XML document from a sequence of string fragments.  *sequence* is a "
"list or other sequence containing XML data fragments.  *parser* is an "
"optional parser instance.  If not given, the standard :class:`XMLParser` "
"parser is used.  Returns an :class:`Element` instance."
msgstr ""
"Розбирає XML-документ із послідовності фрагментів рядків. *послідовність* — "
"це список або інша послідовність, що містить фрагменти даних XML. *parser* є "
"необов’язковим екземпляром парсера. Якщо не вказано, використовується "
"стандартний аналізатор :class:`XMLParser`. Повертає екземпляр :class:"
"`Element`."

msgid ""
"Appends whitespace to the subtree to indent the tree visually. This can be "
"used to generate pretty-printed XML output. *tree* can be an Element or "
"ElementTree.  *space* is the whitespace string that will be inserted for "
"each indentation level, two space characters by default.  For indenting "
"partial subtrees inside of an already indented tree, pass the initial "
"indentation level as *level*."
msgstr ""
"До піддерева додає пробіли для візуального відступу дерева. Це можна "
"використати для генерації красивого друкованого виводу XML. *дерево* може "
"бути елементом або деревом елементів. *пробіл* — це пробільний рядок, який "
"буде вставлено для кожного рівня відступу, два символи пробілу за "
"замовчуванням. Для відступу часткових піддерев усередині дерева з відступами "
"передайте початковий рівень відступу як *level*."

msgid ""
"Check if an object appears to be a valid element object.  *element* is an "
"element instance.  Return ``True`` if this is an element object."
msgstr ""
"Перевірте, чи об’єкт є дійсним об’єктом елемента. *element* — екземпляр "
"елемента. Повертає ``True``, якщо це об’єкт елемента."

msgid ""
"Parses an XML section into an element tree incrementally, and reports what's "
"going on to the user.  *source* is a filename or :term:`file object` "
"containing XML data.  *events* is a sequence of events to report back.  The "
"supported events are the strings ``\"start\"``, ``\"end\"``, "
"``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` and ``\"end-ns\"`` (the \"ns\" "
"events are used to get detailed namespace information).  If *events* is "
"omitted, only ``\"end\"`` events are reported. *parser* is an optional "
"parser instance.  If not given, the standard :class:`XMLParser` parser is "
"used.  *parser* must be a subclass of :class:`XMLParser` and can only use "
"the default :class:`TreeBuilder` as a target.  Returns an :term:`iterator` "
"providing ``(event, elem)`` pairs."
msgstr ""
"Поступово розбирає розділ XML у дерево елементів і повідомляє про те, що "
"відбувається користувачеві. *джерело* — це ім’я файлу або :term:`file "
"object`, що містить дані XML. *події* — це послідовність подій, про які "
"потрібно повідомити. Підтримуваними подіями є рядки ``\"start\"``, "
"``\"end\"``, ``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` і ``\"end-ns\"`` "
"(події \"ns\" використовуються для отримання детальної інформації про "
"простір імен). Якщо *events* опущено, повідомляються лише події ``\"end\"``. "
"*parser* є необов’язковим екземпляром парсера. Якщо не вказано, "
"використовується стандартний аналізатор :class:`XMLParser`. *parser* має "
"бути підкласом :class:`XMLParser` і може використовувати лише типовий :class:"
"`TreeBuilder` як ціль. Повертає :term:`iterator`, що забезпечує пари "
"``(event, elem)``."

msgid ""
"Note that while :func:`iterparse` builds the tree incrementally, it issues "
"blocking reads on *source* (or the file it names).  As such, it's unsuitable "
"for applications where blocking reads can't be made.  For fully non-blocking "
"parsing, see :class:`XMLPullParser`."
msgstr ""
"Зауважте, що хоча :func:`iterparse` будує дерево поступово, він блокує "
"читання *source* (або файлу, який він називає). Таким чином, він не "
"підходить для додатків, де блокування зчитування неможливе. Повністю "
"неблокуючий аналіз див. :class:`XMLPullParser`."

msgid ""
":func:`iterparse` only guarantees that it has seen the \">\" character of a "
"starting tag when it emits a \"start\" event, so the attributes are defined, "
"but the contents of the text and tail attributes are undefined at that "
"point.  The same applies to the element children; they may or may not be "
"present."
msgstr ""
":func:`iterparse` лише гарантує, що він побачив символ \">\" початкового "
"тегу, коли він випромінює подію \"start\", тому атрибути визначені, але "
"вміст атрибутів text і tail на цьому етапі не визначено . Те саме стосується "
"елемента діти; вони можуть бути або не бути присутніми."

msgid "If you need a fully populated element, look for \"end\" events instead."
msgstr ""
"Якщо вам потрібен повністю заповнений елемент, шукайте події \"кінець\"."

msgid "The *parser* argument."
msgstr "Аргумент *parser*."

msgid "The ``comment`` and ``pi`` events were added."
msgstr "Додано події ``comment`` і ``pi``."

msgid ""
"Parses an XML section into an element tree.  *source* is a filename or file "
"object containing XML data.  *parser* is an optional parser instance.  If "
"not given, the standard :class:`XMLParser` parser is used.  Returns an :"
"class:`ElementTree` instance."
msgstr ""
"Розбирає розділ XML у дерево елементів. *джерело* — це ім’я файлу або об’єкт "
"файлу, що містить дані XML. *parser* є необов’язковим екземпляром парсера. "
"Якщо не вказано, використовується стандартний аналізатор :class:`XMLParser`. "
"Повертає екземпляр :class:`ElementTree`."

msgid ""
"PI element factory.  This factory function creates a special element that "
"will be serialized as an XML processing instruction.  *target* is a string "
"containing the PI target.  *text* is a string containing the PI contents, if "
"given.  Returns an element instance, representing a processing instruction."
msgstr ""
"Завод ПІ-елементів. Ця фабрична функція створює спеціальний елемент, який "
"буде серіалізовано як інструкцію обробки XML. *target* — це рядок, що "
"містить ціль PI. *текст* — це рядок, що містить вміст PI, якщо його вказано. "
"Повертає екземпляр елемента, що представляє інструкцію обробки."

msgid ""
"Note that :class:`XMLParser` skips over processing instructions in the input "
"instead of creating comment objects for them. An :class:`ElementTree` will "
"only contain processing instruction nodes if they have been inserted into to "
"the tree using one of the :class:`Element` methods."
msgstr ""
"Зауважте, що :class:`XMLParser` пропускає інструкції обробки у вхідних даних "
"замість того, щоб створювати для них об’єкти коментарів. :class:"
"`ElementTree` міститиме лише вузли інструкцій обробки, якщо їх було "
"вставлено в дерево за допомогою одного з методів :class:`Element`."

msgid ""
"Registers a namespace prefix.  The registry is global, and any existing "
"mapping for either the given prefix or the namespace URI will be removed. "
"*prefix* is a namespace prefix.  *uri* is a namespace uri.  Tags and "
"attributes in this namespace will be serialized with the given prefix, if at "
"all possible."
msgstr ""
"Реєструє префікс простору імен. Реєстр є глобальним, і будь-яке існуюче "
"відображення для заданого префікса або URI простору імен буде видалено. "
"*префікс* — це префікс простору імен. *uri* — це uri простору імен. Теги й "
"атрибути в цьому просторі імен будуть серіалізовані з заданим префіксом, "
"якщо це взагалі можливо."

msgid ""
"Subelement factory.  This function creates an element instance, and appends "
"it to an existing element."
msgstr ""
"Піделементний завод. Ця функція створює екземпляр елемента та додає його до "
"існуючого елемента."

msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *parent* is the parent element.  *tag* is "
"the subelement name.  *attrib* is an optional dictionary, containing element "
"attributes.  *extra* contains additional attributes, given as keyword "
"arguments.  Returns an element instance."
msgstr ""
"Ім’я елемента, назви атрибутів і значення атрибутів можуть бути байтовими "
"рядками або рядками Unicode. *parent* є батьківським елементом. *тег* — це "
"назва піделемента. *attrib* — необов’язковий словник, що містить атрибути "
"елемента. *extra* містить додаткові атрибути, надані як аргументи ключових "
"слів. Повертає екземпляр елемента."

msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is "
"the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to "
"generate a Unicode string (otherwise, a bytestring is generated).  *method* "
"is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). *xml_declaration*, *default_namespace* and "
"*short_empty_elements* has the same meaning as in :meth:`ElementTree.write`. "
"Returns an (optionally) encoded string containing the XML data."
msgstr ""
"Створює рядкове представлення елемента XML, включаючи всі піделементи. "
"*element* є екземпляром :class:`Element`. *кодування* [1]_ — вихідне "
"кодування (за замовчуванням — US-ASCII). Використовуйте "
"``encoding=\"unicode\"``, щоб створити рядок Юнікод (інакше буде згенеровано "
"байтовий рядок). *method* — це ``\"xml\"``, ``\"html\"`` або ``\"text\"`` "
"(за замовчуванням ``\"xml\"``). *xml_declaration*, *default_namespace* і "
"*short_empty_elements* мають те саме значення, що й у :meth:`ElementTree."
"write`. Повертає (необов’язково) закодований рядок, що містить дані XML."

msgid "The *short_empty_elements* parameter."
msgstr "Параметр *short_empty_elements*."

msgid "The *xml_declaration* and *default_namespace* parameters."
msgstr "Параметри *xml_declaration* і *default_namespace*."

msgid ""
"The :func:`tostring` function now preserves the attribute order specified by "
"the user."
msgstr ""
"Функція :func:`tostring` тепер зберігає порядок атрибутів, указаний "
"користувачем."

msgid ""
"Generates a string representation of an XML element, including all "
"subelements.  *element* is an :class:`Element` instance.  *encoding* [1]_ is "
"the output encoding (default is US-ASCII).  Use ``encoding=\"unicode\"`` to "
"generate a Unicode string (otherwise, a bytestring is generated).  *method* "
"is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` (default is "
"``\"xml\"``). *xml_declaration*, *default_namespace* and "
"*short_empty_elements* has the same meaning as in :meth:`ElementTree.write`. "
"Returns a list of (optionally) encoded strings containing the XML data. It "
"does not guarantee any specific sequence, except that ``b\"\"."
"join(tostringlist(element)) == tostring(element)``."
msgstr ""
"Створює рядкове представлення елемента XML, включаючи всі піделементи. "
"*element* є екземпляром :class:`Element`. *кодування* [1]_ — вихідне "
"кодування (за замовчуванням — US-ASCII). Використовуйте "
"``encoding=\"unicode\"``, щоб створити рядок Юнікод (інакше буде згенеровано "
"байтовий рядок). *method* — це ``\"xml\"``, ``\"html\"`` або ``\"text\"`` "
"(за замовчуванням ``\"xml\"``). *xml_declaration*, *default_namespace* і "
"*short_empty_elements* мають те саме значення, що й у :meth:`ElementTree."
"write`. Повертає список (необов’язково) закодованих рядків, що містять дані "
"XML. Це не гарантує жодної конкретної послідовності, за винятком того, що "
"``b\"\".join(tostringlist(element)) == tostring(element)``."

msgid ""
"The :func:`tostringlist` function now preserves the attribute order "
"specified by the user."
msgstr ""
"Функція :func:`tostringlist` тепер зберігає порядок атрибутів, указаний "
"користувачем."

msgid ""
"Parses an XML section from a string constant.  This function can be used to "
"embed \"XML literals\" in Python code.  *text* is a string containing XML "
"data.  *parser* is an optional parser instance.  If not given, the standard :"
"class:`XMLParser` parser is used.  Returns an :class:`Element` instance."
msgstr ""
"Розбирає розділ XML із константи рядка. Цю функцію можна використовувати для "
"вбудовування \"XML-літералів\" у код Python. *текст* — це рядок, що містить "
"дані XML. *parser* є необов’язковим екземпляром парсера. Якщо не вказано, "
"використовується стандартний аналізатор :class:`XMLParser`. Повертає "
"екземпляр :class:`Element`."

msgid ""
"Parses an XML section from a string constant, and also returns a dictionary "
"which maps from element id:s to elements.  *text* is a string containing XML "
"data.  *parser* is an optional parser instance.  If not given, the standard :"
"class:`XMLParser` parser is used.  Returns a tuple containing an :class:"
"`Element` instance and a dictionary."
msgstr ""
"Розбирає розділ XML із константи рядка, а також повертає словник, який "
"відображає ідентифікатори елемента: елементи. *текст* — це рядок, що містить "
"дані XML. *parser* є необов’язковим екземпляром парсера. Якщо не вказано, "
"використовується стандартний аналізатор :class:`XMLParser`. Повертає кортеж, "
"що містить екземпляр :class:`Element` і словник."

msgid "XInclude support"
msgstr "XInclude підтримка"

msgid ""
"This module provides limited support for `XInclude directives <https://www."
"w3.org/TR/xinclude/>`_, via the :mod:`xml.etree.ElementInclude` helper "
"module.  This module can be used to insert subtrees and text strings into "
"element trees, based on information in the tree."
msgstr ""
"Цей модуль надає обмежену підтримку для `XInclude директив <https://www.w3."
"org/TR/xinclude/>`_ через допоміжний модуль :mod:`xml.etree.ElementInclude`. "
"Цей модуль можна використовувати для вставки піддерев і текстових рядків у "
"дерева елементів на основі інформації в дереві."

msgid ""
"Here's an example that demonstrates use of the XInclude module. To include "
"an XML document in the current document, use the ``{http://www.w3.org/2001/"
"XInclude}include`` element and set the **parse** attribute to ``\"xml\"``, "
"and use the **href** attribute to specify the document to include."
msgstr ""
"Ось приклад, який демонструє використання модуля XInclude. Щоб включити XML-"
"документ у поточний документ, використовуйте елемент ``{http://www.w3."
"org/2001/XInclude}include`` і встановіть атрибут **parse** на ``\"xml\"`` і "
"використовуйте атрибут **href**, щоб указати документ, який потрібно "
"включити."

msgid ""
"By default, the **href** attribute is treated as a file name. You can use "
"custom loaders to override this behaviour. Also note that the standard "
"helper does not support XPointer syntax."
msgstr ""
"За замовчуванням атрибут **href** розглядається як ім’я файлу. Ви можете "
"використовувати спеціальні завантажувачі, щоб змінити цю поведінку. Також "
"зауважте, що стандартний помічник не підтримує синтаксис XPointer."

msgid ""
"To process this file, load it as usual, and pass the root element to the :"
"mod:`xml.etree.ElementTree` module:"
msgstr ""
"Щоб обробити цей файл, завантажте його як зазвичай і передайте кореневий "
"елемент модулю :mod:`xml.etree.ElementTree`:"

msgid ""
"The ElementInclude module replaces the ``{http://www.w3.org/2001/XInclude}"
"include`` element with the root element from the **source.xml** document. "
"The result might look something like this:"
msgstr ""
"Модуль ElementInclude замінює елемент ``{http://www.w3.org/2001/XInclude}"
"include`` на кореневий елемент із документа **source.xml**. Результат може "
"виглядати приблизно так:"

msgid ""
"If the **parse** attribute is omitted, it defaults to \"xml\". The href "
"attribute is required."
msgstr ""
"Якщо атрибут **parse** пропущено, за замовчуванням він має значення \"xml\". "
"Потрібен атрибут href."

msgid ""
"To include a text document, use the ``{http://www.w3.org/2001/XInclude}"
"include`` element, and set the **parse** attribute to \"text\":"
msgstr ""
"Щоб включити текстовий документ, використовуйте елемент ``{http://www.w3."
"org/2001/XInclude}include`` і встановіть атрибут **parse** на \"text\":"

msgid "The result might look something like:"
msgstr "Результат може виглядати приблизно так:"

msgid ""
"Default loader. This default loader reads an included resource from disk.  "
"*href* is a URL. *parse* is for parse mode either \"xml\" or \"text\".  "
"*encoding* is an optional text encoding.  If not given, encoding is "
"``utf-8``.  Returns the expanded resource.  If the parse mode is "
"``\"xml\"``, this is an ElementTree instance.  If the parse mode is "
"\"text\", this is a Unicode string.  If the loader fails, it can return None "
"or raise an exception."
msgstr ""
"Завантажувач за замовчуванням. Цей завантажувач за замовчуванням читає "
"включений ресурс із диска. *href* – це URL-адреса. *parse* для режиму "
"аналізу \"xml\" або \"text\". *кодування* — необов’язкове кодування тексту. "
"Якщо не вказано, кодування ``utf-8``. Повертає розгорнутий ресурс. Якщо "
"режим аналізу ``\"xml\"``, це екземпляр ElementTree. Якщо режим аналізу "
"\"текстовий\", це рядок Юнікоду. Якщо завантажувач виходить з ладу, він може "
"повернути None або викликати виняток."

msgid ""
"This function expands XInclude directives.  *elem* is the root element.  "
"*loader* is an optional resource loader.  If omitted, it defaults to :func:"
"`default_loader`. If given, it should be a callable that implements the same "
"interface as :func:`default_loader`.  *base_url* is base URL of the original "
"file, to resolve relative include file references.  *max_depth* is the "
"maximum number of recursive inclusions.  Limited to reduce the risk of "
"malicious content explosion. Pass a negative value to disable the limitation."
msgstr ""
"Ця функція розширює директиви XInclude. *elem* є кореневим елементом. "
"*loader* є додатковим завантажувачем ресурсів. Якщо опущено, за "
"замовчуванням :func:`default_loader`. Якщо задано, це має бути виклик, який "
"реалізує той самий інтерфейс, що й :func:`default_loader`. *base_url* — це "
"базова URL-адреса оригінального файлу, щоб вирішити відносні посилання на "
"файли включення. *max_depth* — максимальна кількість рекурсивних включень. "
"Обмежено, щоб зменшити ризик вибуху шкідливого вмісту. Передайте від’ємне "
"значення, щоб вимкнути обмеження."

msgid ""
"Returns the expanded resource.  If the parse mode is ``\"xml\"``, this is an "
"ElementTree instance.  If the parse mode is \"text\", this is a Unicode "
"string.  If the loader fails, it can return None or raise an exception."
msgstr ""
"Повертає розгорнутий ресурс. Якщо режим аналізу ``\"xml\"``, це екземпляр "
"ElementTree. Якщо режим аналізу \"текстовий\", це рядок Юнікоду. Якщо "
"завантажувач виходить з ладу, він може повернути None або викликати виняток."

msgid "The *base_url* and *max_depth* parameters."
msgstr "Параметри *base_url* і *max_depth*."

msgid "Element Objects"
msgstr "Об'єкти елементів"

msgid ""
"Element class.  This class defines the Element interface, and provides a "
"reference implementation of this interface."
msgstr ""
"Клас елемента. Цей клас визначає інтерфейс Element і забезпечує еталонну "
"реалізацію цього інтерфейсу."

msgid ""
"The element name, attribute names, and attribute values can be either "
"bytestrings or Unicode strings.  *tag* is the element name.  *attrib* is an "
"optional dictionary, containing element attributes.  *extra* contains "
"additional attributes, given as keyword arguments."
msgstr ""
"Ім’я елемента, назви атрибутів і значення атрибутів можуть бути байтовими "
"рядками або рядками Unicode. *тег* — це назва елемента. *attrib* — "
"необов’язковий словник, що містить атрибути елемента. *extra* містить "
"додаткові атрибути, надані як аргументи ключового слова."

msgid ""
"A string identifying what kind of data this element represents (the element "
"type, in other words)."
msgstr ""
"Рядок, що визначає, який тип даних представляє цей елемент (іншими словами, "
"тип елемента)."

msgid ""
"These attributes can be used to hold additional data associated with the "
"element.  Their values are usually strings but may be any application-"
"specific object.  If the element is created from an XML file, the *text* "
"attribute holds either the text between the element's start tag and its "
"first child or end tag, or ``None``, and the *tail* attribute holds either "
"the text between the element's end tag and the next tag, or ``None``.  For "
"the XML data"
msgstr ""
"Ці атрибути можна використовувати для зберігання додаткових даних, "
"пов’язаних з елементом. Їх значення зазвичай є рядками, але можуть бути будь-"
"якими об’єктами, що стосуються конкретної програми. Якщо елемент створено з "
"файлу XML, атрибут *text* містить або текст між початковим тегом елемента та "
"його першим дочірнім або кінцевим тегом, або ``None``, а атрибут *tail* "
"містить або текст між кінцевий тег елемента та наступний тег або ``None``. "
"Для даних XML"

msgid ""
"the *a* element has ``None`` for both *text* and *tail* attributes, the *b* "
"element has *text* ``\"1\"`` and *tail* ``\"4\"``, the *c* element has "
"*text* ``\"2\"`` and *tail* ``None``, and the *d* element has *text* "
"``None`` and *tail* ``\"3\"``."
msgstr ""
"елемент *a* має ``None`` як для атрибутів *text*, так і для *tail*, елемент "
"*b* має *text* ``\"1\"`` і *tail* ``\"4\"``, елемент *c* має *text* "
"``\"2\"`` і *tail* ``None``, а елемент *d* має *text* ``None`` і *tail* "
"``\"3\"``."

msgid ""
"To collect the inner text of an element, see :meth:`itertext`, for example "
"``\"\".join(element.itertext())``."
msgstr ""
"Щоб зібрати внутрішній текст елемента, перегляньте :meth:`itertext`, "
"наприклад ``\"\".join(element.itertext())``."

msgid "Applications may store arbitrary objects in these attributes."
msgstr "Програми можуть зберігати довільні об’єкти в цих атрибутах."

msgid ""
"A dictionary containing the element's attributes.  Note that while the "
"*attrib* value is always a real mutable Python dictionary, an ElementTree "
"implementation may choose to use another internal representation, and create "
"the dictionary only if someone asks for it.  To take advantage of such "
"implementations, use the dictionary methods below whenever possible."
msgstr ""
"Словник, що містить атрибути елемента. Зауважте, що хоча значення *attrib* "
"завжди є справжнім змінним словником Python, реалізація ElementTree може "
"використовувати інше внутрішнє представлення та створювати словник, лише "
"якщо хтось про це попросить. Щоб скористатися перевагами таких реалізацій, "
"використовуйте наведені нижче методи словника, коли це можливо."

msgid "The following dictionary-like methods work on the element attributes."
msgstr "Наступні методи, подібні до словника, працюють з атрибутами елемента."

msgid ""
"Resets an element.  This function removes all subelements, clears all "
"attributes, and sets the text and tail attributes to ``None``."
msgstr ""
"Скидає елемент. Ця функція видаляє всі піделементи, очищає всі атрибути та "
"встановлює для атрибутів text і tail значення ``None``."

msgid "Gets the element attribute named *key*."
msgstr "Отримує атрибут елемента з назвою *key*."

msgid ""
"Returns the attribute value, or *default* if the attribute was not found."
msgstr "Повертає значення атрибута або *default*, якщо атрибут не знайдено."

msgid ""
"Returns the element attributes as a sequence of (name, value) pairs.  The "
"attributes are returned in an arbitrary order."
msgstr ""
"Повертає атрибути елемента як послідовність пар (ім’я, значення). Атрибути "
"повертаються в довільному порядку."

msgid ""
"Returns the elements attribute names as a list.  The names are returned in "
"an arbitrary order."
msgstr ""
"Повертає назви атрибутів елементів у вигляді списку. Імена повертаються в "
"довільному порядку."

msgid "Set the attribute *key* on the element to *value*."
msgstr "Установіть для атрибута *key* елемента значення *value*."

msgid "The following methods work on the element's children (subelements)."
msgstr "Наступні методи працюють над дочірніми елементами (піделементами)."

msgid ""
"Adds the element *subelement* to the end of this element's internal list of "
"subelements.  Raises :exc:`TypeError` if *subelement* is not an :class:"
"`Element`."
msgstr ""
"Додає елемент *subelement* у кінець внутрішнього списку піделементів цього "
"елемента. Викликає :exc:`TypeError`, якщо *subelement* не є :class:`Element`."

msgid ""
"Appends *subelements* from a sequence object with zero or more elements. "
"Raises :exc:`TypeError` if a subelement is not an :class:`Element`."
msgstr ""
"Додає *піделементи* з об’єкта послідовності з нулем або більше елементами. "
"Викликає :exc:`TypeError`, якщо піделемент не є :class:`Element`."

msgid ""
"Finds the first subelement matching *match*.  *match* may be a tag name or "
"a :ref:`path <elementtree-xpath>`.  Returns an element instance or "
"``None``.  *namespaces* is an optional mapping from namespace prefix to full "
"name.  Pass ``''`` as prefix to move all unprefixed tag names in the "
"expression into the given namespace."
msgstr ""
"Знаходить перший піделемент, що відповідає *match*. *match* може бути назвою "
"тегу або :ref:`шляхом <elementtree-xpath>`. Повертає екземпляр елемента або "
"``None``. *простори імен* — це необов’язкове відображення префікса простору "
"імен на повне ім’я. Передайте ``''`` як префікс, щоб перемістити всі імена "
"тегів без префіксів у виразі до вказаного простору імен."

msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns a list containing all matching elements in document "
"order.  *namespaces* is an optional mapping from namespace prefix to full "
"name.  Pass ``''`` as prefix to move all unprefixed tag names in the "
"expression into the given namespace."
msgstr ""
"Знаходить усі відповідні піделементи за назвою тегу або :ref:`шляхом "
"<elementtree-xpath>`. Повертає список, що містить усі відповідні елементи в "
"порядку документа. *простори імен* — це необов’язкове відображення префікса "
"простору імен на повне ім’я. Передайте ``''`` як префікс, щоб перемістити "
"всі імена тегів без префіксів у виразі до вказаного простору імен."

msgid ""
"Finds text for the first subelement matching *match*.  *match* may be a tag "
"name or a :ref:`path <elementtree-xpath>`.  Returns the text content of the "
"first matching element, or *default* if no element was found. Note that if "
"the matching element has no text content an empty string is returned. "
"*namespaces* is an optional mapping from namespace prefix to full name.  "
"Pass ``''`` as prefix to move all unprefixed tag names in the expression "
"into the given namespace."
msgstr ""
"Знаходить текст для першого піделемента, який відповідає *match*. *match* "
"може бути назвою тегу або :ref:`шляхом <elementtree-xpath>`. Повертає "
"текстовий вміст першого відповідного елемента або *за замовчуванням*, якщо "
"елемент не знайдено. Зауважте, що якщо відповідний елемент не має текстового "
"вмісту, повертається порожній рядок. *простори імен* — це необов’язкове "
"відображення префікса простору імен на повне ім’я. Передайте ``''`` як "
"префікс, щоб перемістити всі імена тегів без префіксів у виразі до вказаного "
"простору імен."

msgid ""
"Inserts *subelement* at the given position in this element.  Raises :exc:"
"`TypeError` if *subelement* is not an :class:`Element`."
msgstr ""
"Вставляє *піделемент* у задану позицію цього елемента. Викликає :exc:"
"`TypeError`, якщо *subelement* не є :class:`Element`."

msgid ""
"Creates a tree :term:`iterator` with the current element as the root. The "
"iterator iterates over this element and all elements below it, in document "
"(depth first) order.  If *tag* is not ``None`` or ``'*'``, only elements "
"whose tag equals *tag* are returned from the iterator.  If the tree "
"structure is modified during iteration, the result is undefined."
msgstr ""
"Створює дерево :term:`iterator` з поточним елементом як коренем. Ітератор "
"повторює цей елемент і всі елементи під ним у порядку документа (спочатку "
"глибина). Якщо *tag* не є ``None`` або ``'*'``, ітератор повертає лише "
"елементи, тег яких дорівнює *tag*. Якщо структуру дерева змінено під час "
"ітерації, результат буде невизначеним."

msgid ""
"Finds all matching subelements, by tag name or :ref:`path <elementtree-"
"xpath>`.  Returns an iterable yielding all matching elements in document "
"order. *namespaces* is an optional mapping from namespace prefix to full "
"name."
msgstr ""
"Знаходить усі відповідні піделементи за назвою тегу або :ref:`шляхом "
"<elementtree-xpath>`. Повертає iterable, що дає всі відповідні елементи в "
"порядку документа. *простори імен* — це необов’язкове відображення префікса "
"простору імен на повне ім’я."

msgid ""
"Creates a text iterator.  The iterator loops over this element and all "
"subelements, in document order, and returns all inner text."
msgstr ""
"Створює текстовий ітератор. Ітератор проходить по цьому елементу та всім "
"піделементам у порядку документа та повертає весь внутрішній текст."

msgid ""
"Creates a new element object of the same type as this element.  Do not call "
"this method, use the :func:`SubElement` factory function instead."
msgstr ""
"Створює новий об’єкт елемента того самого типу, що й цей елемент. Не "
"викликайте цей метод, замість цього використовуйте фабричну функцію :func:"
"`SubElement`."

msgid ""
"Removes *subelement* from the element.  Unlike the find\\* methods this "
"method compares elements based on the instance identity, not on tag value or "
"contents."
msgstr ""
"Видаляє *піделемент* з елемента. На відміну від методів find\\*, цей метод "
"порівнює елементи на основі ідентичності екземпляра, а не на основі значення "
"тегу чи вмісту."

msgid ""
":class:`Element` objects also support the following sequence type methods "
"for working with subelements: :meth:`~object.__delitem__`, :meth:`~object."
"__getitem__`, :meth:`~object.__setitem__`, :meth:`~object.__len__`."
msgstr ""
"Об’єкти :class:`Element` також підтримують такі методи типу послідовності "
"для роботи з піделементами: :meth:`~object.__delitem__`, :meth:`~object."
"__getitem__`, :meth:`~object.__setitem__`,  :meth:`~об’єкт.__len__`."

msgid ""
"Caution: Elements with no subelements will test as ``False``.  This behavior "
"will change in future versions.  Use specific ``len(elem)`` or ``elem is "
"None`` test instead. ::"
msgstr ""
"Застереження: елементи без піделементів перевірятимуться як ``False``. Ця "
"поведінка зміниться в наступних версіях. Натомість використовуйте "
"спеціальний тест ``len(elem)`` або ``elem is None``. ::"

msgid ""
"Prior to Python 3.8, the serialisation order of the XML attributes of "
"elements was artificially made predictable by sorting the attributes by "
"their name. Based on the now guaranteed ordering of dicts, this arbitrary "
"reordering was removed in Python 3.8 to preserve the order in which "
"attributes were originally parsed or created by user code."
msgstr ""
"До Python 3.8 порядок серіалізації XML-атрибутів елементів штучно робили "
"передбачуваним шляхом сортування атрибутів за їх назвою. Базуючись на тепер "
"гарантованому порядку диктовок, цей довільний порядок було вилучено в Python "
"3.8, щоб зберегти порядок, у якому атрибути були спочатку проаналізовані або "
"створені кодом користувача."

msgid ""
"In general, user code should try not to depend on a specific ordering of "
"attributes, given that the `XML Information Set <https://www.w3.org/TR/xml-"
"infoset/>`_ explicitly excludes the attribute order from conveying "
"information. Code should be prepared to deal with any ordering on input. In "
"cases where deterministic XML output is required, e.g. for cryptographic "
"signing or test data sets, canonical serialisation is available with the :"
"func:`canonicalize` function."
msgstr ""
"Загалом код користувача має намагатися не залежати від певного порядку "
"атрибутів, враховуючи, що `Набір інформації XML <https://www.w3.org/TR/xml-"
"infoset/>`_ явно виключає порядок атрибутів із передачі інформації. Код має "
"бути готовий до будь-якого впорядкування вхідних даних. У випадках, коли "
"потрібен детермінований вивід XML, напр. для криптографічного підпису або "
"тестових наборів даних доступна канонічна серіалізація за допомогою функції :"
"func:`canonicalize`."

msgid ""
"In cases where canonical output is not applicable but a specific attribute "
"order is still desirable on output, code should aim for creating the "
"attributes directly in the desired order, to avoid perceptual mismatches for "
"readers of the code. In cases where this is difficult to achieve, a recipe "
"like the following can be applied prior to serialisation to enforce an order "
"independently from the Element creation::"
msgstr ""
"У випадках, коли канонічний вивід незастосовний, але певний порядок "
"атрибутів все ще бажаний на виводі, код повинен прагнути створювати атрибути "
"безпосередньо в бажаному порядку, щоб уникнути невідповідності сприйняття "
"для читачів коду. У випадках, коли цього важко досягти, перед серіалізацією "
"можна застосувати такий рецепт, як наведений нижче, щоб забезпечити "
"виконання порядку незалежно від створення Елемента:"

msgid "ElementTree Objects"
msgstr "Об’єкти ElementTree"

msgid ""
"ElementTree wrapper class.  This class represents an entire element "
"hierarchy, and adds some extra support for serialization to and from "
"standard XML."
msgstr ""
"Клас обгортки ElementTree. Цей клас представляє всю ієрархію елементів і "
"додає деяку додаткову підтримку для серіалізації в і з стандартного XML."

msgid ""
"*element* is the root element.  The tree is initialized with the contents of "
"the XML *file* if given."
msgstr ""
"*element* є кореневим елементом. Дерево ініціалізується вмістом *файлу* XML, "
"якщо його надано."

msgid ""
"Replaces the root element for this tree.  This discards the current contents "
"of the tree, and replaces it with the given element.  Use with care.  "
"*element* is an element instance."
msgstr ""
"Замінює кореневий елемент для цього дерева. Це відкидає поточний вміст "
"дерева та замінює його вказаним елементом. Використовуйте з обережністю. "
"*element* — екземпляр елемента."

msgid "Same as :meth:`Element.find`, starting at the root of the tree."
msgstr "Те саме, що :meth:`Element.find`, починаючи з кореня дерева."

msgid "Same as :meth:`Element.findall`, starting at the root of the tree."
msgstr "Те саме, що :meth:`Element.findall`, починаючи з кореня дерева."

msgid "Same as :meth:`Element.findtext`, starting at the root of the tree."
msgstr "Те саме, що :meth:`Element.findtext`, починаючи з кореня дерева."

msgid "Returns the root element for this tree."
msgstr "Повертає кореневий елемент для цього дерева."

msgid ""
"Creates and returns a tree iterator for the root element.  The iterator "
"loops over all elements in this tree, in section order.  *tag* is the tag to "
"look for (default is to return all elements)."
msgstr ""
"Створює та повертає ітератор дерева для кореневого елемента. Ітератор "
"перебирає всі елементи в цьому дереві в порядку секцій. *тег* — це тег, який "
"потрібно шукати (за замовчуванням повертаються всі елементи)."

msgid "Same as :meth:`Element.iterfind`, starting at the root of the tree."
msgstr "Те саме, що :meth:`Element.iterfind`, починаючи з кореня дерева."

msgid ""
"Loads an external XML section into this element tree.  *source* is a file "
"name or :term:`file object`.  *parser* is an optional parser instance. If "
"not given, the standard :class:`XMLParser` parser is used.  Returns the "
"section root element."
msgstr ""
"Завантажує зовнішній розділ XML у це дерево елементів. *джерело* — це ім’я "
"файлу або :term:`file object`. *parser* є необов’язковим екземпляром "
"парсера. Якщо не вказано, використовується стандартний аналізатор :class:"
"`XMLParser`. Повертає кореневий елемент розділу."

msgid ""
"Writes the element tree to a file, as XML.  *file* is a file name, or a :"
"term:`file object` opened for writing.  *encoding* [1]_ is the output "
"encoding (default is US-ASCII). *xml_declaration* controls if an XML "
"declaration should be added to the file.  Use ``False`` for never, ``True`` "
"for always, ``None`` for only if not US-ASCII or UTF-8 or Unicode (default "
"is ``None``). *default_namespace* sets the default XML namespace (for "
"\"xmlns\"). *method* is either ``\"xml\"``, ``\"html\"`` or ``\"text\"`` "
"(default is ``\"xml\"``). The keyword-only *short_empty_elements* parameter "
"controls the formatting of elements that contain no content.  If ``True`` "
"(the default), they are emitted as a single self-closed tag, otherwise they "
"are emitted as a pair of start/end tags."
msgstr ""
"Записує дерево елементів у файл як XML. *file* — це ім’я файлу або :term:"
"`file object`, відкритий для запису. *кодування* [1]_ — вихідне кодування "
"(за замовчуванням — US-ASCII). *xml_declaration* визначає, чи слід додавати "
"XML-декларацію до файлу. Використовуйте ``False`` для ніколи, ``True`` для "
"завжди, ``None`` тільки якщо не US-ASCII або UTF-8 або Unicode (за "
"замовчуванням ``None``). *default_namespace* встановлює простір імен XML за "
"умовчанням (для \"xmlns\"). *method* — це ``\"xml\"``, ``\"html\"`` або "
"``\"text\"`` (за замовчуванням ``\"xml\"``). Параметр "
"*short_empty_elements*, що містить лише ключове слово, керує форматуванням "
"елементів, які не містять вмісту. Якщо ``True`` (за замовчуванням), вони "
"випускаються як один самозакритий тег, інакше вони випускаються як пара "
"початкових/кінцевих тегів."

msgid ""
"The output is either a string (:class:`str`) or binary (:class:`bytes`). "
"This is controlled by the *encoding* argument.  If *encoding* is "
"``\"unicode\"``, the output is a string; otherwise, it's binary.  Note that "
"this may conflict with the type of *file* if it's an open :term:`file "
"object`; make sure you do not try to write a string to a binary stream and "
"vice versa."
msgstr ""
"Результатом буде рядок (:class:`str`) або двійковий (:class:`bytes`). Це "
"контролюється аргументом *encoding*. Якщо *кодування* є ``\"юнікодом\"``, "
"результатом є рядок; інакше це двійковий файл. Зауважте, що це може "
"конфліктувати з типом *file*, якщо це відкритий :term:`file object`; "
"переконайтеся, що ви не намагаєтесь записати рядок у двійковий потік і "
"навпаки."

msgid ""
"The :meth:`write` method now preserves the attribute order specified by the "
"user."
msgstr ""
"Метод :meth:`write` тепер зберігає порядок атрибутів, указаний користувачем."

msgid "This is the XML file that is going to be manipulated::"
msgstr "Це XML-файл, яким буде маніпулювати:"

msgid ""
"Example of changing the attribute \"target\" of every link in first "
"paragraph::"
msgstr "Приклад зміни атрибута \"target\" кожного посилання в першому абзаці::"

msgid "QName Objects"
msgstr "Об'єкти QName"

msgid ""
"QName wrapper.  This can be used to wrap a QName attribute value, in order "
"to get proper namespace handling on output.  *text_or_uri* is a string "
"containing the QName value, in the form {uri}local, or, if the tag argument "
"is given, the URI part of a QName.  If *tag* is given, the first argument is "
"interpreted as a URI, and this argument is interpreted as a local name. :"
"class:`QName` instances are opaque."
msgstr ""
"Обгортка QName. Це можна використовувати для обгортання значення атрибута "
"QName, щоб отримати правильну обробку простору імен на виході. *text_or_uri* "
"— це рядок, що містить значення QName у формі {uri}local або, якщо вказано "
"аргумент тегу, частину URI QName. Якщо вказано *тег*, перший аргумент "
"інтерпретується як URI, а цей аргумент інтерпретується як локальне ім’я. "
"Екземпляри :class:`QName` є непрозорими."

msgid "TreeBuilder Objects"
msgstr "Об’єкти TreeBuilder"

msgid ""
"Generic element structure builder.  This builder converts a sequence of "
"start, data, end, comment and pi method calls to a well-formed element "
"structure.  You can use this class to build an element structure using a "
"custom XML parser, or a parser for some other XML-like format."
msgstr ""
"Загальний конструктор структур елемента. Цей конструктор перетворює "
"послідовність викликів методу початку, даних, кінця, коментаря та pi у добре "
"сформовану структуру елементів. Ви можете використовувати цей клас, щоб "
"побудувати структуру елемента за допомогою спеціального синтаксичного "
"аналізатора XML або іншого XML-подібного формату."

msgid ""
"*element_factory*, when given, must be a callable accepting two positional "
"arguments: a tag and a dict of attributes.  It is expected to return a new "
"element instance."
msgstr ""
"*element_factory*, якщо задано, має бути викликом, що приймає два позиційні "
"аргументи: тег і dict атрибутів. Очікується, що він поверне новий екземпляр "
"елемента."

msgid ""
"The *comment_factory* and *pi_factory* functions, when given, should behave "
"like the :func:`Comment` and :func:`ProcessingInstruction` functions to "
"create comments and processing instructions.  When not given, the default "
"factories will be used.  When *insert_comments* and/or *insert_pis* is true, "
"comments/pis will be inserted into the tree if they appear within the root "
"element (but not outside of it)."
msgstr ""
"Функції *comment_factory* і *pi_factory*, якщо їх надано, повинні поводитися "
"як функції :func:`Comment` і :func:`ProcessingInstruction` для створення "
"коментарів і інструкцій з обробки. Якщо не вказано, будуть використані "
"фабрики за замовчуванням. Якщо *insert_comments* і/або *insert_pis* має "
"значення true, коментарі/pis буде вставлено в дерево, якщо вони з’являться в "
"кореневому елементі (але не поза ним)."

msgid ""
"Flushes the builder buffers, and returns the toplevel document element.  "
"Returns an :class:`Element` instance."
msgstr ""
"Очищає буфери конструктора та повертає елемент документа верхнього рівня. "
"Повертає екземпляр :class:`Element`."

msgid ""
"Adds text to the current element.  *data* is a string.  This should be "
"either a bytestring, or a Unicode string."
msgstr ""
"Додає текст до поточного елемента. *data* — це рядок. Це має бути байтовий "
"рядок або рядок Unicode."

msgid ""
"Closes the current element.  *tag* is the element name.  Returns the closed "
"element."
msgstr ""
"Закриває поточний елемент. *тег* — це назва елемента. Повертає закритий "
"елемент."

msgid ""
"Opens a new element.  *tag* is the element name.  *attrs* is a dictionary "
"containing element attributes.  Returns the opened element."
msgstr ""
"Відкриває новий елемент. *тег* — це назва елемента. *attrs* — це словник, що "
"містить атрибути елементів. Повертає відкритий елемент."

msgid ""
"Creates a comment with the given *text*.  If ``insert_comments`` is true, "
"this will also add it to the tree."
msgstr ""
"Створює коментар із заданим *текстом*. Якщо ``insert_comments`` має значення "
"true, це також додасть його до дерева."

msgid ""
"Creates a comment with the given *target* name and *text*.  If "
"``insert_pis`` is true, this will also add it to the tree."
msgstr ""
"Створює коментар із заданою *цільовою* назвою та *текстом*. Якщо "
"``insert_pis`` має значення true, це також додасть його до дерева."

msgid ""
"In addition, a custom :class:`TreeBuilder` object can provide the following "
"methods:"
msgstr ""
"Крім того, спеціальний об’єкт :class:`TreeBuilder` може надавати такі методи:"

msgid ""
"Handles a doctype declaration.  *name* is the doctype name.  *pubid* is the "
"public identifier.  *system* is the system identifier.  This method does not "
"exist on the default :class:`TreeBuilder` class."
msgstr ""
"Обробляє оголошення doctype. *name* — це ім’я типу документа. *pubid* є "
"публічним ідентифікатором. *system* — це ідентифікатор системи. Цей метод не "
"існує в класі :class:`TreeBuilder` за замовчуванням."

msgid ""
"Is called whenever the parser encounters a new namespace declaration, before "
"the ``start()`` callback for the opening element that defines it. *prefix* "
"is ``''`` for the default namespace and the declared namespace prefix name "
"otherwise.  *uri* is the namespace URI."
msgstr ""
"Викликається кожного разу, коли синтаксичний аналізатор зустрічає нове "
"оголошення простору імен перед зворотним викликом ``start()`` для "
"початкового елемента, який його визначає. *префікс* — це ``''`` для простору "
"імен за замовчуванням, а в інших випадках – оголошене ім’я префікса простору "
"імен. *uri* — URI простору імен."

msgid ""
"Is called after the ``end()`` callback of an element that declared a "
"namespace prefix mapping, with the name of the *prefix* that went out of "
"scope."
msgstr ""
"Викликається після зворотного виклику ``end()`` елемента, який оголосив "
"відображення префікса простору імен, з назвою *префікса*, який вийшов за "
"межі області видимості."

msgid ""
"A `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_ writer.  Arguments are the "
"same as for the :func:`canonicalize` function.  This class does not build a "
"tree but translates the callback events directly into a serialised form "
"using the *write* function."
msgstr ""
"Письменник `C14N 2.0 <https://www.w3.org/TR/xml-c14n2/>`_. Аргументи такі ж, "
"як і для функції :func:`canonicalize`. Цей клас не створює дерево, а "
"перетворює події зворотного виклику безпосередньо в серіалізовану форму за "
"допомогою функції *write*."

msgid "XMLParser Objects"
msgstr "Об’єкти XMLParser"

msgid ""
"This class is the low-level building block of the module.  It uses :mod:`xml."
"parsers.expat` for efficient, event-based parsing of XML.  It can be fed XML "
"data incrementally with the :meth:`feed` method, and parsing events are "
"translated to a push API - by invoking callbacks on the *target* object.  If "
"*target* is omitted, the standard :class:`TreeBuilder` is used. If "
"*encoding* [1]_ is given, the value overrides the encoding specified in the "
"XML file."
msgstr ""
"Цей клас є будівельним блоком низького рівня модуля. Він використовує :mod:"
"`xml.parsers.expat` для ефективного аналізу XML на основі подій. Він може "
"передавати XML-дані поетапно за допомогою методу :meth:`feed`, а події "
"синтаксичного аналізу транслюються в push API шляхом виклику зворотних "
"викликів для об’єкта *target*. Якщо *target* опущено, використовується "
"стандартний :class:`TreeBuilder`. Якщо вказано *кодування* [1]_, значення "
"має перевагу над кодуванням, указаним у файлі XML."

msgid ""
"Parameters are now :ref:`keyword-only <keyword-only_parameter>`. The *html* "
"argument no longer supported."
msgstr ""
"Параметри тепер :ref:`лише ключове слово <keyword-only_parameter>`. Аргумент "
"*html* більше не підтримується."

msgid ""
"Finishes feeding data to the parser.  Returns the result of calling the "
"``close()`` method of the *target* passed during construction; by default, "
"this is the toplevel document element."
msgstr ""
"Завершує подачу даних до аналізатора. Повертає результат виклику методу "
"``close()`` *target*, переданого під час створення; за замовчуванням це "
"елемент документа верхнього рівня."

msgid "Feeds data to the parser.  *data* is encoded data."
msgstr "Подає дані в аналізатор. *data* — це закодовані дані."

msgid ""
":meth:`XMLParser.feed` calls *target*\\'s ``start(tag, attrs_dict)`` method "
"for each opening tag, its ``end(tag)`` method for each closing tag, and data "
"is processed by method ``data(data)``.  For further supported callback "
"methods, see the :class:`TreeBuilder` class.  :meth:`XMLParser.close` calls "
"*target*\\'s method ``close()``. :class:`XMLParser` can be used not only for "
"building a tree structure. This is an example of counting the maximum depth "
"of an XML file::"
msgstr ""
":meth:`XMLParser.feed` викликає метод *target* ``start(tag, attrs_dict)`` "
"для кожного початкового тегу, його метод ``end(tag)`` для кожного "
"закриваючого тегу, і дані обробляються методом ``дані(дані)``. Інші "
"підтримувані методи зворотного виклику див. у класі :class:`TreeBuilder`. :"
"meth:`XMLParser.close` викликає метод *target*\\``close()``. :class:"
"`XMLParser` можна використовувати не тільки для побудови деревовидної "
"структури. Це приклад підрахунку максимальної глибини файлу XML:"

msgid "XMLPullParser Objects"
msgstr "Об’єкти XMLPullParser"

msgid ""
"A pull parser suitable for non-blocking applications.  Its input-side API is "
"similar to that of :class:`XMLParser`, but instead of pushing calls to a "
"callback target, :class:`XMLPullParser` collects an internal list of parsing "
"events and lets the user read from it. *events* is a sequence of events to "
"report back.  The supported events are the strings ``\"start\"``, "
"``\"end\"``, ``\"comment\"``, ``\"pi\"``, ``\"start-ns\"`` and ``\"end-"
"ns\"`` (the \"ns\" events are used to get detailed namespace information).  "
"If *events* is omitted, only ``\"end\"`` events are reported."
msgstr ""
"Синтаксичний аналізатор, що підходить для неблокуючих програм. Його API на "
"стороні введення схожий на API :class:`XMLParser`, але замість того, щоб "
"надсилати виклики до цілі зворотного виклику, :class:`XMLPullParser` збирає "
"внутрішній список подій аналізу та дозволяє користувачеві читати з нього. "
"*події* — це послідовність подій, про які потрібно повідомити. "
"Підтримуваними подіями є рядки ``\"start\"``, ``\"end\"``, ``\"comment\"``, "
"``\"pi\"``, ``\"start-ns\"`` і ``\"end-ns\"`` (події \"ns\" використовуються "
"для отримання детальної інформації про простір імен). Якщо *events* опущено, "
"повідомляються лише події ``\"end\"``."

msgid "Feed the given bytes data to the parser."
msgstr "Передайте надані дані в байтах аналізатору."

msgid ""
"Signal the parser that the data stream is terminated. Unlike :meth:"
"`XMLParser.close`, this method always returns :const:`None`. Any events not "
"yet retrieved when the parser is closed can still be read with :meth:"
"`read_events`."
msgstr ""
"Сигналізуйте синтаксичному аналізатору, що потік даних завершено. На відміну "
"від :meth:`XMLParser.close`, цей метод завжди повертає :const:`None`. Будь-"
"які події, які ще не були отримані, коли синтаксичний аналізатор закрито, "
"все ще можна прочитати за допомогою :meth:`read_events`."

msgid ""
"Return an iterator over the events which have been encountered in the data "
"fed to the parser.  The iterator yields ``(event, elem)`` pairs, where "
"*event* is a string representing the type of event (e.g. ``\"end\"``) and "
"*elem* is the encountered :class:`Element` object, or other context value as "
"follows."
msgstr ""
"Повертає ітератор над подіями, які зустрічаються в даних, переданих до "
"аналізатора. Ітератор видає пари ``(event, elem)``, де *event* — рядок, що "
"представляє тип події (наприклад, ``\"end\"``), а *elem* — це знайдений "
"об’єкт :class:`Element` або інше значення контексту, як показано нижче."

msgid "``start``, ``end``: the current Element."
msgstr "``start``, ``end``: поточний елемент."

msgid "``comment``, ``pi``: the current comment / processing instruction"
msgstr "``comment``, ``pi``: поточний коментар / інструкція обробки"

msgid ""
"``start-ns``: a tuple ``(prefix, uri)`` naming the declared namespace "
"mapping."
msgstr ""
"``start-ns``: кортеж ``(prefix, uri)``, який іменує оголошене відображення "
"простору імен."

msgid "``end-ns``: :const:`None` (this may change in a future version)"
msgstr "``end-ns``: :const:`None` (це може змінитися в наступній версії)"

msgid ""
"Events provided in a previous call to :meth:`read_events` will not be "
"yielded again.  Events are consumed from the internal queue only when they "
"are retrieved from the iterator, so multiple readers iterating in parallel "
"over iterators obtained from :meth:`read_events` will have unpredictable "
"results."
msgstr ""
"Події, надані в попередньому виклику :meth:`read_events`, не будуть видані "
"знову. Події споживаються з внутрішньої черги лише тоді, коли вони отримані "
"з ітератора, тому кілька читачів, які паралельно повторюють ітератори, "
"отримані з :meth:`read_events`, матимуть непередбачувані результати."

msgid ""
":class:`XMLPullParser` only guarantees that it has seen the \">\" character "
"of a starting tag when it emits a \"start\" event, so the attributes are "
"defined, but the contents of the text and tail attributes are undefined at "
"that point.  The same applies to the element children; they may or may not "
"be present."
msgstr ""
":class:`XMLPullParser` лише гарантує, що він побачив символ \">\" "
"початкового тегу, коли він випромінює подію \"start\", тому атрибути "
"визначені, але вміст атрибутів text і tail на той момент не визначено . Те "
"саме стосується елемента діти; вони можуть бути або не бути присутніми."

msgid "Exceptions"
msgstr "Винятки"

msgid ""
"XML parse error, raised by the various parsing methods in this module when "
"parsing fails.  The string representation of an instance of this exception "
"will contain a user-friendly error message.  In addition, it will have the "
"following attributes available:"
msgstr ""
"Помилка аналізу XML, викликана різними методами аналізу в цьому модулі, коли "
"аналіз не вдається. Рядкове представлення екземпляра цього винятку міститиме "
"зручне повідомлення про помилку. Крім того, він матиме такі доступні "
"атрибути:"

msgid ""
"A numeric error code from the expat parser. See the documentation of :mod:"
"`xml.parsers.expat` for the list of error codes and their meanings."
msgstr ""
"Числовий код помилки від аналізатора expat. Перегляньте документацію :mod:"
"`xml.parsers.expat`, щоб переглянути список кодів помилок та їх значення."

msgid ""
"A tuple of *line*, *column* numbers, specifying where the error occurred."
msgstr "Кортеж чисел *рядка*, *стовпця*, що вказує, де сталася помилка."

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"The encoding string included in XML output should conform to the appropriate "
"standards.  For example, \"UTF-8\" is valid, but \"UTF8\" is not.  See "
"https://www.w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl and https://"
"www.iana.org/assignments/character-sets/character-sets.xhtml."
msgstr ""
"Рядок кодування, включений у вивід XML, має відповідати відповідним "
"стандартам. Наприклад, \"UTF-8\" дійсний, а \"UTF8\" – ні. Див. https://www."
"w3.org/TR/2006/REC-xml11-20060816/#NT-EncodingDecl і https://www.iana.org/"
"assignments/character-sets/character-sets.xhtml."
