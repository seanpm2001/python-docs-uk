# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:14+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`struct` --- Interpret bytes as packed binary data"
msgstr ":mod:`struct` --- Інтерпретувати байти як упаковані двійкові дані"

msgid "**Source code:** :source:`Lib/struct.py`"
msgstr "**Вихідний код:** :source:`Lib/struct.py`"

msgid ""
"This module performs conversions between Python values and C structs "
"represented as Python :class:`bytes` objects.  This can be used in handling "
"binary data stored in files or from network connections, among other "
"sources.  It uses :ref:`struct-format-strings` as compact descriptions of "
"the layout of the C structs and the intended conversion to/from Python "
"values."
msgstr ""
"Цей модуль виконує перетворення між значеннями Python і структурами C, "
"представленими як об’єкти Python :class:`bytes`. Це можна використовувати "
"для обробки двійкових даних, що зберігаються у файлах або з мережевих "
"з’єднань, серед інших джерел. Він використовує :ref:`struct-format-strings` "
"як компактний опис компонування структур C і передбачуваного перетворення в/"
"з значень Python."

msgid ""
"By default, the result of packing a given C struct includes pad bytes in "
"order to maintain proper alignment for the C types involved; similarly, "
"alignment is taken into account when unpacking.  This behavior is chosen so "
"that the bytes of a packed struct correspond exactly to the layout in memory "
"of the corresponding C struct.  To handle platform-independent data formats "
"or omit implicit pad bytes, use ``standard`` size and alignment instead of "
"``native`` size and alignment: see :ref:`struct-alignment` for details."
msgstr ""
"За замовчуванням результат упаковки заданої структури C включає байти "
"заповнення, щоб підтримувати належне вирівнювання для задіяних типів C; так "
"само центрування враховується при розпакуванні. Ця поведінка вибирається "
"так, щоб байти упакованої структури точно відповідали макету в пам’яті "
"відповідної структури C. Щоб обробляти незалежні від платформи формати даних "
"або пропускати неявні байти, використовуйте ``стандартний`` розмір і "
"вирівнювання замість ``власного`` розміру та вирівнювання: подробиці див. :"
"ref:`struct-alignment`."

msgid ""
"Several :mod:`struct` functions (and methods of :class:`Struct`) take a "
"*buffer* argument.  This refers to objects that implement the :ref:"
"`bufferobjects` and provide either a readable or read-writable buffer.  The "
"most common types used for that purpose are :class:`bytes` and :class:"
"`bytearray`, but many other types that can be viewed as an array of bytes "
"implement the buffer protocol, so that they can be read/filled without "
"additional copying from a :class:`bytes` object."
msgstr ""
"Кілька функцій :mod:`struct` (та методи :class:`Struct`) приймають аргумент "
"*buffer*. Це відноситься до об’єктів, які реалізують :ref:`bufferobjects` і "
"забезпечують доступний для читання чи запису буфер. Найпоширенішими типами, "
"які використовуються для цієї мети, є :class:`bytes` і :class:`bytearray`, "
"але багато інших типів, які можна розглядати як масив байтів, реалізують "
"протокол буфера, тому їх можна читати/заповнювати без додаткове копіювання з "
"об'єкта :class:`bytes`."

msgid "Functions and Exceptions"
msgstr "Функції та винятки"

msgid "The module defines the following exception and functions:"
msgstr "Модуль визначає такі винятки та функції:"

msgid ""
"Exception raised on various occasions; argument is a string describing what "
"is wrong."
msgstr ""
"Виняток, що виникає з різних приводів; аргумент - це рядок, що описує те, що "
"є неправильним."

msgid ""
"Return a bytes object containing the values *v1*, *v2*, ... packed according "
"to the format string *format*.  The arguments must match the values required "
"by the format exactly."
msgstr ""
"Повертає об’єкт bytes, що містить значення *v1*, *v2*, ... упаковані "
"відповідно до рядка формату *format*. Аргументи мають точно відповідати "
"значенням, які вимагає формат."

msgid ""
"Pack the values *v1*, *v2*, ... according to the format string *format* and "
"write the packed bytes into the writable buffer *buffer* starting at "
"position *offset*.  Note that *offset* is a required argument."
msgstr ""
"Упакуйте значення *v1*, *v2*, ... відповідно до рядка формату *format* і "
"запишіть упаковані байти в записуваний буфер *buffer*, починаючи з позиції "
"*offset*. Зауважте, що *offset* є обов’язковим аргументом."

msgid ""
"Unpack from the buffer *buffer* (presumably packed by ``pack(format, ...)``) "
"according to the format string *format*.  The result is a tuple even if it "
"contains exactly one item.  The buffer's size in bytes must match the size "
"required by the format, as reflected by :func:`calcsize`."
msgstr ""
"Розпакуйте з буфера *buffer* (імовірно запакованого ``pack(format, ...)``) "
"відповідно до рядка формату *format*. Результатом є кортеж, навіть якщо він "
"містить рівно один елемент. Розмір буфера в байтах має відповідати розміру, "
"який вимагає формат, як це відображається :func:`calcsize`."

msgid ""
"Unpack from *buffer* starting at position *offset*, according to the format "
"string *format*.  The result is a tuple even if it contains exactly one "
"item.  The buffer's size in bytes, starting at position *offset*, must be at "
"least the size required by the format, as reflected by :func:`calcsize`."
msgstr ""
"Розпакуйте з *buffer*, починаючи з позиції *offset*, відповідно до рядка "
"формату *format*. Результатом є кортеж, навіть якщо він містить рівно один "
"елемент. Розмір буфера в байтах, починаючи з позиції *offset*, має бути "
"принаймні розміром, який вимагається форматом, що відображається :func:"
"`calcsize`."

msgid ""
"Iteratively unpack from the buffer *buffer* according to the format string "
"*format*.  This function returns an iterator which will read equally sized "
"chunks from the buffer until all its contents have been consumed.  The "
"buffer's size in bytes must be a multiple of the size required by the "
"format, as reflected by :func:`calcsize`."
msgstr ""

msgid "Each iteration yields a tuple as specified by the format string."
msgstr "Кожна ітерація дає кортеж, як зазначено в рядку формату."

msgid ""
"Return the size of the struct (and hence of the bytes object produced by "
"``pack(format, ...)``) corresponding to the format string *format*."
msgstr ""
"Повертає розмір структури (і, отже, об’єкта bytes, створеного "
"``pack(format, ...)``), що відповідає рядку формату *format*."

msgid "Format Strings"
msgstr "Форматувати рядки"

msgid ""
"Format strings are the mechanism used to specify the expected layout when "
"packing and unpacking data.  They are built up from :ref:`format-"
"characters`, which specify the type of data being packed/unpacked.  In "
"addition, there are special characters for controlling the :ref:`struct-"
"alignment`."
msgstr ""
"Рядки формату — це механізм, який використовується для визначення "
"очікуваного макета під час пакування та розпакування даних. Вони складаються "
"з :ref:`format-characters`, які вказують тип даних, що пакуються/"
"розпаковуються. Крім того, існують спеціальні символи для керування :ref:"
"`struct-alignment`."

msgid "Byte Order, Size, and Alignment"
msgstr "Порядок байтів, розмір і вирівнювання"

msgid ""
"By default, C types are represented in the machine's native format and byte "
"order, and properly aligned by skipping pad bytes if necessary (according to "
"the rules used by the C compiler)."
msgstr ""
"За замовчуванням типи C представлені у власному форматі машини та порядку "
"байтів і належним чином вирівняні шляхом пропуску байтів, якщо необхідно "
"(відповідно до правил, які використовує компілятор C)."

msgid ""
"Alternatively, the first character of the format string can be used to "
"indicate the byte order, size and alignment of the packed data, according to "
"the following table:"
msgstr ""
"Крім того, перший символ рядка формату можна використовувати для вказівки "
"порядку байтів, розміру та вирівнювання упакованих даних згідно з наведеною "
"нижче таблицею:"

msgid "Character"
msgstr "характер"

msgid "Byte order"
msgstr "Порядок байтів"

msgid "Size"
msgstr "Розмір"

msgid "Alignment"
msgstr "Вирівнювання"

msgid "``@``"
msgstr "``@``"

msgid "native"
msgstr "рідний"

msgid "``=``"
msgstr "``=``"

msgid "standard"
msgstr "стандарт"

msgid "none"
msgstr "немає"

msgid "``<``"
msgstr "``<``"

msgid "little-endian"
msgstr "маленький байт"

msgid "``>``"
msgstr "``>``"

msgid "big-endian"
msgstr "великий байт"

msgid "``!``"
msgstr "``!``"

msgid "network (= big-endian)"
msgstr "мережа (= порядок байтів)"

msgid "If the first character is not one of these, ``'@'`` is assumed."
msgstr "Якщо перший символ не є одним із цих, передбачається ``'@'``."

msgid ""
"Native byte order is big-endian or little-endian, depending on the host "
"system. For example, Intel x86 and AMD64 (x86-64) are little-endian; IBM z "
"and most legacy architectures are big-endian; and ARM, RISC-V and IBM Power "
"feature switchable endianness (bi-endian, though the former two are nearly "
"always little-endian in practice). Use ``sys.byteorder`` to check the "
"endianness of your system."
msgstr ""
"Власний порядок байтів — старший або маленький, залежно від хост-системи. "
"Наприклад, Intel x86 і AMD64 (x86-64) мають порядок байтів; IBM z і "
"більшість застарілих архітектур мають порядок байтів; а ARM, RISC-V і IBM "
"Power мають можливість перемикання порядку байтів (bi-endian, хоча на "
"практиці перші два майже завжди мають порядковий порядок байтів). "
"Використовуйте ``sys.byteorder``, щоб перевірити байтовий порядок вашої "
"системи."

msgid ""
"Native size and alignment are determined using the C compiler's ``sizeof`` "
"expression.  This is always combined with native byte order."
msgstr ""
"Власний розмір і вирівнювання визначаються за допомогою виразу ``sizeof`` "
"компілятора C. Це завжди поєднується з рідним порядком байтів."

msgid ""
"Standard size depends only on the format character;  see the table in the :"
"ref:`format-characters` section."
msgstr ""
"Стандартний розмір залежить тільки від символу формату; див. таблицю в "
"розділі :ref:`format-characters`."

msgid ""
"Note the difference between ``'@'`` and ``'='``: both use native byte order, "
"but the size and alignment of the latter is standardized."
msgstr ""
"Зверніть увагу на різницю між ``'@'`` і ``'='``: обидва використовують "
"власний порядок байтів, але розмір і вирівнювання останнього стандартизовані."

msgid ""
"The form ``'!'`` represents the network byte order which is always big-"
"endian as defined in `IETF RFC 1700 <IETF RFC 1700_>`_."
msgstr ""
"Форма ``'!'`` представляє мережевий порядок байтів, який завжди є старшим "
"байтом, як визначено в `IETF RFC 1700 <IETF RFC 1700_>`_."

msgid ""
"There is no way to indicate non-native byte order (force byte-swapping); use "
"the appropriate choice of ``'<'`` or ``'>'``."
msgstr ""
"Немає способу вказати невласний порядок байтів (примусова заміна байтів); "
"використовуйте відповідний вибір ``' <'`` or ``'> ''``."

msgid "Notes:"
msgstr "Примітки:"

msgid ""
"Padding is only automatically added between successive structure members. No "
"padding is added at the beginning or the end of the encoded struct."
msgstr ""
"Відступи автоматично додаються лише між послідовними елементами структури. "
"Заповнення не додається на початку або в кінці закодованої структури."

msgid ""
"No padding is added when using non-native size and alignment, e.g. with '<', "
"'>', '=', and '!'."
msgstr ""
"Під час використання невласного розміру та вирівнювання відступи не "
"додаються, напр. з \"<', '>\", \"=\" і \"!\"."

msgid ""
"To align the end of a structure to the alignment requirement of a particular "
"type, end the format with the code for that type with a repeat count of "
"zero.  See :ref:`struct-examples`."
msgstr ""
"Щоб вирівняти кінець структури відповідно до вимог вирівнювання певного "
"типу, завершіть формат кодом для цього типу з нульовою кількістю повторів. "
"Див. :ref:`struct-examples`."

msgid "Format Characters"
msgstr "Формат символів"

msgid ""
"Format characters have the following meaning; the conversion between C and "
"Python values should be obvious given their types.  The 'Standard size' "
"column refers to the size of the packed value in bytes when using standard "
"size; that is, when the format string starts with one of ``'<'``, ``'>'``, "
"``'!'`` or ``'='``.  When using native size, the size of the packed value is "
"platform-dependent."
msgstr ""
"Символи форматування мають таке значення; перетворення між значеннями C і "
"Python повинно бути очевидним, враховуючи їхні типи. Стовпець \"Стандартний "
"розмір\" стосується розміру упакованого значення в байтах при використанні "
"стандартного розміру; тобто, коли форматний рядок починається з одного з ``' "
"<'``, ``'> ''``, ``'!''`` або ``'='``. При використанні рідного розміру "
"розмір упакованого значення залежить від платформи."

msgid "Format"
msgstr "Формат"

msgid "C Type"
msgstr "C Тип"

msgid "Python type"
msgstr "Тип Python"

msgid "Standard size"
msgstr "Стандартний розмір"

msgid "Notes"
msgstr "Примітки"

msgid "``x``"
msgstr "``x``"

msgid "pad byte"
msgstr "pad byte"

msgid "no value"
msgstr "немає значення"

msgid "\\(7)"
msgstr "\\(7)"

msgid "``c``"
msgstr "``c``"

msgid ":c:expr:`char`"
msgstr ""

msgid "bytes of length 1"
msgstr "байти довжиною 1"

msgid "1"
msgstr "1"

msgid "``b``"
msgstr "``b``"

msgid ":c:expr:`signed char`"
msgstr ""

msgid "integer"
msgstr "ціле число"

msgid "\\(1), \\(2)"
msgstr "\\(1), \\(2)"

msgid "``B``"
msgstr "``B``"

msgid ":c:expr:`unsigned char`"
msgstr ""

msgid "\\(2)"
msgstr "\\(2)"

msgid "``?``"
msgstr "``?``"

msgid ":c:expr:`_Bool`"
msgstr ""

msgid "bool"
msgstr "bool"

msgid "\\(1)"
msgstr "\\(1)"

msgid "``h``"
msgstr "``h``"

msgid ":c:expr:`short`"
msgstr ""

msgid "2"
msgstr "2"

msgid "``H``"
msgstr "``H``"

msgid ":c:expr:`unsigned short`"
msgstr ""

msgid "``i``"
msgstr "``я``"

msgid ":c:expr:`int`"
msgstr ""

msgid "4"
msgstr "4"

msgid "``I``"
msgstr "``Я``"

msgid ":c:expr:`unsigned int`"
msgstr ""

msgid "``l``"
msgstr "``l``"

msgid ":c:expr:`long`"
msgstr ""

msgid "``L``"
msgstr "``L``"

msgid ":c:expr:`unsigned long`"
msgstr ""

msgid "``q``"
msgstr "``q``"

msgid ":c:expr:`long long`"
msgstr ""

msgid "8"
msgstr "8"

msgid "``Q``"
msgstr "``Q``"

msgid ":c:expr:`unsigned long long`"
msgstr ""

msgid "``n``"
msgstr "``n``"

msgid ":c:expr:`ssize_t`"
msgstr ""

msgid "\\(3)"
msgstr "\\(3)"

msgid "``N``"
msgstr "``N``"

msgid ":c:expr:`size_t`"
msgstr ""

msgid "``e``"
msgstr "``e``"

msgid "\\(6)"
msgstr "\\(6)"

msgid "float"
msgstr "плавати"

msgid "\\(4)"
msgstr "\\(4)"

msgid "``f``"
msgstr "``f``"

msgid ":c:expr:`float`"
msgstr ""

msgid "``d``"
msgstr "``d``"

msgid ":c:expr:`double`"
msgstr ""

msgid "``s``"
msgstr "``s``"

msgid ":c:expr:`char[]`"
msgstr ""

msgid "bytes"
msgstr "байтів"

msgid "``p``"
msgstr "``p``"

msgid "``P``"
msgstr "``P``"

msgid ":c:expr:`void \\*`"
msgstr ""

msgid "\\(5)"
msgstr "\\(5)"

msgid "Added support for the ``'n'`` and ``'N'`` formats."
msgstr "Додано підтримку форматів ``'n'`` і ``'N'``."

msgid "Added support for the ``'e'`` format."
msgstr "Додано підтримку формату ``'e''``."

msgid ""
"The ``'?'`` conversion code corresponds to the :c:expr:`_Bool` type defined "
"by C99. If this type is not available, it is simulated using a :c:expr:"
"`char`. In standard mode, it is always represented by one byte."
msgstr ""

msgid ""
"When attempting to pack a non-integer using any of the integer conversion "
"codes, if the non-integer has a :meth:`__index__` method then that method is "
"called to convert the argument to an integer before packing."
msgstr ""
"Під час спроби запакувати неціле число за допомогою будь-якого з кодів "
"перетворення цілого числа, якщо неціле число має метод :meth:`__index__`, "
"тоді цей метод викликається для перетворення аргументу в ціле перед "
"пакуванням."

msgid "Added use of the :meth:`__index__` method for non-integers."
msgstr "Додано використання методу :meth:`__index__` для нецілих чисел."

msgid ""
"The ``'n'`` and ``'N'`` conversion codes are only available for the native "
"size (selected as the default or with the ``'@'`` byte order character). For "
"the standard size, you can use whichever of the other integer formats fits "
"your application."
msgstr ""
"Коди перетворення ``'n'`` і ``'N'`` доступні лише для рідного розміру "
"(вибрано як типовий або з символом порядку байтів ``'@''``). Для "
"стандартного розміру ви можете використовувати будь-який з інших форматів "
"цілих чисел, який підходить для вашої програми."

msgid ""
"For the ``'f'``, ``'d'`` and ``'e'`` conversion codes, the packed "
"representation uses the IEEE 754 binary32, binary64 or binary16 format (for "
"``'f'``, ``'d'`` or ``'e'`` respectively), regardless of the floating-point "
"format used by the platform."
msgstr ""
"Для кодів перетворення ``'f'``, ``'d'`` і ``'e'`` упаковане представлення "
"використовує формат IEEE 754 binary32, binary64 або binary16 (для ``'f''`` , "
"``'d'`` або ``'e'`` відповідно), незалежно від формату з плаваючою комою, "
"який використовується платформою."

msgid ""
"The ``'P'`` format character is only available for the native byte ordering "
"(selected as the default or with the ``'@'`` byte order character). The byte "
"order character ``'='`` chooses to use little- or big-endian ordering based "
"on the host system. The struct module does not interpret this as native "
"ordering, so the ``'P'`` format is not available."
msgstr ""
"Символ формату ``'P'`` доступний лише для власного порядку байтів (вибрано "
"як типовий або з символом порядку байтів ``'@'``). Символ порядку байтів "
"``'='`` вибирає порядок використання малого або великого порядку байтів на "
"основі головної системи. Модуль struct не інтерпретує це як рідне "
"впорядкування, тому формат ``'P'`` недоступний."

msgid ""
"The IEEE 754 binary16 \"half precision\" type was introduced in the 2008 "
"revision of the `IEEE 754 standard <ieee 754 standard_>`_. It has a sign "
"bit, a 5-bit exponent and 11-bit precision (with 10 bits explicitly stored), "
"and can represent numbers between approximately ``6.1e-05`` and ``6.5e+04`` "
"at full precision. This type is not widely supported by C compilers: on a "
"typical machine, an unsigned short can be used for storage, but not for math "
"operations. See the Wikipedia page on the `half-precision floating-point "
"format <half precision format_>`_ for more information."
msgstr ""
"Двійковий тип16 IEEE 754 із \"половиною точності\" було введено в редакції "
"2008 року `стандарту IEEE 754 <ieee 754 standard_>`_. Він має знаковий біт, "
"5-бітний експоненту та 11-бітну точність (з 10 бітами, збереженими явно), і "
"може представляти числа приблизно від ``6.1e-05`` до ``6.5e+04`` з повною "
"точністю. . Цей тип не широко підтримується компіляторами C: на типовій "
"машині беззнаковий короткий можна використовувати для зберігання, але не для "
"математичних операцій. Перегляньте сторінку Вікіпедії про `формат числа з "
"плаваючою комою половинної точності <half precision format_>`_ для отримання "
"додаткової інформації."

msgid "For padding, ``x`` inserts null bytes."
msgstr ""

msgid ""
"A format character may be preceded by an integral repeat count.  For "
"example, the format string ``'4h'`` means exactly the same as ``'hhhh'``."
msgstr ""
"Символу форматування може передувати цілий підрахунок повторів. Наприклад, "
"рядок формату ``'4h''`` означає те саме, що ``'hhhh'``."

msgid ""
"Whitespace characters between formats are ignored; a count and its format "
"must not contain whitespace though."
msgstr ""
"Пробіли між форматами ігноруються; кількість і його формат не повинні "
"містити пробіли."

msgid ""
"For the ``'s'`` format character, the count is interpreted as the length of "
"the bytes, not a repeat count like for the other format characters; for "
"example, ``'10s'`` means a single 10-byte string, while ``'10c'`` means 10 "
"characters. If a count is not given, it defaults to 1.  For packing, the "
"string is truncated or padded with null bytes as appropriate to make it fit. "
"For unpacking, the resulting bytes object always has exactly the specified "
"number of bytes.  As a special case, ``'0s'`` means a single, empty string "
"(while ``'0c'`` means 0 characters)."
msgstr ""
"Для символу формату ``'s`` кількість інтерпретується як довжина байтів, а не "
"кількість повторів, як для інших символів формату; наприклад, ``'10s'`` "
"означає один 10-байтовий рядок, тоді як ``'10c''`` означає 10 символів. Якщо "
"підрахунок не вказано, за замовчуванням він дорівнює 1. Для упаковки рядок "
"скорочується або доповнюється нульовими байтами відповідно до того, щоб "
"зробити його відповідним. Для розпакування отриманий об’єкт bytes завжди має "
"точно вказану кількість байтів. Як окремий випадок, \"0s\" означає один "
"порожній рядок (тоді як \"0c\" означає 0 символів)."

msgid ""
"When packing a value ``x`` using one of the integer formats (``'b'``, "
"``'B'``, ``'h'``, ``'H'``, ``'i'``, ``'I'``, ``'l'``, ``'L'``, ``'q'``, "
"``'Q'``), if ``x`` is outside the valid range for that format then :exc:"
"`struct.error` is raised."
msgstr ""
"Під час пакування значення ``x`` з використанням одного з цілочисельних "
"форматів (``'b'``, ``'B'``, ``'h'``, ``'H'``, ``'i'``, ``'I'``, ``'l'``, "
"``'L'``, ``'q'``, ``'Q'``), якщо ``x`` знаходиться за межами допустимого "
"діапазону для цього формату, тоді виникає :exc:`struct.error`."

msgid ""
"Previously, some of the integer formats wrapped out-of-range values and "
"raised :exc:`DeprecationWarning` instead of :exc:`struct.error`."
msgstr ""
"Раніше деякі цілочисельні формати обгортали значення поза діапазоном і "
"викликали :exc:`DeprecationWarning` замість :exc:`struct.error`."

msgid ""
"The ``'p'`` format character encodes a \"Pascal string\", meaning a short "
"variable-length string stored in a *fixed number of bytes*, given by the "
"count. The first byte stored is the length of the string, or 255, whichever "
"is smaller.  The bytes of the string follow.  If the string passed in to :"
"func:`pack` is too long (longer than the count minus 1), only the leading "
"``count-1`` bytes of the string are stored.  If the string is shorter than "
"``count-1``, it is padded with null bytes so that exactly count bytes in all "
"are used.  Note that for :func:`unpack`, the ``'p'`` format character "
"consumes ``count`` bytes, but that the string returned can never contain "
"more than 255 bytes."
msgstr ""
"Символ формату ``'p'`` кодує \"рядок Pascal\", що означає короткий рядок "
"змінної довжини, що зберігається у *фіксованій кількості байтів*, визначеній "
"підрахунком. Перший збережений байт — це довжина рядка або 255, залежно від "
"того, що менше. Далі йдуть байти рядка. Якщо рядок, переданий у :func:"
"`pack`, задовгий (довший за лічильник мінус 1), зберігаються лише перші "
"байти ``count-1`` рядка. Якщо рядок коротший за ``count-1``, він "
"доповнюється нульовими байтами, щоб використати рівно кількість байтів. "
"Зверніть увагу, що для :func:`unpack` символ формату ``'p'`` споживає "
"``count`` байтів, але що повернутий рядок ніколи не може містити більше 255 "
"байтів."

msgid ""
"For the ``'?'`` format character, the return value is either :const:`True` "
"or :const:`False`. When packing, the truth value of the argument object is "
"used. Either 0 or 1 in the native or standard bool representation will be "
"packed, and any non-zero value will be ``True`` when unpacking."
msgstr ""
"Для символу формату ``'?'`` повертається значення :const:`True` або :const:"
"`False`. При упаковці використовується значення істинності об'єкта "
"аргументу. Буде запаковано 0 або 1 у нативному або стандартному логічному "
"представленні, а будь-яке ненульове значення під час розпакування буде "
"``True``."

msgid "Examples"
msgstr "Приклади"

msgid ""
"All examples assume a native byte order, size, and alignment with a big-"
"endian machine."
msgstr ""
"Усі приклади передбачають власний порядок байтів, розмір і вирівнювання з "
"машиною старшого порядку."

msgid "A basic example of packing/unpacking three integers::"
msgstr "Базовий приклад пакування/розпакування трьох цілих чисел::"

msgid ""
"Unpacked fields can be named by assigning them to variables or by wrapping "
"the result in a named tuple::"
msgstr ""
"Розпаковані поля можна назвати, призначивши їх змінним або загорнувши "
"результат у іменований кортеж::"

msgid ""
"The ordering of format characters may have an impact on size since the "
"padding needed to satisfy alignment requirements is different::"
msgstr ""
"Порядок символів формату може впливати на розмір, оскільки відступи, "
"необхідні для задоволення вимог вирівнювання, відрізняються:"

msgid ""
"The following format ``'llh0l'`` specifies two pad bytes at the end, "
"assuming longs are aligned on 4-byte boundaries::"
msgstr ""
"Наступний формат ``'llh0l'`` вказує два байти заповнення в кінці, "
"припускаючи, що longs вирівняно на 4-байтових границях::"

msgid ""
"This only works when native size and alignment are in effect; standard size "
"and alignment does not enforce any alignment."
msgstr ""
"Це працює лише тоді, коли діють оригінальний розмір і вирівнювання; "
"стандартний розмір і вирівнювання не забезпечують жодного вирівнювання."

msgid "Module :mod:`array`"
msgstr "Модуль :mod:`array`"

msgid "Packed binary storage of homogeneous data."
msgstr "Упаковане двійкове сховище однорідних даних."

msgid "Module :mod:`xdrlib`"
msgstr "Модуль :mod:`xdrlib`"

msgid "Packing and unpacking of XDR data."
msgstr "Пакування та розпакування даних XDR."

msgid "Classes"
msgstr "Класи"

msgid "The :mod:`struct` module also defines the following type:"
msgstr "Модуль :mod:`struct` також визначає наступний тип:"

msgid ""
"Return a new Struct object which writes and reads binary data according to "
"the format string *format*.  Creating a Struct object once and calling its "
"methods is more efficient than calling the :mod:`struct` functions with the "
"same format since the format string only needs to be compiled once."
msgstr ""
"Повертає новий об’єкт Struct, який записує та читає двійкові дані відповідно "
"до рядка формату *format*. Одноразове створення об’єкта Struct і виклик його "
"методів є більш ефективним, ніж виклик функцій :mod:`struct` з тим самим "
"форматом, оскільки рядок формату потрібно скомпілювати лише один раз."

msgid ""
"The compiled versions of the most recent format strings passed to :class:"
"`Struct` and the module-level functions are cached, so programs that use "
"only a few format strings needn't worry about reusing a single :class:"
"`Struct` instance."
msgstr ""
"Зібрані версії найновіших рядків формату, переданих до :class:`Struct`, і "
"функцій рівня модуля кешуються, тому програмам, які використовують лише "
"кілька рядків формату, не потрібно турбуватися про повторне використання "
"окремого екземпляра :class:`Struct` ."

msgid "Compiled Struct objects support the following methods and attributes:"
msgstr "Зкомпільовані об’єкти Struct підтримують наступні методи та атрибути:"

msgid ""
"Identical to the :func:`pack` function, using the compiled format. "
"(``len(result)`` will equal :attr:`size`.)"
msgstr ""
"Ідентична функції :func:`pack`, використовуючи скомпільований формат. "
"(``len(result)`` дорівнюватиме :attr:`size`.)"

msgid "Identical to the :func:`pack_into` function, using the compiled format."
msgstr ""
"Ідентична функції :func:`pack_into`, використовуючи скомпільований формат."

msgid ""
"Identical to the :func:`unpack` function, using the compiled format. The "
"buffer's size in bytes must equal :attr:`size`."
msgstr ""
"Ідентична функції :func:`unpack`, використовуючи скомпільований формат. "
"Розмір буфера в байтах має дорівнювати :attr:`size`."

msgid ""
"Identical to the :func:`unpack_from` function, using the compiled format. "
"The buffer's size in bytes, starting at position *offset*, must be at least :"
"attr:`size`."
msgstr ""
"Ідентична функції :func:`unpack_from`, використовуючи скомпільований формат. "
"Розмір буфера в байтах, починаючи з позиції *offset*, має бути не менше :"
"attr:`size`."

msgid ""
"Identical to the :func:`iter_unpack` function, using the compiled format. "
"The buffer's size in bytes must be a multiple of :attr:`size`."
msgstr ""
"Ідентична функції :func:`iter_unpack`, використовуючи скомпільований формат. "
"Розмір буфера в байтах має бути кратним :attr:`size`."

msgid "The format string used to construct this Struct object."
msgstr ""
"Рядок формату, який використовується для створення цього об’єкта Struct."

msgid "The format string type is now :class:`str` instead of :class:`bytes`."
msgstr "Тип рядка формату тепер :class:`str` замість :class:`bytes`."

msgid ""
"The calculated size of the struct (and hence of the bytes object produced by "
"the :meth:`pack` method) corresponding to :attr:`format`."
msgstr ""
"Розрахований розмір структури (і, отже, об’єкта bytes, створеного методом :"
"meth:`pack`), що відповідає :attr:`format`."
