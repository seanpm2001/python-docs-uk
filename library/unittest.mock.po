# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-29 17:18+0300\n"
"PO-Revision-Date: 2022-07-02 20:43+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid ":mod:`unittest.mock` --- mock object library"
msgstr ":mod:`unittest.mock` --- бібліотека макетів об'єктів"

msgid "**Source code:** :source:`Lib/unittest/mock.py`"
msgstr "**Вихідний код:** :source:`Lib/unittest/mock.py`"

msgid ""
":mod:`unittest.mock` is a library for testing in Python. It allows you to "
"replace parts of your system under test with mock objects and make "
"assertions about how they have been used."
msgstr ""
":mod:`unittest.mock` — це бібліотека для тестування на Python. Це дозволяє "
"вам замінити частини вашої тестованої системи на фіктивні об’єкти та зробити "
"твердження про те, як вони використовувалися."

msgid ""
":mod:`unittest.mock` provides a core :class:`Mock` class removing the need "
"to create a host of stubs throughout your test suite. After performing an "
"action, you can make assertions about which methods / attributes were used "
"and arguments they were called with. You can also specify return values and "
"set needed attributes in the normal way."
msgstr ""
":mod:`unittest.mock` надає базовий клас :class:`Mock`, який усуває "
"необхідність створювати безліч заглушок у вашому наборі тестів. Після "
"виконання дії ви можете зробити твердження про те, які методи/атрибути були "
"використані та аргументи, з якими вони були викликані. Ви також можете "
"вказати значення, що повертаються, і встановити необхідні атрибути звичайним "
"способом."

msgid ""
"Additionally, mock provides a :func:`patch` decorator that handles patching "
"module and class level attributes within the scope of a test, along with :"
"const:`sentinel` for creating unique objects. See the `quick guide`_ for "
"some examples of how to use :class:`Mock`, :class:`MagicMock` and :func:"
"`patch`."
msgstr ""
"Крім того, mock надає декоратор :func:`patch`, який обробляє модуль "
"виправлення та атрибути рівня класу в межах тесту, а також :const:`sentinel` "
"для створення унікальних об’єктів. Перегляньте короткий посібник (`quick "
"guide`_) для деяких прикладів використання :class:`Mock`, :class:`MagicMock` "
"і :func:`patch`."

msgid ""
"Mock is designed for use with :mod:`unittest` and is based on the 'action -> "
"assertion' pattern instead of 'record -> replay' used by many mocking "
"frameworks."
msgstr ""
"Mock розроблений для використання з :mod:`unittest` і базується на шаблоні "
"\"action -> assertion\" замість \"record -> replay\", який використовується "
"багатьма фреймворками мокінгу."

msgid ""
"There is a backport of :mod:`unittest.mock` for earlier versions of Python, "
"available as `mock on PyPI <https://pypi.org/project/mock>`_."
msgstr ""
"Існує бекпорт :mod:`unittest.mock` для попередніх версій Python, доступний "
"як `mock on PyPI <https://pypi.org/project/mock>`_."

msgid "Quick Guide"
msgstr "Короткий посібник"

msgid ""
":class:`Mock` and :class:`MagicMock` objects create all attributes and "
"methods as you access them and store details of how they have been used. You "
"can configure them, to specify return values or limit what attributes are "
"available, and then make assertions about how they have been used:"
msgstr ""
"Об’єкти :class:`Mock` і :class:`MagicMock` створюють усі атрибути та методи "
"під час доступу до них і зберігають відомості про те, як вони "
"використовувалися. Ви можете налаштувати їх, щоб указати значення, що "
"повертаються, або обмежити доступність атрибутів, а потім зробити твердження "
"про те, як вони використовувалися:"

msgid ""
":attr:`side_effect` allows you to perform side effects, including raising an "
"exception when a mock is called:"
msgstr ""
":attr:`side_effect` дозволяє виконувати побічні ефекти, включно з викликом "
"винятку під час виклику макету:"

msgid ""
"Mock has many other ways you can configure it and control its behaviour. For "
"example the *spec* argument configures the mock to take its specification "
"from another object. Attempting to access attributes or methods on the mock "
"that don't exist on the spec will fail with an :exc:`AttributeError`."
msgstr ""
"Mock має багато інших способів налаштувати його та контролювати його "
"поведінку. Наприклад, аргумент *spec* налаштовує макет на отримання "
"специфікації з іншого об’єкта. Спроба отримати доступ до атрибутів або "
"методів у макеті, які не існують у специфікації, закінчиться помилкою з :exc:"
"`AttributeError`."

msgid ""
"The :func:`patch` decorator / context manager makes it easy to mock classes "
"or objects in a module under test. The object you specify will be replaced "
"with a mock (or other object) during the test and restored when the test "
"ends::"
msgstr ""
"Декоратор/менеджер контексту :func:`patch` дозволяє легко імітувати класи чи "
"об’єкти в тестованому модулі. Вказаний вами об’єкт буде замінено макетом "
"(або іншим об’єктом) під час тесту та відновлено після завершення тесту:"

msgid ""
"When you nest patch decorators the mocks are passed in to the decorated "
"function in the same order they applied (the normal *Python* order that "
"decorators are applied). This means from the bottom up, so in the example "
"above the mock for ``module.ClassName1`` is passed in first."
msgstr ""
"Коли ви вкладаєте декоратори латок, макети передаються до декорованої "
"функції в тому ж порядку, в якому вони застосовані (звичайний *Python* "
"порядок застосування декораторів). Це означає знизу вгору, тому у наведеному "
"вище прикладі спочатку передається макет для ``module.ClassName1``."

msgid ""
"With :func:`patch` it matters that you patch objects in the namespace where "
"they are looked up. This is normally straightforward, but for a quick guide "
"read :ref:`where to patch <where-to-patch>`."
msgstr ""
"З :func:`patch` важливо, щоб ви латали об’єкти в просторі імен, де вони "
"шукаються. Зазвичай це просто, але для короткого посібника прочитайте :ref:"
"`де патч <where-to-patch>`."

msgid ""
"As well as a decorator :func:`patch` can be used as a context manager in a "
"with statement:"
msgstr ""
"Як і декоратор :func:`patch` можна використовувати як менеджер контексту в "
"операторі with:"

msgid ""
"There is also :func:`patch.dict` for setting values in a dictionary just "
"during a scope and restoring the dictionary to its original state when the "
"test ends:"
msgstr ""
"Існує також :func:`patch.dict` для встановлення значень у словнику лише під "
"час області видимості та відновлення словника до початкового стану після "
"завершення тесту:"

msgid ""
"Mock supports the mocking of Python :ref:`magic methods <magic-methods>`. "
"The easiest way of using magic methods is with the :class:`MagicMock` class. "
"It allows you to do things like:"
msgstr ""
"Mock підтримує знущання над Python :ref:`магічні методи <magic-methods>`. "
"Найпростіший спосіб використання магічних методів — це клас :class:"
"`MagicMock`. Це дозволяє вам робити такі речі, як:"

msgid ""
"Mock allows you to assign functions (or other Mock instances) to magic "
"methods and they will be called appropriately. The :class:`MagicMock` class "
"is just a Mock variant that has all of the magic methods pre-created for you "
"(well, all the useful ones anyway)."
msgstr ""
"Mock дозволяє вам призначати функції (або інші екземпляри Mock) магічним "
"методам, і вони будуть викликані належним чином. Клас :class:`MagicMock` — "
"це просто варіант Mock, який містить усі магічні методи, попередньо створені "
"для вас (ну, у всякому разі, всі корисні)."

msgid ""
"The following is an example of using magic methods with the ordinary Mock "
"class:"
msgstr ""
"Нижче наведено приклад використання магічних методів із звичайним класом "
"Mock:"

msgid ""
"For ensuring that the mock objects in your tests have the same api as the "
"objects they are replacing, you can use :ref:`auto-speccing <auto-"
"speccing>`. Auto-speccing can be done through the *autospec* argument to "
"patch, or the :func:`create_autospec` function. Auto-speccing creates mock "
"objects that have the same attributes and methods as the objects they are "
"replacing, and any functions and methods (including constructors) have the "
"same call signature as the real object."
msgstr ""
"Щоб переконатися, що макетні об’єкти у ваших тестах мають той самий API, що "
"й об’єкти, які вони замінюють, ви можете використати :ref:`auto-speccing "
"<auto-speccing>`. Автоматичну специфікацію можна виконати за допомогою "
"аргументу *autospec* для виправлення або функції :func:`create_autospec`. "
"Автоматична специфікація створює макетні об’єкти, які мають ті самі атрибути "
"та методи, що й об’єкти, які вони замінюють, а будь-які функції та методи "
"(включаючи конструктори) мають ту саму сигнатуру виклику, що й реальний "
"об’єкт."

msgid ""
"This ensures that your mocks will fail in the same way as your production "
"code if they are used incorrectly:"
msgstr ""
"Це гарантує, що ваші макети не працюватимуть так само, як і ваш робочий код, "
"якщо вони використовуються неправильно:"

msgid ""
":func:`create_autospec` can also be used on classes, where it copies the "
"signature of the ``__init__`` method, and on callable objects where it "
"copies the signature of the ``__call__`` method."
msgstr ""
":func:`create_autospec` також можна використовувати в класах, де він копіює "
"сигнатуру методу ``__init__``, і на викликаних об’єктах, де він копіює "
"сигнатуру ``__call__`` методу."

msgid "The Mock Class"
msgstr "Імітаційний клас"

msgid ""
":class:`Mock` is a flexible mock object intended to replace the use of stubs "
"and test doubles throughout your code. Mocks are callable and create "
"attributes as new mocks when you access them [#]_. Accessing the same "
"attribute will always return the same mock. Mocks record how you use them, "
"allowing you to make assertions about what your code has done to them."
msgstr ""
":class:`Mock` — це гнучкий макет об’єкта, призначений для заміни "
"використання заглушок і тестових дублів у вашому коді. Макети можна "
"викликати та створювати атрибути як нові макети під час доступу до них [#]_. "
"Доступ до того самого атрибута завжди повертатиме той самий макет. Mocks "
"записують, як ви їх використовуєте, дозволяючи вам робити твердження про те, "
"що з ними зробив ваш код."

msgid ""
":class:`MagicMock` is a subclass of :class:`Mock` with all the magic methods "
"pre-created and ready to use. There are also non-callable variants, useful "
"when you are mocking out objects that aren't callable: :class:"
"`NonCallableMock` and :class:`NonCallableMagicMock`"
msgstr ""
":class:`MagicMock` є підкласом :class:`Mock` з усіма магічними методами, "
"попередньо створеними та готовими до використання. Існують також варіанти "
"без можливості виклику, корисні, коли ви знущаєтеся над об’єктами, які не "
"можна викликати: :class:`NonCallableMock` і :class:`NonCallableMagicMock`"

msgid ""
"The :func:`patch` decorators makes it easy to temporarily replace classes in "
"a particular module with a :class:`Mock` object. By default :func:`patch` "
"will create a :class:`MagicMock` for you. You can specify an alternative "
"class of :class:`Mock` using the *new_callable* argument to :func:`patch`."
msgstr ""
"Декоратори :func:`patch` дозволяють легко тимчасово замінити класи в певному "
"модулі на об’єкт :class:`Mock`. За умовчанням :func:`patch` створить для "
"вас :class:`MagicMock`. Ви можете вказати альтернативний клас :class:`Mock` "
"за допомогою аргументу *new_callable* для :func:`patch`."

msgid ""
"Create a new :class:`Mock` object. :class:`Mock` takes several optional "
"arguments that specify the behaviour of the Mock object:"
msgstr ""
"Створіть новий об’єкт :class:`Mock`. :class:`Mock` приймає кілька додаткових "
"аргументів, які визначають поведінку об’єкта Mock:"

msgid ""
"*spec*: This can be either a list of strings or an existing object (a class "
"or instance) that acts as the specification for the mock object. If you pass "
"in an object then a list of strings is formed by calling dir on the object "
"(excluding unsupported magic attributes and methods). Accessing any "
"attribute not in this list will raise an :exc:`AttributeError`."
msgstr ""
"*spec*: це може бути або список рядків, або існуючий об’єкт (клас або "
"екземпляр), який діє як специфікація для макетного об’єкта. Якщо ви "
"передаєте об’єкт, тоді список рядків формується шляхом виклику dir для "
"об’єкта (за винятком непідтримуваних магічних атрибутів і методів). Доступ "
"до будь-якого атрибута, якого немає в цьому списку, викличе :exc:"
"`AttributeError`."

msgid ""
"If *spec* is an object (rather than a list of strings) then :attr:`~instance."
"__class__` returns the class of the spec object. This allows mocks to pass :"
"func:`isinstance` tests."
msgstr ""
"Якщо *spec* є об’єктом (а не списком рядків), тоді :attr:`~instance."
"__class__` повертає клас специфікаційного об’єкта. Це дозволяє макетам "
"проходити тести :func:`isinstance`."

msgid ""
"*spec_set*: A stricter variant of *spec*. If used, attempting to *set* or "
"get an attribute on the mock that isn't on the object passed as *spec_set* "
"will raise an :exc:`AttributeError`."
msgstr ""
"*spec_set*: суворіший варіант *spec*. У разі використання спроба "
"*встановити* або отримати атрибут у макеті, якого немає в об’єкті, "
"переданому як *spec_set*, викличе :exc:`AttributeError`."

msgid ""
"*side_effect*: A function to be called whenever the Mock is called. See the :"
"attr:`~Mock.side_effect` attribute. Useful for raising exceptions or "
"dynamically changing return values. The function is called with the same "
"arguments as the mock, and unless it returns :data:`DEFAULT`, the return "
"value of this function is used as the return value."
msgstr ""
"*side_effect*: функція, яка викликається щоразу, коли викликається Mock. "
"Перегляньте атрибут :attr:`~Mock.side_effect`. Корисно для створення "
"винятків або динамічної зміни повернених значень. Функція викликається з "
"тими самими аргументами, що й макет, і якщо вона не повертає :data:"
"`DEFAULT`, значення, що повертається цією функцією, використовується як "
"значення, що повертається."

msgid ""
"Alternatively *side_effect* can be an exception class or instance. In this "
"case the exception will be raised when the mock is called."
msgstr ""
"Крім того, *side_effect* може бути класом винятків або екземпляром. У цьому "
"випадку виняток буде викликано під час виклику макета."

msgid ""
"If *side_effect* is an iterable then each call to the mock will return the "
"next value from the iterable."
msgstr ""
"Якщо *side_effect* є iterable, тоді кожен виклик mock повертатиме наступне "
"значення з iterable."

msgid "A *side_effect* can be cleared by setting it to ``None``."
msgstr ""
"*Побічний_ефект* можна очистити, встановивши для нього значення ``None``."

msgid ""
"*return_value*: The value returned when the mock is called. By default this "
"is a new Mock (created on first access). See the :attr:`return_value` "
"attribute."
msgstr ""
"*return_value*: значення, що повертається під час виклику макета. За "
"замовчуванням це новий макет (створений під час першого доступу). "
"Перегляньте атрибут :attr:`return_value`."

msgid ""
"*unsafe*: By default, accessing any attribute whose name starts with "
"*assert*, *assret*, *asert*, *aseert* or *assrt* will raise an :exc:"
"`AttributeError`. Passing ``unsafe=True`` will allow access to these "
"attributes."
msgstr ""
"*небезпечно*: за умовчанням доступ до будь-якого атрибута, ім’я якого "
"починається з *assert*, *assret*, *assert*, *aseert* або *assrt*, призведе "
"до появи :exc:`AttributeError`. Передача ``unsafe=True`` дозволить отримати "
"доступ до цих атрибутів."

msgid ""
"*wraps*: Item for the mock object to wrap. If *wraps* is not ``None`` then "
"calling the Mock will pass the call through to the wrapped object (returning "
"the real result). Attribute access on the mock will return a Mock object "
"that wraps the corresponding attribute of the wrapped object (so attempting "
"to access an attribute that doesn't exist will raise an :exc:"
"`AttributeError`)."
msgstr ""
"*wraps*: Елемент для обгортання фіктивного об’єкта. Якщо *wraps* не "
"``None``, тоді виклик Mock передасть виклик оберненому об’єкту (повертаючи "
"реальний результат). Доступ до атрибутів у макеті поверне об’єкт Mock, який "
"обгортає відповідний атрибут упакованого об’єкта (тому спроба отримати "
"доступ до атрибута, якого не існує, викличе :exc:`AttributeError`)."

msgid ""
"If the mock has an explicit *return_value* set then calls are not passed to "
"the wrapped object and the *return_value* is returned instead."
msgstr ""
"Якщо макет має явний набір *return_value*, тоді виклики не передаються до "
"упакованого об’єкта, а замість нього повертається *return_value*."

msgid ""
"*name*: If the mock has a name then it will be used in the repr of the mock. "
"This can be useful for debugging. The name is propagated to child mocks."
msgstr ""
"*ім’я*: якщо макет має ім’я, воно використовуватиметься у відтворенні "
"макета. Це може бути корисним для налагодження. Ім'я поширюється на дитячі "
"глузування."

msgid ""
"Mocks can also be called with arbitrary keyword arguments. These will be "
"used to set attributes on the mock after it is created. See the :meth:"
"`configure_mock` method for details."
msgstr ""
"Mocks також можна викликати з довільними ключовими аргументами. Вони "
"використовуватимуться для встановлення атрибутів макета після його "
"створення. Дивіться метод :meth:`configure_mock` для отримання детальної "
"інформації."

msgid "Assert that the mock was called at least once."
msgstr "Стверджуйте, що макет був викликаний принаймні один раз."

msgid "Assert that the mock was called exactly once."
msgstr "Стверджуйте, що макет був викликаний рівно один раз."

msgid ""
"This method is a convenient way of asserting that the last call has been "
"made in a particular way:"
msgstr ""
"Цей метод є зручним способом підтвердження того, що останній виклик було "
"зроблено певним чином:"

msgid ""
"Assert that the mock was called exactly once and that call was with the "
"specified arguments."
msgstr ""
"Стверджуйте, що макет був викликаний рівно один раз і цей виклик був із "
"зазначеними аргументами."

msgid "assert the mock has been called with the specified arguments."
msgstr "стверджувати, що макет був викликаний із зазначеними аргументами."

msgid ""
"The assert passes if the mock has *ever* been called, unlike :meth:"
"`assert_called_with` and :meth:`assert_called_once_with` that only pass if "
"the call is the most recent one, and in the case of :meth:"
"`assert_called_once_with` it must also be the only call."
msgstr ""
"Твердження проходить, якщо макет *колись* викликався, на відміну від :meth:"
"`assert_ called_with` і :meth:`assert_ called_once_with`, які проходять, "
"лише якщо виклик є останнім, і у випадку :meth:`assert_ called_once_with` це "
"також має бути єдиний виклик."

msgid ""
"assert the mock has been called with the specified calls. The :attr:"
"`mock_calls` list is checked for the calls."
msgstr ""
"стверджувати, що макет було викликано за допомогою вказаних викликів. "
"Список :attr:`mock_calls` перевіряється на наявність викликів."

msgid ""
"If *any_order* is false then the calls must be sequential. There can be "
"extra calls before or after the specified calls."
msgstr ""
"Якщо *any_order* має значення false, виклики мають бути послідовними. До або "
"після вказаних викликів можуть бути додаткові дзвінки."

msgid ""
"If *any_order* is true then the calls can be in any order, but they must all "
"appear in :attr:`mock_calls`."
msgstr ""
"Якщо *any_order* має значення true, виклики можуть бути в будь-якому "
"порядку, але всі вони мають відображатися в :attr:`mock_calls`."

msgid "Assert the mock was never called."
msgstr "Стверджуйте, що макет ніколи не викликався."

msgid "The reset_mock method resets all the call attributes on a mock object:"
msgstr "Метод reset_mock скидає всі атрибути виклику на макетному об’єкті:"

msgid "Added two keyword only argument to the reset_mock function."
msgstr "До функції reset_mock додано два аргументи лише для ключових слів."

msgid ""
"This can be useful where you want to make a series of assertions that reuse "
"the same object. Note that :meth:`reset_mock` *doesn't* clear the return "
"value, :attr:`side_effect` or any child attributes you have set using normal "
"assignment by default. In case you want to reset *return_value* or :attr:"
"`side_effect`, then pass the corresponding parameter as ``True``. Child "
"mocks and the return value mock (if any) are reset as well."
msgstr ""
"Це може бути корисним, якщо ви хочете зробити серію тверджень, які повторно "
"використовують той самий об’єкт. Зауважте, що :meth:`reset_mock` *не* очищає "
"повернуте значення, :attr:`side_effect` або будь-які дочірні атрибути, які "
"ви встановили за умовчанням за допомогою звичайного призначення. Якщо ви "
"хочете скинути *return_value* або :attr:`side_effect`, передайте відповідний "
"параметр як ``True``. Дочірні імітації та макет повертаного значення (якщо "
"є) також скидаються."

msgid "*return_value*, and :attr:`side_effect` are keyword only argument."
msgstr ""
"*повернене_значення* та :attr:`side_effect` є аргументом лише для ключового "
"слова."

msgid ""
"Add a spec to a mock. *spec* can either be an object or a list of strings. "
"Only attributes on the *spec* can be fetched as attributes from the mock."
msgstr ""
"Додайте специфікацію до макета. *spec* може бути або об’єктом, або списком "
"рядків. Лише атрибути в *специфікації* можна отримати як атрибути з макета."

msgid "If *spec_set* is true then only attributes on the spec can be set."
msgstr ""
"Якщо *spec_set* має значення true, можна встановити лише атрибути "
"специфікації."

msgid ""
"Attach a mock as an attribute of this one, replacing its name and parent. "
"Calls to the attached mock will be recorded in the :attr:`method_calls` and :"
"attr:`mock_calls` attributes of this one."
msgstr ""
"Додайте макет як атрибут цього, замінивши його ім’я та батьківський елемент. "
"Виклики вкладеного макету будуть записані в атрибутах :attr:`method_calls` "
"і :attr:`mock_calls` цього."

msgid "Set attributes on the mock through keyword arguments."
msgstr "Встановіть атрибути макета за допомогою аргументів ключових слів."

msgid ""
"Attributes plus return values and side effects can be set on child mocks "
"using standard dot notation and unpacking a dictionary in the method call:"
msgstr ""
"Атрибути плюс значення, що повертаються, і побічні ефекти можуть бути "
"встановлені на дочірніх моделях за допомогою стандартної нотації з крапками "
"та розпакування словника під час виклику методу:"

msgid "The same thing can be achieved in the constructor call to mocks:"
msgstr "Те саме можна досягти у виклику конструктора mocks:"

msgid ""
":meth:`configure_mock` exists to make it easier to do configuration after "
"the mock has been created."
msgstr ""
":meth:`configure_mock` існує, щоб полегшити налаштування після створення "
"макету."

msgid ""
":class:`Mock` objects limit the results of ``dir(some_mock)`` to useful "
"results. For mocks with a *spec* this includes all the permitted attributes "
"for the mock."
msgstr ""
"Об’єкти :class:`Mock` обмежують результати ``dir(some_mock)`` корисними "
"результатами. Для макетів із *специфікацією* це включає всі дозволені "
"атрибути для макету."

msgid ""
"See :data:`FILTER_DIR` for what this filtering does, and how to switch it "
"off."
msgstr ""
"Перегляньте :data:`FILTER_DIR`, щоб дізнатися, що робить це фільтрування та "
"як його вимкнути."

msgid ""
"Create the child mocks for attributes and return value. By default child "
"mocks will be the same type as the parent. Subclasses of Mock may want to "
"override this to customize the way child mocks are made."
msgstr ""
"Створіть дочірні макети для атрибутів і повертайте значення. За "
"замовчуванням дочірні макети будуть того самого типу, що й батьківські. "
"Підкласи Mock можуть захотіти перевизначити це, щоб налаштувати спосіб "
"створення дочірніх моків."

msgid ""
"For non-callable mocks the callable variant will be used (rather than any "
"custom subclass)."
msgstr ""
"Для макетів, які не підлягають виклику, використовуватиметься варіант, який "
"можна викликати (а не будь-який настроюваний підклас)."

msgid "A boolean representing whether or not the mock object has been called:"
msgstr "Логічне значення, яке вказує, чи було викликано макетний об’єкт:"

msgid "An integer telling you how many times the mock object has been called:"
msgstr ""
"Ціле число, яке повідомляє вам, скільки разів був викликаний макетний об’єкт:"

msgid "Set this to configure the value returned by calling the mock:"
msgstr ""
"Встановіть це, щоб налаштувати значення, що повертається викликом mock:"

msgid ""
"The default return value is a mock object and you can configure it in the "
"normal way:"
msgstr ""
"Типовим значенням, що повертається, є макет об’єкта, і ви можете налаштувати "
"його звичайним способом:"

msgid ":attr:`return_value` can also be set in the constructor:"
msgstr ":attr:`return_value` також можна встановити в конструкторі:"

msgid ""
"This can either be a function to be called when the mock is called, an "
"iterable or an exception (class or instance) to be raised."
msgstr ""
"Це може бути або функція, яку потрібно викликати під час виклику макета, "
"ітерація або виняток (клас або екземпляр), який потрібно викликати."

msgid ""
"If you pass in a function it will be called with same arguments as the mock "
"and unless the function returns the :data:`DEFAULT` singleton the call to "
"the mock will then return whatever the function returns. If the function "
"returns :data:`DEFAULT` then the mock will return its normal value (from "
"the :attr:`return_value`)."
msgstr ""
"Якщо ви передаєте функцію, вона буде викликана з тими самими аргументами, що "
"й макет, і якщо функція не повертає синглтон :data:`DEFAULT`, виклик макету "
"поверне те, що повертає функція. Якщо функція повертає :data:`DEFAULT`, "
"макет поверне своє нормальне значення (з :attr:`return_value`)."

msgid ""
"If you pass in an iterable, it is used to retrieve an iterator which must "
"yield a value on every call.  This value can either be an exception instance "
"to be raised, or a value to be returned from the call to the mock (:data:"
"`DEFAULT` handling is identical to the function case)."
msgstr ""
"Якщо ви передаєте ітератор, він використовується для отримання ітератора, "
"який повинен видавати значення під час кожного виклику. Це значення може "
"бути або екземпляром винятку, який буде створено, або значенням, яке буде "
"повернуто викликом mock (обробка :data:`DEFAULT` ідентична функції case)."

msgid ""
"An example of a mock that raises an exception (to test exception handling of "
"an API):"
msgstr ""
"Приклад макету, який викликає виняткову ситуацію (для перевірки обробки "
"винятків API):"

msgid "Using :attr:`side_effect` to return a sequence of values:"
msgstr "Використання :attr:`side_effect` для повернення послідовності значень:"

msgid "Using a callable:"
msgstr "Використання виклику:"

msgid ""
":attr:`side_effect` can be set in the constructor. Here's an example that "
"adds one to the value the mock is called with and returns it:"
msgstr ""
":attr:`side_effect` можна встановити в конструкторі. Ось приклад, який додає "
"одиницю до значення, з яким викликається макет, і повертає його:"

msgid "Setting :attr:`side_effect` to ``None`` clears it:"
msgstr "Встановлення :attr:`side_effect` на ``None`` очищає його:"

msgid ""
"This is either ``None`` (if the mock hasn't been called), or the arguments "
"that the mock was last called with. This will be in the form of a tuple: the "
"first member, which can also be accessed through the ``args`` property, is "
"any ordered arguments the mock was called with (or an empty tuple) and the "
"second member, which can also be accessed through the ``kwargs`` property, "
"is any keyword arguments (or an empty dictionary)."
msgstr ""
"Це або ``None`` (якщо макет не було викликано), або аргументи, з якими макет "
"було викликано востаннє. Це буде у формі кортежу: перший член, до якого "
"також можна отримати доступ через властивість ``args``, — це будь-які "
"впорядковані аргументи, з якими було викликано макет (або порожній кортеж), "
"а другий член, який може доступ також через властивість ``kwargs``, це будь-"
"які ключові аргументи (або порожній словник)."

msgid ""
":attr:`call_args`, along with members of the lists :attr:`call_args_list`, :"
"attr:`method_calls` and :attr:`mock_calls` are :data:`call` objects. These "
"are tuples, so they can be unpacked to get at the individual arguments and "
"make more complex assertions. See :ref:`calls as tuples <calls-as-tuples>`."
msgstr ""
":attr:`call_args` разом із членами списків :attr:`call_args_list`, :attr:"
"`method_calls` і :attr:`mock_calls` є об’єктами :data:`call`. Це кортежі, "
"тому їх можна розпакувати, щоб отримати окремі аргументи та зробити "
"складніші твердження. Перегляньте :ref:`виклики як кортежі <calls-as-"
"tuples>`."

msgid "Added ``args`` and ``kwargs`` properties."
msgstr "Додано властивості ``args`` і ``kwargs``."

msgid ""
"This is a list of all the calls made to the mock object in sequence (so the "
"length of the list is the number of times it has been called). Before any "
"calls have been made it is an empty list. The :data:`call` object can be "
"used for conveniently constructing lists of calls to compare with :attr:"
"`call_args_list`."
msgstr ""
"Це список усіх послідовних викликів макетного об’єкта (тому довжина списку — "
"це кількість викликів до нього). До здійснення будь-яких викликів це "
"порожній список. Об’єкт :data:`call` можна використовувати для зручного "
"створення списків викликів для порівняння з :attr:`call_args_list`."

msgid ""
"Members of :attr:`call_args_list` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
"Члени :attr:`call_args_list` є об’єктами :data:`call`. Їх можна розпакувати "
"як кортежі, щоб отримати окремі аргументи. Перегляньте :ref:`виклики як "
"кортежі <calls-as-tuples>`."

msgid ""
"As well as tracking calls to themselves, mocks also track calls to methods "
"and attributes, and *their* methods and attributes:"
msgstr ""
"Крім відстеження викликів самих себе, mocks також відстежують виклики "
"методів і атрибутів, а також *їх* методів і атрибутів:"

msgid ""
"Members of :attr:`method_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
"Члени :attr:`method_calls` є об’єктами :data:`call`. Їх можна розпакувати як "
"кортежі, щоб отримати окремі аргументи. Перегляньте :ref:`виклики як кортежі "
"<calls-as-tuples>`."

msgid ""
":attr:`mock_calls` records *all* calls to the mock object, its methods, "
"magic methods *and* return value mocks."
msgstr ""
":attr:`mock_calls` записує *всі* виклики макетного об’єкта, його методи, "
"чарівні методи *та* імітації значення, що повертається."

msgid ""
"Members of :attr:`mock_calls` are :data:`call` objects. These can be "
"unpacked as tuples to get at the individual arguments. See :ref:`calls as "
"tuples <calls-as-tuples>`."
msgstr ""
"Члени :attr:`mock_calls` є об’єктами :data:`call`. Їх можна розпакувати як "
"кортежі, щоб отримати окремі аргументи. Перегляньте :ref:`виклики як кортежі "
"<calls-as-tuples>`."

msgid ""
"The way :attr:`mock_calls` are recorded means that where nested calls are "
"made, the parameters of ancestor calls are not recorded and so will always "
"compare equal:"
msgstr ""
"Спосіб запису :attr:`mock_calls` означає, що там, де здійснюються вкладені "
"виклики, параметри викликів предків не записуються, тому порівняння завжди "
"буде рівним:"

msgid ""
"Normally the :attr:`__class__` attribute of an object will return its type. "
"For a mock object with a :attr:`spec`, ``__class__`` returns the spec class "
"instead. This allows mock objects to pass :func:`isinstance` tests for the "
"object they are replacing / masquerading as:"
msgstr ""
"Зазвичай атрибут :attr:`__class__` об’єкта повертає його тип. Для фіктивного "
"об’єкта зі специфікацією :attr:`spec` ``__class__`` замість цього повертає "
"клас специфікації. Це дозволяє фіктивним об’єктам проходити тести :func:"
"`isinstance` для об’єкта, який вони замінюють/маскують під:"

msgid ""
":attr:`__class__` is assignable to, this allows a mock to pass an :func:"
"`isinstance` check without forcing you to use a spec:"
msgstr ""
":attr:`__class__` можна призначити, це дозволяє макету проходити перевірку :"
"func:`isinstance`, не змушуючи вас використовувати специфікацію:"

msgid ""
"A non-callable version of :class:`Mock`. The constructor parameters have the "
"same meaning of :class:`Mock`, with the exception of *return_value* and "
"*side_effect* which have no meaning on a non-callable mock."
msgstr ""
"Версія :class:`Mock`, яка не викликається. Параметри конструктора мають те "
"саме значення, що й :class:`Mock`, за винятком *return_value* і "
"*side_effect*, які не мають значення для макету, який не викликається."

msgid ""
"Mock objects that use a class or an instance as a :attr:`spec` or :attr:"
"`spec_set` are able to pass :func:`isinstance` tests:"
msgstr ""
"Макетні об’єкти, які використовують клас або екземпляр як :attr:`spec` або :"
"attr:`spec_set`, можуть проходити :func:`isinstance` тести:"

msgid ""
"The :class:`Mock` classes have support for mocking magic methods. See :ref:"
"`magic methods <magic-methods>` for the full details."
msgstr ""
"Класи :class:`Mock` підтримують методи насміхуватої магії. Дивіться :ref:"
"`магічні методи <magic-methods>` для повної інформації."

msgid ""
"The mock classes and the :func:`patch` decorators all take arbitrary keyword "
"arguments for configuration. For the :func:`patch` decorators the keywords "
"are passed to the constructor of the mock being created. The keyword "
"arguments are for configuring attributes of the mock:"
msgstr ""
"Імітаційні класи та декоратори :func:`patch` приймають довільні ключові "
"аргументи для налаштування. Для декораторів :func:`patch` ключові слова "
"передаються до конструктора макета, який створюється. Ключові аргументи "
"призначені для налаштування атрибутів макета:"

msgid ""
"The return value and side effect of child mocks can be set in the same way, "
"using dotted notation. As you can't use dotted names directly in a call you "
"have to create a dictionary and unpack it using ``**``:"
msgstr ""
"Повернене значення та побічний ефект дочірніх імітацій можна встановити "
"таким же чином, використовуючи позначення з крапками. Оскільки ви не можете "
"використовувати імена з крапками безпосередньо у виклику, вам потрібно "
"створити словник і розпакувати його за допомогою ``**``:"

msgid ""
"A callable mock which was created with a *spec* (or a *spec_set*) will "
"introspect the specification object's signature when matching calls to the "
"mock.  Therefore, it can match the actual call's arguments regardless of "
"whether they were passed positionally or by name::"
msgstr ""
"Викликаний макет, створений за допомогою *spec* (або *spec_set*), перевіряє "
"підпис об’єкта специфікації під час зіставлення викликів з макетом. Таким "
"чином, він може відповідати фактичним аргументам виклику незалежно від того, "
"чи були вони передані позиційно чи за назвою::"

msgid ""
"This applies to :meth:`~Mock.assert_called_with`, :meth:`~Mock."
"assert_called_once_with`, :meth:`~Mock.assert_has_calls` and :meth:`~Mock."
"assert_any_call`.  When :ref:`auto-speccing`, it will also apply to method "
"calls on the mock object."
msgstr ""
"Це стосується :meth:`~Mock.assert_ called_with`, :meth:`~Mock.assert_ "
"called_once_with`, :meth:`~Mock.assert_has_calls` і :meth:`~Mock."
"assert_any_call`. Коли :ref:`auto-speccing`, це також застосовуватиметься до "
"викликів методів фіктивного об’єкта."

msgid "Added signature introspection on specced and autospecced mock objects."
msgstr ""
"Додано авторську перевірку підпису на специфіковані та автоматично "
"специфіковані макетні об’єкти."

msgid ""
"A mock intended to be used as a property, or other descriptor, on a class. :"
"class:`PropertyMock` provides :meth:`__get__` and :meth:`__set__` methods so "
"you can specify a return value when it is fetched."
msgstr ""
"Макет, призначений для використання як властивість або інший дескриптор "
"класу. :class:`PropertyMock` надає методи :meth:`__get__` і :meth:`__set__`, "
"щоб ви могли вказати повертане значення під час його отримання."

msgid ""
"Fetching a :class:`PropertyMock` instance from an object calls the mock, "
"with no args. Setting it calls the mock with the value being set. ::"
msgstr ""
"Отримання екземпляра :class:`PropertyMock` з об’єкта викликає макет без "
"аргументів. Його встановлення викликає макет із встановленим значенням. ::"

msgid ""
"Because of the way mock attributes are stored you can't directly attach a :"
"class:`PropertyMock` to a mock object. Instead you can attach it to the mock "
"type object::"
msgstr ""
"Через те, як зберігаються макетні атрибути, ви не можете безпосередньо "
"прикріпити :class:`PropertyMock` до макетного об’єкта. Замість цього ви "
"можете прикріпити його до об’єкта макетного типу::"

msgid ""
"An asynchronous version of :class:`MagicMock`. The :class:`AsyncMock` object "
"will behave so the object is recognized as an async function, and the result "
"of a call is an awaitable."
msgstr ""
"Асинхронна версія :class:`MagicMock`. Об’єкт :class:`AsyncMock` "
"поводитиметься таким чином, що об’єкт розпізнається як асинхронна функція, а "
"результат виклику є очікуваним."

msgid ""
"The result of ``mock()`` is an async function which will have the outcome of "
"``side_effect`` or ``return_value`` after it has been awaited:"
msgstr ""
"Результатом ``mock()`` є асинхронна функція, яка матиме результат "
"``side_effect`` або ``return_value`` після очікування:"

msgid ""
"if ``side_effect`` is a function, the async function will return the result "
"of that function,"
msgstr ""
"якщо ``side_effect`` є функцією, асинхронна функція поверне результат цієї "
"функції,"

msgid ""
"if ``side_effect`` is an exception, the async function will raise the "
"exception,"
msgstr "якщо ``side_effect`` є винятком, функція async викличе виняток,"

msgid ""
"if ``side_effect`` is an iterable, the async function will return the next "
"value of the iterable, however, if the sequence of result is exhausted, "
"``StopAsyncIteration`` is raised immediately,"
msgstr ""
"якщо ``side_effect`` є ітерованим, функція async поверне наступне значення "
"ітерованого, однак, якщо послідовність результатів вичерпана, "
"``StopAsyncIteration`` викликається негайно,"

msgid ""
"if ``side_effect`` is not defined, the async function will return the value "
"defined by ``return_value``, hence, by default, the async function returns a "
"new :class:`AsyncMock` object."
msgstr ""
"якщо ``side_effect`` не визначено, функція async поверне значення, визначене "
"``return_value``, отже, за замовчуванням функція async повертає новий "
"об’єкт :class:`AsyncMock`."

msgid ""
"Setting the *spec* of a :class:`Mock` or :class:`MagicMock` to an async "
"function will result in a coroutine object being returned after calling."
msgstr ""
"Встановлення *специфікації* :class:`Mock` або :class:`MagicMock` на "
"асинхронну функцію призведе до повернення об’єкта співпрограми після виклику."

msgid ""
"Setting the *spec* of a :class:`Mock`, :class:`MagicMock`, or :class:"
"`AsyncMock` to a class with asynchronous and synchronous functions will "
"automatically detect the synchronous functions and set them as :class:"
"`MagicMock` (if the parent mock is :class:`AsyncMock` or :class:`MagicMock`) "
"or :class:`Mock` (if the parent mock is :class:`Mock`). All asynchronous "
"functions will be :class:`AsyncMock`."
msgstr ""
"Встановлення *специфікації* :class:`Mock`, :class:`MagicMock` або :class:"
"`AsyncMock` для класу з асинхронними та синхронними функціями автоматично "
"визначить синхронні функції та встановить їх як :class:`MagicMock` (якщо "
"батьківським макетом є :class:`AsyncMock` або :class:`MagicMock`) або :class:"
"`Mock` (якщо батьківським макетом є :class:`Mock`). Усі асинхронні функції "
"будуть :class:`AsyncMock`."

msgid ""
"Assert that the mock was awaited at least once. Note that this is separate "
"from the object having been called, the ``await`` keyword must be used:"
msgstr ""
"Стверджуйте, що макету чекали хоча б раз. Зауважте, що це окремо від "
"викликаного об’єкта, необхідно використовувати ключове слово ``await``:"

msgid "Assert that the mock was awaited exactly once."
msgstr "Стверджують, що макет чекали рівно один раз."

msgid "Assert that the last await was with the specified arguments."
msgstr ""
"Підтвердження того, що останнє очікування було з указаними аргументами."

msgid ""
"Assert that the mock was awaited exactly once and with the specified "
"arguments."
msgstr ""
"Стверджуйте, що макет очікувався рівно один раз і з вказаними аргументами."

msgid "Assert the mock has ever been awaited with the specified arguments."
msgstr ""
"Стверджуйте, що макет коли-небудь був очікуваний із зазначеними аргументами."

msgid ""
"Assert the mock has been awaited with the specified calls. The :attr:"
"`await_args_list` list is checked for the awaits."
msgstr ""
"Стверджувати, що макет очікувався з указаними викликами. Список :attr:"
"`await_args_list` перевіряється на наявність очікувань."

msgid ""
"If *any_order* is false then the awaits must be sequential. There can be "
"extra calls before or after the specified awaits."
msgstr ""
"Якщо *any_order* має значення false, очікування мають бути послідовними. "
"Можуть бути додаткові виклики до або після вказаних очікувань."

msgid ""
"If *any_order* is true then the awaits can be in any order, but they must "
"all appear in :attr:`await_args_list`."
msgstr ""
"Якщо *any_order* має значення true, очікування можуть бути в будь-якому "
"порядку, але всі вони мають відображатися в :attr:`await_args_list`."

msgid "Assert that the mock was never awaited."
msgstr "Стверджують, що макет так і не дочекався."

msgid ""
"See :func:`Mock.reset_mock`. Also sets :attr:`await_count` to 0, :attr:"
"`await_args` to None, and clears the :attr:`await_args_list`."
msgstr ""
"Перегляньте :func:`Mock.reset_mock`. Також встановлює :attr:`await_count` на "
"0, :attr:`await_args` на None і очищає :attr:`await_args_list`."

msgid ""
"An integer keeping track of how many times the mock object has been awaited."
msgstr "Ціле число, яке відстежує, скільки разів очікувався макетний об’єкт."

msgid ""
"This is either ``None`` (if the mock hasn’t been awaited), or the arguments "
"that the mock was last awaited with. Functions the same as :attr:`Mock."
"call_args`."
msgstr ""
"Це або ``None`` (якщо макет не був очікуваний), або аргументи, з якими макет "
"було очікувано востаннє. Функціонує так само, як :attr:`Mock.call_args`."

msgid ""
"This is a list of all the awaits made to the mock object in sequence (so the "
"length of the list is the number of times it has been awaited). Before any "
"awaits have been made it is an empty list."
msgstr ""
"Це список усіх очікувань, зроблених для макетного об’єкта в послідовності "
"(тому довжина списку — це кількість разів, коли його очікували). Перш ніж "
"було зроблено будь-які очікування, це порожній список."

msgid "Calling"
msgstr "Дзвінок"

msgid ""
"Mock objects are callable. The call will return the value set as the :attr:"
"`~Mock.return_value` attribute. The default return value is a new Mock "
"object; it is created the first time the return value is accessed (either "
"explicitly or by calling the Mock) - but it is stored and the same one "
"returned each time."
msgstr ""
"Фіктивні об'єкти можна викликати. Виклик поверне значення, встановлене як "
"атрибут :attr:`~Mock.return_value`. Типовим значенням, що повертається, є "
"новий об’єкт Mock; воно створюється під час першого доступу до значення, що "
"повертається (явним чином або шляхом виклику Mock), але воно зберігається й "
"кожного разу повертається те саме."

msgid ""
"Calls made to the object will be recorded in the attributes like :attr:"
"`~Mock.call_args` and :attr:`~Mock.call_args_list`."
msgstr ""
"Виклики, здійснені до об’єкта, будуть записані в такі атрибути, як :attr:"
"`~Mock.call_args` і :attr:`~Mock.call_args_list`."

msgid ""
"If :attr:`~Mock.side_effect` is set then it will be called after the call "
"has been recorded, so if :attr:`side_effect` raises an exception the call is "
"still recorded."
msgstr ""
"Якщо встановлено :attr:`~Mock.side_effect`, він буде викликаний після запису "
"виклику, отже, якщо :attr:`side_effect` викликає виняток, виклик усе одно "
"записується."

msgid ""
"The simplest way to make a mock raise an exception when called is to make :"
"attr:`~Mock.side_effect` an exception class or instance:"
msgstr ""
"Найпростіший спосіб змусити макет викликати виняток під час виклику — це "
"зробити :attr:`~Mock.side_effect` класом або екземпляром виключення:"

msgid ""
"If :attr:`side_effect` is a function then whatever that function returns is "
"what calls to the mock return. The :attr:`side_effect` function is called "
"with the same arguments as the mock. This allows you to vary the return "
"value of the call dynamically, based on the input:"
msgstr ""
"Якщо :attr:`side_effect` є функцією, то те, що повертає ця функція, викликає "
"імітацію повернення. Функція :attr:`side_effect` викликається з тими самими "
"аргументами, що й макет. Це дозволяє динамічно змінювати значення, що "
"повертається викликом, на основі вхідних даних:"

msgid ""
"If you want the mock to still return the default return value (a new mock), "
"or any set return value, then there are two ways of doing this. Either "
"return :attr:`mock.return_value` from inside :attr:`side_effect`, or return :"
"data:`DEFAULT`:"
msgstr ""
"Якщо ви хочете, щоб макет усе ще повертав типове значення, що повертається "
"(новий макет), або будь-яке встановлене повертається значення, то є два "
"способи зробити це. Або поверніть :attr:`mock.return_value` зсередини :attr:"
"`side_effect`, або поверніть :data:`DEFAULT`:"

msgid ""
"To remove a :attr:`side_effect`, and return to the default behaviour, set "
"the :attr:`side_effect` to ``None``:"
msgstr ""
"Щоб видалити :attr:`side_effect` і повернутися до типової поведінки, "
"установіть :attr:`side_effect` значення ``None``:"

msgid ""
"The :attr:`side_effect` can also be any iterable object. Repeated calls to "
"the mock will return values from the iterable (until the iterable is "
"exhausted and a :exc:`StopIteration` is raised):"
msgstr ""
":attr:`side_effect` також може бути будь-яким ітерованим об’єктом. Повторні "
"виклики mock повертатимуть значення з iterable (поки iterable не буде "
"вичерпано та не буде викликано :exc:`StopIteration`):"

msgid ""
"If any members of the iterable are exceptions they will be raised instead of "
"returned::"
msgstr ""
"Якщо будь-які члени iterable є винятками, вони будуть викликані замість "
"повернення::"

msgid "Deleting Attributes"
msgstr "Видалення атрибутів"

msgid ""
"Mock objects create attributes on demand. This allows them to pretend to be "
"objects of any type."
msgstr ""
"Макетні об’єкти створюють атрибути на вимогу. Це дозволяє їм видавати себе "
"за об’єкти будь-якого типу."

msgid ""
"You may want a mock object to return ``False`` to a :func:`hasattr` call, or "
"raise an :exc:`AttributeError` when an attribute is fetched. You can do this "
"by providing an object as a :attr:`spec` for a mock, but that isn't always "
"convenient."
msgstr ""
"Ви можете захотіти, щоб імітаційний об’єкт повертав ``False`` виклику :func:"
"`hasattr` або викликав :exc:`AttributeError`, коли атрибут отримується. Ви "
"можете зробити це, надавши об’єкт як :attr:`spec` для макету, але це не "
"завжди зручно."

msgid ""
"You \"block\" attributes by deleting them. Once deleted, accessing an "
"attribute will raise an :exc:`AttributeError`."
msgstr ""
"Ви \"блокуєте\" атрибути, видаляючи їх. Після видалення доступ до атрибута "
"викличе :exc:`AttributeError`."

msgid "Mock names and the name attribute"
msgstr "Макетні назви та атрибут name"

msgid ""
"Since \"name\" is an argument to the :class:`Mock` constructor, if you want "
"your mock object to have a \"name\" attribute you can't just pass it in at "
"creation time. There are two alternatives. One option is to use :meth:`~Mock."
"configure_mock`::"
msgstr ""
"Оскільки \"name\" є аргументом конструктора :class:`Mock`, якщо ви хочете, "
"щоб ваш макетний об’єкт мав атрибут \"name\", ви не можете просто передати "
"його під час створення. Є дві альтернативи. Одним із варіантів є "
"використання :meth:`~Mock.configure_mock`::"

msgid ""
"A simpler option is to simply set the \"name\" attribute after mock "
"creation::"
msgstr ""
"Простішим варіантом є просто встановити атрибут \"name\" після створення "
"макета::"

msgid "Attaching Mocks as Attributes"
msgstr "Додавання макетів як атрибутів"

msgid ""
"When you attach a mock as an attribute of another mock (or as the return "
"value) it becomes a \"child\" of that mock. Calls to the child are recorded "
"in the :attr:`~Mock.method_calls` and :attr:`~Mock.mock_calls` attributes of "
"the parent. This is useful for configuring child mocks and then attaching "
"them to the parent, or for attaching mocks to a parent that records all "
"calls to the children and allows you to make assertions about the order of "
"calls between mocks:"
msgstr ""
"Коли ви додаєте макет як атрибут іншого макету (або як значення, що "
"повертається), він стає \"дочірнім\" для цього макету. Виклики дочірнього "
"елемента записуються в атрибутах :attr:`~Mock.method_calls` і :attr:`~Mock."
"mock_calls` батьківського. Це корисно для конфігурації дочірніх імітацій, а "
"потім прикріплення їх до батьківського, або для прикріплення імітацій до "
"батьківського, який записує всі виклики до нащадків і дозволяє вам робити "
"твердження щодо порядку викликів між імітаціями:"

msgid ""
"The exception to this is if the mock has a name. This allows you to prevent "
"the \"parenting\" if for some reason you don't want it to happen."
msgstr ""
"Винятком є випадки, коли макет має назву. Це дозволяє запобігти "
"\"батьківству\", якщо з якихось причин ви цього не хочете."

msgid ""
"Mocks created for you by :func:`patch` are automatically given names. To "
"attach mocks that have names to a parent you use the :meth:`~Mock."
"attach_mock` method::"
msgstr ""
"Макети, створені для вас :func:`patch`, автоматично отримують імена. Щоб "
"приєднати імена до батьківського елемента, ви використовуєте метод :meth:"
"`~Mock.attach_mock`::"

msgid ""
"The only exceptions are magic methods and attributes (those that have "
"leading and trailing double underscores). Mock doesn't create these but "
"instead raises an :exc:`AttributeError`. This is because the interpreter "
"will often implicitly request these methods, and gets *very* confused to get "
"a new Mock object when it expects a magic method. If you need magic method "
"support see :ref:`magic methods <magic-methods>`."
msgstr ""
"Єдиний виняток становлять магічні методи та атрибути (ті, що мають на "
"початку та в кінці подвійне підкреслення). Mock не створює їх, а натомість "
"викликає :exc:`AttributeError`. Це пояснюється тим, що інтерпретатор часто "
"неявно запитує ці методи і *дуже* плутається, коли отримує новий об’єкт "
"Mock, коли очікує чарівний метод. Якщо вам потрібна підтримка магічних "
"методів, перегляньте :ref:`магічні методи <magic-methods>`."

msgid "The patchers"
msgstr "Патчери"

msgid ""
"The patch decorators are used for patching objects only within the scope of "
"the function they decorate. They automatically handle the unpatching for "
"you, even if exceptions are raised. All of these functions can also be used "
"in with statements or as class decorators."
msgstr ""
"Декоратори латок використовуються для латання об’єктів лише в межах функції, "
"яку вони декорують. Вони автоматично виконують видалення виправлень за вас, "
"навіть якщо виникають винятки. Усі ці функції також можна використовувати в "
"операторах або як декоратори класів."

msgid "patch"
msgstr "патч"

msgid ""
"The key is to do the patching in the right namespace. See the section `where "
"to patch`_."
msgstr ""
"Головне — виконати виправлення у правильному просторі імен. Дивіться розділ "
"`where to patch`_."

msgid ""
":func:`patch` acts as a function decorator, class decorator or a context "
"manager. Inside the body of the function or with statement, the *target* is "
"patched with a *new* object. When the function/with statement exits the "
"patch is undone."
msgstr ""
":func:`patch` діє як декоратор функції, декоратор класу або менеджер "
"контексту. Усередині тіла функції або оператора *ціль* додається до *нового* "
"об’єкта. Коли оператор function/with завершує роботу, патч скасовується."

msgid ""
"If *new* is omitted, then the target is replaced with an :class:`AsyncMock` "
"if the patched object is an async function or a :class:`MagicMock` "
"otherwise. If :func:`patch` is used as a decorator and *new* is omitted, the "
"created mock is passed in as an extra argument to the decorated function. "
"If :func:`patch` is used as a context manager the created mock is returned "
"by the context manager."
msgstr ""
"Якщо *new* пропущено, ціль замінюється на :class:`AsyncMock`, якщо "
"виправлений об’єкт є асинхронною функцією, або :class:`MagicMock` інакше. "
"Якщо :func:`patch` використовується як декоратор, а *new* опущено, створений "
"макет передається як додатковий аргумент до декорованої функції. Якщо :func:"
"`patch` використовується як менеджер контексту, створений макет повертається "
"менеджером контексту."

msgid ""
"*target* should be a string in the form ``'package.module.ClassName'``. The "
"*target* is imported and the specified object replaced with the *new* "
"object, so the *target* must be importable from the environment you are "
"calling :func:`patch` from. The target is imported when the decorated "
"function is executed, not at decoration time."
msgstr ""
"*ціль* має бути рядком у формі ``'package.module.ClassName``. *Ціль* "
"імпортується, а вказаний об’єкт замінюється на *новий* об’єкт, тому *ціль* "
"має бути імпортованою із середовища, з якого ви викликаєте :func:`patch`. "
"Ціль імпортується під час виконання декорованої функції, а не під час "
"декорування."

msgid ""
"The *spec* and *spec_set* keyword arguments are passed to the :class:"
"`MagicMock` if patch is creating one for you."
msgstr ""
"Ключові аргументи *spec* і *spec_set* передаються в :class:`MagicMock`, якщо "
"patch створює його для вас."

msgid ""
"In addition you can pass ``spec=True`` or ``spec_set=True``, which causes "
"patch to pass in the object being mocked as the spec/spec_set object."
msgstr ""
"Крім того, ви можете передати ``spec=True`` або ``spec_set=True``, що "
"спричиняє передачу латки в об’єкті, який імітується, як об’єкт spec/spec_set."

msgid ""
"*new_callable* allows you to specify a different class, or callable object, "
"that will be called to create the *new* object. By default :class:"
"`AsyncMock` is used for async functions and :class:`MagicMock` for the rest."
msgstr ""
"*new_callable* дозволяє вказати інший клас або викликаний об’єкт, який буде "
"викликано для створення *нового* об’єкта. За замовчуванням :class:"
"`AsyncMock` використовується для асинхронних функцій, а :class:`MagicMock` "
"для решти."

msgid ""
"A more powerful form of *spec* is *autospec*. If you set ``autospec=True`` "
"then the mock will be created with a spec from the object being replaced. "
"All attributes of the mock will also have the spec of the corresponding "
"attribute of the object being replaced. Methods and functions being mocked "
"will have their arguments checked and will raise a :exc:`TypeError` if they "
"are called with the wrong signature. For mocks replacing a class, their "
"return value (the 'instance') will have the same spec as the class. See the :"
"func:`create_autospec` function and :ref:`auto-speccing`."
msgstr ""
"Більш потужною формою *spec* є *autospec*. Якщо ви встановите "
"``autospec=True``, макет буде створено зі специфікацією об’єкта, який "
"замінюється. Усі атрибути макета також матимуть специфікацію відповідного "
"атрибута об’єкта, який замінюється. Методи та функції, які знущаються, "
"перевірятимуть аргументи та викличуть :exc:`TypeError`, якщо вони викликані "
"з неправильним підписом. Для моків, які замінюють клас, їх значення, що "
"повертається (\"екземпляр\") матиме ту саму специфікацію, що й клас. "
"Перегляньте функцію :func:`create_autospec` і :ref:`auto-speccing`."

msgid ""
"Instead of ``autospec=True`` you can pass ``autospec=some_object`` to use an "
"arbitrary object as the spec instead of the one being replaced."
msgstr ""
"Замість ``autospec=True`` ви можете передати ``autospec=some_object``, щоб "
"використовувати довільний об’єкт як специфікацію замість того, що "
"замінюється."

msgid ""
"By default :func:`patch` will fail to replace attributes that don't exist. "
"If you pass in ``create=True``, and the attribute doesn't exist, patch will "
"create the attribute for you when the patched function is called, and delete "
"it again after the patched function has exited. This is useful for writing "
"tests against attributes that your production code creates at runtime. It is "
"off by default because it can be dangerous. With it switched on you can "
"write passing tests against APIs that don't actually exist!"
msgstr ""
"За замовчуванням :func:`patch` не зможе замінити атрибути, яких не існує. "
"Якщо ви передаєте ``create=True``, а атрибут не існує, patch створить "
"атрибут для вас під час виклику виправленої функції та видалить його знову "
"після завершення виправленої функції. Це корисно для написання тестів щодо "
"атрибутів, які ваш робочий код створює під час виконання. За умовчанням його "
"вимкнено, оскільки це може бути небезпечно. Якщо його ввімкнути, ви можете "
"писати тести проходження проти API, яких насправді не існує!"

msgid ""
"If you are patching builtins in a module then you don't need to pass "
"``create=True``, it will be added by default."
msgstr ""
"Якщо ви виправляєте вбудовані компоненти в модулі, вам не потрібно "
"передавати ``create=True``, він буде доданий за замовчуванням."

msgid ""
"Patch can be used as a :class:`TestCase` class decorator. It works by "
"decorating each test method in the class. This reduces the boilerplate code "
"when your test methods share a common patchings set. :func:`patch` finds "
"tests by looking for method names that start with ``patch.TEST_PREFIX``. By "
"default this is ``'test'``, which matches the way :mod:`unittest` finds "
"tests. You can specify an alternative prefix by setting ``patch."
"TEST_PREFIX``."
msgstr ""
"Патч можна використовувати як декоратор класу :class:`TestCase`. Він працює, "
"прикрашаючи кожен метод тестування в класі. Це зменшує шаблонний код, коли "
"ваші методи тестування мають загальний набір виправлень. :func:`patch` "
"знаходить тести, шукаючи назви методів, які починаються з ``patch."
"TEST_PREFIX``. За замовчуванням це ``'test'``, що відповідає способу, яким :"
"mod:`unittest` знаходить тести. Ви можете вказати альтернативний префікс, "
"встановивши ``patch.TEST_PREFIX``."

msgid ""
"Patch can be used as a context manager, with the with statement. Here the "
"patching applies to the indented block after the with statement. If you use "
"\"as\" then the patched object will be bound to the name after the \"as\"; "
"very useful if :func:`patch` is creating a mock object for you."
msgstr ""
"Патч можна використовувати як менеджер контексту за допомогою оператора "
"with. Тут виправлення застосовується до блоку з відступом після оператора "
"with. Якщо ви використовуєте \"as\", тоді виправлений об’єкт буде "
"прив’язаний до імені після \"as\"; дуже корисно, якщо :func:`patch` створює "
"для вас макет об’єкта."

msgid ""
":func:`patch` takes arbitrary keyword arguments. These will be passed to :"
"class:`AsyncMock` if the patched object is asynchronous, to :class:"
"`MagicMock` otherwise or to *new_callable* if specified."
msgstr ""
":func:`patch` приймає довільні ключові аргументи. Вони будуть передані до :"
"class:`AsyncMock`, якщо виправлений об’єкт є асинхронним, до :class:"
"`MagicMock` інакше або до *new_callable*, якщо вказано."

msgid ""
"``patch.dict(...)``, ``patch.multiple(...)`` and ``patch.object(...)`` are "
"available for alternate use-cases."
msgstr ""
"``patch.dict(...)``, ``patch.multiple(...)`` і ``patch.object(...)`` "
"доступні для альтернативних варіантів використання."

msgid ""
":func:`patch` as function decorator, creating the mock for you and passing "
"it into the decorated function::"
msgstr ""
":func:`patch` як декоратор функції, створює макет для вас і передає його в "
"декоровану функцію::"

msgid ""
"Patching a class replaces the class with a :class:`MagicMock` *instance*. If "
"the class is instantiated in the code under test then it will be the :attr:"
"`~Mock.return_value` of the mock that will be used."
msgstr ""
"Виправлення класу замінює клас на *екземпляр* :class:`MagicMock`. Якщо "
"екземпляр класу створено в тестованому коді, тоді використовуватиметься :"
"attr:`~Mock.return_value` макету."

msgid ""
"If the class is instantiated multiple times you could use :attr:`~Mock."
"side_effect` to return a new mock each time. Alternatively you can set the "
"*return_value* to be anything you want."
msgstr ""
"Якщо екземпляр класу створюється кілька разів, ви можете використовувати :"
"attr:`~Mock.side_effect`, щоб щоразу повертати новий макет. Крім того, ви "
"можете встановити *return_value* як будь-яке значення."

msgid ""
"To configure return values on methods of *instances* on the patched class "
"you must do this on the :attr:`return_value`. For example::"
msgstr ""
"Щоб налаштувати значення, що повертаються для методів *екземплярів* у "
"виправленому класі, ви повинні зробити це в :attr:`return_value`. Наприклад::"

msgid ""
"If you use *spec* or *spec_set* and :func:`patch` is replacing a *class*, "
"then the return value of the created mock will have the same spec. ::"
msgstr ""
"Якщо ви використовуєте *spec* або *spec_set* і :func:`patch` замінює *клас*, "
"тоді значення, що повертається створеним макетом, матиме ту саму "
"специфікацію. ::"

msgid ""
"The *new_callable* argument is useful where you want to use an alternative "
"class to the default :class:`MagicMock` for the created mock. For example, "
"if you wanted a :class:`NonCallableMock` to be used::"
msgstr ""
"Аргумент *new_callable* корисний, якщо ви хочете використовувати клас, "
"альтернативний типовому :class:`MagicMock` для створеного макету. Наприклад, "
"якщо ви хочете використовувати :class:`NonCallableMock`:"

msgid ""
"Another use case might be to replace an object with an :class:`io.StringIO` "
"instance::"
msgstr ""
"Іншим варіантом використання може бути заміна об’єкта екземпляром :class:`io."
"StringIO`::"

msgid ""
"When :func:`patch` is creating a mock for you, it is common that the first "
"thing you need to do is to configure the mock. Some of that configuration "
"can be done in the call to patch. Any arbitrary keywords you pass into the "
"call will be used to set attributes on the created mock::"
msgstr ""
"Коли :func:`patch` створює для вас макет, зазвичай перше, що вам потрібно "
"зробити, це налаштувати макет. Частину цієї конфігурації можна виконати під "
"час виклику patch. Будь-які довільні ключові слова, які ви передаєте у "
"виклик, використовуватимуться для встановлення атрибутів створеного mock::"

msgid ""
"As well as attributes on the created mock attributes, like the :attr:`~Mock."
"return_value` and :attr:`~Mock.side_effect`, of child mocks can also be "
"configured. These aren't syntactically valid to pass in directly as keyword "
"arguments, but a dictionary with these as keys can still be expanded into a :"
"func:`patch` call using ``**``::"
msgstr ""
"Крім атрибутів у створених макетних атрибутах, таких як :attr:`~Mock."
"return_value` і :attr:`~Mock.side_effect`, дочірніх макетів також можна "
"налаштувати. Вони не є синтаксично дійсними для безпосередньої передачі як "
"аргументи ключового слова, але словник із ними як ключами все одно можна "
"розгорнути у виклик :func:`patch` за допомогою ``**``::"

msgid ""
"By default, attempting to patch a function in a module (or a method or an "
"attribute in a class) that does not exist will fail with :exc:"
"`AttributeError`::"
msgstr ""
"За замовчуванням спроба виправити функцію в модулі (або метод чи атрибут у "
"класі), який не існує, закінчиться помилкою з :exc:`AttributeError`::"

msgid ""
"but adding ``create=True`` in the call to :func:`patch` will make the "
"previous example work as expected::"
msgstr ""
"але додавання ``create=True`` до виклику :func:`patch` змусить попередній "
"приклад працювати належним чином::"

msgid ""
":func:`patch` now returns an :class:`AsyncMock` if the target is an async "
"function."
msgstr ""
":func:`patch` тепер повертає :class:`AsyncMock`, якщо метою є асинхронна "
"функція."

msgid "patch.object"
msgstr "patch.object"

msgid ""
"patch the named member (*attribute*) on an object (*target*) with a mock "
"object."
msgstr ""
"заправити названий член (*атрибут*) на об’єкті (*ціль*) за допомогою "
"макетного об’єкта."

msgid ""
":func:`patch.object` can be used as a decorator, class decorator or a "
"context manager. Arguments *new*, *spec*, *create*, *spec_set*, *autospec* "
"and *new_callable* have the same meaning as for :func:`patch`. Like :func:"
"`patch`, :func:`patch.object` takes arbitrary keyword arguments for "
"configuring the mock object it creates."
msgstr ""
":func:`patch.object` можна використовувати як декоратор, декоратор класу або "
"менеджер контексту. Аргументи *new*, *spec*, *create*, *spec_set*, "
"*autospec* і *new_callable* мають те саме значення, що й для :func:`patch`. "
"Подібно до :func:`patch`, :func:`patch.object` приймає довільні ключові "
"аргументи для налаштування макетного об’єкта, який він створює."

msgid ""
"When used as a class decorator :func:`patch.object` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"При використанні як декоратора класу :func:`patch.object` враховує ``patch."
"TEST_PREFIX`` для вибору методів для обгортання."

msgid ""
"You can either call :func:`patch.object` with three arguments or two "
"arguments. The three argument form takes the object to be patched, the "
"attribute name and the object to replace the attribute with."
msgstr ""
"Ви можете викликати :func:`patch.object` з трьома або двома аргументами. "
"Форма з трьома аргументами містить об’єкт, який потрібно виправити, ім’я "
"атрибута та об’єкт, на який потрібно замінити атрибут."

msgid ""
"When calling with the two argument form you omit the replacement object, and "
"a mock is created for you and passed in as an extra argument to the "
"decorated function:"
msgstr ""
"Під час виклику з формою з двома аргументами ви пропускаєте об’єкт заміни, і "
"для вас створюється макет, який передається як додатковий аргумент до "
"декорованої функції:"

msgid ""
"*spec*, *create* and the other arguments to :func:`patch.object` have the "
"same meaning as they do for :func:`patch`."
msgstr ""
"*spec*, *create* та інші аргументи для :func:`patch.object` мають те саме "
"значення, що й для :func:`patch`."

msgid "patch.dict"
msgstr "patch.dict"

msgid ""
"Patch a dictionary, or dictionary like object, and restore the dictionary to "
"its original state after the test."
msgstr ""
"Виправте словник або об’єкт, схожий на словник, і відновіть словник до "
"початкового стану після тесту."

msgid ""
"*in_dict* can be a dictionary or a mapping like container. If it is a "
"mapping then it must at least support getting, setting and deleting items "
"plus iterating over keys."
msgstr ""
"*in_dict* може бути словником або контейнером, схожим на відображення. Якщо "
"це відображення, то воно повинно принаймні підтримувати отримання, "
"встановлення та видалення елементів, а також ітерацію по ключах."

msgid ""
"*in_dict* can also be a string specifying the name of the dictionary, which "
"will then be fetched by importing it."
msgstr ""
"*in_dict* також може бути рядком, що визначає назву словника, який потім "
"буде отримано шляхом його імпорту."

msgid ""
"*values* can be a dictionary of values to set in the dictionary. *values* "
"can also be an iterable of ``(key, value)`` pairs."
msgstr ""
"*values* може бути словником значень для встановлення в словнику. *значення* "
"також можуть бути повторюваними парами ``(ключ, значення)``."

msgid ""
"If *clear* is true then the dictionary will be cleared before the new values "
"are set."
msgstr ""
"Якщо *clear* має значення true, словник буде очищено перед встановленням "
"нових значень."

msgid ""
":func:`patch.dict` can also be called with arbitrary keyword arguments to "
"set values in the dictionary."
msgstr ""
":func:`patch.dict` також можна викликати з довільними ключовими аргументами "
"для встановлення значень у словнику."

msgid ""
":func:`patch.dict` now returns the patched dictionary when used as a context "
"manager."
msgstr ""
":func:`patch.dict` тепер повертає виправлений словник, коли використовується "
"як менеджер контексту."

msgid ""
":func:`patch.dict` can be used as a context manager, decorator or class "
"decorator:"
msgstr ""
":func:`patch.dict` можна використовувати як контекстний менеджер, декоратор "
"або декоратор класу:"

msgid ""
"When used as a class decorator :func:`patch.dict` honours ``patch."
"TEST_PREFIX`` (default to ``'test'``) for choosing which methods to wrap:"
msgstr ""
"Коли використовується як декоратор класу, :func:`patch.dict` враховує "
"``patch.TEST_PREFIX`` (за замовчуванням ``'test'``) для вибору методів для "
"обгортання:"

msgid ""
"If you want to use a different prefix for your test, you can inform the "
"patchers of the different prefix by setting ``patch.TEST_PREFIX``. For more "
"details about how to change the value of see :ref:`test-prefix`."
msgstr ""
"Якщо ви хочете використовувати інший префікс для свого тесту, ви можете "
"повідомити патчерів про інший префікс, встановивши ``patch.TEST_PREFIX``. "
"Докладніше про те, як змінити значення див. :ref:`test-prefix`."

msgid ""
":func:`patch.dict` can be used to add members to a dictionary, or simply let "
"a test change a dictionary, and ensure the dictionary is restored when the "
"test ends."
msgstr ""
":func:`patch.dict` можна використовувати для додавання членів до словника "
"або просто дозволити тесту змінити словник і переконатися, що словник буде "
"відновлено після завершення тесту."

msgid ""
"Keywords can be used in the :func:`patch.dict` call to set values in the "
"dictionary:"
msgstr ""
"Ключові слова можна використовувати у виклику :func:`patch.dict` для "
"встановлення значень у словнику:"

msgid ""
":func:`patch.dict` can be used with dictionary like objects that aren't "
"actually dictionaries. At the very minimum they must support item getting, "
"setting, deleting and either iteration or membership test. This corresponds "
"to the magic methods :meth:`__getitem__`, :meth:`__setitem__`, :meth:"
"`__delitem__` and either :meth:`__iter__` or :meth:`__contains__`."
msgstr ""
":func:`patch.dict` можна використовувати з об’єктами, подібними до "
"словників, які насправді не є словниками. Як мінімум, вони повинні "
"підтримувати отримання, налаштування, видалення елементів і або ітерацію, "
"або перевірку членства. Це відповідає магічним методам :meth:`__getitem__`, :"
"meth:`__setitem__`, :meth:`__delitem__` і :meth:`__iter__` або :meth:"
"`__contains__`."

msgid "patch.multiple"
msgstr "patch.multiple"

msgid ""
"Perform multiple patches in a single call. It takes the object to be patched "
"(either as an object or a string to fetch the object by importing) and "
"keyword arguments for the patches::"
msgstr ""
"Виконайте кілька патчів за один виклик. Він приймає об’єкт, який потрібно "
"виправити (або як об’єкт, або рядок для отримання об’єкта шляхом імпорту), а "
"також ключові аргументи для патчів::"

msgid ""
"Use :data:`DEFAULT` as the value if you want :func:`patch.multiple` to "
"create mocks for you. In this case the created mocks are passed into a "
"decorated function by keyword, and a dictionary is returned when :func:"
"`patch.multiple` is used as a context manager."
msgstr ""
"Використовуйте :data:`DEFAULT` як значення, якщо ви хочете, щоб :func:`patch."
"multiple` створював для вас макети. У цьому випадку створені макети "
"передаються в декоровану функцію за ключовим словом, а словник повертається, "
"коли :func:`patch.multiple` використовується як менеджер контексту."

msgid ""
":func:`patch.multiple` can be used as a decorator, class decorator or a "
"context manager. The arguments *spec*, *spec_set*, *create*, *autospec* and "
"*new_callable* have the same meaning as for :func:`patch`. These arguments "
"will be applied to *all* patches done by :func:`patch.multiple`."
msgstr ""
":func:`patch.multiple` можна використовувати як декоратор, декоратор класу "
"або менеджер контексту. Аргументи *spec*, *spec_set*, *create*, *autospec* і "
"*new_callable* мають те саме значення, що й для :func:`patch`. Ці аргументи "
"будуть застосовані до *всіх* патчів, створених :func:`patch.multiple`."

msgid ""
"When used as a class decorator :func:`patch.multiple` honours ``patch."
"TEST_PREFIX`` for choosing which methods to wrap."
msgstr ""
"При використанні як декоратор класу :func:`patch.multiple` враховує ``patch."
"TEST_PREFIX`` для вибору методів для обгортання."

msgid ""
"If you want :func:`patch.multiple` to create mocks for you, then you can "
"use :data:`DEFAULT` as the value. If you use :func:`patch.multiple` as a "
"decorator then the created mocks are passed into the decorated function by "
"keyword. ::"
msgstr ""
"Якщо ви хочете, щоб :func:`patch.multiple` створював для вас макети, ви "
"можете використовувати :data:`DEFAULT` як значення. Якщо ви використовуєте :"
"func:`patch.multiple` як декоратор, тоді створені макети передаються в "
"декоровану функцію за ключовим словом. ::"

msgid ""
":func:`patch.multiple` can be nested with other ``patch`` decorators, but "
"put arguments passed by keyword *after* any of the standard arguments "
"created by :func:`patch`::"
msgstr ""
":func:`patch.multiple` можна вкладати в інші декоратори ``patch``, але "
"розміщувати аргументи, передані ключовим словом *після* будь-яких "
"стандартних аргументів, створених :func:`patch`::"

msgid ""
"If :func:`patch.multiple` is used as a context manager, the value returned "
"by the context manager is a dictionary where created mocks are keyed by "
"name::"
msgstr ""
"Якщо :func:`patch.multiple` використовується як менеджер контексту, "
"значення, яке повертає менеджер контексту, є словником, у якому створені "
"макети вказуються за назвою::"

msgid "patch methods: start and stop"
msgstr "методи латання: запуск і зупинка"

msgid ""
"All the patchers have :meth:`start` and :meth:`stop` methods. These make it "
"simpler to do patching in ``setUp`` methods or where you want to do multiple "
"patches without nesting decorators or with statements."
msgstr ""
"Усі патчери мають методи :meth:`start` і :meth:`stop`. Це спрощує виконання "
"виправлень у методах ``setUp`` або там, де потрібно виконати кілька латок "
"без декораторів вкладення або за допомогою операторів."

msgid ""
"To use them call :func:`patch`, :func:`patch.object` or :func:`patch.dict` "
"as normal and keep a reference to the returned ``patcher`` object. You can "
"then call :meth:`start` to put the patch in place and :meth:`stop` to undo "
"it."
msgstr ""
"Щоб використати їх, викличте :func:`patch`, :func:`patch.object` або :func:"
"`patch.dict` як зазвичай і збережіть посилання на повернутий об’єкт "
"``patcher``. Потім ви можете викликати :meth:`start`, щоб поставити патч на "
"місце, і :meth:`stop`, щоб скасувати його."

msgid ""
"If you are using :func:`patch` to create a mock for you then it will be "
"returned by the call to ``patcher.start``. ::"
msgstr ""
"Якщо ви використовуєте :func:`patch` для створення макету, його буде "
"повернено викликом ``patcher.start``. ::"

msgid ""
"A typical use case for this might be for doing multiple patches in the "
"``setUp`` method of a :class:`TestCase`::"
msgstr ""
"Типовим випадком використання для цього може бути виконання кількох патчів у "
"методі ``setUp`` :class:`TestCase`::"

msgid ""
"If you use this technique you must ensure that the patching is \"undone\" by "
"calling ``stop``. This can be fiddlier than you might think, because if an "
"exception is raised in the ``setUp`` then ``tearDown`` is not called. :meth:"
"`unittest.TestCase.addCleanup` makes this easier::"
msgstr ""
"Якщо ви використовуєте цю техніку, ви повинні переконатися, що виправлення "
"\"скасовано\", викликавши ``stop``. Це може бути складніше, ніж ви могли б "
"подумати, оскільки якщо в ``setUp`` виникає виняток, ``tearDown`` не "
"викликається. :meth:`unittest.TestCase.addCleanup` полегшує це::"

msgid ""
"As an added bonus you no longer need to keep a reference to the ``patcher`` "
"object."
msgstr ""
"Як додатковий бонус, вам більше не потрібно зберігати посилання на об’єкт "
"``patcher``."

msgid ""
"It is also possible to stop all patches which have been started by using :"
"func:`patch.stopall`."
msgstr ""
"Також можна зупинити всі запущені латки за допомогою :func:`patch.stopall`."

msgid "Stop all active patches. Only stops patches started with ``start``."
msgstr "Зупинити всі активні патчі. Зупиняє лише патчі, розпочаті з ``start``."

msgid "patch builtins"
msgstr "вбудовані виправлення"

msgid ""
"You can patch any builtins within a module. The following example patches "
"builtin :func:`ord`::"
msgstr ""
"Ви можете виправляти будь-які вбудовані компоненти в модулі. Наступні "
"приклади патчів вбудовані в :func:`ord`::"

msgid "TEST_PREFIX"
msgstr "TEST_PREFIX"

msgid ""
"All of the patchers can be used as class decorators. When used in this way "
"they wrap every test method on the class. The patchers recognise methods "
"that start with ``'test'`` as being test methods. This is the same way that "
"the :class:`unittest.TestLoader` finds test methods by default."
msgstr ""
"Усі патчери можна використовувати як декоратори класів. При такому "
"використанні вони загортають кожен тестовий метод у клас. Патчери "
"розпізнають методи, які починаються з ``'test'``, як методи тестування. "
"Таким же чином :class:`unittest.TestLoader` знаходить тестові методи за "
"замовчуванням."

msgid ""
"It is possible that you want to use a different prefix for your tests. You "
"can inform the patchers of the different prefix by setting ``patch."
"TEST_PREFIX``::"
msgstr ""
"Можливо, ви хочете використовувати інший префікс для своїх тестів. Ви можете "
"повідомити патчерів про інший префікс, встановивши ``patch.TEST_PREFIX``::"

msgid "Nesting Patch Decorators"
msgstr "Декоратори вкладених патчів"

msgid ""
"If you want to perform multiple patches then you can simply stack up the "
"decorators."
msgstr ""
"Якщо ви хочете виконати кілька патчів, ви можете просто скласти декоратори."

msgid "You can stack up multiple patch decorators using this pattern:"
msgstr ""
"Ви можете скласти кілька декораторів патчів, використовуючи цей шаблон:"

msgid ""
"Note that the decorators are applied from the bottom upwards. This is the "
"standard way that Python applies decorators. The order of the created mocks "
"passed into your test function matches this order."
msgstr ""
"Зверніть увагу, що декоратори наносяться знизу вгору. Це стандартний спосіб, "
"у який Python застосовує декоратори. Порядок створених макетів, переданих у "
"вашу тестову функцію, відповідає цьому порядку."

msgid "Where to patch"
msgstr "Де латати"

msgid ""
":func:`patch` works by (temporarily) changing the object that a *name* "
"points to with another one. There can be many names pointing to any "
"individual object, so for patching to work you must ensure that you patch "
"the name used by the system under test."
msgstr ""
":func:`patch` працює, (тимчасово) змінюючи об’єкт, на який вказує *ім’я*, на "
"інший. Може бути багато імен, які вказують на будь-який окремий об’єкт, "
"тому, щоб виправлення працювало, ви повинні переконатися, що ви виправляєте "
"ім’я, яке використовує тестована система."

msgid ""
"The basic principle is that you patch where an object is *looked up*, which "
"is not necessarily the same place as where it is defined. A couple of "
"examples will help to clarify this."
msgstr ""
"Основний принцип полягає в тому, що ви виправляєте там, де об’єкт "
"*переглядається*, що не обов’язково є тим самим місцем, де він визначений. "
"Кілька прикладів допоможуть прояснити це."

msgid ""
"Imagine we have a project that we want to test with the following structure::"
msgstr ""
"Уявіть, що у нас є проект, який ми хочемо перевірити з такою структурою:"

msgid ""
"Now we want to test ``some_function`` but we want to mock out ``SomeClass`` "
"using :func:`patch`. The problem is that when we import module b, which we "
"will have to do then it imports ``SomeClass`` from module a. If we use :func:"
"`patch` to mock out ``a.SomeClass`` then it will have no effect on our test; "
"module b already has a reference to the *real* ``SomeClass`` and it looks "
"like our patching had no effect."
msgstr ""
"Тепер ми хочемо протестувати ``some_function``, але ми хочемо змакувати "
"``SomeClass`` за допомогою :func:`patch`. Проблема полягає в тому, що коли "
"ми імпортуємо модуль b, що нам доведеться зробити, він імпортує "
"``SomeClass`` з модуля a. Якщо ми використовуємо :func:`patch` для імітації "
"``a.SomeClass``, то це не вплине на наш тест; модуль b уже містить посилання "
"на *справжній* ``SomeClass``, і, схоже, наше виправлення не мало ефекту."

msgid ""
"The key is to patch out ``SomeClass`` where it is used (or where it is "
"looked up). In this case ``some_function`` will actually look up "
"``SomeClass`` in module b, where we have imported it. The patching should "
"look like::"
msgstr ""
"Головне – виправити ``SomeClass`` там, де він використовується (або де його "
"шукають). У цьому випадку ``some_function`` фактично шукатиме ``SomeClass`` "
"у модулі b, куди ми його імпортували. Виправлення має виглядати:"

msgid ""
"However, consider the alternative scenario where instead of ``from a import "
"SomeClass`` module b does ``import a`` and ``some_function`` uses ``a."
"SomeClass``. Both of these import forms are common. In this case the class "
"we want to patch is being looked up in the module and so we have to patch "
"``a.SomeClass`` instead::"
msgstr ""
"Однак розглянемо альтернативний сценарій, де замість ``from a import "
"SomeClass`` модуль b виконує ``імпорт a``, а ``some_function`` використовує "
"``a.SomeClass``. Обидві ці форми імпорту поширені. У цьому випадку клас, "
"який ми хочемо виправити, шукається в модулі, тому ми повинні замість цього "
"виправити ``a.SomeClass``::"

msgid "Patching Descriptors and Proxy Objects"
msgstr "Виправлення дескрипторів і проксі-об’єктів"

msgid ""
"Both patch_ and patch.object_ correctly patch and restore descriptors: class "
"methods, static methods and properties. You should patch these on the "
"*class* rather than an instance. They also work with *some* objects that "
"proxy attribute access, like the `django settings object <https://web."
"archive.org/web/20200603181648/http://www.voidspace.org.uk/python/weblog/"
"arch_d7_2010_12_04.shtml#e1198>`_."
msgstr ""
"І patch_, і patch.object_ правильно виправляють і відновлюють дескриптори: "
"методи класу, статичні методи та властивості. Вам слід виправити їх у "
"*класі*, а не в екземплярі. Вони також працюють з *деякими* об’єктами, які "
"проксі-сервер доступу до атрибутів, як-от `об’єкт налаштувань django "
"<https://web.archive.org/web/20200603181648/http://www.voidspace.org.uk/"
"python/weblog/arch_d7_2010_12_04.shtml#e1198>`_."

msgid "MagicMock and magic method support"
msgstr "Підтримка MagicMock і магічного методу"

msgid "Mocking Magic Methods"
msgstr "Знущальні магічні методи"

msgid ""
":class:`Mock` supports mocking the Python protocol methods, also known as "
"\"magic methods\". This allows mock objects to replace containers or other "
"objects that implement Python protocols."
msgstr ""
":class:`Mock` підтримує висміювання методів протоколу Python, також відомих "
"як \"магічні методи\". Це дозволяє фіктивним об’єктам замінювати контейнери "
"чи інші об’єкти, які реалізують протоколи Python."

msgid ""
"Because magic methods are looked up differently from normal methods [#]_, "
"this support has been specially implemented. This means that only specific "
"magic methods are supported. The supported list includes *almost* all of "
"them. If there are any missing that you need please let us know."
msgstr ""
"Оскільки магічні методи шукаються інакше, ніж звичайні методи [#]_, цю "
"підтримку було реалізовано спеціально. Це означає, що підтримуються лише "
"певні магічні методи. Список підтримуваних включає *майже* всі з них. Якщо "
"вам бракує чогось, повідомте нам."

msgid ""
"You mock magic methods by setting the method you are interested in to a "
"function or a mock instance. If you are using a function then it *must* take "
"``self`` as the first argument [#]_."
msgstr ""
"Ви імітуєте магічні методи, встановлюючи для методу, який вас цікавить, "
"функцію або імітаційний екземпляр. Якщо ви використовуєте функцію, вона "
"*має* приймати ``self`` як перший аргумент [#]_."

msgid ""
"One use case for this is for mocking objects used as context managers in a :"
"keyword:`with` statement:"
msgstr ""
"Одним із варіантів використання цього є знущання над об’єктами, що "
"використовуються як менеджери контексту в операторі :keyword:`with`:"

msgid ""
"Calls to magic methods do not appear in :attr:`~Mock.method_calls`, but they "
"are recorded in :attr:`~Mock.mock_calls`."
msgstr ""
"Виклики магічних методів не відображаються в :attr:`~Mock.method_calls`, але "
"вони записуються в :attr:`~Mock.mock_calls`."

msgid ""
"If you use the *spec* keyword argument to create a mock then attempting to "
"set a magic method that isn't in the spec will raise an :exc:"
"`AttributeError`."
msgstr ""
"Якщо ви використовуєте аргумент ключового слова *spec* для створення макета, "
"тоді спроба встановити магічний метод, якого немає в специфікації, призведе "
"до появи :exc:`AttributeError`."

msgid "The full list of supported magic methods is:"
msgstr "Повний список підтримуваних магічних методів:"

msgid "``__hash__``, ``__sizeof__``, ``__repr__`` and ``__str__``"
msgstr "``__hash__``, ``__sizeof__``, ``__repr__`` і ``__str__``"

msgid "``__dir__``, ``__format__`` and ``__subclasses__``"
msgstr "``__dir__``, ``__format__`` і ``__subclasses__``"

msgid "``__round__``, ``__floor__``, ``__trunc__`` and ``__ceil__``"
msgstr "``__round__``, ``__floor__``, ``__trunc__`` і ``__ceil__``"

msgid ""
"Comparisons: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` and "
"``__ne__``"
msgstr ""
"Порівняння: ``__lt__``, ``__gt__``, ``__le__``, ``__ge__``, ``__eq__`` і "
"``__ne__``"

msgid ""
"Container methods: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` and "
"``__missing__``"
msgstr ""
"Методи контейнерів: ``__getitem__``, ``__setitem__``, ``__delitem__``, "
"``__contains__``, ``__len__``, ``__iter__``, ``__reversed__`` і "
"``__missing__``"

msgid ""
"Context manager: ``__enter__``, ``__exit__``, ``__aenter__`` and "
"``__aexit__``"
msgstr ""
"Менеджер контексту: ``__enter__``, ``__exit__``, ``__aenter__`` і "
"``__aexit__``"

msgid "Unary numeric methods: ``__neg__``, ``__pos__`` and ``__invert__``"
msgstr "Унарні числові методи: ``__neg__``, ``__pos__`` і ``__invert__``"

msgid ""
"The numeric methods (including right hand and in-place variants): "
"``__add__``, ``__sub__``, ``__mul__``, ``__matmul__``, ``__truediv__``, "
"``__floordiv__``, ``__mod__``, ``__divmod__``, ``__lshift__``, "
"``__rshift__``, ``__and__``, ``__xor__``, ``__or__``, and ``__pow__``"
msgstr ""
"Числові методи (включаючи правосторонні та варіанти на місці): ``__add__``, "
"``__sub__``, ``__mul__``, ``__matmul__``, ``__truediv__``, ``__floordiv__``, "
"``__mod__``, ``__divmod__``, ``__lshift__``, ``__rshift__``, ``__and__``, "
"``__xor__``, ``__or__`` і ``__pow__``"

msgid ""
"Numeric conversion methods: ``__complex__``, ``__int__``, ``__float__`` and "
"``__index__``"
msgstr ""
"Числові методи перетворення: ``__complex__``, ``__int__``, ``__float__`` і "
"``__index__``"

msgid "Descriptor methods: ``__get__``, ``__set__`` and ``__delete__``"
msgstr "Методи дескриптора: ``__get__``, ``__set__`` і ``__delete__``"

msgid ""
"Pickling: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` and ``__setstate__``"
msgstr ""
"Травлення: ``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, "
"``__getnewargs__``, ``__getstate__`` і ``__setstate__``"

msgid "File system path representation: ``__fspath__``"
msgstr "Представлення шляху файлової системи: ``__fspath__``"

msgid "Asynchronous iteration methods: ``__aiter__`` and ``__anext__``"
msgstr "Асинхронні методи ітерації: ``__aiter__`` і ``__anext__``"

msgid "Added support for :func:`os.PathLike.__fspath__`."
msgstr "Додано підтримку для :func:`os.PathLike.__fspath__`."

msgid ""
"Added support for ``__aenter__``, ``__aexit__``, ``__aiter__`` and "
"``__anext__``."
msgstr ""
"Додано підтримку ``__aenter__``, ``__aexit__``, ``__aiter__`` і "
"``__anext__``."

msgid ""
"The following methods exist but are *not* supported as they are either in "
"use by mock, can't be set dynamically, or can cause problems:"
msgstr ""
"Наступні методи існують, але *не* підтримуються, оскільки вони або "
"використовуються макетом, не можуть бути встановлені динамічно або можуть "
"спричиняти проблеми:"

msgid "``__getattr__``, ``__setattr__``, ``__init__`` and ``__new__``"
msgstr "``__getattr__``, ``__setattr__``, ``__init__`` і ``__new__``"

msgid ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"
msgstr ""
"``__prepare__``, ``__instancecheck__``, ``__subclasscheck__``, ``__del__``"

msgid "Magic Mock"
msgstr "Магічний макет"

msgid ""
"There are two ``MagicMock`` variants: :class:`MagicMock` and :class:"
"`NonCallableMagicMock`."
msgstr ""
"Є два варіанти ``MagicMock``: :class:`MagicMock` і :class:"
"`NonCallableMagicMock`."

msgid ""
"``MagicMock`` is a subclass of :class:`Mock` with default implementations of "
"most of the magic methods. You can use ``MagicMock`` without having to "
"configure the magic methods yourself."
msgstr ""
"``MagicMock`` є підкласом :class:`Mock` із стандартними реалізаціями "
"більшості магічних методів. Ви можете використовувати ``MagicMock`` без "
"необхідності самостійно налаштовувати магічні методи."

msgid "The constructor parameters have the same meaning as for :class:`Mock`."
msgstr "Параметри конструктора мають те саме значення, що й для :class:`Mock`."

msgid ""
"If you use the *spec* or *spec_set* arguments then *only* magic methods that "
"exist in the spec will be created."
msgstr ""
"Якщо ви використовуєте аргументи *spec* або *spec_set*, тоді будуть створені "
"*лише* магічні методи, які існують у специфікації."

msgid "A non-callable version of :class:`MagicMock`."
msgstr "Версія :class:`MagicMock`, яка не викликається."

msgid ""
"The constructor parameters have the same meaning as for :class:`MagicMock`, "
"with the exception of *return_value* and *side_effect* which have no meaning "
"on a non-callable mock."
msgstr ""
"Параметри конструктора мають те саме значення, що й для :class:`MagicMock`, "
"за винятком *return_value* і *side_effect*, які не мають значення для "
"макету, який не викликається."

msgid ""
"The magic methods are setup with :class:`MagicMock` objects, so you can "
"configure them and use them in the usual way:"
msgstr ""
"Магічні методи встановлюються за допомогою об’єктів :class:`MagicMock`, тож "
"ви можете налаштувати їх і використовувати у звичайний спосіб:"

msgid ""
"By default many of the protocol methods are required to return objects of a "
"specific type. These methods are preconfigured with a default return value, "
"so that they can be used without you having to do anything if you aren't "
"interested in the return value. You can still *set* the return value "
"manually if you want to change the default."
msgstr ""
"За замовчуванням багато методів протоколу потрібні для повернення об’єктів "
"певного типу. Ці методи попередньо налаштовані зі значенням, що повертається "
"за замовчуванням, тому їх можна використовувати без необхідності робити будь-"
"які дії, якщо ви не зацікавлені у значенні, що повертається. Ви все ще "
"можете *встановити* значення, що повертається, вручну, якщо ви хочете "
"змінити значення за замовчуванням."

msgid "Methods and their defaults:"
msgstr "Методи та їх значення за замовчуванням:"

msgid "``__lt__``: ``NotImplemented``"
msgstr "``__lt__``: ``Не реалізовано``"

msgid "``__gt__``: ``NotImplemented``"
msgstr "``__gt__``: ``Не реалізовано``"

msgid "``__le__``: ``NotImplemented``"
msgstr "``__le__``: ``Не реалізовано``"

msgid "``__ge__``: ``NotImplemented``"
msgstr "``__ge__``: ``Не реалізовано``"

msgid "``__int__``: ``1``"
msgstr "``__int__``: ``1``"

msgid "``__contains__``: ``False``"
msgstr "``__contains__``: ``False``"

msgid "``__len__``: ``0``"
msgstr "``__len__``: ``0``"

msgid "``__iter__``: ``iter([])``"
msgstr "``__iter__``: ``iter([])``"

msgid "``__exit__``: ``False``"
msgstr "``__exit__``: ``False``"

msgid "``__aexit__``: ``False``"
msgstr "``__aexit__``: ``False``"

msgid "``__complex__``: ``1j``"
msgstr "``__complex__``: ``1j``"

msgid "``__float__``: ``1.0``"
msgstr "``__float__``: ``1.0``"

msgid "``__bool__``: ``True``"
msgstr "``__bool__``: ``Правда``"

msgid "``__index__``: ``1``"
msgstr "``__index__``: ``1``"

msgid "``__hash__``: default hash for the mock"
msgstr "``__hash__``: типовий хеш для макета"

msgid "``__str__``: default str for the mock"
msgstr "``__str__``: рядок за умовчанням для макета"

msgid "``__sizeof__``: default sizeof for the mock"
msgstr "``__sizeof__``: розмір за замовчуванням для макету"

msgid "For example:"
msgstr "Наприклад:"

msgid ""
"The two equality methods, :meth:`__eq__` and :meth:`__ne__`, are special. "
"They do the default equality comparison on identity, using the :attr:`~Mock."
"side_effect` attribute, unless you change their return value to return "
"something else::"
msgstr ""
"Два методи рівності, :meth:`__eq__` і :meth:`__ne__`, є особливими. Вони "
"порівнюють рівність за замовчуванням щодо ідентичності, використовуючи "
"атрибут :attr:`~Mock.side_effect`, якщо ви не зміните їх значення, що "
"повертається, щоб повернути щось інше::"

msgid ""
"The return value of :meth:`MagicMock.__iter__` can be any iterable object "
"and isn't required to be an iterator:"
msgstr ""
"Повернене значення :meth:`MagicMock.__iter__` може бути будь-яким ітерованим "
"об’єктом і не обов’язково бути ітератором:"

msgid ""
"If the return value *is* an iterator, then iterating over it once will "
"consume it and subsequent iterations will result in an empty list:"
msgstr ""
"Якщо значення, що повертається, *є* ітератором, одноразове повторення над "
"ним споживатиме його, а наступні ітерації призведуть до порожнього списку:"

msgid ""
"``MagicMock`` has all of the supported magic methods configured except for "
"some of the obscure and obsolete ones. You can still set these up if you "
"want."
msgstr ""
"У ``MagicMock`` налаштовано всі підтримувані магічні методи, за винятком "
"деяких незрозумілих і застарілих. Ви все ще можете налаштувати їх, якщо "
"хочете."

msgid ""
"Magic methods that are supported but not setup by default in ``MagicMock`` "
"are:"
msgstr ""
"Магічні методи, які підтримуються, але не налаштовані за замовчуванням у "
"``MagicMock``:"

msgid "``__subclasses__``"
msgstr "``__subclasses__``"

msgid "``__dir__``"
msgstr "``__dir__``"

msgid "``__format__``"
msgstr "``__format__``"

msgid "``__get__``, ``__set__`` and ``__delete__``"
msgstr "``__get__``, ``__set__`` і ``__delete__``"

msgid "``__reversed__`` and ``__missing__``"
msgstr "``__reversed__`` і ``__missing__``"

msgid ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``__getnewargs__``, "
"``__getstate__`` and ``__setstate__``"
msgstr ""
"``__reduce__``, ``__reduce_ex__``, ``__getinitargs__``, ``__getnewargs__``, "
"``__getstate__`` і ``__setstate__``"

msgid "``__getformat__``"
msgstr "``__getformat__``"

msgid ""
"Magic methods *should* be looked up on the class rather than the instance. "
"Different versions of Python are inconsistent about applying this rule. The "
"supported protocol methods should work with all supported versions of Python."
msgstr ""
"Чарівні методи *слід* шукати в класі, а не в екземплярі. Різні версії Python "
"несумісні щодо застосування цього правила. Підтримувані методи протоколу "
"мають працювати з усіма підтримуваними версіями Python."

msgid ""
"The function is basically hooked up to the class, but each ``Mock`` instance "
"is kept isolated from the others."
msgstr ""
"Функція в основному підключена до класу, але кожен екземпляр ``Mock`` "
"зберігається ізольованим від інших."

msgid "Helpers"
msgstr "Помічники"

msgid "sentinel"
msgstr "дозорний"

msgid ""
"The ``sentinel`` object provides a convenient way of providing unique "
"objects for your tests."
msgstr ""
"Об’єкт ``sentinel`` забезпечує зручний спосіб надання унікальних об’єктів "
"для ваших тестів."

msgid ""
"Attributes are created on demand when you access them by name. Accessing the "
"same attribute will always return the same object. The objects returned have "
"a sensible repr so that test failure messages are readable."
msgstr ""
"Атрибути створюються на вимогу, коли ви отримуєте доступ до них за іменем. "
"Доступ до того самого атрибуту завжди повертатиме той самий об’єкт. "
"Повернуті об’єкти мають розумне відображення, тому повідомлення про помилку "
"тесту можна прочитати."

msgid ""
"The ``sentinel`` attributes now preserve their identity when they are :mod:"
"`copied <copy>` or :mod:`pickled <pickle>`."
msgstr ""
"Атрибути ``sentinel`` тепер зберігають свою ідентичність, коли їх :mod:"
"`скопіюють <copy>` або :mod:`маринують <pickle>`."

msgid ""
"Sometimes when testing you need to test that a specific object is passed as "
"an argument to another method, or returned. It can be common to create named "
"sentinel objects to test this. :data:`sentinel` provides a convenient way of "
"creating and testing the identity of objects like this."
msgstr ""
"Іноді під час тестування вам потрібно перевірити, чи певний об’єкт "
"передається як аргумент до іншого методу або повертається. Для перевірки "
"цього може бути звичайним створення іменованих дозорних об’єктів. :data:"
"`sentinel` забезпечує зручний спосіб створення та перевірки ідентичності "
"таких об’єктів."

msgid ""
"In this example we monkey patch ``method`` to return ``sentinel."
"some_object``:"
msgstr ""
"У цьому прикладі ми використовуємо ``method`` для повернення ``sentinel."
"some_object``:"

msgid "DEFAULT"
msgstr "ЗА ПРОМОВЧАННЯМ"

msgid ""
"The :data:`DEFAULT` object is a pre-created sentinel (actually ``sentinel."
"DEFAULT``). It can be used by :attr:`~Mock.side_effect` functions to "
"indicate that the normal return value should be used."
msgstr ""
"Об’єкт :data:`DEFAULT` є попередньо створеним дозорним (насправді ``sentinel."
"DEFAULT``). Його можна використовувати функціями :attr:`~Mock.side_effect`, "
"щоб вказати, що потрібно використовувати звичайне повертане значення."

msgid "call"
msgstr "виклик"

msgid ""
":func:`call` is a helper object for making simpler assertions, for comparing "
"with :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, :attr:`~Mock."
"mock_calls` and :attr:`~Mock.method_calls`. :func:`call` can also be used "
"with :meth:`~Mock.assert_has_calls`."
msgstr ""
":func:`call` — це допоміжний об’єкт для створення простіших тверджень, для "
"порівняння з :attr:`~Mock.call_args`, :attr:`~Mock.call_args_list`, :attr:"
"`~Mock.mock_calls` і :attr:`~Mock.method_calls`. :func:`call` також можна "
"використовувати з :meth:`~Mock.assert_has_calls`."

msgid ""
"For a call object that represents multiple calls, :meth:`call_list` returns "
"a list of all the intermediate calls as well as the final call."
msgstr ""
"Для об’єкта виклику, який представляє кілька викликів, :meth:`call_list` "
"повертає список усіх проміжних викликів, а також остаточний виклик."

msgid ""
"``call_list`` is particularly useful for making assertions on \"chained "
"calls\". A chained call is multiple calls on a single line of code. This "
"results in multiple entries in :attr:`~Mock.mock_calls` on a mock. Manually "
"constructing the sequence of calls can be tedious."
msgstr ""
"``call_list`` особливо корисний для створення тверджень щодо \"ланцюжкових "
"викликів\". Зв’язаний виклик — це кілька викликів в одному рядку коду. Це "
"призводить до кількох записів у :attr:`~Mock.mock_calls` на макеті. Побудова "
"послідовності викликів вручну може бути виснажливою."

msgid ""
":meth:`~call.call_list` can construct the sequence of calls from the same "
"chained call:"
msgstr ""
":meth:`~call.call_list` може побудувати послідовність викликів з одного "
"ланцюжкового виклику:"

msgid ""
"A ``call`` object is either a tuple of (positional args, keyword args) or "
"(name, positional args, keyword args) depending on how it was constructed. "
"When you construct them yourself this isn't particularly interesting, but "
"the ``call`` objects that are in the :attr:`Mock.call_args`, :attr:`Mock."
"call_args_list` and :attr:`Mock.mock_calls` attributes can be introspected "
"to get at the individual arguments they contain."
msgstr ""
"Об’єкт ``виклику`` є або кортежем (позиційні аргументи, аргументи ключового "
"слова) або (ім’я, позиційні аргументи, аргументи ключового слова) залежно "
"від того, як він був створений. Коли ви створюєте їх самостійно, це не "
"особливо цікаво, але об’єкти ``call``, які знаходяться в :attr:`Mock."
"call_args`, :attr:`Mock.call_args_list` і :attr:`Mock.mock_calls` атрибути "
"можна перевірити, щоб отримати окремі аргументи, які вони містять."

msgid ""
"The ``call`` objects in :attr:`Mock.call_args` and :attr:`Mock."
"call_args_list` are two-tuples of (positional args, keyword args) whereas "
"the ``call`` objects in :attr:`Mock.mock_calls`, along with ones you "
"construct yourself, are three-tuples of (name, positional args, keyword "
"args)."
msgstr ""
"Об’єкти ``call`` у :attr:`Mock.call_args` і :attr:`Mock.call_args_list` є "
"двома кортежами (позиційні аргументи, аргументи ключового слова), тоді як "
"об’єкти ``call`` у :attr:`Mock.mock_calls` разом із тими, які ви створюєте "
"самостійно, складаються з трьох кортежів (ім’я, позиційні аргументи, "
"аргументи ключового слова)."

msgid ""
"You can use their \"tupleness\" to pull out the individual arguments for "
"more complex introspection and assertions. The positional arguments are a "
"tuple (an empty tuple if there are no positional arguments) and the keyword "
"arguments are a dictionary:"
msgstr ""
"Ви можете використовувати їх \"кортеж\", щоб отримати окремі аргументи для "
"більш складного самоаналізу та тверджень. Позиційні аргументи — це кортеж "
"(порожній кортеж, якщо позиційних аргументів немає), а ключові аргументи — "
"це словник:"

msgid "create_autospec"
msgstr "create_autospec"

msgid ""
"Create a mock object using another object as a spec. Attributes on the mock "
"will use the corresponding attribute on the *spec* object as their spec."
msgstr ""
"Створіть макет об’єкта, використовуючи інший об’єкт як специфікацію. "
"Атрибути на макеті використовуватимуть відповідний атрибут об’єкта *spec* як "
"свою специфікацію."

msgid ""
"Functions or methods being mocked will have their arguments checked to "
"ensure that they are called with the correct signature."
msgstr ""
"Аргументи функцій або методів, які висміюються, перевірятимуть, щоб "
"переконатися, що вони викликаються з правильною сигнатурою."

msgid ""
"If *spec_set* is ``True`` then attempting to set attributes that don't exist "
"on the spec object will raise an :exc:`AttributeError`."
msgstr ""
"Якщо *spec_set* має значення ``True``, тоді спроба встановити атрибути, яких "
"не існує в об’єкті специфікації, призведе до появи :exc:`AttributeError`."

msgid ""
"If a class is used as a spec then the return value of the mock (the instance "
"of the class) will have the same spec. You can use a class as the spec for "
"an instance object by passing ``instance=True``. The returned mock will only "
"be callable if instances of the mock are callable."
msgstr ""
"Якщо клас використовується як специфікація, тоді значення, що повертається "
"mock (екземпляр класу), матиме ту саму специфікацію. Ви можете "
"використовувати клас як специфікацію для об’єкта екземпляра, передавши "
"``instance=True``. Повернений макет можна буде викликати, лише якщо його "
"екземпляри можна викликати."

msgid ""
":func:`create_autospec` also takes arbitrary keyword arguments that are "
"passed to the constructor of the created mock."
msgstr ""
":func:`create_autospec` також приймає довільні ключові аргументи, які "
"передаються конструктору створеного макету."

msgid ""
"See :ref:`auto-speccing` for examples of how to use auto-speccing with :func:"
"`create_autospec` and the *autospec* argument to :func:`patch`."
msgstr ""
"Перегляньте :ref:`auto-speccing` для прикладів використання автоматичної "
"специфікації з :func:`create_autospec` і аргументом *autospec* для :func:"
"`patch`."

msgid ""
":func:`create_autospec` now returns an :class:`AsyncMock` if the target is "
"an async function."
msgstr ""
":func:`create_autospec` тепер повертає :class:`AsyncMock`, якщо метою є "
"асинхронна функція."

msgid "ANY"
msgstr "БУДЬ-ЯКИЙ"

msgid ""
"Sometimes you may need to make assertions about *some* of the arguments in a "
"call to mock, but either not care about some of the arguments or want to "
"pull them individually out of :attr:`~Mock.call_args` and make more complex "
"assertions on them."
msgstr ""
"Іноді вам може знадобитися зробити твердження щодо *деяких* аргументів у "
"виклику mock, але ви або не дбаєте про деякі з аргументів, або хочете "
"вилучити їх окремо з :attr:`~Mock.call_args` і зробити складнішими "
"твердження на них."

msgid ""
"To ignore certain arguments you can pass in objects that compare equal to "
"*everything*. Calls to :meth:`~Mock.assert_called_with` and :meth:`~Mock."
"assert_called_once_with` will then succeed no matter what was passed in."
msgstr ""
"Щоб ігнорувати певні аргументи, ви можете передати об’єкти, порівняння яких "
"дорівнює *всему*. Виклики :meth:`~Mock.assert_ called_with` і :meth:`~Mock."
"assert_ called_once_with` будуть успішними незалежно від того, що було "
"передано."

msgid ""
":data:`ANY` can also be used in comparisons with call lists like :attr:"
"`~Mock.mock_calls`:"
msgstr ""
":data:`ANY` також можна використовувати для порівняння зі списками викликів, "
"наприклад :attr:`~Mock.mock_calls`:"

msgid "FILTER_DIR"
msgstr "FILTER_DIR"

msgid ""
":data:`FILTER_DIR` is a module level variable that controls the way mock "
"objects respond to :func:`dir`. The default is ``True``, which uses the "
"filtering described below, to only show useful members. If you dislike this "
"filtering, or need to switch it off for diagnostic purposes, then set ``mock."
"FILTER_DIR = False``."
msgstr ""
":data:`FILTER_DIR` — це змінна рівня модуля, яка керує тим, як макетні "
"об’єкти реагують на :func:`dir`. Типовим значенням є ``True``, яке "
"використовує описану нижче фільтрацію, щоб відображати лише корисних "
"учасників. Якщо вам не подобається це фільтрування або потрібно вимкнути "
"його з метою діагностики, тоді встановіть ``mock.FILTER_DIR = False``."

msgid ""
"With filtering on, ``dir(some_mock)`` shows only useful attributes and will "
"include any dynamically created attributes that wouldn't normally be shown. "
"If the mock was created with a *spec* (or *autospec* of course) then all the "
"attributes from the original are shown, even if they haven't been accessed "
"yet:"
msgstr ""
"Якщо фільтрацію ввімкнено, ``dir(some_mock)`` показує лише корисні атрибути "
"та включатиме будь-які динамічно створені атрибути, які зазвичай не "
"відображаються. Якщо макет було створено за допомогою *spec* (або "
"*autospec*, звичайно), тоді відображаються всі атрибути з оригіналу, навіть "
"якщо до них ще не було доступу:"

msgid ""
"Many of the not-very-useful (private to :class:`Mock` rather than the thing "
"being mocked) underscore and double underscore prefixed attributes have been "
"filtered from the result of calling :func:`dir` on a :class:`Mock`. If you "
"dislike this behaviour you can switch it off by setting the module level "
"switch :data:`FILTER_DIR`:"
msgstr ""
"Багато з не дуже корисних (приватних для :class:`Mock`, а не для того, що "
"висміюється) атрибутів підкреслення та подвійного підкреслення з префіксом "
"було відфільтровано з результату виклику :func:`dir` на :class:`Mock`. Якщо "
"вам не подобається така поведінка, ви можете вимкнути її, встановивши "
"перемикач рівня модуля :data:`FILTER_DIR`:"

msgid ""
"Alternatively you can just use ``vars(my_mock)`` (instance members) and "
"``dir(type(my_mock))`` (type members) to bypass the filtering irrespective "
"of :data:`mock.FILTER_DIR`."
msgstr ""
"Крім того, ви можете просто використати ``vars(my_mock)`` (члени екземпляра) "
"і ``dir(type(my_mock))`` (члени типу), щоб обійти фільтрацію незалежно від :"
"data:`mock.FILTER_DIR`."

msgid "mock_open"
msgstr "mock_open"

msgid ""
"A helper function to create a mock to replace the use of :func:`open`. It "
"works for :func:`open` called directly or used as a context manager."
msgstr ""
"Допоміжна функція для створення макету замість використання :func:`open`. Це "
"працює для :func:`open`, що викликається безпосередньо або використовується "
"як контекстний менеджер."

msgid ""
"The *mock* argument is the mock object to configure. If ``None`` (the "
"default) then a :class:`MagicMock` will be created for you, with the API "
"limited to methods or attributes available on standard file handles."
msgstr ""
"Аргумент *mock* є макетним об’єктом для налаштування. Якщо ``None`` (за "
"замовчуванням), тоді для вас буде створено :class:`MagicMock` з API, "
"обмеженим методами чи атрибутами, доступними для стандартних дескрипторів "
"файлів."

msgid ""
"*read_data* is a string for the :meth:`~io.IOBase.read`, :meth:`~io.IOBase."
"readline`, and :meth:`~io.IOBase.readlines` methods of the file handle to "
"return.  Calls to those methods will take data from *read_data* until it is "
"depleted.  The mock of these methods is pretty simplistic: every time the "
"*mock* is called, the *read_data* is rewound to the start.  If you need more "
"control over the data that you are feeding to the tested code you will need "
"to customize this mock for yourself.  When that is insufficient, one of the "
"in-memory filesystem packages on `PyPI <https://pypi.org>`_ can offer a "
"realistic filesystem for testing."
msgstr ""
"*read_data* — це рядок для методів :meth:`~io.IOBase.read`, :meth:`~io."
"IOBase.readline` і :meth:`~io.IOBase.readlines` дескриптора файлу "
"повернення. Виклики цих методів братимуть дані з *read_data*, доки вони не "
"будуть вичерпані. Макет цих методів досить простий: щоразу, коли "
"викликається *mock*, *read_data* перемотується на початок. Якщо вам потрібен "
"більший контроль над даними, які ви подаєте до перевіреного коду, вам "
"потрібно буде налаштувати цей макет під себе. Якщо цього недостатньо, один "
"із пакетів файлової системи в пам’яті на `PyPI <https://pypi.org>`_ може "
"запропонувати реалістичну файлову систему для тестування."

msgid ""
"Added :meth:`~io.IOBase.readline` and :meth:`~io.IOBase.readlines` support. "
"The mock of :meth:`~io.IOBase.read` changed to consume *read_data* rather "
"than returning it on each call."
msgstr ""
"Додано підтримку :meth:`~io.IOBase.readline` і :meth:`~io.IOBase.readlines`. "
"Макет :meth:`~io.IOBase.read` змінено, щоб споживати *read_data*, а не "
"повертати їх під час кожного виклику."

msgid "*read_data* is now reset on each call to the *mock*."
msgstr "*read_data* тепер скидається під час кожного виклику *mock*."

msgid ""
"Added :meth:`__iter__` to implementation so that iteration (such as in for "
"loops) correctly consumes *read_data*."
msgstr ""
"До реалізації додано :meth:`__iter__`, щоб ітерація (наприклад, у циклах "
"for) правильно споживала *read_data*."

msgid ""
"Using :func:`open` as a context manager is a great way to ensure your file "
"handles are closed properly and is becoming common::"
msgstr ""
"Використання :func:`open` як контекстного менеджера є чудовим способом "
"переконатися, що ваші дескриптори файлів закриті належним чином, і стає "
"поширеним::"

msgid ""
"The issue is that even if you mock out the call to :func:`open` it is the "
"*returned object* that is used as a context manager (and has :meth:"
"`__enter__` and :meth:`__exit__` called)."
msgstr ""
"Проблема полягає в тому, що навіть якщо ви імітуєте виклик :func:`open`, це "
"*повернений об’єкт*, який використовується як менеджер контексту (і "
"викликає :meth:`__enter__` і :meth:`__exit__`) ."

msgid ""
"Mocking context managers with a :class:`MagicMock` is common enough and "
"fiddly enough that a helper function is useful. ::"
msgstr ""
"Знущання над контекстними менеджерами за допомогою :class:`MagicMock` є "
"досить поширеним і досить складним, щоб допоміжна функція була корисною. ::"

msgid "And for reading files::"
msgstr "І для читання файлів::"

msgid "Autospeccing"
msgstr "Автоматична специфікація"

msgid ""
"Autospeccing is based on the existing :attr:`spec` feature of mock. It "
"limits the api of mocks to the api of an original object (the spec), but it "
"is recursive (implemented lazily) so that attributes of mocks only have the "
"same api as the attributes of the spec. In addition mocked functions / "
"methods have the same call signature as the original so they raise a :exc:"
"`TypeError` if they are called incorrectly."
msgstr ""
"Автоматична специфікація базується на існуючій функції :attr:`spec` mock. "
"Він обмежує API mocks до API оригінального об’єкта (специфікації), але він є "
"рекурсивним (реалізується ліниво), тому атрибути mocks мають лише той самий "
"API, що й атрибути специфікації. Крім того, імітовані функції/методи мають "
"таку саму сигнатуру виклику, як і оригінальні, тому вони викликають :exc:"
"`TypeError`, якщо їх викликають неправильно."

msgid "Before I explain how auto-speccing works, here's why it is needed."
msgstr ""
"Перш ніж пояснювати, як працює автоматична специфікація, ось чому вона "
"потрібна."

msgid ""
":class:`Mock` is a very powerful and flexible object, but it suffers from "
"two flaws when used to mock out objects from a system under test. One of "
"these flaws is specific to the :class:`Mock` api and the other is a more "
"general problem with using mock objects."
msgstr ""
":class:`Mock` є дуже потужним і гнучким об'єктом, але він страждає від двох "
"недоліків, коли використовується для імітації об'єктів із системи, що "
"тестується. Одна з цих недоліків є специфічною для API :class:`Mock`, а інша "
"є більш загальною проблемою використання фіктивних об’єктів."

msgid ""
"First the problem specific to :class:`Mock`. :class:`Mock` has two assert "
"methods that are extremely handy: :meth:`~Mock.assert_called_with` and :meth:"
"`~Mock.assert_called_once_with`."
msgstr ""
"Спочатку проблема, специфічна для :class:`Mock`. :class:`Mock` має два "
"надзвичайно зручні методи підтвердження: :meth:`~Mock.assert_ called_with` "
"і :meth:`~Mock.assert_ called_once_with`."

msgid ""
"Because mocks auto-create attributes on demand, and allow you to call them "
"with arbitrary arguments, if you misspell one of these assert methods then "
"your assertion is gone:"
msgstr ""
"Оскільки висміює автоматичне створення атрибутів на вимогу та дозволяє "
"викликати їх із довільними аргументами, якщо ви неправильно напишете один із "
"цих методів assert, ваше твердження зникне:"

msgid "Your tests can pass silently and incorrectly because of the typo."
msgstr "Ваші тести можуть проходити мовчки та неправильно через помилку."

msgid ""
"The second issue is more general to mocking. If you refactor some of your "
"code, rename members and so on, any tests for code that is still using the "
"*old api* but uses mocks instead of the real objects will still pass. This "
"means your tests can all pass even though your code is broken."
msgstr ""
"Друге питання стосується насмішок. Якщо ви переробите частину свого коду, "
"перейменуєте члени тощо, будь-які тести для коду, який все ще використовує "
"*старий api*, але використовує імітації замість реальних об’єктів, усе одно "
"пройдуть. Це означає, що всі ваші тести можуть пройти, навіть якщо ваш код "
"зламано."

msgid ""
"Note that this is another reason why you need integration tests as well as "
"unit tests. Testing everything in isolation is all fine and dandy, but if "
"you don't test how your units are \"wired together\" there is still lots of "
"room for bugs that tests might have caught."
msgstr ""
"Зауважте, що це ще одна причина, чому вам потрібні інтеграційні тести, а "
"також модульні тести. Тестувати все ізольовано — це чудово, але якщо ви не "
"перевірятимете, як ваші пристрої \"з’єднані між собою\", все ще є багато "
"місця для помилок, які могли виявити тести."

msgid ""
":mod:`mock` already provides a feature to help with this, called speccing. "
"If you use a class or instance as the :attr:`spec` for a mock then you can "
"only access attributes on the mock that exist on the real class:"
msgstr ""
":mod:`mock` вже надає функцію, яка допоможе з цим, яка називається "
"специфікація. Якщо ви використовуєте клас або екземпляр як :attr:`spec` для "
"макету, ви зможете отримати доступ лише до тих атрибутів макета, які існують "
"у реальному класі:"

msgid ""
"The spec only applies to the mock itself, so we still have the same issue "
"with any methods on the mock:"
msgstr ""
"Специфікація стосується лише самого макету, тому ми все ще маємо ту саму "
"проблему з будь-якими методами на макеті:"

msgid ""
"Auto-speccing solves this problem. You can either pass ``autospec=True`` to :"
"func:`patch` / :func:`patch.object` or use the :func:`create_autospec` "
"function to create a mock with a spec. If you use the ``autospec=True`` "
"argument to :func:`patch` then the object that is being replaced will be "
"used as the spec object. Because the speccing is done \"lazily\" (the spec "
"is created as attributes on the mock are accessed) you can use it with very "
"complex or deeply nested objects (like modules that import modules that "
"import modules) without a big performance hit."
msgstr ""
"Автоматична специфікація вирішує цю проблему. Ви можете передати "
"``autospec=True`` в :func:`patch` / :func:`patch.object` або використати "
"функцію :func:`create_autospec`, щоб створити макет зі специфікацією. Якщо "
"ви використовуєте аргумент ``autospec=True`` для :func:`patch`, тоді об’єкт, "
"який замінюється, використовуватиметься як об’єкт специфікації. Оскільки "
"специфікація виконується \"ліниво\" (специфікація створюється під час "
"доступу до атрибутів макету), ви можете використовувати її з дуже складними "
"або глибоко вкладеними об’єктами (як-от модулі, які імпортують модулі, які "
"імпортують модулі) без значного зниження продуктивності."

msgid "Here's an example of it in use::"
msgstr "Ось приклад його використання::"

msgid ""
"You can see that :class:`request.Request` has a spec. :class:`request."
"Request` takes two arguments in the constructor (one of which is *self*). "
"Here's what happens if we try to call it incorrectly::"
msgstr ""
"Ви бачите, що :class:`request.Request` має специфікацію. :class:`request."
"Request` приймає два аргументи в конструкторі (один з яких *self*). Ось що "
"станеться, якщо ми спробуємо викликати його неправильно:"

msgid ""
"The spec also applies to instantiated classes (i.e. the return value of "
"specced mocks)::"
msgstr ""
"Специфікація також стосується екземплярів класів (тобто значення, що "
"повертається specced mocks):"

msgid ""
":class:`Request` objects are not callable, so the return value of "
"instantiating our mocked out :class:`request.Request` is a non-callable "
"mock. With the spec in place any typos in our asserts will raise the correct "
"error::"
msgstr ""
"Об’єкти :class:`Request` не можна викликати, тому значення, що повертається "
"при створенні екземпляра нашого :class:`request.Request` є макетом, який не "
"можна викликати. Якщо специфікація на місці, будь-які друкарські помилки в "
"наших твердженнях викличуть правильну помилку::"

msgid ""
"In many cases you will just be able to add ``autospec=True`` to your "
"existing :func:`patch` calls and then be protected against bugs due to typos "
"and api changes."
msgstr ""
"У багатьох випадках ви просто зможете додати ``autospec=True`` до наявних "
"викликів :func:`patch` і тоді захистити себе від помилок через помилки друку "
"та зміни API."

msgid ""
"As well as using *autospec* through :func:`patch` there is a :func:"
"`create_autospec` for creating autospecced mocks directly:"
msgstr ""
"Окрім використання *autospec* через :func:`patch`, існує :func:"
"`create_autospec` для безпосереднього створення автоспецованих макетів:"

msgid ""
"This isn't without caveats and limitations however, which is why it is not "
"the default behaviour. In order to know what attributes are available on the "
"spec object, autospec has to introspect (access attributes) the spec. As you "
"traverse attributes on the mock a corresponding traversal of the original "
"object is happening under the hood. If any of your specced objects have "
"properties or descriptors that can trigger code execution then you may not "
"be able to use autospec. On the other hand it is much better to design your "
"objects so that introspection is safe [#]_."
msgstr ""
"Однак це не без застережень і обмежень, тому це не типова поведінка. Щоб "
"дізнатися, які атрибути доступні для об’єкта специфікації, autospec має "
"перевірити специфікацію (отримати доступ до атрибутів). Коли ви обходите "
"атрибути на макеті, відповідний обхід оригінального об’єкта відбувається під "
"капотом. Якщо будь-який з ваших специфікованих об’єктів має властивості або "
"дескриптори, які можуть ініціювати виконання коду, можливо, ви не зможете "
"використовувати автоспец. З іншого боку, набагато краще проектувати ваші "
"об’єкти так, щоб самоаналіз був безпечним [#]_."

msgid ""
"A more serious problem is that it is common for instance attributes to be "
"created in the :meth:`__init__` method and not to exist on the class at all. "
"*autospec* can't know about any dynamically created attributes and restricts "
"the api to visible attributes. ::"
msgstr ""
"Серйознішою проблемою є те, що атрибути екземпляра зазвичай створюються в "
"методі :meth:`__init__` і взагалі не існують у класі. *autospec* не може "
"знати про жодні динамічно створені атрибути та обмежує API лише видимими "
"атрибутами. ::"

msgid ""
"There are a few different ways of resolving this problem. The easiest, but "
"not necessarily the least annoying, way is to simply set the required "
"attributes on the mock after creation. Just because *autospec* doesn't allow "
"you to fetch attributes that don't exist on the spec it doesn't prevent you "
"setting them::"
msgstr ""
"Існує кілька способів вирішення цієї проблеми. Найпростіший, але не "
"обов’язково найменш дратуючий спосіб – це просто встановити необхідні "
"атрибути на макет після створення. Просто тому, що *autospec* не дозволяє "
"отримати атрибути, яких немає в специфікації, це не заважає вам налаштувати "
"їх::"

msgid ""
"There is a more aggressive version of both *spec* and *autospec* that *does* "
"prevent you setting non-existent attributes. This is useful if you want to "
"ensure your code only *sets* valid attributes too, but obviously it prevents "
"this particular scenario:"
msgstr ""
"Існує більш агресивна версія як *spec*, так і *autospec*, яка *не* запобігає "
"встановленню неіснуючих атрибутів. Це корисно, якщо ви хочете, щоб ваш код "
"також *встановлював* дійсні атрибути, але, очевидно, це запобігає цьому "
"конкретному сценарію:"

msgid ""
"Probably the best way of solving the problem is to add class attributes as "
"default values for instance members initialised in :meth:`__init__`. Note "
"that if you are only setting default attributes in :meth:`__init__` then "
"providing them via class attributes (shared between instances of course) is "
"faster too. e.g."
msgstr ""
"Ймовірно, найкращим способом вирішення проблеми є додавання атрибутів класу "
"як значень за замовчуванням для членів екземпляра, ініціалізованих у :meth:"
"`__init__`. Зауважте, що якщо ви лише встановлюєте атрибути за замовчуванням "
"у :meth:`__init__`, тоді надання їх через атрибути класу (звичайно, спільні "
"для екземплярів) теж швидше. напр."

msgid ""
"This brings up another issue. It is relatively common to provide a default "
"value of ``None`` for members that will later be an object of a different "
"type. ``None`` would be useless as a spec because it wouldn't let you access "
"*any* attributes or methods on it. As ``None`` is *never* going to be useful "
"as a spec, and probably indicates a member that will normally of some other "
"type, autospec doesn't use a spec for members that are set to ``None``. "
"These will just be ordinary mocks (well - MagicMocks):"
msgstr ""
"Це породжує іншу проблему. Відносно поширеним є надання значення за "
"замовчуванням ``None`` для членів, які пізніше будуть об’єктом іншого типу. "
"``None`` буде марним як специфікація, тому що це не дозволить вам отримати "
"доступ до *будь-яких* атрибутів або методів на ньому. Оскільки ``None`` "
"*ніколи* не буде корисним як специфікація, і, ймовірно, вказує на член, який "
"зазвичай буде іншого типу, autospec не використовує специфікацію для членів, "
"для яких встановлено ``None``. Це будуть просто звичайні макети (добре - "
"MagicMocks):"

msgid ""
"If modifying your production classes to add defaults isn't to your liking "
"then there are more options. One of these is simply to use an instance as "
"the spec rather than the class. The other is to create a subclass of the "
"production class and add the defaults to the subclass without affecting the "
"production class. Both of these require you to use an alternative object as "
"the spec. Thankfully :func:`patch` supports this - you can simply pass the "
"alternative object as the *autospec* argument::"
msgstr ""
"Якщо вам не до вподоби модифікація виробничих класів для додавання значень "
"за замовчуванням, тоді є більше варіантів. Одним із них є просто "
"використання екземпляра як специфікації, а не класу. Інший полягає у "
"створенні підкласу виробничого класу та додаванні стандартних значень до "
"підкласу, не впливаючи на виробничий клас. Обидва вони вимагають "
"використання альтернативного об’єкта як специфікації. На щастя, :func:"
"`patch` підтримує це — ви можете просто передати альтернативний об’єкт як "
"аргумент *autospec*::"

msgid ""
"This only applies to classes or already instantiated objects. Calling a "
"mocked class to create a mock instance *does not* create a real instance. It "
"is only attribute lookups - along with calls to :func:`dir` - that are done."
msgstr ""
"Це стосується лише класів або вже створених об’єктів. Виклик фіктивного "
"класу для створення фальшивого екземпляра *не* створює справжній екземпляр. "
"Виконуються лише пошуки атрибутів разом із викликами :func:`dir`."

msgid "Sealing mocks"
msgstr "Герметизація макетів"

msgid ""
"Seal will disable the automatic creation of mocks when accessing an "
"attribute of the mock being sealed or any of its attributes that are already "
"mocks recursively."
msgstr ""
"Seal вимкне автоматичне створення макетів під час доступу до атрибута "
"макету, який запечатується, або будь-якого з його атрибутів, які вже є "
"макетами рекурсивно."

msgid ""
"If a mock instance with a name or a spec is assigned to an attribute it "
"won't be considered in the sealing chain. This allows one to prevent seal "
"from fixing part of the mock object. ::"
msgstr ""
"Якщо атрибуту присвоєно макет екземпляра з іменем або специфікацією, він не "
"враховуватиметься в ланцюжку запечатування. Це дозволяє запобігти фіксації "
"пломбою частини фіктивного об'єкта. ::"
