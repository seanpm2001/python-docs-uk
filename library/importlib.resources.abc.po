# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-06-29 17:18+0300\n"
"PO-Revision-Date: 2022-07-05 15:40+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "*Superseded by TraversableResources*"
msgstr "*Замінено TraversableResources*"

msgid ""
"An :term:`abstract base class` to provide the ability to read *resources*."
msgstr ":term:`abstract base class` для надання можливості читати *ресурси*."

msgid ""
"From the perspective of this ABC, a *resource* is a binary artifact that is "
"shipped within a package. Typically this is something like a data file that "
"lives next to the ``__init__.py`` file of the package. The purpose of this "
"class is to help abstract out the accessing of such data files so that it "
"does not matter if the package and its data file(s) are stored in a e.g. zip "
"file versus on the file system."
msgstr ""
"З точки зору цієї ABC, *ресурс* — це бінарний артефакт, який доставляється в "
"пакеті. Зазвичай це щось на зразок файлу даних, який знаходиться поруч із "
"файлом ``__init__.py`` файлу пакета. Мета цього класу полягає в тому, щоб "
"допомогти абстрагуватися від доступу до таких файлів даних, щоб не мати "
"значення, чи зберігається пакет і його файл(и) даних у, наприклад, zip-файл "
"проти файлової системи."

msgid ""
"For any of methods of this class, a *resource* argument is expected to be a :"
"term:`path-like object` which represents conceptually just a file name. This "
"means that no subdirectory paths should be included in the *resource* "
"argument. This is because the location of the package the reader is for, "
"acts as the \"directory\". Hence the metaphor for directories and file names "
"is packages and resources, respectively. This is also why instances of this "
"class are expected to directly correlate to a specific package (instead of "
"potentially representing multiple packages or a module)."
msgstr ""
"Для будь-якого методу цього класу очікується, що аргумент *resource* буде :"
"term:`path-like object`, який концептуально представляє лише ім’я файлу. Це "
"означає, що шляхи підкаталогів не повинні включатися в аргумент *resource*. "
"Це пояснюється тим, що місце розташування пакета, для якого призначений "
"зчитувач, діє як \"каталог\". Тому метафорою для каталогів і імен файлів є "
"пакети та ресурси відповідно. Ось чому очікується, що екземпляри цього класу "
"безпосередньо співвідносяться з певним пакетом (замість того, щоб потенційно "
"представляти кілька пакетів або модуль)."

msgid ""
"Loaders that wish to support resource reading are expected to provide a "
"method called ``get_resource_reader(fullname)`` which returns an object "
"implementing this ABC's interface. If the module specified by fullname is "
"not a package, this method should return :const:`None`. An object compatible "
"with this ABC should only be returned when the specified module is a package."
msgstr ""
"Очікується, що завантажувачі, які бажають підтримувати читання ресурсів, "
"нададуть метод під назвою ``get_resource_reader(fullname)``, який повертає "
"об’єкт, що реалізує цей інтерфейс ABC. Якщо модуль, указаний повним іменем, "
"не є пакетом, цей метод має повернути :const:`None`. Об’єкт, сумісний із цим "
"ABC, слід повертати лише тоді, коли вказаний модуль є пакетом."

msgid ""
"Returns an opened, :term:`file-like object` for binary reading of the "
"*resource*."
msgstr ""
"Повертає відкритий :term:`file-like object` для двійкового читання *ресурсу*."

msgid "If the resource cannot be found, :exc:`FileNotFoundError` is raised."
msgstr "Якщо ресурс не знайдено, виникає :exc:`FileNotFoundError`."

msgid "Returns the file system path to the *resource*."
msgstr "Повертає шлях файлової системи до *ресурсу*."

msgid ""
"If the resource does not concretely exist on the file system, raise :exc:"
"`FileNotFoundError`."
msgstr ""
"Якщо ресурс конкретно не існує у файловій системі, викликайте :exc:"
"`FileNotFoundError`."

msgid ""
"Returns ``True`` if the named *name* is considered a resource. :exc:"
"`FileNotFoundError` is raised if *name* does not exist."
msgstr ""
"Повертає ``True``, якщо назване *ім’я* вважається ресурсом. :exc:"
"`FileNotFoundError` виникає, якщо *name* не існує."

msgid ""
"Returns an :term:`iterable` of strings over the contents of the package. Do "
"note that it is not required that all names returned by the iterator be "
"actual resources, e.g. it is acceptable to return names for which :meth:"
"`is_resource` would be false."
msgstr ""
"Повертає :term:`iterable` рядків над вмістом пакета. Зауважте, що не "
"обов’язково, щоб усі імена, які повертає ітератор, були фактичними "
"ресурсами, наприклад. прийнятно повертати імена, для яких :meth:"
"`is_resource` буде false."

msgid ""
"Allowing non-resource names to be returned is to allow for situations where "
"how a package and its resources are stored are known a priori and the non-"
"resource names would be useful. For instance, returning subdirectory names "
"is allowed so that when it is known that the package and resources are "
"stored on the file system then those subdirectory names can be used directly."
msgstr ""
"Дозволити повертати нересурсні імена, щоб дозволити ситуації, коли те, як "
"пакет і його ресурси зберігаються, відомі апріорі, і нересурсні імена будуть "
"корисними. Наприклад, дозволено повертати імена підкаталогів, щоб, якщо "
"відомо, що пакет і ресурси зберігаються у файловій системі, ці імена "
"підкаталогів можна було використовувати безпосередньо."

msgid "The abstract method returns an iterable of no items."
msgstr "Абстрактний метод повертає ітерацію без елементів."

msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loading arbitrary resources from the storage back-end."
msgstr ""
"Абстрактний базовий клас для :term:`loader`, який реалізує необов’язковий "
"протокол :pep:`302` для завантаження довільних ресурсів із внутрішнього "
"сховища."

msgid ""
"This ABC is deprecated in favour of supporting resource loading through :"
"class:`importlib.abc.ResourceReader`."
msgstr ""
"Цей ABC застарів на користь підтримки завантаження ресурсів через :class:"
"`importlib.abc.ResourceReader`."

msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing arbitrary "
"data can implement this abstract method to give direct access to the data "
"stored. :exc:`OSError` is to be raised if the *path* cannot be found. The "
"*path* is expected to be constructed using a module's :attr:`__file__` "
"attribute or an item from a package's :attr:`__path__`."
msgstr ""
"Абстрактний метод для повернення байтів для даних, розташованих за *шляхом*. "
"Завантажувачі, які мають серверну систему зберігання, подібну до файлів, яка "
"дозволяє зберігати довільні дані, можуть реалізувати цей абстрактний метод, "
"щоб надати прямий доступ до збережених даних. :exc:`OSError` виникає, якщо "
"*шлях* не може бути знайдений. Очікується, що *шлях* буде створено за "
"допомогою атрибута :attr:`__file__` модуля або елемента з :attr:`__path__` "
"пакета."

msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Викликає :exc:`OSError` замість :exc:`NotImplementedError`."

msgid ""
"An abstract base class for a :term:`loader` which implements the optional :"
"pep:`302` protocol for loaders that inspect modules."
msgstr ""
"Абстрактний базовий клас для :term:`loader`, який реалізує додатковий "
"протокол :pep:`302` для завантажувачів, які перевіряють модулі."

msgid ""
"Return the code object for a module, or ``None`` if the module does not have "
"a code object (as would be the case, for example, for a built-in module).  "
"Raise an :exc:`ImportError` if loader cannot find the requested module."
msgstr ""
"Повертає об’єкт коду для модуля або ``None``, якщо модуль не має об’єкта "
"коду (як, наприклад, у випадку вбудованого модуля). Викликає :exc:"
"`ImportError`, якщо завантажувач не може знайти потрібний модуль."

msgid ""
"While the method has a default implementation, it is suggested that it be "
"overridden if possible for performance."
msgstr ""
"Хоча метод має реалізацію за замовчуванням, пропонується замінити його, якщо "
"це можливо для продуктивності."

msgid "No longer abstract and a concrete implementation is provided."
msgstr "Більше не абстрактне, а конкретна реалізація."

msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source is "
"available (e.g. a built-in module). Raises :exc:`ImportError` if the loader "
"cannot find the module specified."
msgstr ""
"Абстрактний метод для повернення вихідного коду модуля. Він повертається як "
"текстовий рядок з використанням :term:`universal newlines`, переводячи всі "
"розпізнані роздільники рядків у символи ``'\\n'``. Повертає ``None``, якщо "
"джерело недоступне (наприклад, вбудований модуль). Викликає :exc:"
"`ImportError`, якщо завантажувач не може знайти вказаний модуль."

msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr "Викликає :exc:`ImportError` замість :exc:`NotImplementedError`."

msgid ""
"An optional method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader` "
"cannot find the module."
msgstr ""
"Додатковий метод для повернення істинного значення, якщо модуль є пакетом, і "
"хибного значення в іншому випадку. :exc:`ImportError` виникає, якщо :term:"
"`loader` не може знайти модуль."

msgid "Create a code object from Python source."
msgstr "Створіть об’єкт коду з джерела Python."

msgid ""
"The *data* argument can be whatever the :func:`compile` function supports (i."
"e. string or bytes). The *path* argument should be the \"path\" to where the "
"source code originated from, which can be an abstract concept (e.g. location "
"in a zip file)."
msgstr ""
"Аргументом *data* може бути те, що підтримує функція :func:`compile` (тобто "
"рядок або байти). Аргумент *path* має бути \"шляхом\", звідки походить "
"вихідний код, що може бути абстрактним поняттям (наприклад, розташуванням у "
"файлі zip)."

msgid ""
"With the subsequent code object one can execute it in a module by running "
"``exec(code, module.__dict__)``."
msgstr ""
"З наступним об’єктом коду можна виконати його в модулі, запустивши "
"``exec(code, module.__dict__)``."

msgid "Made the method static."
msgstr "Зробив метод статичним."

msgid "Implementation of :meth:`Loader.exec_module`."
msgstr "Реалізація :meth:`Loader.exec_module`."

msgid "Implementation of :meth:`Loader.load_module`."
msgstr "Реалізація :meth:`Loader.load_module`."

msgid "use :meth:`exec_module` instead."
msgstr "замість цього використовуйте :meth:`exec_module`."

msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, when "
"implemented, helps a module to be executed as a script. The ABC represents "
"an optional :pep:`302` protocol."
msgstr ""
"Абстрактний базовий клас, успадкований від :class:`InspectLoader`, який, "
"реалізований, допомагає модулю виконуватися як сценарій. ABC представляє "
"необов’язковий протокол :pep:`302`."

msgid ""
"An abstract method that is to return the value of :attr:`__file__` for the "
"specified module. If no path is available, :exc:`ImportError` is raised."
msgstr ""
"Абстрактний метод, який повертає значення :attr:`__file__` для зазначеного "
"модуля. Якщо шлях недоступний, виникає :exc:`ImportError`."

msgid ""
"If source code is available, then the method should return the path to the "
"source file, regardless of whether a bytecode was used to load the module."
msgstr ""
"Якщо вихідний код доступний, тоді метод має повертати шлях до вихідного "
"файлу, незалежно від того, чи використовувався байт-код для завантаження "
"модуля."

msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, providing concrete implementations of :meth:"
"`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
"Абстрактний базовий клас, який успадковує :class:`ResourceLoader` і :class:"
"`ExecutionLoader`, надаючи конкретні реалізації :meth:`ResourceLoader."
"get_data` і :meth:`ExecutionLoader.get_filename`."

msgid ""
"The *fullname* argument is a fully resolved name of the module the loader is "
"to handle. The *path* argument is the path to the file for the module."
msgstr ""
"Аргумент *повне ім’я* — це повне ім’я модуля, який має обробляти "
"завантажувач. Аргумент *path* — це шлях до файлу модуля."

msgid "The name of the module the loader can handle."
msgstr "Назва модуля, який може обробляти завантажувач."

msgid "Path to the file of the module."
msgstr "Шлях до файлу модуля."

msgid "Calls super's ``load_module()``."
msgstr "Викликає ``load_module()`` супер."

msgid "Use :meth:`Loader.exec_module` instead."
msgstr "Натомість використовуйте :meth:`Loader.exec_module`."

msgid "Returns :attr:`path`."
msgstr "Повертає :attr:`path`."

msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "Читає *path* як двійковий файл і повертає байти з нього."

msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and :"
"class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"Абстрактний базовий клас для реалізації вихідного (і необов’язково байт-"
"коду) завантаження файлу. Клас успадковує як :class:`ResourceLoader`, так і :"
"class:`ExecutionLoader`, що вимагає реалізації:"

msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

msgid ""
"Should only return the path to the source file; sourceless loading is not "
"supported."
msgstr ""
"Має повертати лише шлях до вихідного файлу; завантаження без джерел не "
"підтримується."

msgid ""
"The abstract methods defined by this class are to add optional bytecode file "
"support. Not implementing these optional methods (or causing them to raise :"
"exc:`NotImplementedError`) causes the loader to only work with source code. "
"Implementing the methods allows the loader to work with source *and* "
"bytecode files; it does not allow for *sourceless* loading where only "
"bytecode is provided.  Bytecode files are an optimization to speed up "
"loading by removing the parsing step of Python's compiler, and so no "
"bytecode-specific API is exposed."
msgstr ""
"Абстрактні методи, визначені цим класом, призначені для додавання додаткової "
"підтримки файлу байт-коду. Нереалізація цих додаткових методів (або виклик "
"їх :exc:`NotImplementedError`) змушує завантажувач працювати лише з вихідним "
"кодом. Реалізація методів дозволяє завантажувачу працювати з вихідними *та* "
"файлами байт-коду; він не допускає *безджерельного* завантаження, де "
"надається лише байт-код. Файли байт-коду є оптимізацією для прискорення "
"завантаження шляхом видалення кроку синтаксичного аналізу компілятора "
"Python, тому API, специфічний для байт-коду, не розкривається."

msgid ""
"Optional abstract method which returns a :class:`dict` containing metadata "
"about the specified path.  Supported dictionary keys are:"
msgstr ""
"Додатковий абстрактний метод, який повертає :class:`dict`, що містить "
"метадані про вказаний шлях. Підтримувані ключі словника:"

msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing "
"the modification time of the source code;"
msgstr ""
"``'mtime'`` (обов'язковий): ціле число або число з плаваючою комою, що "
"представляє час модифікації вихідного коду;"

msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (необов'язковий): розмір у байтах вихідного коду."

msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr ""
"Будь-які інші ключі в словнику ігноруються, щоб дозволити майбутні "
"розширення. Якщо шлях не можна обробити, виникає :exc:`OSError`."

msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr "Викликати :exc:`OSError` замість :exc:`NotImplementedError`."

msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr ""
"Додатковий абстрактний метод, який повертає час модифікації для вказаного "
"шляху."

msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't have "
"to implement it, but it is still available for compatibility purposes. "
"Raise :exc:`OSError` if the path cannot be handled."
msgstr ""
"Цей метод застарів на користь :meth:`path_stats`. Вам не потрібно його "
"впроваджувати, але він все ще доступний для цілей сумісності. Викликати :exc:"
"`OSError`, якщо шлях неможливо обробити."

msgid ""
"Optional abstract method which writes the specified bytes to a file path. "
"Any intermediate directories which do not exist are to be created "
"automatically."
msgstr ""
"Додатковий абстрактний метод, який записує вказані байти в шлях до файлу. "
"Будь-які проміжні каталоги, яких не існує, створюються автоматично."

msgid ""
"When writing to the path fails because the path is read-only (:attr:`errno."
"EACCES`/:exc:`PermissionError`), do not propagate the exception."
msgstr ""
"Якщо запис у шлях не вдається через те, що шлях доступний лише для читання (:"
"attr:`errno.EACCES`/:exc:`PermissionError`), не поширюйте виняткову ситуацію."

msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr "Більше не викликає :exc:`NotImplementedError` під час виклику."

msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr "Конкретна реалізація :meth:`InspectLoader.get_code`."

msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr "Конкретна реалізація :meth:`Loader.exec_module`."

msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr "Конкретна реалізація :meth:`Loader.load_module`."

msgid "Use :meth:`exec_module` instead."
msgstr "Замість цього використовуйте :meth:`exec_module`."

msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr "Конкретна реалізація :meth:`InspectLoader.get_source`."

msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by :meth:"
"`ExecutionLoader.get_filename`) is a file named ``__init__`` when the file "
"extension is removed **and** the module name itself does not end in "
"``__init__``."
msgstr ""
"Конкретна реалізація :meth:`InspectLoader.is_package`. Модуль вважається "
"пакетом, якщо його шлях до файлу (відповідно до :meth:`ExecutionLoader."
"get_filename`) є файлом з іменем ``__init__``, коли розширення файлу "
"видалено **і** сама назва модуля не закінчується на ``__init__``."

msgid ""
"An object with a subset of pathlib.Path methods suitable for traversing "
"directories and opening files."
msgstr ""
"Об’єкт із підмножиною методів pathlib.Path, придатних для обходу каталогів і "
"відкриття файлів."

msgid "Abstract. The base name of this object without any parent references."
msgstr "Анотація. Базова назва цього об’єкта без батьківських посилань."

msgid "Yield Traversable objects in self."
msgstr "Прибуток Traversable об'єктів в себе."

msgid "Return True if self is a directory."
msgstr "Повертає True, якщо self є каталогом."

msgid "Return True if self is a file."
msgstr "Повертає True, якщо self є файлом."

msgid "Return Traversable child in self."
msgstr "Повернення Прохідної дитини в себе."

msgid ""
"*mode* may be 'r' or 'rb' to open as text or binary. Return a handle "
"suitable for reading (same as :attr:`pathlib.Path.open`)."
msgstr ""
"*mode* може бути \"r\" або \"rb\", щоб відкрити як текстовий або двійковий "
"файл. Повертає дескриптор, придатний для читання (те саме, що :attr:`pathlib."
"Path.open`)."

msgid ""
"When opening as text, accepts encoding parameters such as those accepted by :"
"attr:`io.TextIOWrapper`."
msgstr ""
"Коли відкривається як текст, приймає параметри кодування, такі як ті, які "
"приймає :attr:`io.TextIOWrapper`."

msgid "Read contents of self as bytes."
msgstr "Читати вміст себе як байти."

msgid "Read contents of self as text."
msgstr "Прочитати вміст себе як текст."

msgid ""
"An abstract base class for resource readers capable of serving the :meth:"
"`importlib.resources.files` interface. Subclasses :class:`importlib.abc."
"ResourceReader` and provides concrete implementations of the :class:"
"`importlib.abc.ResourceReader`'s abstract methods. Therefore, any loader "
"supplying :class:`importlib.abc.TraversableReader` also supplies "
"ResourceReader."
msgstr ""
"Абстрактний базовий клас для читачів ресурсів, здатний обслуговувати "
"інтерфейс :meth:`importlib.resources.files`. Підкласи :class:`importlib.abc."
"ResourceReader` і надають конкретні реалізації абстрактних методів :class:"
"`importlib.abc.ResourceReader`. Таким чином, будь-який завантажувач, який "
"надає :class:`importlib.abc.TraversableReader`, також надає ResourceReader."

msgid ""
"Loaders that wish to support resource reading are expected to implement this "
"interface."
msgstr ""
"Очікується, що завантажувачі, які бажають підтримувати читання ресурсів, "
"реалізують цей інтерфейс."

msgid ""
"Returns a :class:`importlib.abc.Traversable` object for the loaded package."
msgstr ""
"Повертає об’єкт :class:`importlib.abc.Traversable` для завантаженого пакета."
