# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:49+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Module Objects"
msgstr "Об’єкти модуля"

msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python module type.  "
"This is exposed to Python programs as ``types.ModuleType``."
msgstr ""
"Цей екземпляр :c:type:`PyTypeObject` представляє тип модуля Python. Це "
"доступно для програм Python як ``types.ModuleType``."

msgid ""
"Return true if *p* is a module object, or a subtype of a module object. This "
"function always succeeds."
msgstr ""
"Повертає true, якщо *p* є об’єктом модуля або підтипом об’єкта модуля. Ця "
"функція завжди успішна."

msgid ""
"Return true if *p* is a module object, but not a subtype of :c:data:"
"`PyModule_Type`.  This function always succeeds."
msgstr ""
"Повертає true, якщо *p* є об’єктом модуля, але не підтипом :c:data:"
"`PyModule_Type`. Ця функція завжди успішна."

msgid ""
"Return a new module object with the :attr:`__name__` attribute set to "
"*name*. The module's :attr:`__name__`, :attr:`__doc__`, :attr:`__package__`, "
"and :attr:`__loader__` attributes are filled in (all but :attr:`__name__` "
"are set to ``None``); the caller is responsible for providing a :attr:"
"`__file__` attribute."
msgstr ""
"Повертає новий об’єкт модуля з атрибутом :attr:`__name__`, встановленим на "
"*name*. Атрибути модуля :attr:`__name__`, :attr:`__doc__`, :attr:"
"`__package__` і :attr:`__loader__` заповнюються (для всіх, крім :attr:"
"`__name__`, встановлено значення ``None``); абонент відповідає за надання "
"атрибута :attr:`__file__`."

msgid ":attr:`__package__` and :attr:`__loader__` are set to ``None``."
msgstr ":attr:`__package__` і :attr:`__loader__` мають значення ``None``."

msgid ""
"Similar to :c:func:`PyModule_NewObject`, but the name is a UTF-8 encoded "
"string instead of a Unicode object."
msgstr ""
"Подібно до :c:func:`PyModule_NewObject`, але ім’я — це рядок у кодуванні "
"UTF-8, а не об’єкт Unicode."

msgid ""
"Return the dictionary object that implements *module*'s namespace; this "
"object is the same as the :attr:`~object.__dict__` attribute of the module "
"object. If *module* is not a module object (or a subtype of a module "
"object), :exc:`SystemError` is raised and ``NULL`` is returned."
msgstr ""
"Повертає об’єкт словника, який реалізує простір імен *module*; цей об’єкт "
"збігається з атрибутом :attr:`~object.__dict__` об’єкта модуля. Якщо "
"*module* не є об’єктом модуля (або підтипом об’єкта модуля), виникає :exc:"
"`SystemError` і повертається ``NULL``."

msgid ""
"It is recommended extensions use other ``PyModule_*`` and ``PyObject_*`` "
"functions rather than directly manipulate a module's :attr:`~object."
"__dict__`."
msgstr ""

msgid ""
"Return *module*'s :attr:`__name__` value.  If the module does not provide "
"one, or if it is not a string, :exc:`SystemError` is raised and ``NULL`` is "
"returned."
msgstr ""
"Повертає значення *module* :attr:`__name__`. Якщо модуль не надає його або "
"якщо це не рядок, виникає :exc:`SystemError` і повертається ``NULL``."

msgid ""
"Similar to :c:func:`PyModule_GetNameObject` but return the name encoded to "
"``'utf-8'``."
msgstr ""
"Подібно до :c:func:`PyModule_GetNameObject`, але повертає назву, закодовану "
"в ``'utf-8'``."

msgid ""
"Return the \"state\" of the module, that is, a pointer to the block of "
"memory allocated at module creation time, or ``NULL``.  See :c:member:"
"`PyModuleDef.m_size`."
msgstr ""
"Повертає \"стан\" модуля, тобто вказівник на блок пам’яті, виділений під час "
"створення модуля, або ``NULL``. Перегляньте :c:member:`PyModuleDef.m_size`."

msgid ""
"Return a pointer to the :c:type:`PyModuleDef` struct from which the module "
"was created, or ``NULL`` if the module wasn't created from a definition."
msgstr ""
"Повертає вказівник на структуру :c:type:`PyModuleDef`, з якої було створено "
"модуль, або ``NULL``, якщо модуль не було створено з визначення."

msgid ""
"Return the name of the file from which *module* was loaded using *module*'s :"
"attr:`__file__` attribute.  If this is not defined, or if it is not a "
"unicode string, raise :exc:`SystemError` and return ``NULL``; otherwise "
"return a reference to a Unicode object."
msgstr ""
"Повертає назву файлу, з якого було завантажено *module*, використовуючи "
"атрибут *module* :attr:`__file__`. Якщо це не визначено, або якщо це не "
"рядок Юнікод, викликати :exc:`SystemError` і повернути ``NULL``; інакше "
"повертає посилання на об’єкт Unicode."

msgid ""
"Similar to :c:func:`PyModule_GetFilenameObject` but return the filename "
"encoded to 'utf-8'."
msgstr ""
"Подібно до :c:func:`PyModule_GetFilenameObject`, але повертає назву файлу, "
"закодовану як 'utf-8'."

msgid ""
":c:func:`PyModule_GetFilename` raises :c:type:`UnicodeEncodeError` on "
"unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead."
msgstr ""
":c:func:`PyModule_GetFilename` викликає :c:type:`UnicodeEncodeError` на "
"некодованих іменах файлів, замість цього використовуйте :c:func:"
"`PyModule_GetFilenameObject`."

msgid "Initializing C modules"
msgstr "Ініціалізація модулів C"

msgid ""
"Modules objects are usually created from extension modules (shared libraries "
"which export an initialization function), or compiled-in modules (where the "
"initialization function is added using :c:func:`PyImport_AppendInittab`). "
"See :ref:`building` or :ref:`extending-with-embedding` for details."
msgstr ""
"Об’єкти Modules зазвичай створюються з модулів розширення (спільних "
"бібліотек, які експортують функцію ініціалізації) або скомпільованих модулів "
"(куди функція ініціалізації додається за допомогою :c:func:"
"`PyImport_AppendInittab`). Дивіться :ref:`building` або :ref:`extending-with-"
"embedding` для деталей."

msgid ""
"The initialization function can either pass a module definition instance to :"
"c:func:`PyModule_Create`, and return the resulting module object, or request "
"\"multi-phase initialization\" by returning the definition struct itself."
msgstr ""
"Функція ініціалізації може або передати екземпляр визначення модуля до :c:"
"func:`PyModule_Create` і повернути результуючий об’єкт модуля, або запросити "
"\"багатофазову ініціалізацію\", повернувши саму структуру визначення."

msgid ""
"The module definition struct, which holds all information needed to create a "
"module object. There is usually only one statically initialized variable of "
"this type for each module."
msgstr ""
"Структура визначення модуля, яка містить всю інформацію, необхідну для "
"створення об’єкта модуля. Зазвичай існує лише одна статично ініціалізована "
"змінна цього типу для кожного модуля."

msgid "Always initialize this member to :const:`PyModuleDef_HEAD_INIT`."
msgstr "Завжди ініціалізуйте цей член :const:`PyModuleDef_HEAD_INIT`."

msgid "Name for the new module."
msgstr "Назва для нового модуля."

msgid ""
"Docstring for the module; usually a docstring variable created with :c:macro:"
"`PyDoc_STRVAR` is used."
msgstr ""
"Рядок документації для модуля; зазвичай використовується змінна docstring, "
"створена за допомогою :c:macro:`PyDoc_STRVAR`."

msgid ""
"Module state may be kept in a per-module memory area that can be retrieved "
"with :c:func:`PyModule_GetState`, rather than in static globals. This makes "
"modules safe for use in multiple sub-interpreters."
msgstr ""
"Стан модуля може зберігатися в області пам’яті для кожного модуля, яку можна "
"отримати за допомогою :c:func:`PyModule_GetState`, а не в статичних "
"глобалах. Це робить модулі безпечними для використання в кількох "
"субінтерпретаторах."

msgid ""
"This memory area is allocated based on *m_size* on module creation, and "
"freed when the module object is deallocated, after the :c:member:`m_free` "
"function has been called, if present."
msgstr ""
"Ця область пам’яті виділяється на основі *m_size* під час створення модуля "
"та звільняється, коли об’єкт модуля звільняється, після виклику функції :c:"
"member:`m_free`, якщо вона є."

msgid ""
"Setting ``m_size`` to ``-1`` means that the module does not support sub-"
"interpreters, because it has global state."
msgstr ""
"Встановлення ``m_size`` на ``-1`` означає, що модуль не підтримує суб-"
"інтерпретатори, оскільки він має глобальний стан."

msgid ""
"Setting it to a non-negative value means that the module can be re-"
"initialized and specifies the additional amount of memory it requires for "
"its state. Non-negative ``m_size`` is required for multi-phase "
"initialization."
msgstr ""
"Встановлення невід’ємного значення означає, що модуль можна повторно "
"ініціалізувати, і вказує додатковий обсяг пам’яті, який йому потрібен для "
"його стану. Для багатофазної ініціалізації необхідний невід’ємний ``m_size``."

msgid "See :PEP:`3121` for more details."
msgstr "Додаткову інформацію див. :PEP:`3121`."

msgid ""
"A pointer to a table of module-level functions, described by :c:type:"
"`PyMethodDef` values.  Can be ``NULL`` if no functions are present."
msgstr ""
"Покажчик на таблицю функцій рівня модуля, описану значеннями :c:type:"
"`PyMethodDef`. Може бути ``NULL``, якщо функції відсутні."

msgid ""
"An array of slot definitions for multi-phase initialization, terminated by a "
"``{0, NULL}`` entry. When using single-phase initialization, *m_slots* must "
"be ``NULL``."
msgstr ""
"Масив визначень слотів для багатофазної ініціалізації, що завершується "
"записом ``{0, NULL}``. У разі використання однофазної ініціалізації "
"*m_slots* має бути ``NULL``."

msgid ""
"Prior to version 3.5, this member was always set to ``NULL``, and was "
"defined as:"
msgstr "До версії 3.5 цей член завжди мав значення ``NULL`` і визначався як:"

msgid ""
"A traversal function to call during GC traversal of the module object, or "
"``NULL`` if not needed."
msgstr ""
"Функція обходу, яка викликається під час обходу GC об’єкта модуля, або "
"``NULL``, якщо не потрібна."

msgid ""
"This function is not called if the module state was requested but is not "
"allocated yet. This is the case immediately after the module is created and "
"before the module is executed (:c:data:`Py_mod_exec` function). More "
"precisely, this function is not called if :c:member:`m_size` is greater than "
"0 and the module state (as returned by :c:func:`PyModule_GetState`) is "
"``NULL``."
msgstr ""
"Ця функція не викликається, якщо стан модуля було запитано, але ще не "
"виділено. Це відбувається одразу після створення модуля та перед його "
"виконанням (функція :c:data:`Py_mod_exec`). Точніше, ця функція не "
"викликається, якщо :c:member:`m_size` більше 0, а стан модуля (як "
"повертається :c:func:`PyModule_GetState`) дорівнює ``NULL``."

msgid "No longer called before the module state is allocated."
msgstr "Більше не викликається до виділення стану модуля."

msgid ""
"A clear function to call during GC clearing of the module object, or "
"``NULL`` if not needed."
msgstr ""
"Очистити функцію для виклику під час очищення GC об’єкта модуля або "
"``NULL``, якщо не потрібно."

msgid ""
"Like :c:member:`PyTypeObject.tp_clear`, this function is not *always* called "
"before a module is deallocated. For example, when reference counting is "
"enough to determine that an object is no longer used, the cyclic garbage "
"collector is not involved and :c:member:`~PyModuleDef.m_free` is called "
"directly."
msgstr ""
"Як і :c:member:`PyTypeObject.tp_clear`, ця функція не *завжди* викликається "
"до того, як модуль буде звільнено. Наприклад, коли підрахунку посилань "
"достатньо, щоб визначити, що об’єкт більше не використовується, циклічний "
"збирач сміття не задіяний і :c:member:`~PyModuleDef.m_free` викликається "
"безпосередньо."

msgid ""
"A function to call during deallocation of the module object, or ``NULL`` if "
"not needed."
msgstr ""
"Функція для виклику під час звільнення об’єкта модуля або ``NULL``, якщо "
"вона не потрібна."

msgid "Single-phase initialization"
msgstr "Однофазна ініціалізація"

msgid ""
"The module initialization function may create and return the module object "
"directly. This is referred to as \"single-phase initialization\", and uses "
"one of the following two module creation functions:"
msgstr ""
"Функція ініціалізації модуля може створювати та повертати об’єкт модуля "
"безпосередньо. Це називається \"однофазною ініціалізацією\" та використовує "
"одну з наступних двох функцій створення модуля:"

msgid ""
"Create a new module object, given the definition in *def*.  This behaves "
"like :c:func:`PyModule_Create2` with *module_api_version* set to :const:"
"`PYTHON_API_VERSION`."
msgstr ""
"Створіть новий об’єкт модуля відповідно до визначення в *def*. Це поводиться "
"як :c:func:`PyModule_Create2` з *module_api_version* встановленим на :const:"
"`PYTHON_API_VERSION`."

msgid ""
"Create a new module object, given the definition in *def*, assuming the API "
"version *module_api_version*.  If that version does not match the version of "
"the running interpreter, a :exc:`RuntimeWarning` is emitted."
msgstr ""
"Створіть новий об’єкт модуля, враховуючи визначення в *def*, припускаючи "
"версію API *module_api_version*. Якщо ця версія не збігається з версією "
"запущеного інтерпретатора, видається :exc:`RuntimeWarning`."

msgid ""
"Most uses of this function should be using :c:func:`PyModule_Create` "
"instead; only use this if you are sure you need it."
msgstr ""
"Більшість випадків використання цієї функції має використовувати замість "
"неї :c:func:`PyModule_Create`; використовуйте це, лише якщо ви впевнені, що "
"це вам потрібно."

msgid ""
"Before it is returned from in the initialization function, the resulting "
"module object is typically populated using functions like :c:func:"
"`PyModule_AddObjectRef`."
msgstr ""
"Перед поверненням у функції ініціалізації результуючий об’єкт модуля "
"зазвичай заповнюється за допомогою таких функцій, як :c:func:"
"`PyModule_AddObjectRef`."

msgid "Multi-phase initialization"
msgstr "Багатофазова ініціалізація"

msgid ""
"An alternate way to specify extensions is to request \"multi-phase "
"initialization\". Extension modules created this way behave more like Python "
"modules: the initialization is split between the *creation phase*, when the "
"module object is created, and the *execution phase*, when it is populated. "
"The distinction is similar to the :py:meth:`__new__` and :py:meth:`__init__` "
"methods of classes."
msgstr ""
"Альтернативним способом визначення розширень є запит на \"багатофазову "
"ініціалізацію\". Модулі розширення, створені таким чином, поводяться більше "
"як модулі Python: ініціалізація розподіляється між *фазою створення*, коли "
"створюється об’єкт модуля, і *фазою виконання*, коли він заповнюється. "
"Розрізнення подібне до методів класів :py:meth:`__new__` і :py:meth:"
"`__init__`."

msgid ""
"Unlike modules created using single-phase initialization, these modules are "
"not singletons: if the *sys.modules* entry is removed and the module is re-"
"imported, a new module object is created, and the old module is subject to "
"normal garbage collection -- as with Python modules. By default, multiple "
"modules created from the same definition should be independent: changes to "
"one should not affect the others. This means that all state should be "
"specific to the module object (using e.g. using :c:func:"
"`PyModule_GetState`), or its contents (such as the module's :attr:`__dict__` "
"or individual classes created with :c:func:`PyType_FromSpec`)."
msgstr ""
"На відміну від модулів, створених за допомогою однофазної ініціалізації, ці "
"модулі не є одиночними: якщо запис *sys.modules* видаляється та модуль "
"імпортується повторно, створюється новий об’єкт модуля, а старий модуль "
"підлягає звичайному збиранню сміття -- як і з модулями Python. За "
"замовчуванням кілька модулів, створених з одного визначення, мають бути "
"незалежними: зміни в одному не повинні впливати на інші. Це означає, що весь "
"стан має бути специфічним для об’єкта модуля (використовуючи, наприклад, "
"використання :c:func:`PyModule_GetState`), або його вмісту (наприклад, :attr:"
"`__dict__` модуля або окремих класів, створених за допомогою :c:func:"
"`PyType_FromSpec`)."

msgid ""
"All modules created using multi-phase initialization are expected to "
"support :ref:`sub-interpreters <sub-interpreter-support>`. Making sure "
"multiple modules are independent is typically enough to achieve this."
msgstr ""
"Очікується, що всі модулі, створені за допомогою багатофазної ініціалізації, "
"підтримуватимуть :ref:`sub-інтерпретатори <sub-interpreter-support>`. "
"Переконавшись, що декілька модулів є незалежними, як правило, достатньо, щоб "
"досягти цього."

msgid ""
"To request multi-phase initialization, the initialization function "
"(PyInit_modulename) returns a :c:type:`PyModuleDef` instance with non-empty :"
"c:member:`~PyModuleDef.m_slots`. Before it is returned, the ``PyModuleDef`` "
"instance must be initialized with the following function:"
msgstr ""
"Для запиту багатофазної ініціалізації функція ініціалізації "
"(PyInit_modulename) повертає екземпляр :c:type:`PyModuleDef` з непорожнім :c:"
"member:`~PyModuleDef.m_slots`. Перш ніж його буде повернуто, примірник "
"``PyModuleDef`` має бути ініціалізований такою функцією:"

msgid ""
"Ensures a module definition is a properly initialized Python object that "
"correctly reports its type and reference count."
msgstr ""
"Гарантує, що визначення модуля є правильно ініціалізованим об’єктом Python, "
"який правильно повідомляє про свій тип і кількість посилань."

msgid "Returns *def* cast to ``PyObject*``, or ``NULL`` if an error occurred."
msgstr ""
"Повертає *def* приведення до ``PyObject*`` або ``NULL``, якщо сталася "
"помилка."

msgid ""
"The *m_slots* member of the module definition must point to an array of "
"``PyModuleDef_Slot`` structures:"
msgstr ""
"Член *m_slots* у визначенні модуля має вказувати на масив структур "
"``PyModuleDef_Slot``:"

msgid "A slot ID, chosen from the available values explained below."
msgstr "Ідентифікатор слота, вибраний із доступних значень, пояснених нижче."

msgid "Value of the slot, whose meaning depends on the slot ID."
msgstr "Значення слота, значення якого залежить від ідентифікатора слота."

msgid "The *m_slots* array must be terminated by a slot with id 0."
msgstr "Масив *m_slots* повинен закінчуватися слотом з ідентифікатором 0."

msgid "The available slot types are:"
msgstr "Доступні типи слотів:"

msgid ""
"Specifies a function that is called to create the module object itself. The "
"*value* pointer of this slot must point to a function of the signature:"
msgstr ""
"Визначає функцію, яка викликається для створення самого об’єкта модуля. "
"Покажчик *значення* цього слота має вказувати на функцію підпису:"

msgid ""
"The function receives a :py:class:`~importlib.machinery.ModuleSpec` "
"instance, as defined in :PEP:`451`, and the module definition. It should "
"return a new module object, or set an error and return ``NULL``."
msgstr ""
"Функція отримує екземпляр :py:class:`~importlib.machinery.ModuleSpec`, як "
"визначено в :PEP:`451`, і визначення модуля. Він має повернути новий об’єкт "
"модуля або встановити помилку та повернути ``NULL``."

msgid ""
"This function should be kept minimal. In particular, it should not call "
"arbitrary Python code, as trying to import the same module again may result "
"in an infinite loop."
msgstr ""
"Ця функція повинна бути мінімальною. Зокрема, він не повинен викликати "
"довільний код Python, оскільки повторна спроба імпортувати той самий модуль "
"може призвести до нескінченного циклу."

msgid ""
"Multiple ``Py_mod_create`` slots may not be specified in one module "
"definition."
msgstr ""
"Кілька слотів ``Py_mod_create`` не можуть бути вказані в одному визначенні "
"модуля."

msgid ""
"If ``Py_mod_create`` is not specified, the import machinery will create a "
"normal module object using :c:func:`PyModule_New`. The name is taken from "
"*spec*, not the definition, to allow extension modules to dynamically adjust "
"to their place in the module hierarchy and be imported under different names "
"through symlinks, all while sharing a single module definition."
msgstr ""
"Якщо ``Py_mod_create`` не вказано, механізм імпорту створить звичайний "
"об’єкт модуля за допомогою :c:func:`PyModule_New`. Ім’я взято з *spec*, а не "
"з визначення, щоб дозволити модулям розширення динамічно адаптуватися до "
"свого місця в ієрархії модулів і імпортуватися під різними іменами за "
"допомогою символічних посилань, водночас користуючись єдиним визначенням "
"модуля."

msgid ""
"There is no requirement for the returned object to be an instance of :c:type:"
"`PyModule_Type`. Any type can be used, as long as it supports setting and "
"getting import-related attributes. However, only ``PyModule_Type`` instances "
"may be returned if the ``PyModuleDef`` has non-``NULL`` ``m_traverse``, "
"``m_clear``, ``m_free``; non-zero ``m_size``; or slots other than "
"``Py_mod_create``."
msgstr ""
"Немає вимоги, щоб повернутий об’єкт був екземпляром :c:type:`PyModule_Type`. "
"Можна використовувати будь-який тип, якщо він підтримує встановлення та "
"отримання пов’язаних з імпортом атрибутів. Однак лише екземпляри "
"``PyModule_Type`` можуть повертатися, якщо ``PyModuleDef`` має не-``NULL`` "
"``m_traverse``, ``m_clear``, ``m_free``; ненульовий ``m_size``; або слоти, "
"відмінні від ``Py_mod_create``."

msgid ""
"Specifies a function that is called to *execute* the module. This is "
"equivalent to executing the code of a Python module: typically, this "
"function adds classes and constants to the module. The signature of the "
"function is:"
msgstr ""
"Визначає функцію, яка викликається для *виконання* модуля. Це еквівалентно "
"виконанню коду модуля Python: зазвичай ця функція додає класи та константи "
"до модуля. Сигнатура функції:"

msgid ""
"If multiple ``Py_mod_exec`` slots are specified, they are processed in the "
"order they appear in the *m_slots* array."
msgstr ""
"Якщо вказано кілька слотів ``Py_mod_exec``, вони обробляються в тому "
"порядку, в якому вони з’являються в масиві *m_slots*."

msgid "See :PEP:`489` for more details on multi-phase initialization."
msgstr ""
"Перегляньте :PEP:`489` для отримання додаткової інформації про багатофазову "
"ініціалізацію."

msgid "Low-level module creation functions"
msgstr "Функції створення модулів низького рівня"

msgid ""
"The following functions are called under the hood when using multi-phase "
"initialization. They can be used directly, for example when creating module "
"objects dynamically. Note that both ``PyModule_FromDefAndSpec`` and "
"``PyModule_ExecDef`` must be called to fully initialize a module."
msgstr ""
"Наступні функції викликаються під капотом під час використання багатофазної "
"ініціалізації. Їх можна використовувати безпосередньо, наприклад, при "
"динамічному створенні об’єктів модуля. Зауважте, що для повної ініціалізації "
"модуля необхідно викликати як ``PyModule_FromDefAndSpec``, так і "
"``PyModule_ExecDef``."

msgid ""
"Create a new module object, given the definition in *module* and the "
"ModuleSpec *spec*.  This behaves like :c:func:`PyModule_FromDefAndSpec2` "
"with *module_api_version* set to :const:`PYTHON_API_VERSION`."
msgstr ""
"Створіть новий об’єкт модуля, враховуючи визначення в *module* і ModuleSpec "
"*spec*. Це поводиться як :c:func:`PyModule_FromDefAndSpec2` з "
"*module_api_version* встановленим на :const:`PYTHON_API_VERSION`."

msgid ""
"Create a new module object, given the definition in *module* and the "
"ModuleSpec *spec*, assuming the API version *module_api_version*. If that "
"version does not match the version of the running interpreter, a :exc:"
"`RuntimeWarning` is emitted."
msgstr ""
"Створіть новий об’єкт модуля, враховуючи визначення в *module* та ModuleSpec "
"*spec*, припускаючи версію API *module_api_version*. Якщо ця версія не "
"збігається з версією запущеного інтерпретатора, видається :exc:"
"`RuntimeWarning`."

msgid ""
"Most uses of this function should be using :c:func:`PyModule_FromDefAndSpec` "
"instead; only use this if you are sure you need it."
msgstr ""
"У більшості випадків використання цієї функції має використовувати :c:func:"
"`PyModule_FromDefAndSpec`; використовуйте це, лише якщо ви впевнені, що це "
"вам потрібно."

msgid "Process any execution slots (:c:data:`Py_mod_exec`) given in *def*."
msgstr ""
"Обробити будь-які слоти виконання (:c:data:`Py_mod_exec`), указані в *def*."

msgid ""
"Set the docstring for *module* to *docstring*. This function is called "
"automatically when creating a module from ``PyModuleDef``, using either "
"``PyModule_Create`` or ``PyModule_FromDefAndSpec``."
msgstr ""
"Встановіть рядок документації для *module* на *string*. Ця функція "
"викликається автоматично під час створення модуля з ``PyModuleDef`` за "
"допомогою ``PyModule_Create`` або ``PyModule_FromDefAndSpec``."

msgid ""
"Add the functions from the ``NULL`` terminated *functions* array to "
"*module*. Refer to the :c:type:`PyMethodDef` documentation for details on "
"individual entries (due to the lack of a shared module namespace, module "
"level \"functions\" implemented in C typically receive the module as their "
"first parameter, making them similar to instance methods on Python classes). "
"This function is called automatically when creating a module from "
"``PyModuleDef``, using either ``PyModule_Create`` or "
"``PyModule_FromDefAndSpec``."
msgstr ""
"Додайте функції з масиву *functions* із закінченням ``NULL`` до *module*. "
"Зверніться до документації :c:type:`PyMethodDef`, щоб дізнатися більше про "
"окремі записи (через відсутність спільного простору імен модуля \"функції\" "
"рівня модуля, реалізовані в C, зазвичай отримують модуль як свій перший "
"параметр, що робить їх схожими на екземпляр методи на класах Python). Ця "
"функція викликається автоматично під час створення модуля з ``PyModuleDef`` "
"за допомогою ``PyModule_Create`` або ``PyModule_FromDefAndSpec``."

msgid "Support functions"
msgstr "Допоміжні функції"

msgid ""
"The module initialization function (if using single phase initialization) or "
"a function called from a module execution slot (if using multi-phase "
"initialization), can use the following functions to help initialize the "
"module state:"
msgstr ""
"Функція ініціалізації модуля (якщо використовується однофазна ініціалізація) "
"або функція, що викликається зі слота виконання модуля (якщо "
"використовується багатофазова ініціалізація), може використовувати такі "
"функції, щоб допомогти ініціалізувати стан модуля:"

msgid ""
"Add an object to *module* as *name*.  This is a convenience function which "
"can be used from the module's initialization function."
msgstr ""
"Додайте об’єкт до *модуля* як *ім’я*. Це зручна функція, яку можна "
"використовувати з функції ініціалізації модуля."

msgid ""
"On success, return ``0``. On error, raise an exception and return ``-1``."
msgstr ""
"У разі успіху поверніть ``0``. У разі помилки викликає виняток і повертає "
"``-1``."

msgid ""
"Return ``NULL`` if *value* is ``NULL``. It must be called with an exception "
"raised in this case."
msgstr ""
"Повертає ``NULL``, якщо *значення* дорівнює ``NULL``. У цьому випадку його "
"потрібно викликати з винятком."

msgid "Example usage::"
msgstr "Приклад використання::"

msgid ""
"The example can also be written without checking explicitly if *obj* is "
"``NULL``::"
msgstr ""
"Приклад також можна написати без явної перевірки, якщо *obj* має значення "
"``NULL``::"

msgid ""
"Note that ``Py_XDECREF()`` should be used instead of ``Py_DECREF()`` in this "
"case, since *obj* can be ``NULL``."
msgstr ""
"Зверніть увагу, що в цьому випадку слід використовувати ``Py_XDECREF()`` "
"замість ``Py_DECREF()``, оскільки *obj* може бути ``NULL``."

msgid ""
"Similar to :c:func:`PyModule_AddObjectRef`, but steals a reference to "
"*value* on success (if it returns ``0``)."
msgstr ""
"Подібно до :c:func:`PyModule_AddObjectRef`, але в разі успіху викрадає "
"посилання на *value* (якщо повертає ``0``)."

msgid ""
"The new :c:func:`PyModule_AddObjectRef` function is recommended, since it is "
"easy to introduce reference leaks by misusing the :c:func:"
"`PyModule_AddObject` function."
msgstr ""
"Рекомендовано використовувати нову функцію :c:func:`PyModule_AddObjectRef`, "
"оскільки внаслідок неправильного використання функції :c:func:"
"`PyModule_AddObject` легко створити витоки посилань."

msgid ""
"Unlike other functions that steal references, ``PyModule_AddObject()`` only "
"decrements the reference count of *value* **on success**."
msgstr ""
"На відміну від інших функцій, які викрадають посилання, "
"``PyModule_AddObject()`` лише зменшує кількість посилань *значення* **у разі "
"успіху**."

msgid ""
"This means that its return value must be checked, and calling code must :c:"
"func:`Py_DECREF` *value* manually on error."
msgstr ""
"Це означає, що його повертане значення має бути перевірено, а код виклику "
"повинен :c:func:`Py_DECREF` *значення* вручну у разі помилки."

msgid ""
"Add an integer constant to *module* as *name*.  This convenience function "
"can be used from the module's initialization function. Return ``-1`` on "
"error, ``0`` on success."
msgstr ""
"Додайте цілу константу до *module* як *name*. Цю зручну функцію можна "
"використовувати з функції ініціалізації модуля. Повертає ``-1`` у разі "
"помилки, ``0`` у разі успіху."

msgid ""
"Add a string constant to *module* as *name*.  This convenience function can "
"be used from the module's initialization function.  The string *value* must "
"be ``NULL``-terminated.  Return ``-1`` on error, ``0`` on success."
msgstr ""
"Додайте рядкову константу до *module* як *name*. Цю зручну функцію можна "
"використовувати з функції ініціалізації модуля. Рядок *значення* має "
"завершуватися ``NULL``. Повертає ``-1`` у разі помилки, ``0`` у разі успіху."

msgid ""
"Add an int constant to *module*. The name and the value are taken from "
"*macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the int "
"constant *AF_INET* with the value of *AF_INET* to *module*. Return ``-1`` on "
"error, ``0`` on success."
msgstr ""
"Додайте константу int до *module*. Ім'я та значення взято з *макросу*. "
"Наприклад, ``PyModule_AddIntMacro(module, AF_INET)`` додає константу int "
"*AF_INET* зі значенням *AF_INET* до *module*. Повертає ``-1`` у разі "
"помилки, ``0`` у разі успіху."

msgid "Add a string constant to *module*."
msgstr "Додайте рядкову константу до *module*."

msgid ""
"Add a type object to *module*. The type object is finalized by calling "
"internally :c:func:`PyType_Ready`. The name of the type object is taken from "
"the last component of :c:member:`~PyTypeObject.tp_name` after dot. Return "
"``-1`` on error, ``0`` on success."
msgstr ""
"Додайте об’єкт типу до *module*. Об’єкт типу завершується внутрішнім "
"викликом :c:func:`PyType_Ready`. Ім’я об’єкта типу береться з останнього "
"компонента :c:member:`~PyTypeObject.tp_name` після крапки. Повертає ``-1`` у "
"разі помилки, ``0`` у разі успіху."

msgid "Module lookup"
msgstr "Пошук модуля"

msgid ""
"Single-phase initialization creates singleton modules that can be looked up "
"in the context of the current interpreter. This allows the module object to "
"be retrieved later with only a reference to the module definition."
msgstr ""
"Однофазова ініціалізація створює однотонні модулі, які можна шукати в "
"контексті поточного інтерпретатора. Це дозволяє пізніше отримати об’єкт "
"модуля лише з посиланням на визначення модуля."

msgid ""
"These functions will not work on modules created using multi-phase "
"initialization, since multiple such modules can be created from a single "
"definition."
msgstr ""
"Ці функції не працюватимуть на модулях, створених за допомогою багатофазної "
"ініціалізації, оскільки кілька таких модулів можна створити з одного "
"визначення."

msgid ""
"Returns the module object that was created from *def* for the current "
"interpreter. This method requires that the module object has been attached "
"to the interpreter state with :c:func:`PyState_AddModule` beforehand. In "
"case the corresponding module object is not found or has not been attached "
"to the interpreter state yet, it returns ``NULL``."
msgstr ""
"Повертає об’єкт модуля, який було створено з *def* для поточного "
"інтерпретатора. Цей метод вимагає, щоб об’єкт модуля був прикріплений до "
"стану інтерпретатора за допомогою :c:func:`PyState_AddModule` заздалегідь. "
"Якщо відповідний об’єкт модуля не знайдено або ще не приєднано до стану "
"інтерпретатора, він повертає ``NULL``."

msgid ""
"Attaches the module object passed to the function to the interpreter state. "
"This allows the module object to be accessible via :c:func:"
"`PyState_FindModule`."
msgstr ""
"Приєднує об’єкт модуля, переданий у функцію, до стану інтерпретатора. Це "
"дозволяє об’єкту модуля бути доступним через :c:func:`PyState_FindModule`."

msgid "Only effective on modules created using single-phase initialization."
msgstr "Діє лише для модулів, створених за допомогою однофазної ініціалізації."

msgid ""
"Python calls ``PyState_AddModule`` automatically after importing a module, "
"so it is unnecessary (but harmless) to call it from module initialization "
"code. An explicit call is needed only if the module's own init code "
"subsequently calls ``PyState_FindModule``. The function is mainly intended "
"for implementing alternative import mechanisms (either by calling it "
"directly, or by referring to its implementation for details of the required "
"state updates)."
msgstr ""
"Python автоматично викликає ``PyState_AddModule`` після імпортування модуля, "
"тому непотрібно (але нешкідливо) викликати його з коду ініціалізації модуля. "
"Явний виклик потрібен, лише якщо власний код ініціалізації модуля згодом "
"викликає ``PyState_FindModule``. Ця функція в основному призначена для "
"впровадження альтернативних механізмів імпорту (або через її прямий виклик, "
"або шляхом посилання на її реалізацію для отримання деталей необхідних "
"оновлень стану)."

msgid "The caller must hold the GIL."
msgstr "Абонент повинен тримати GIL."

msgid "Return 0 on success or -1 on failure."
msgstr "Повертає 0 у разі успіху або -1 у разі невдачі."

msgid ""
"Removes the module object created from *def* from the interpreter state. "
"Return 0 on success or -1 on failure."
msgstr ""
"Видаляє об’єкт модуля, створений з *def*, зі стану інтерпретатора. Повертає "
"0 у разі успіху або -1 у разі невдачі."
