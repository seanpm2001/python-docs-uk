# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:49+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Memory Management"
msgstr "Управління пам'яттю"

msgid "Overview"
msgstr "Огляд"

msgid ""
"Memory management in Python involves a private heap containing all Python "
"objects and data structures. The management of this private heap is ensured "
"internally by the *Python memory manager*.  The Python memory manager has "
"different components which deal with various dynamic storage management "
"aspects, like sharing, segmentation, preallocation or caching."
msgstr ""
"Керування пам’яттю в Python включає приватну купу, що містить усі об’єкти та "
"структури даних Python. Управління цією приватною купою забезпечується "
"внутрішньо за допомогою *Менеджера пам’яті Python*. Менеджер пам’яті Python "
"має різні компоненти, які стосуються різноманітних аспектів керування "
"динамічним сховищем, наприклад спільного використання, сегментації, "
"попереднього розподілу чи кешування."

msgid ""
"At the lowest level, a raw memory allocator ensures that there is enough "
"room in the private heap for storing all Python-related data by interacting "
"with the memory manager of the operating system. On top of the raw memory "
"allocator, several object-specific allocators operate on the same heap and "
"implement distinct memory management policies adapted to the peculiarities "
"of every object type. For example, integer objects are managed differently "
"within the heap than strings, tuples or dictionaries because integers imply "
"different storage requirements and speed/space tradeoffs. The Python memory "
"manager thus delegates some of the work to the object-specific allocators, "
"but ensures that the latter operate within the bounds of the private heap."
msgstr ""
"На найнижчому рівні розподільник необробленої пам’яті забезпечує наявність "
"достатнього місця в приватній купі для зберігання всіх пов’язаних із Python "
"даних шляхом взаємодії з диспетчером пам’яті операційної системи. Окрім "
"необробленого розподільника пам’яті, кілька об’єктно-специфічних "
"розподільників працюють на одній купі та реалізують різні політики керування "
"пам’яттю, адаптовані до особливостей кожного типу об’єкта. Наприклад, цілими "
"об’єктами в купі керують інакше, ніж рядками, кортежами чи словниками, "
"оскільки цілі числа передбачають різні вимоги до сховища та компроміси між "
"швидкістю та простором. Таким чином, менеджер пам’яті Python делегує частину "
"роботи об’єктно-специфічним розподільникам, але гарантує, що останні "
"працюють у межах приватної купи."

msgid ""
"It is important to understand that the management of the Python heap is "
"performed by the interpreter itself and that the user has no control over "
"it, even if they regularly manipulate object pointers to memory blocks "
"inside that heap.  The allocation of heap space for Python objects and other "
"internal buffers is performed on demand by the Python memory manager through "
"the Python/C API functions listed in this document."
msgstr ""
"Важливо розуміти, що керування купою Python виконується самим "
"інтерпретатором і що користувач не має контролю над нею, навіть якщо вони "
"регулярно маніпулюють покажчиками об’єктів на блоки пам’яті всередині цієї "
"купи. Виділення простору купи для об’єктів Python та інших внутрішніх "
"буферів виконується на вимогу менеджером пам’яті Python за допомогою функцій "
"API Python/C, перелічених у цьому документі."

msgid ""
"To avoid memory corruption, extension writers should never try to operate on "
"Python objects with the functions exported by the C library: :c:func:"
"`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`.  This will "
"result in  mixed calls between the C allocator and the Python memory manager "
"with fatal consequences, because they implement different algorithms and "
"operate on different heaps.  However, one may safely allocate and release "
"memory blocks with the C library allocator for individual purposes, as shown "
"in the following example::"
msgstr ""
"Щоб уникнути пошкодження пам’яті, автори розширень ніколи не повинні "
"намагатися працювати з об’єктами Python за допомогою функцій, експортованих "
"бібліотекою C: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` і :c:"
"func:`free`. Це призведе до змішаних викликів між розподільником C і "
"диспетчером пам’яті Python із фатальними наслідками, оскільки вони "
"реалізують різні алгоритми та працюють із різними купами. Однак можна "
"безпечно виділяти та звільняти блоки пам’яті за допомогою розподільника "
"бібліотеки C для окремих цілей, як показано в наступному прикладі:"

msgid ""
"In this example, the memory request for the I/O buffer is handled by the C "
"library allocator. The Python memory manager is involved only in the "
"allocation of the bytes object returned as a result."
msgstr ""
"У цьому прикладі запит пам’яті для буфера введення/виведення обробляється "
"розподільником бібліотеки C. Менеджер пам’яті Python бере участь лише у "
"розподілі об’єкта bytes, який повертається в результаті."

msgid ""
"In most situations, however, it is recommended to allocate memory from the "
"Python heap specifically because the latter is under control of the Python "
"memory manager. For example, this is required when the interpreter is "
"extended with new object types written in C. Another reason for using the "
"Python heap is the desire to *inform* the Python memory manager about the "
"memory needs of the extension module. Even when the requested memory is used "
"exclusively for internal, highly specific purposes, delegating all memory "
"requests to the Python memory manager causes the interpreter to have a more "
"accurate image of its memory footprint as a whole. Consequently, under "
"certain circumstances, the Python memory manager may or may not trigger "
"appropriate actions, like garbage collection, memory compaction or other "
"preventive procedures. Note that by using the C library allocator as shown "
"in the previous example, the allocated memory for the I/O buffer escapes "
"completely the Python memory manager."
msgstr ""

msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to configure the "
"memory allocators used by Python."
msgstr ""
"Змінну середовища :envvar:`PYTHONMALLOC` можна використовувати для "
"налаштування розподільників пам’яті, які використовує Python."

msgid ""
"The :envvar:`PYTHONMALLOCSTATS` environment variable can be used to print "
"statistics of the :ref:`pymalloc memory allocator <pymalloc>` every time a "
"new pymalloc object arena is created, and on shutdown."
msgstr ""
"Змінну середовища :envvar:`PYTHONMALLOCSTATS` можна використовувати для "
"виведення статистики :ref:`розподільника пам’яті pymalloc <pymalloc>` "
"кожного разу, коли створюється нова арена об’єкта pymalloc, і після "
"завершення роботи."

msgid "Allocator Domains"
msgstr "Розподільник доменів"

msgid ""
"All allocating functions belong to one of three different \"domains\" (see "
"also :c:type:`PyMemAllocatorDomain`). These domains represent different "
"allocation strategies and are optimized for different purposes. The specific "
"details on how every domain allocates memory or what internal functions each "
"domain calls is considered an implementation detail, but for debugging "
"purposes a simplified table can be found at :ref:`here <default-memory-"
"allocators>`. There is no hard requirement to use the memory returned by the "
"allocation functions belonging to a given domain for only the purposes "
"hinted by that domain (although this is the recommended practice). For "
"example, one could use the memory returned by :c:func:`PyMem_RawMalloc` for "
"allocating Python objects or the memory returned by :c:func:"
"`PyObject_Malloc` for allocating memory for buffers."
msgstr ""
"Усі функції розподілу належать до одного з трьох різних \"доменів\" (див. "
"також :c:type:`PyMemAllocatorDomain`). Ці домени представляють різні "
"стратегії розподілу та оптимізовані для різних цілей. Конкретні відомості "
"про те, як кожен домен розподіляє пам’ять або які внутрішні функції викликає "
"кожен домен, вважаються деталями реалізації, але для цілей налагодження "
"спрощену таблицю можна знайти за адресою :ref:`тут <default-memory-"
"allocators>`. Немає жорстких вимог щодо використання пам’яті, повернутої "
"функціями розподілу, що належить даному домену, лише для цілей, визначених "
"цим доменом (хоча це рекомендована практика). Наприклад, можна використати "
"пам’ять, яку повертає :c:func:`PyMem_RawMalloc` для виділення об’єктів "
"Python, або пам’ять, яку повертає :c:func:`PyObject_Malloc`, для виділення "
"пам’яті для буферів."

msgid "The three allocation domains are:"
msgstr "Три домени розподілу:"

msgid ""
"Raw domain: intended for allocating memory for general-purpose memory "
"buffers where the allocation *must* go to the system allocator or where the "
"allocator can operate without the :term:`GIL`. The memory is requested "
"directly to the system."
msgstr ""
"Необроблений домен: призначений для розподілу пам’яті для буферів пам’яті "
"загального призначення, де розподіл *має* надходити до системного "
"розподілювача або де розподільник може працювати без :term:`GIL`. Пам'ять "
"запитується безпосередньо системою."

msgid ""
"\"Mem\" domain: intended for allocating memory for Python buffers and "
"general-purpose memory buffers where the allocation must be performed with "
"the :term:`GIL` held. The memory is taken from the Python private heap."
msgstr ""
"Домен \"Mem\": призначений для виділення пам’яті для буферів Python і "
"буферів пам’яті загального призначення, де розподіл має виконуватися з "
"утриманням :term:`GIL`. Пам'ять береться з приватної купи Python."

msgid ""
"Object domain: intended for allocating memory belonging to Python objects. "
"The memory is taken from the Python private heap."
msgstr ""
"Домен об’єктів: призначений для розподілу пам’яті, що належить об’єктам "
"Python. Пам'ять береться з приватної купи Python."

msgid ""
"When freeing memory previously allocated by the allocating functions "
"belonging to a given domain,the matching specific deallocating functions "
"must be used. For example, :c:func:`PyMem_Free` must be used to free memory "
"allocated using :c:func:`PyMem_Malloc`."
msgstr ""
"Під час звільнення пам’яті, попередньо виділеної функціями розподілу, що "
"належать до даного домену, необхідно використовувати відповідні спеціальні "
"функції звільнення. Наприклад, :c:func:`PyMem_Free` потрібно використовувати "
"для звільнення пам’яті, виділеної за допомогою :c:func:`PyMem_Malloc`."

msgid "Raw Memory Interface"
msgstr "Інтерфейс необробленої пам'яті"

msgid ""
"The following function sets are wrappers to the system allocator. These "
"functions are thread-safe, the :term:`GIL <global interpreter lock>` does "
"not need to be held."
msgstr ""
"Наступні набори функцій є оболонками для системного розподілювача. Ці "
"функції є потокобезпечними, :term:`GIL <global interpreter lock>` не "
"потрібно зберігати."

msgid ""
"The :ref:`default raw memory allocator <default-memory-allocators>` uses the "
"following functions: :c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` "
"and :c:func:`free`; call ``malloc(1)`` (or ``calloc(1, 1)``) when requesting "
"zero bytes."
msgstr ""
":ref:`за замовчуванням необроблений розподільник пам’яті <default-memory-"
"allocators>` використовує такі функції: :c:func:`malloc`, :c:func:`calloc`, :"
"c:func:`realloc` і :c:func:`free`; викликати ``malloc(1)`` (або ``calloc(1, "
"1)``), коли запитує нульові байти."

msgid ""
"Allocates *n* bytes and returns a pointer of type :c:expr:`void*` to the "
"allocated memory, or ``NULL`` if the request fails."
msgstr ""

msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_RawMalloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Запит нульових байтів повертає окремий вказівник, відмінний від ``NULL``, "
"якщо це можливо, ніби замість цього було викликано ``PyMem_RawMalloc(1)``. "
"Пам'ять жодним чином не буде ініціалізовано."

msgid ""
"Allocates *nelem* elements each whose size in bytes is *elsize* and returns "
"a pointer of type :c:expr:`void*` to the allocated memory, or ``NULL`` if "
"the request fails. The memory is initialized to zeros."
msgstr ""

msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_RawCalloc(1, 1)`` had been "
"called instead."
msgstr ""
"Запит нульових елементів або елементів розміром нуль байтів повертає окремий "
"вказівник, відмінний від ``NULL``, якщо це можливо, ніби замість цього було "
"викликано ``PyMem_RawCalloc(1, 1)``."

msgid ""
"Resizes the memory block pointed to by *p* to *n* bytes. The contents will "
"be unchanged to the minimum of the old and the new sizes."
msgstr ""
"Змінює розмір блоку пам'яті, на який вказує *p*, до *n* байтів. Вміст буде "
"незмінним до мінімуму старого та нового розмірів."

msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_RawMalloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Якщо *p* має значення ``NULL``, виклик еквівалентний ``PyMem_RawMalloc(n)``; "
"інакше, якщо *n* дорівнює нулю, розмір блоку пам’яті змінюється, але не "
"звільняється, а повернутий вказівник не є ``NULL``."

msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or :c:func:"
"`PyMem_RawCalloc`."
msgstr ""
"Якщо *p* не має значення ``NULL``, воно має бути повернуто попереднім "
"викликом :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` або :c:func:"
"`PyMem_RawCalloc`."

msgid ""
"If the request fails, :c:func:`PyMem_RawRealloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Якщо запит завершується невдало, :c:func:`PyMem_RawRealloc` повертає "
"``NULL``, а *p* залишається дійсним покажчиком на попередню область пам’яті."

msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` or :c:"
"func:`PyMem_RawCalloc`.  Otherwise, or if ``PyMem_RawFree(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Звільняє блок пам’яті, на який вказує *p*, який мав бути повернутий "
"попереднім викликом :c:func:`PyMem_RawMalloc`, :c:func:`PyMem_RawRealloc` "
"або :c:func:`PyMem_RawCalloc`. В іншому випадку, або якщо "
"``PyMem_RawFree(p)`` був викликаний раніше, виникає невизначена поведінка."

msgid "If *p* is ``NULL``, no operation is performed."
msgstr "Якщо *p* має значення ``NULL``, жодна операція не виконується."

msgid "Memory Interface"
msgstr "Інтерфейс пам'яті"

msgid ""
"The following function sets, modeled after the ANSI C standard, but "
"specifying behavior when requesting zero bytes, are available for allocating "
"and releasing memory from the Python heap."
msgstr ""
"Наступні набори функцій, створені за стандартом ANSI C, але вказуючи "
"поведінку під час запиту нульових байтів, доступні для виділення та "
"звільнення пам’яті з купи Python."

msgid ""
"The :ref:`default memory allocator <default-memory-allocators>` uses the :"
"ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
":ref:`розподільник пам’яті за замовчуванням <default-memory-allocators>` "
"використовує :ref:`розподільник пам’яті pymalloc <pymalloc>`."

msgid ""
"The :term:`GIL <global interpreter lock>` must be held when using these "
"functions."
msgstr ""
":term:`GIL <global interpreter lock>` має зберігатися під час використання "
"цих функцій."

msgid ""
"The default allocator is now pymalloc instead of system :c:func:`malloc`."
msgstr ""
"Типовим розподільником тепер є pymalloc замість system :c:func:`malloc`."

msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyMem_Malloc(1)`` had been called instead. The memory will not have "
"been initialized in any way."
msgstr ""
"Запит нульових байтів повертає окремий вказівник, відмінний від ``NULL``, "
"якщо це можливо, ніби замість цього було викликано ``PyMem_Malloc(1)``. "
"Пам'ять жодним чином не буде ініціалізовано."

msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyMem_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Запит нульових елементів або елементів розміром нуль байтів повертає окремий "
"вказівник, відмінний від ``NULL``, якщо це можливо, як якщо б замість цього "
"було викликано ``PyMem_Calloc(1, 1)``."

msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyMem_Malloc(n)``; else if "
"*n* is equal to zero, the memory block is resized but is not freed, and the "
"returned pointer is non-``NULL``."
msgstr ""
"Якщо *p* має значення ``NULL``, виклик еквівалентний ``PyMem_Malloc(n)``; "
"інакше, якщо *n* дорівнює нулю, розмір блоку пам’яті змінюється, але не "
"звільняється, а повернутий вказівник не є ``NULL``."

msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:`PyMem_Calloc`."
msgstr ""
"Якщо *p* не має значення ``NULL``, воно має бути повернуто попереднім "
"викликом :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` або :c:func:"
"`PyMem_Calloc`."

msgid ""
"If the request fails, :c:func:`PyMem_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Якщо запит не вдається, :c:func:`PyMem_Realloc` повертає ``NULL``, а *p* "
"залишається дійсним покажчиком на попередню область пам’яті."

msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` or :c:func:"
"`PyMem_Calloc`.  Otherwise, or if ``PyMem_Free(p)`` has been called before, "
"undefined behavior occurs."
msgstr ""
"Звільняє блок пам’яті, на який вказує *p*, який мав бути повернутий "
"попереднім викликом :c:func:`PyMem_Malloc`, :c:func:`PyMem_Realloc` або :c:"
"func:`PyMem_Calloc`. В іншому випадку, або якщо ``PyMem_Free(p)`` був "
"викликаний раніше, виникає невизначена поведінка."

msgid ""
"The following type-oriented macros are provided for convenience.  Note  that "
"*TYPE* refers to any C type."
msgstr ""
"Для зручності надано наступні типоорієнтовані макроси. Зауважте, що *TYPE* "
"відноситься до будь-якого типу C."

msgid ""
"Same as :c:func:`PyMem_Malloc`, but allocates ``(n * sizeof(TYPE))`` bytes "
"of memory.  Returns a pointer cast to :c:expr:`TYPE*`.  The memory will not "
"have been initialized in any way."
msgstr ""

msgid ""
"Same as :c:func:`PyMem_Realloc`, but the memory block is resized to ``(n * "
"sizeof(TYPE))`` bytes.  Returns a pointer cast to :c:expr:`TYPE*`. On "
"return, *p* will be a pointer to the new memory area, or ``NULL`` in the "
"event of failure."
msgstr ""

msgid ""
"This is a C preprocessor macro; *p* is always reassigned.  Save the original "
"value of *p* to avoid losing memory when handling errors."
msgstr ""
"Це макрос препроцесора C; *p* завжди перепризначається. Збережіть початкове "
"значення *p*, щоб уникнути втрати пам’яті під час обробки помилок."

msgid "Same as :c:func:`PyMem_Free`."
msgstr "Те саме, що :c:func:`PyMem_Free`."

msgid ""
"In addition, the following macro sets are provided for calling the Python "
"memory allocator directly, without involving the C API functions listed "
"above. However, note that their use does not preserve binary compatibility "
"across Python versions and is therefore deprecated in extension modules."
msgstr ""
"Крім того, наведені нижче набори макросів надаються для безпосереднього "
"виклику розподільника пам’яті Python без залучення функцій C API, "
"перелічених вище. Однак зауважте, що їх використання не зберігає двійкову "
"сумісність між версіями Python і тому не підтримується в модулях розширення."

msgid "``PyMem_MALLOC(size)``"
msgstr "``PyMem_MALLOC(розмір)``"

msgid "``PyMem_NEW(type, size)``"
msgstr "``PyMem_NEW(тип, розмір)``"

msgid "``PyMem_REALLOC(ptr, size)``"
msgstr "``PyMem_REALLOC(ptr, size)``"

msgid "``PyMem_RESIZE(ptr, type, size)``"
msgstr "``PyMem_RESIZE(ptr, тип, розмір)``"

msgid "``PyMem_FREE(ptr)``"
msgstr "``PyMem_FREE(ptr)``"

msgid "``PyMem_DEL(ptr)``"
msgstr "``PyMem_DEL(ptr)``"

msgid "Object allocators"
msgstr "Розподільники об'єктів"

msgid ""
"There is no guarantee that the memory returned by these allocators can be "
"successfully cast to a Python object when intercepting the allocating "
"functions in this domain by the methods described in the :ref:`Customize "
"Memory Allocators <customize-memory-allocators>` section."
msgstr ""
"Немає жодної гарантії, що пам’ять, повернута цими розподільниками, може бути "
"успішно передана об’єкту Python під час перехоплення функцій виділення в "
"цьому домені за допомогою методів, описаних у розділі :ref:`Налаштування "
"розподільників пам’яті <customize-memory-allocators>`."

msgid ""
"The :ref:`default object allocator <default-memory-allocators>` uses the :"
"ref:`pymalloc memory allocator <pymalloc>`."
msgstr ""
":ref:`розподільник об’єктів за замовчуванням <default-memory-allocators>` "
"використовує :ref:`розподільник пам’яті pymalloc <pymalloc>`."

msgid ""
"Requesting zero bytes returns a distinct non-``NULL`` pointer if possible, "
"as if ``PyObject_Malloc(1)`` had been called instead. The memory will not "
"have been initialized in any way."
msgstr ""
"Запит нульових байтів повертає окремий покажчик, відмінний від ``NULL``, "
"якщо це можливо, ніби замість цього було викликано ``PyObject_Malloc(1)``. "
"Пам'ять жодним чином не буде ініціалізовано."

msgid ""
"Requesting zero elements or elements of size zero bytes returns a distinct "
"non-``NULL`` pointer if possible, as if ``PyObject_Calloc(1, 1)`` had been "
"called instead."
msgstr ""
"Запит нульових елементів або елементів розміром нуль байтів повертає окремий "
"вказівник, відмінний від ``NULL``, якщо це можливо, як якщо б замість цього "
"було викликано ``PyObject_Calloc(1, 1)``."

msgid ""
"If *p* is ``NULL``, the call is equivalent to ``PyObject_Malloc(n)``; else "
"if *n* is equal to zero, the memory block is resized but is not freed, and "
"the returned pointer is non-``NULL``."
msgstr ""
"Якщо *p* має значення ``NULL``, виклик еквівалентний ``PyObject_Malloc(n)``; "
"інакше, якщо *n* дорівнює нулю, розмір блоку пам’яті змінюється, але не "
"звільняється, а повернутий вказівник не є ``NULL``."

msgid ""
"Unless *p* is ``NULL``, it must have been returned by a previous call to :c:"
"func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or :c:func:"
"`PyObject_Calloc`."
msgstr ""
"Якщо *p* не має значення ``NULL``, воно має бути повернуто попереднім "
"викликом :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` або :c:func:"
"`PyObject_Calloc`."

msgid ""
"If the request fails, :c:func:`PyObject_Realloc` returns ``NULL`` and *p* "
"remains a valid pointer to the previous memory area."
msgstr ""
"Якщо запит не вдається, :c:func:`PyObject_Realloc` повертає ``NULL``, а *p* "
"залишається дійсним покажчиком на попередню область пам’яті."

msgid ""
"Frees the memory block pointed to by *p*, which must have been returned by a "
"previous call to :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` or :c:"
"func:`PyObject_Calloc`.  Otherwise, or if ``PyObject_Free(p)`` has been "
"called before, undefined behavior occurs."
msgstr ""
"Звільняє блок пам’яті, на який вказує *p*, який мав бути повернутий "
"попереднім викликом :c:func:`PyObject_Malloc`, :c:func:`PyObject_Realloc` "
"або :c:func:`PyObject_Calloc`. В іншому випадку, або якщо "
"``PyObject_Free(p)`` був викликаний раніше, виникає невизначена поведінка."

msgid "Default Memory Allocators"
msgstr "Типові розподілювачі пам'яті"

msgid "Default memory allocators:"
msgstr "Розподільники пам'яті за замовчуванням:"

msgid "Configuration"
msgstr "Конфігурація"

msgid "Name"
msgstr "Ім'я"

msgid "PyMem_RawMalloc"
msgstr "PyMem_RawMalloc"

msgid "PyMem_Malloc"
msgstr "PyMem_Malloc"

msgid "PyObject_Malloc"
msgstr "PyObject_Malloc"

msgid "Release build"
msgstr "Реліз збірки"

msgid "``\"pymalloc\"``"
msgstr "``\"pymalloc\"``"

msgid "``malloc``"
msgstr "``malloc``"

msgid "``pymalloc``"
msgstr "``pymalloc``"

msgid "Debug build"
msgstr "Налагодити збірку"

msgid "``\"pymalloc_debug\"``"
msgstr "``\"pymalloc_debug\"``"

msgid "``malloc`` + debug"
msgstr "``malloc`` + налагодження"

msgid "``pymalloc`` + debug"
msgstr "``pymalloc`` + налагодження"

msgid "Release build, without pymalloc"
msgstr "Випуск збірки без pymalloc"

msgid "``\"malloc\"``"
msgstr "``\"malloc\"``"

msgid "Debug build, without pymalloc"
msgstr "Збірка налагодження без pymalloc"

msgid "``\"malloc_debug\"``"
msgstr "``\"malloc_debug\"``"

msgid "Legend:"
msgstr "Легенда:"

msgid "Name: value for :envvar:`PYTHONMALLOC` environment variable."
msgstr "Ім’я: значення для змінної середовища :envvar:`PYTHONMALLOC`."

msgid ""
"``malloc``: system allocators from the standard C library, C functions: :c:"
"func:`malloc`, :c:func:`calloc`, :c:func:`realloc` and :c:func:`free`."
msgstr ""
"``malloc``: системні розподільники зі стандартної бібліотеки C, функції C: :"
"c:func:`malloc`, :c:func:`calloc`, :c:func:`realloc` і :c:func:`free`."

msgid "``pymalloc``: :ref:`pymalloc memory allocator <pymalloc>`."
msgstr "``pymalloc``: :ref:`розподіл пам'яті pymalloc <pymalloc>`."

msgid ""
"\"+ debug\": with :ref:`debug hooks on the Python memory allocators <pymem-"
"debug-hooks>`."
msgstr ""
"\"+ debug\": з :ref:`debug хуками розподільників пам’яті Python <pymem-debug-"
"hooks>`."

msgid "\"Debug build\": :ref:`Python build in debug mode <debug-build>`."
msgstr ""
"\"Налагоджувальна збірка\": :ref:`Збірка Python у режимі налагодження <debug-"
"build>`."

msgid "Customize Memory Allocators"
msgstr "Налаштувати розподільники пам'яті"

msgid ""
"Structure used to describe a memory block allocator. The structure has the "
"following fields:"
msgstr ""
"Структура, яка використовується для опису розподілювача блоків пам'яті. "
"Структура має такі поля:"

msgid "Field"
msgstr "Поле"

msgid "Meaning"
msgstr "Значення"

msgid "``void *ctx``"
msgstr "``недійсний *ctx``"

msgid "user context passed as first argument"
msgstr "контекст користувача, переданий як перший аргумент"

msgid "``void* malloc(void *ctx, size_t size)``"
msgstr "``void* malloc(void *ctx, size_t size)``"

msgid "allocate a memory block"
msgstr "виділити блок пам'яті"

msgid "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"
msgstr "``void* calloc(void *ctx, size_t nelem, size_t elsize)``"

msgid "allocate a memory block initialized with zeros"
msgstr "виділити блок пам'яті, ініціалізований нулями"

msgid "``void* realloc(void *ctx, void *ptr, size_t new_size)``"
msgstr "``void* realloc(void *ctx, void *ptr, size_t new_size)``"

msgid "allocate or resize a memory block"
msgstr "виділити або змінити розмір блоку пам'яті"

msgid "``void free(void *ctx, void *ptr)``"
msgstr "``void free(void *ctx, void *ptr)``"

msgid "free a memory block"
msgstr "звільнити блок пам'яті"

msgid ""
"The :c:type:`PyMemAllocator` structure was renamed to :c:type:"
"`PyMemAllocatorEx` and a new ``calloc`` field was added."
msgstr ""
"Структуру :c:type:`PyMemAllocator` було перейменовано на :c:type:"
"`PyMemAllocatorEx` і додано нове поле ``calloc``."

msgid "Enum used to identify an allocator domain. Domains:"
msgstr "Enum використовується для визначення домену розподілювача. Домени:"

msgid "Functions:"
msgstr "функції:"

msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

msgid ":c:func:`PyMem_Malloc`,"
msgstr ":c:func:`PyMem_Malloc`,"

msgid ":c:func:`PyMem_Realloc`"
msgstr ":c:func:`PyMem_Realloc`"

msgid ":c:func:`PyMem_Calloc`"
msgstr ":c:func:`PyMem_Calloc`"

msgid ":c:func:`PyMem_Free`"
msgstr ":c:func:`PyMem_Free`"

msgid ":c:func:`PyObject_Malloc`"
msgstr ":c:func:`PyObject_Malloc`"

msgid ":c:func:`PyObject_Realloc`"
msgstr ":c:func:`PyObject_Realloc`"

msgid ":c:func:`PyObject_Calloc`"
msgstr ":c:func:`PyObject_Calloc`"

msgid ":c:func:`PyObject_Free`"
msgstr ":c:func:`PyObject_Free`"

msgid "Get the memory block allocator of the specified domain."
msgstr "Отримати розподільник блоків пам’яті вказаного домену."

msgid "Set the memory block allocator of the specified domain."
msgstr "Установіть розподільник блоків пам'яті для вказаного домену."

msgid ""
"The new allocator must return a distinct non-``NULL`` pointer when "
"requesting zero bytes."
msgstr ""
"Новий розподільник має повертати окремий покажчик, відмінний від ``NULL``, "
"коли запитує нульові байти."

msgid ""
"For the :c:data:`PYMEM_DOMAIN_RAW` domain, the allocator must be thread-"
"safe: the :term:`GIL <global interpreter lock>` is not held when the "
"allocator is called."
msgstr ""
"Для домену :c:data:`PYMEM_DOMAIN_RAW` розподільник має бути "
"потокобезпечним: :term:`GIL <global interpreter lock>` не утримується під "
"час виклику розподілювача."

msgid ""
"If the new allocator is not a hook (does not call the previous allocator), "
"the :c:func:`PyMem_SetupDebugHooks` function must be called to reinstall the "
"debug hooks on top on the new allocator."
msgstr ""
"Якщо новий розподільник не є хуком (не викликає попереднього розподільника), "
"необхідно викликати функцію :c:func:`PyMem_SetupDebugHooks`, щоб "
"перевстановити налагоджувальні хуки поверх нового розподільника."

msgid ""
"See also :c:member:`PyPreConfig.allocator` and :ref:`Preinitialize Python "
"with PyPreConfig <c-preinit>`."
msgstr ""

msgid ":c:func:`PyMem_SetAllocator` does have the following contract:"
msgstr ""

msgid ""
"It can be called after :c:func:`Py_PreInitialize` and before :c:func:"
"`Py_InitializeFromConfig` to install a custom memory allocator. There are no "
"restrictions over the installed allocator other than the ones imposed by the "
"domain (for instance, the Raw Domain allows the allocator to be called "
"without the GIL held). See :ref:`the section on allocator domains <allocator-"
"domains>` for more information."
msgstr ""

msgid ""
"If called after Python has finish initializing (after :c:func:"
"`Py_InitializeFromConfig` has been called) the allocator **must** wrap the "
"existing allocator. Substituting the current allocator for some other "
"arbitrary one is **not supported**."
msgstr ""

msgid ""
"Setup :ref:`debug hooks in the Python memory allocators <pymem-debug-hooks>` "
"to detect memory errors."
msgstr ""
"Налаштування :ref:`налагоджувальних хуків у розподільниках пам’яті Python "
"<pymem-debug-hooks>` для виявлення помилок пам’яті."

msgid "Debug hooks on the Python memory allocators"
msgstr "Налагодження перехоплювачів розподілювачів пам’яті Python"

msgid ""
"When :ref:`Python is built in debug mode <debug-build>`, the :c:func:"
"`PyMem_SetupDebugHooks` function is called at the :ref:`Python "
"preinitialization <c-preinit>` to setup debug hooks on Python memory "
"allocators to detect memory errors."
msgstr ""
"Коли :ref:`Python зібрано в режимі налагодження <debug-build>`, функція :c:"
"func:`PyMem_SetupDebugHooks` викликається під час :ref:`попередньої "
"ініціалізації Python <c-preinit>`, щоб налаштувати перехоплення налагодження "
"на розподільниках пам’яті Python для виявлення помилок пам’яті."

msgid ""
"The :envvar:`PYTHONMALLOC` environment variable can be used to install debug "
"hooks on a Python compiled in release mode (ex: ``PYTHONMALLOC=debug``)."
msgstr ""
"Змінну оточення :envvar:`PYTHONMALLOC` можна використовувати для "
"встановлення хуків налагодження на Python, скомпільованому в режимі випуску "
"(наприклад: ``PYTHONMALLOC=debug``)."

msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function can be used to set debug hooks "
"after calling :c:func:`PyMem_SetAllocator`."
msgstr ""
"Функцію :c:func:`PyMem_SetupDebugHooks` можна використати для встановлення "
"хуків налагодження після виклику :c:func:`PyMem_SetAllocator`."

msgid ""
"These debug hooks fill dynamically allocated memory blocks with special, "
"recognizable bit patterns. Newly allocated memory is filled with the byte "
"``0xCD`` (``PYMEM_CLEANBYTE``), freed memory is filled with the byte "
"``0xDD`` (``PYMEM_DEADBYTE``). Memory blocks are surrounded by \"forbidden "
"bytes\" filled with the byte ``0xFD`` (``PYMEM_FORBIDDENBYTE``). Strings of "
"these bytes are unlikely to be valid addresses, floats, or ASCII strings."
msgstr ""
"Ці хуки налагодження заповнюють динамічно виділені блоки пам’яті "
"спеціальними розпізнаваними бітовими шаблонами. Щойно виділена пам'ять "
"заповнюється байтом ``0xCD`` (``PYMEM_CLEANBYTE``), звільнена пам'ять "
"заповнюється байтом ``0xDD`` (``PYMEM_DEADBYTE``). Блоки пам'яті оточені "
"\"забороненими байтами\", заповненими байтом ``0xFD`` "
"(``PYMEM_FORBIDDENBYTE``). Рядки цих байтів навряд чи будуть дійсними "
"адресами, числами з плаваючою точкою або рядками ASCII."

msgid "Runtime checks:"
msgstr "Перевірки виконання:"

msgid ""
"Detect API violations. For example, detect if :c:func:`PyObject_Free` is "
"called on a memory block allocated by :c:func:`PyMem_Malloc`."
msgstr ""
"Виявлення порушень API. Наприклад, виявити, чи викликається :c:func:"
"`PyObject_Free` для блоку пам’яті, виділеного :c:func:`PyMem_Malloc`."

msgid "Detect write before the start of the buffer (buffer underflow)."
msgstr "Виявлення запису до початку буфера (переповнення буфера)."

msgid "Detect write after the end of the buffer (buffer overflow)."
msgstr "Виявлення запису після закінчення буфера (переповнення буфера)."

msgid ""
"Check that the :term:`GIL <global interpreter lock>` is held when allocator "
"functions of :c:data:`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) and :"
"c:data:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) domains are called."
msgstr ""
"Переконайтеся, що :term:`GIL <global interpreter lock>` зберігається, коли "
"функції розподільника :c:data:`PYMEM_DOMAIN_OBJ` (наприклад: :c:func:"
"`PyObject_Malloc`) і :c:data:`PYMEM_DOMAIN_MEM` (наприклад: :c:func:"
"`PyMem_Malloc`) викликаються домени."

msgid ""
"On error, the debug hooks use the :mod:`tracemalloc` module to get the "
"traceback where a memory block was allocated. The traceback is only "
"displayed if :mod:`tracemalloc` is tracing Python memory allocations and the "
"memory block was traced."
msgstr ""
"У разі помилки хуки налагодження використовують модуль :mod:`tracemalloc`, "
"щоб отримати зворотне відстеження, де було виділено блок пам’яті. Зворотне "
"відстеження відображається, лише якщо :mod:`tracemalloc` відстежує виділення "
"пам’яті Python і блок пам’яті відстежується."

msgid ""
"Let *S* = ``sizeof(size_t)``. ``2*S`` bytes are added at each end of each "
"block of *N* bytes requested.  The memory layout is like so, where p "
"represents the address returned by a malloc-like or realloc-like function "
"(``p[i:j]`` means the slice of bytes from ``*(p+i)`` inclusive up to "
"``*(p+j)`` exclusive; note that the treatment of negative indices differs "
"from a Python slice):"
msgstr ""
"Нехай *S* = ``sizeof(size_t)``. ``2*S`` байти додаються на кожному кінці "
"кожного запитуваного блоку *N* байтів. Схема пам’яті така, де p представляє "
"адресу, повернуту функцією, подібною до malloc або realloc (``p[i:j]`` "
"означає зріз байтів з ``*(p+i)`` включно до ``*(p+j)`` винятково; зауважте, "
"що обробка від’ємних індексів відрізняється від фрагмента Python):"

msgid "``p[-2*S:-S]``"
msgstr "``p[-2*S:-S]``"

msgid ""
"Number of bytes originally asked for.  This is a size_t, big-endian (easier "
"to read in a memory dump)."
msgstr ""
"Первісно запитана кількість байтів. Це size_t, big-endian (легше читати в "
"дампі пам’яті)."

msgid "``p[-S]``"
msgstr "``p[-S]``"

msgid "API identifier (ASCII character):"
msgstr "Ідентифікатор API (символ ASCII):"

msgid "``'r'`` for :c:data:`PYMEM_DOMAIN_RAW`."
msgstr "``'r'`` для :c:data:`PYMEM_DOMAIN_RAW`."

msgid "``'m'`` for :c:data:`PYMEM_DOMAIN_MEM`."
msgstr "``'m''`` для :c:data:`PYMEM_DOMAIN_MEM`."

msgid "``'o'`` for :c:data:`PYMEM_DOMAIN_OBJ`."
msgstr "``'o'`` для :c:data:`PYMEM_DOMAIN_OBJ`."

msgid "``p[-S+1:0]``"
msgstr "``p[-S+1:0]``"

msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch under- writes and reads."
msgstr ""
"Копії PYMEM_FORBIDDENBYTE. Використовується для перехоплення недописів і "
"читань."

msgid "``p[0:N]``"
msgstr "``p[0:N]``"

msgid ""
"The requested memory, filled with copies of PYMEM_CLEANBYTE, used to catch "
"reference to uninitialized memory.  When a realloc-like function is called "
"requesting a larger memory block, the new excess bytes are also filled with "
"PYMEM_CLEANBYTE.  When a free-like function is called, these are overwritten "
"with PYMEM_DEADBYTE, to catch reference to freed memory.  When a realloc- "
"like function is called requesting a smaller memory block, the excess old "
"bytes are also filled with PYMEM_DEADBYTE."
msgstr ""
"Запитана пам'ять, заповнена копіями PYMEM_CLEANBYTE, використовувалася для "
"перехоплення посилань на неініціалізовану пам'ять. Коли функція, подібна до "
"realloc, викликається із запитом більшого блоку пам’яті, нові надлишкові "
"байти також заповнюються PYMEM_CLEANBYTE. Коли викликається функція, подібна "
"до вільної, вони перезаписуються на PYMEM_DEADBYTE, щоб перехопити посилання "
"на звільнену пам’ять. Коли функція, подібна до realloc, викликається із "
"запитом на менший блок пам’яті, зайві старі байти також заповнюються "
"PYMEM_DEADBYTE."

msgid "``p[N:N+S]``"
msgstr "``p[N:N+S]``"

msgid "Copies of PYMEM_FORBIDDENBYTE.  Used to catch over- writes and reads."
msgstr ""
"Копії PYMEM_FORBIDDENBYTE. Використовується для перехоплення перезапису та "
"читання."

msgid "``p[N+S:N+2*S]``"
msgstr "``p[N+S:N+2*S]``"

msgid ""
"Only used if the ``PYMEM_DEBUG_SERIALNO`` macro is defined (not defined by "
"default)."
msgstr ""
"Використовується, лише якщо визначено макрос ``PYMEM_DEBUG_SERIALNO`` (не "
"визначено за замовчуванням)."

msgid ""
"A serial number, incremented by 1 on each call to a malloc-like or realloc-"
"like function.  Big-endian ``size_t``.  If \"bad memory\" is detected later, "
"the serial number gives an excellent way to set a breakpoint on the next "
"run, to capture the instant at which this block was passed out.  The static "
"function bumpserialno() in obmalloc.c is the only place the serial number is "
"incremented, and exists so you can set such a breakpoint easily."
msgstr ""
"Серійний номер, збільшений на 1 під час кожного виклику функції, подібної до "
"malloc або realloc. Стартовий порядок ``size_t``. Якщо \"погана пам’ять\" "
"буде виявлена пізніше, серійний номер дає чудовий спосіб встановити точку "
"зупинки під час наступного запуску, щоб зафіксувати момент, коли цей блок "
"було видалено. Статична функція bumpserialno() у obmalloc.c є єдиним місцем, "
"де збільшується серійний номер, і існує, тому ви можете легко встановити "
"таку точку зупину."

msgid ""
"A realloc-like or free-like function first checks that the "
"PYMEM_FORBIDDENBYTE bytes at each end are intact.  If they've been altered, "
"diagnostic output is written to stderr, and the program is aborted via "
"Py_FatalError().  The other main failure mode is provoking a memory error "
"when a program reads up one of the special bit patterns and tries to use it "
"as an address.  If you get in a debugger then and look at the object, you're "
"likely to see that it's entirely filled with PYMEM_DEADBYTE (meaning freed "
"memory is getting used) or PYMEM_CLEANBYTE (meaning uninitialized memory is "
"getting used)."
msgstr ""
"Функція, подібна до realloc або free, спочатку перевіряє, чи не пошкоджені "
"байти PYMEM_FORBIDDENBYTE на кожному кінці. Якщо їх було змінено, "
"діагностичний вихід записується в stderr, а програма переривається через "
"Py_FatalError(). Інший основний тип помилки - це провокація помилки пам'яті, "
"коли програма зчитує один із спеціальних бітових шаблонів і намагається "
"використати його як адресу. Якщо ви зайдете в налагоджувач і подивіться на "
"об’єкт, ви, ймовірно, побачите, що він повністю заповнений PYMEM_DEADBYTE "
"(це означає, що звільнена пам’ять використовується) або PYMEM_CLEANBYTE (це "
"означає, що неініціалізована пам’ять використовується)."

msgid ""
"The :c:func:`PyMem_SetupDebugHooks` function now also works on Python "
"compiled in release mode.  On error, the debug hooks now use :mod:"
"`tracemalloc` to get the traceback where a memory block was allocated. The "
"debug hooks now also check if the GIL is held when functions of :c:data:"
"`PYMEM_DOMAIN_OBJ` and :c:data:`PYMEM_DOMAIN_MEM` domains are called."
msgstr ""
"Функція :c:func:`PyMem_SetupDebugHooks` тепер також працює на Python, "
"скомпільованому в режимі випуску. У разі помилки хуки налагодження тепер "
"використовують :mod:`tracemalloc` для отримання зворотного відстеження, де "
"було виділено блок пам’яті. Хуки налагодження тепер також перевіряють, чи "
"утримується GIL під час виклику функцій доменів :c:data:`PYMEM_DOMAIN_OBJ` "
"і :c:data:`PYMEM_DOMAIN_MEM`."

msgid ""
"Byte patterns ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` (``PYMEM_DEADBYTE``) "
"and ``0xFB`` (``PYMEM_FORBIDDENBYTE``) have been replaced with ``0xCD``, "
"``0xDD`` and ``0xFD`` to use the same values than Windows CRT debug "
"``malloc()`` and ``free()``."
msgstr ""
"Шаблони байтів ``0xCB`` (``PYMEM_CLEANBYTE``), ``0xDB`` (``PYMEM_DEADBYTE``) "
"і ``0xFB`` (``PYMEM_FORBIDDENBYTE``) були замінені на ``0xCD``, ``0xDD`` і "
"``0xFD``, щоб використовувати ті самі значення, що й ``malloc()`` і "
"``free()`` для налагодження Windows CRT."

msgid "The pymalloc allocator"
msgstr "Розподільник pymalloc"

msgid ""
"Python has a *pymalloc* allocator optimized for small objects (smaller or "
"equal to 512 bytes) with a short lifetime. It uses memory mappings called "
"\"arenas\" with a fixed size of 256 KiB. It falls back to :c:func:"
"`PyMem_RawMalloc` and :c:func:`PyMem_RawRealloc` for allocations larger than "
"512 bytes."
msgstr ""
"Python має розподільник *pymalloc*, оптимізований для малих об’єктів (менших "
"або рівних 512 байтам) із коротким часом життя. Він використовує "
"відображення пам’яті, які називаються \"аренами\" з фіксованим розміром 256 "
"КБ. Він повертається до :c:func:`PyMem_RawMalloc` і :c:func:"
"`PyMem_RawRealloc` для розподілу розміром більше 512 байт."

msgid ""
"*pymalloc* is the :ref:`default allocator <default-memory-allocators>` of "
"the :c:data:`PYMEM_DOMAIN_MEM` (ex: :c:func:`PyMem_Malloc`) and :c:data:"
"`PYMEM_DOMAIN_OBJ` (ex: :c:func:`PyObject_Malloc`) domains."
msgstr ""
"*pymalloc* є :ref:`розподільником за замовчуванням <default-memory-"
"allocators>` :c:data:`PYMEM_DOMAIN_MEM` (наприклад: :c:func:`PyMem_Malloc`) "
"і :c:data:`PYMEM_DOMAIN_OBJ` (наприклад: :c:func:`PyObject_Malloc`)."

msgid "The arena allocator uses the following functions:"
msgstr "Розподільник арени використовує такі функції:"

msgid ":c:func:`VirtualAlloc` and :c:func:`VirtualFree` on Windows,"
msgstr ":c:func:`VirtualAlloc` і :c:func:`VirtualFree` у Windows,"

msgid ":c:func:`mmap` and :c:func:`munmap` if available,"
msgstr ":c:func:`mmap` і :c:func:`munmap`, якщо доступні,"

msgid ":c:func:`malloc` and :c:func:`free` otherwise."
msgstr ":c:func:`malloc` і :c:func:`free` інакше."

msgid ""
"This allocator is disabled if Python is configured with the :option:`--"
"without-pymalloc` option. It can also be disabled at runtime using the :"
"envvar:`PYTHONMALLOC` environment variable (ex: ``PYTHONMALLOC=malloc``)."
msgstr ""
"Цей розподільник вимкнено, якщо Python налаштовано з параметром :option:`--"
"without-pymalloc`. Його також можна вимкнути під час виконання за допомогою "
"змінної середовища :envvar:`PYTHONMALLOC` (наприклад: "
"``PYTHONMALLOC=malloc``)."

msgid "Customize pymalloc Arena Allocator"
msgstr "Налаштувати pymalloc Arena Allocator"

msgid ""
"Structure used to describe an arena allocator. The structure has three "
"fields:"
msgstr ""
"Структура, яка використовується для опису розподільника арен. Структура має "
"три поля:"

msgid "``void* alloc(void *ctx, size_t size)``"
msgstr "``void* alloc(void *ctx, size_t size)``"

msgid "allocate an arena of size bytes"
msgstr "виділити арену розміром байт"

msgid "``void free(void *ctx, void *ptr, size_t size)``"
msgstr "``void free(void *ctx, void *ptr, size_t size)``"

msgid "free an arena"
msgstr "звільнити арену"

msgid "Get the arena allocator."
msgstr "Отримайте розподільник арен."

msgid "Set the arena allocator."
msgstr "Встановіть розподільник арен."

msgid "tracemalloc C API"
msgstr "tracemalloc C API"

msgid "Track an allocated memory block in the :mod:`tracemalloc` module."
msgstr "Відстежуйте виділений блок пам’яті в модулі :mod:`tracemalloc`."

msgid ""
"Return ``0`` on success, return ``-1`` on error (failed to allocate memory "
"to store the trace). Return ``-2`` if tracemalloc is disabled."
msgstr ""
"Повертає ``0`` у разі успіху, повертає ``-1`` у разі помилки (не вдалося "
"виділити пам’ять для збереження трасування). Повертає ``-2``, якщо "
"tracemalloc вимкнено."

msgid "If memory block is already tracked, update the existing trace."
msgstr "Якщо блок пам’яті вже відстежується, оновіть наявне трасування."

msgid ""
"Untrack an allocated memory block in the :mod:`tracemalloc` module. Do "
"nothing if the block was not tracked."
msgstr ""
"Скасувати відстеження виділеного блоку пам’яті в модулі :mod:`tracemalloc`. "
"Нічого не робити, якщо блок не відстежується."

msgid "Return ``-2`` if tracemalloc is disabled, otherwise return ``0``."
msgstr "Повертає ``-2``, якщо tracemalloc вимкнено, інакше повертає ``0``."

msgid "Examples"
msgstr "Приклади"

msgid ""
"Here is the example from section :ref:`memoryoverview`, rewritten so that "
"the I/O buffer is allocated from the Python heap by using the first function "
"set::"
msgstr ""
"Ось приклад із розділу :ref:`memoryoverview`, переписаний таким чином, що "
"буфер введення/виведення виділяється з купи Python за допомогою першого "
"набору функцій::"

msgid "The same code using the type-oriented function set::"
msgstr "Той самий код із використанням типу орієнтованого набору функцій::"

msgid ""
"Note that in the two examples above, the buffer is always manipulated via "
"functions belonging to the same set. Indeed, it is required to use the same "
"memory API family for a given memory block, so that the risk of mixing "
"different allocators is reduced to a minimum. The following code sequence "
"contains two errors, one of which is labeled as *fatal* because it mixes two "
"different allocators operating on different heaps. ::"
msgstr ""
"Зауважте, що у двох наведених вище прикладах буфером завжди керують функції, "
"що належать одному набору. Дійсно, для певного блоку пам’яті потрібно "
"використовувати одне й те саме сімейство API пам’яті, щоб ризик змішування "
"різних розподільників був зведений до мінімуму. Наступна кодова "
"послідовність містить дві помилки, одна з яких позначена як *фатальна*, "
"оскільки вона змішує два різних розподільника, що працюють на різних "
"купах. ::"

msgid ""
"In addition to the functions aimed at handling raw memory blocks from the "
"Python heap, objects in Python are allocated and released with :c:func:"
"`PyObject_New`, :c:func:`PyObject_NewVar` and :c:func:`PyObject_Del`."
msgstr ""
"На додаток до функцій, спрямованих на обробку необроблених блоків пам’яті з "
"купи Python, об’єкти в Python виділяються та звільняються за допомогою :c:"
"func:`PyObject_New`, :c:func:`PyObject_NewVar` і :c:func:`PyObject_Del` ."

msgid ""
"These will be explained in the next chapter on defining and implementing new "
"object types in C."
msgstr ""
"Це буде пояснено в наступному розділі про визначення та реалізацію нових "
"типів об’єктів у C."
