# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:47+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Buffer Protocol"
msgstr "Буферний протокол"

msgid ""
"Certain objects available in Python wrap access to an underlying memory "
"array or *buffer*.  Such objects include the built-in :class:`bytes` and :"
"class:`bytearray`, and some extension types like :class:`array.array`. Third-"
"party libraries may define their own types for special purposes, such as "
"image processing or numeric analysis."
msgstr ""
"Певні об’єкти, доступні в Python, обертають доступ до базового масиву "
"пам’яті або *буфера*. До таких об’єктів належать вбудовані :class:`bytes` і :"
"class:`bytearray`, а також деякі типи розширень, наприклад :class:`array."
"array`. Бібліотеки сторонніх розробників можуть визначати власні типи для "
"спеціальних цілей, таких як обробка зображень або числовий аналіз."

msgid ""
"While each of these types have their own semantics, they share the common "
"characteristic of being backed by a possibly large memory buffer.  It is "
"then desirable, in some situations, to access that buffer directly and "
"without intermediate copying."
msgstr ""
"У той час як кожен із цих типів має власну семантику, вони поділяють спільну "
"характеристику, що вони підтримуються можливо великим буфером пам’яті. Тоді "
"в деяких ситуаціях бажано отримати доступ до цього буфера безпосередньо й "
"без проміжного копіювання."

msgid ""
"Python provides such a facility at the C level in the form of the :ref:"
"`buffer protocol <bufferobjects>`.  This protocol has two sides:"
msgstr ""
"Python надає таку можливість на рівні C у формі :ref:`протоколу буфера "
"<bufferobjects>`. Цей протокол має дві сторони:"

msgid ""
"on the producer side, a type can export a \"buffer interface\" which allows "
"objects of that type to expose information about their underlying buffer. "
"This interface is described in the section :ref:`buffer-structs`;"
msgstr ""
"на стороні виробника тип може експортувати \"інтерфейс буфера\", який "
"дозволяє об’єктам цього типу надавати інформацію про їхній базовий буфер. "
"Цей інтерфейс описано в розділі :ref:`buffer-structs`;"

msgid ""
"on the consumer side, several means are available to obtain a pointer to the "
"raw underlying data of an object (for example a method parameter)."
msgstr ""
"на стороні споживача доступно кілька засобів для отримання вказівника на "
"необроблені базові дані об’єкта (наприклад, параметр методу)."

msgid ""
"Simple objects such as :class:`bytes` and :class:`bytearray` expose their "
"underlying buffer in byte-oriented form.  Other forms are possible; for "
"example, the elements exposed by an :class:`array.array` can be multi-byte "
"values."
msgstr ""
"Прості об’єкти, такі як :class:`bytes` і :class:`bytearray`, надають свій "
"базовий буфер у байт-орієнтованій формі. Можливі інші форми; наприклад, "
"елементи, представлені :class:`array.array`, можуть мати багатобайтові "
"значення."

msgid ""
"An example consumer of the buffer interface is the :meth:`~io.BufferedIOBase."
"write` method of file objects: any object that can export a series of bytes "
"through the buffer interface can be written to a file.  While :meth:`write` "
"only needs read-only access to the internal contents of the object passed to "
"it, other methods such as :meth:`~io.BufferedIOBase.readinto` need write "
"access to the contents of their argument.  The buffer interface allows "
"objects to selectively allow or reject exporting of read-write and read-only "
"buffers."
msgstr ""
"Прикладом споживача інтерфейсу буфера є метод :meth:`~io.BufferedIOBase."
"write` файлових об’єктів: будь-який об’єкт, який може експортувати серію "
"байтів через інтерфейс буфера, може бути записаний у файл. Тоді як :meth:"
"`write` потрібен лише доступ лише для читання до внутрішнього вмісту "
"переданого йому об’єкта, іншим методам, таким як :meth:`~io.BufferedIOBase."
"readinto` потрібен доступ для запису до вмісту свого аргументу. Інтерфейс "
"буфера дозволяє об’єктам вибірково дозволяти або відхиляти експорт буферів "
"читання-запису та лише читання."

msgid ""
"There are two ways for a consumer of the buffer interface to acquire a "
"buffer over a target object:"
msgstr ""
"Споживач інтерфейсу буфера може отримати буфер над цільовим об’єктом двома "
"способами:"

msgid "call :c:func:`PyObject_GetBuffer` with the right parameters;"
msgstr "викликати :c:func:`PyObject_GetBuffer` з правильними параметрами;"

msgid ""
"call :c:func:`PyArg_ParseTuple` (or one of its siblings) with one of the "
"``y*``, ``w*`` or ``s*`` :ref:`format codes <arg-parsing>`."
msgstr ""
"викликати :c:func:`PyArg_ParseTuple` (або один із його братів і сестер) з "
"одним із ``y*``, ``w*`` або ``s*`` :ref:`кодів формату <arg-parsing>`."

msgid ""
"In both cases, :c:func:`PyBuffer_Release` must be called when the buffer "
"isn't needed anymore.  Failure to do so could lead to various issues such as "
"resource leaks."
msgstr ""
"В обох випадках :c:func:`PyBuffer_Release` потрібно викликати, коли буфер "
"більше не потрібен. Якщо цього не зробити, це може призвести до "
"різноманітних проблем, наприклад до витоку ресурсів."

msgid "Buffer structure"
msgstr "Буферна структура"

msgid ""
"Buffer structures (or simply \"buffers\") are useful as a way to expose the "
"binary data from another object to the Python programmer.  They can also be "
"used as a zero-copy slicing mechanism.  Using their ability to reference a "
"block of memory, it is possible to expose any data to the Python programmer "
"quite easily.  The memory could be a large, constant array in a C extension, "
"it could be a raw block of memory for manipulation before passing to an "
"operating system library, or it could be used to pass around structured data "
"in its native, in-memory format."
msgstr ""
"Буферні структури (або просто \"буфери\") корисні як спосіб надати двійкові "
"дані з іншого об’єкта програмісту Python. Їх також можна використовувати як "
"механізм нарізки без копіювання. Використовуючи їх здатність посилатися на "
"блок пам’яті, можна досить легко надати будь-які дані програмісту Python. "
"Пам’ять може бути великим постійним масивом у розширенні C, це може бути "
"необроблений блок пам’яті для маніпуляцій перед передачею в бібліотеку "
"операційної системи, або її можна використовувати для передачі "
"структурованих даних у їх рідному форматі в пам’яті. ."

msgid ""
"Contrary to most data types exposed by the Python interpreter, buffers are "
"not :c:type:`PyObject` pointers but rather simple C structures.  This allows "
"them to be created and copied very simply.  When a generic wrapper around a "
"buffer is needed, a :ref:`memoryview <memoryview-objects>` object can be "
"created."
msgstr ""
"На відміну від більшості типів даних, наданих інтерпретатором Python, буфери "
"не є покажчиками :c:type:`PyObject`, а досить простими структурами C. Це "
"дозволяє дуже просто створювати та копіювати їх. Якщо потрібна загальна "
"обгортка навколо буфера, можна створити об’єкт :ref:`memoryview <memoryview-"
"objects>`."

msgid ""
"For short instructions how to write an exporting object, see :ref:`Buffer "
"Object Structures <buffer-structs>`. For obtaining a buffer, see :c:func:"
"`PyObject_GetBuffer`."
msgstr ""
"Щоб отримати короткі інструкції щодо написання об’єкта експорту, "
"перегляньте :ref:`Структури об’єктів буфера <buffer-structs>`. Щоб отримати "
"буфер, перегляньте :c:func:`PyObject_GetBuffer`."

msgid ""
"A pointer to the start of the logical structure described by the buffer "
"fields. This can be any location within the underlying physical memory block "
"of the exporter. For example, with negative :c:member:`~Py_buffer.strides` "
"the value may point to the end of the memory block."
msgstr ""
"Покажчик на початок логічної структури, описаної полями буфера. Це може бути "
"будь-яке розташування в базовому блоці фізичної пам’яті експортера. "
"Наприклад, з негативним :c:member:`~Py_buffer.strides` значення може "
"вказувати на кінець блоку пам’яті."

msgid ""
"For :term:`contiguous` arrays, the value points to the beginning of the "
"memory block."
msgstr ""
"Для масивів :term:`contiguous` значення вказує на початок блоку пам’яті."

msgid ""
"A new reference to the exporting object. The reference is owned by the "
"consumer and automatically decremented and set to ``NULL`` by :c:func:"
"`PyBuffer_Release`. The field is the equivalent of the return value of any "
"standard C-API function."
msgstr ""
"Нове посилання на об’єкт експорту. Посилання належить споживачеві, воно "
"автоматично зменшується та встановлюється на ``NULL`` за допомогою :c:func:"
"`PyBuffer_Release`. Поле є еквівалентом значення, яке повертає будь-яка "
"стандартна функція C-API."

msgid ""
"As a special case, for *temporary* buffers that are wrapped by :c:func:"
"`PyMemoryView_FromBuffer` or :c:func:`PyBuffer_FillInfo` this field is "
"``NULL``. In general, exporting objects MUST NOT use this scheme."
msgstr ""
"Як окремий випадок, для *тимчасових* буферів, які обернуті :c:func:"
"`PyMemoryView_FromBuffer` або :c:func:`PyBuffer_FillInfo`, це поле має "
"значення ``NULL``. Загалом, експорт об’єктів НЕ ПОВИНЕН використовувати цю "
"схему."

msgid ""
"``product(shape) * itemsize``. For contiguous arrays, this is the length of "
"the underlying memory block. For non-contiguous arrays, it is the length "
"that the logical structure would have if it were copied to a contiguous "
"representation."
msgstr ""
"``product(shape) * itemsize``. Для безперервних масивів це довжина основного "
"блоку пам’яті. Для несуміжних масивів це довжина, яку мала б логічна "
"структура, якби її було скопійовано до безперервного представлення."

msgid ""
"Accessing ``((char *)buf)[0] up to ((char *)buf)[len-1]`` is only valid if "
"the buffer has been obtained by a request that guarantees contiguity. In "
"most cases such a request will be :c:macro:`PyBUF_SIMPLE` or :c:macro:"
"`PyBUF_WRITABLE`."
msgstr ""
"Доступ до ``((char *)buf)[0] до ((char *)buf)[len-1]`` дійсний, лише якщо "
"буфер було отримано за запитом, який гарантує безперервність. У більшості "
"випадків такий запит буде :c:macro:`PyBUF_SIMPLE` або :c:macro:"
"`PyBUF_WRITABLE`."

msgid ""
"An indicator of whether the buffer is read-only. This field is controlled by "
"the :c:macro:`PyBUF_WRITABLE` flag."
msgstr ""
"Індикатор того, чи буфер доступний лише для читання. Це поле контролюється "
"прапорцем :c:macro:`PyBUF_WRITABLE`."

msgid ""
"Item size in bytes of a single element. Same as the value of :func:`struct."
"calcsize` called on non-``NULL`` :c:member:`~Py_buffer.format` values."
msgstr ""
"Розмір елемента в байтах одного елемента. Те саме, що значення :func:`struct."
"calcsize`, викликане для не-``NULL`` значень :c:member:`~Py_buffer.format`."

msgid ""
"Important exception: If a consumer requests a buffer without the :c:macro:"
"`PyBUF_FORMAT` flag, :c:member:`~Py_buffer.format` will be set to  "
"``NULL``,  but :c:member:`~Py_buffer.itemsize` still has the value for the "
"original format."
msgstr ""
"Важливий виняток: якщо споживач запитує буфер без прапора :c:macro:"
"`PyBUF_FORMAT`, :c:member:`~Py_buffer.format` буде встановлено на ``NULL``, "
"але :c:member:`~Py_buffer.itemsize` все ще має значення для вихідного "
"формату."

msgid ""
"If :c:member:`~Py_buffer.shape` is present, the equality ``product(shape) * "
"itemsize == len`` still holds and the consumer can use :c:member:`~Py_buffer."
"itemsize` to navigate the buffer."
msgstr ""
"Якщо :c:member:`~Py_buffer.shape` присутній, рівність ``product(shape) * "
"itemsize == len`` все ще виконується, і споживач може використовувати :c:"
"member:`~Py_buffer.itemsize` для навігації буфер."

msgid ""
"If :c:member:`~Py_buffer.shape` is ``NULL`` as a result of a :c:macro:"
"`PyBUF_SIMPLE` or a :c:macro:`PyBUF_WRITABLE` request, the consumer must "
"disregard :c:member:`~Py_buffer.itemsize` and assume ``itemsize == 1``."
msgstr ""
"Якщо :c:member:`~Py_buffer.shape` має значення ``NULL`` в результаті запиту :"
"c:macro:`PyBUF_SIMPLE` або :c:macro:`PyBUF_WRITABLE`, споживач повинен "
"ігнорувати :c:member:`~Py_buffer.itemsize` і припустимо ``itemsize == 1``."

msgid ""
"A *NUL* terminated string in :mod:`struct` module style syntax describing "
"the contents of a single item. If this is ``NULL``, ``\"B\"`` (unsigned "
"bytes) is assumed."
msgstr ""
"Рядок із закінченням *NUL* у синтаксисі стилю модуля :mod:`struct` описує "
"вміст окремого елемента. Якщо це ``NULL``, ``\"B\"`` (беззнакові байти)."

msgid "This field is controlled by the :c:macro:`PyBUF_FORMAT` flag."
msgstr "Це поле контролюється прапорцем :c:macro:`PyBUF_FORMAT`."

msgid ""
"The number of dimensions the memory represents as an n-dimensional array. If "
"it is ``0``, :c:member:`~Py_buffer.buf` points to a single item representing "
"a scalar. In this case, :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides` and :c:member:`~Py_buffer.suboffsets` MUST be ``NULL``."
msgstr ""
"Кількість вимірів, які пам’ять представляє як n-вимірний масив. Якщо це "
"``0``, :c:member:`~Py_buffer.buf` вказує на один елемент, що представляє "
"скаляр. У цьому випадку :c:member:`~Py_buffer.shape`, :c:member:`~Py_buffer."
"strides` і :c:member:`~Py_buffer.suboffsets` ПОВИННІ мати значення ``NULL``."

msgid ""
"The macro :c:macro:`PyBUF_MAX_NDIM` limits the maximum number of dimensions "
"to 64. Exporters MUST respect this limit, consumers of multi-dimensional "
"buffers SHOULD be able to handle up to :c:macro:`PyBUF_MAX_NDIM` dimensions."
msgstr ""
"Макрос :c:macro:`PyBUF_MAX_NDIM` обмежує максимальну кількість вимірів до "
"64. Експортери ПОВИННІ дотримуватися цього обмеження, споживачі "
"багатовимірних буферів ПОВИННІ мати можливість обробляти розміри до :c:macro:"
"`PyBUF_MAX_NDIM`."

msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim` "
"indicating the shape of the memory as an n-dimensional array. Note that "
"``shape[0] * ... * shape[ndim-1] * itemsize`` MUST be equal to :c:member:"
"`~Py_buffer.len`."
msgstr ""
"Масив :c:type:`Py_ssize_t` довжини :c:member:`~Py_buffer.ndim`, що вказує "
"форму пам’яті як n-вимірного масиву. Зауважте, що ``shape[0] * ... * "
"shape[ndim-1] * itemsize`` ПОВИНЕН дорівнювати :c:member:`~Py_buffer.len`."

msgid ""
"Shape values are restricted to ``shape[n] >= 0``. The case ``shape[n] == 0`` "
"requires special attention. See `complex arrays`_ for further information."
msgstr ""
"Значення форми обмежені ``shape[n] >= 0``. Випадок ``shape[n] == 0`` вимагає "
"особливої уваги. Див. `complex arrays`_ для отримання додаткової інформації."

msgid "The shape array is read-only for the consumer."
msgstr "Масив форм доступний лише для читання для споживача."

msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim` "
"giving the number of bytes to skip to get to a new element in each dimension."
msgstr ""
"Масив :c:type:`Py_ssize_t` довжини :c:member:`~Py_buffer.ndim`, що вказує "
"кількість байтів, які потрібно пропустити, щоб перейти до нового елемента в "
"кожному вимірі."

msgid ""
"Stride values can be any integer. For regular arrays, strides are usually "
"positive, but a consumer MUST be able to handle the case ``strides[n] <= "
"0``. See `complex arrays`_ for further information."
msgstr ""
"Величина кроку може бути будь-яким цілим числом. Для звичайних масивів кроки "
"зазвичай позитивні, але споживач ПОВИНЕН вміти впоратися з випадком "
"``ступені[n] <= 0``. Див. `complex arrays`_ для отримання додаткової "
"інформації."

msgid "The strides array is read-only for the consumer."
msgstr "Масив strides доступний лише для читання для споживача."

msgid ""
"An array of :c:type:`Py_ssize_t` of length :c:member:`~Py_buffer.ndim`. If "
"``suboffsets[n] >= 0``, the values stored along the nth dimension are "
"pointers and the suboffset value dictates how many bytes to add to each "
"pointer after de-referencing. A suboffset value that is negative indicates "
"that no de-referencing should occur (striding in a contiguous memory block)."
msgstr ""
"Масив :c:type:`Py_ssize_t` довжини :c:member:`~Py_buffer.ndim`. Якщо "
"``suboffsets[n] >= 0``, значення, що зберігаються вздовж n-го виміру, є "
"вказівниками, а значення suboffset визначає, скільки байтів потрібно додати "
"до кожного покажчика після видалення посилань. Від’ємне значення субзміщення "
"вказує на те, що не повинно відбуватися видалення посилань (переміщення в "
"безперервному блоці пам’яті)."

msgid ""
"If all suboffsets are negative (i.e. no de-referencing is needed), then this "
"field must be ``NULL`` (the default value)."
msgstr ""
"Якщо всі підзміщення є від’ємними (тобто не потрібно знімати посилання), "
"тоді це поле має бути ``NULL`` (значення за замовчуванням)."

msgid ""
"This type of array representation is used by the Python Imaging Library "
"(PIL). See `complex arrays`_ for further information how to access elements "
"of such an array."
msgstr ""
"Цей тип представлення масиву використовується бібліотекою зображень Python "
"(PIL). Див. `complex arrays`_ для отримання додаткової інформації про доступ "
"до елементів такого масиву."

msgid "The suboffsets array is read-only for the consumer."
msgstr "Масив suboffsets доступний лише для читання для споживача."

msgid ""
"This is for use internally by the exporting object. For example, this might "
"be re-cast as an integer by the exporter and used to store flags about "
"whether or not the shape, strides, and suboffsets arrays must be freed when "
"the buffer is released. The consumer MUST NOT alter this value."
msgstr ""
"Це для внутрішнього використання об’єктом експорту. Наприклад, це може бути "
"перетворено як ціле число експортером і використано для зберігання прапорів "
"про те, чи потрібно звільняти масиви форми, кроків і підзміщень, коли буфер "
"звільняється. Споживач НЕ ПОВИНЕН змінювати це значення."

msgid "Buffer request types"
msgstr "Типи запитів на буфер"

msgid ""
"Buffers are usually obtained by sending a buffer request to an exporting "
"object via :c:func:`PyObject_GetBuffer`. Since the complexity of the logical "
"structure of the memory can vary drastically, the consumer uses the *flags* "
"argument to specify the exact buffer type it can handle."
msgstr ""
"Буфери зазвичай отримують шляхом надсилання запиту на буфер до об’єкта "
"експорту через :c:func:`PyObject_GetBuffer`. Оскільки складність логічної "
"структури пам’яті може різко змінюватися, споживач використовує аргумент "
"*flags*, щоб визначити точний тип буфера, який він може обробляти."

msgid ""
"All :c:data:`Py_buffer` fields are unambiguously defined by the request type."
msgstr "Усі поля :c:data:`Py_buffer` однозначно визначаються типом запиту."

msgid "request-independent fields"
msgstr "поля, незалежні від запиту"

msgid ""
"The following fields are not influenced by *flags* and must always be filled "
"in with the correct values: :c:member:`~Py_buffer.obj`, :c:member:"
"`~Py_buffer.buf`, :c:member:`~Py_buffer.len`, :c:member:`~Py_buffer."
"itemsize`, :c:member:`~Py_buffer.ndim`."
msgstr ""
"На наступні поля не впливають *прапорці*, і їх потрібно завжди заповнювати "
"правильними значеннями: :c:member:`~Py_buffer.obj`, :c:member:`~Py_buffer."
"buf`, :c:member:`~Py_buffer.len`, :c:member:`~Py_buffer.itemsize`, :c:member:"
"`~Py_buffer.ndim`."

msgid "readonly, format"
msgstr "тільки для читання, формат"

msgid ""
"Controls the :c:member:`~Py_buffer.readonly` field. If set, the exporter "
"MUST provide a writable buffer or else report failure. Otherwise, the "
"exporter MAY provide either a read-only or writable buffer, but the choice "
"MUST be consistent for all consumers."
msgstr ""
"Керує полем :c:member:`~Py_buffer.readonly`. Якщо встановлено, експортер "
"ПОВИНЕН надати буфер для запису або повідомити про помилку. В іншому випадку "
"експортер МОЖЕ надати буфер лише для читання або запису, але вибір ПОВИНЕН "
"бути узгодженим для всіх споживачів."

msgid ""
"Controls the :c:member:`~Py_buffer.format` field. If set, this field MUST be "
"filled in correctly. Otherwise, this field MUST be ``NULL``."
msgstr ""
"Керує полем :c:member:`~Py_buffer.format`. Якщо встановлено, це поле ПОВИННО "
"бути заповнене правильно. В іншому випадку це поле ПОВИННО мати значення "
"``NULL``."

msgid ""
":c:macro:`PyBUF_WRITABLE` can be \\|'d to any of the flags in the next "
"section. Since :c:macro:`PyBUF_SIMPLE` is defined as 0, :c:macro:"
"`PyBUF_WRITABLE` can be used as a stand-alone flag to request a simple "
"writable buffer."
msgstr ""
":c:macro:`PyBUF_WRITABLE` можна приєднати до будь-якого з прапорів у "
"наступному розділі. Оскільки :c:macro:`PyBUF_SIMPLE` визначено як 0, :c:"
"macro:`PyBUF_WRITABLE` можна використовувати як окремий прапор для запиту "
"простого буфера для запису."

msgid ""
":c:macro:`PyBUF_FORMAT` can be \\|'d to any of the flags except :c:macro:"
"`PyBUF_SIMPLE`. The latter already implies format ``B`` (unsigned bytes)."
msgstr ""
":c:macro:`PyBUF_FORMAT` можна приєднати до будь-якого з прапорів, крім :c:"
"macro:`PyBUF_SIMPLE`. Останнє вже передбачає формат ``B`` (беззнакові байти)."

msgid "shape, strides, suboffsets"
msgstr "форма, кроки, підзміщення"

msgid ""
"The flags that control the logical structure of the memory are listed in "
"decreasing order of complexity. Note that each flag contains all bits of the "
"flags below it."
msgstr ""
"Прапори, які керують логічною структурою пам'яті, перераховані в порядку "
"зменшення складності. Зауважте, що кожен прапор містить усі біти прапорів "
"під ним."

msgid "Request"
msgstr "запит"

msgid "shape"
msgstr "форму"

msgid "strides"
msgstr "кроками"

msgid "suboffsets"
msgstr "підзміщення"

msgid "yes"
msgstr "так"

msgid "if needed"
msgstr "при необхідності"

msgid "NULL"
msgstr "НУЛЬ"

msgid "contiguity requests"
msgstr "запити суміжності"

msgid ""
"C or Fortran :term:`contiguity <contiguous>` can be explicitly requested, "
"with and without stride information. Without stride information, the buffer "
"must be C-contiguous."
msgstr ""
"C або Fortran :term:`contiguity <contiguous>` можна запитати явно, з "
"інформацією про крок або без неї. Без інформації про кроки буфер має бути C-"
"суміжним."

msgid "contig"
msgstr "контиг"

msgid "C"
msgstr "C"

msgid "F"
msgstr "Ф"

msgid "C or F"
msgstr "C або F"

msgid ":c:macro:`PyBUF_ND`"
msgstr ":c:macro:`PyBUF_ND`"

msgid "compound requests"
msgstr "складені запити"

msgid ""
"All possible requests are fully defined by some combination of the flags in "
"the previous section. For convenience, the buffer protocol provides "
"frequently used combinations as single flags."
msgstr ""
"Усі можливі запити повністю визначені деякою комбінацією прапорів у "
"попередньому розділі. Для зручності протокол буфера надає часто "
"використовувані комбінації як окремі прапорці."

msgid ""
"In the following table *U* stands for undefined contiguity. The consumer "
"would have to call :c:func:`PyBuffer_IsContiguous` to determine contiguity."
msgstr ""
"У наступній таблиці *U* означає невизначену суміжність. Споживач мав би "
"викликати :c:func:`PyBuffer_IsContiguous`, щоб визначити суміжність."

msgid "readonly"
msgstr "лише для читання"

msgid "format"
msgstr "формат"

msgid "U"
msgstr "U"

msgid "0"
msgstr "0"

msgid "1 or 0"
msgstr "1 або 0"

msgid "Complex arrays"
msgstr "Складні масиви"

msgid "NumPy-style: shape and strides"
msgstr "NumPy-стиль: форма та кроки"

msgid ""
"The logical structure of NumPy-style arrays is defined by :c:member:"
"`~Py_buffer.itemsize`, :c:member:`~Py_buffer.ndim`, :c:member:`~Py_buffer."
"shape` and :c:member:`~Py_buffer.strides`."
msgstr ""
"Логічна структура масивів у стилі NumPy визначається :c:member:`~Py_buffer."
"itemsize`, :c:member:`~Py_buffer.ndim`, :c:member:`~Py_buffer.shape` і :c:"
"member:`~Py_buffer.strides`."

msgid ""
"If ``ndim == 0``, the memory location pointed to by :c:member:`~Py_buffer."
"buf` is interpreted as a scalar of size :c:member:`~Py_buffer.itemsize`. In "
"that case, both :c:member:`~Py_buffer.shape` and :c:member:`~Py_buffer."
"strides` are ``NULL``."
msgstr ""
"Якщо ``ndim == 0``, розташування пам'яті, на яке вказує :c:member:"
"`~Py_buffer.buf`, інтерпретується як скаляр розміру :c:member:`~Py_buffer."
"itemsize`. У цьому випадку і :c:member:`~Py_buffer.shape`, і :c:member:"
"`~Py_buffer.strides` мають значення ``NULL``."

msgid ""
"If :c:member:`~Py_buffer.strides` is ``NULL``, the array is interpreted as a "
"standard n-dimensional C-array. Otherwise, the consumer must access an n-"
"dimensional array as follows:"
msgstr ""
"Якщо :c:member:`~Py_buffer.strides` має значення ``NULL``, масив "
"інтерпретується як стандартний n-вимірний C-масив. В іншому випадку споживач "
"повинен отримати доступ до n-вимірного масиву наступним чином:"

msgid ""
"As noted above, :c:member:`~Py_buffer.buf` can point to any location within "
"the actual memory block. An exporter can check the validity of a buffer with "
"this function:"
msgstr ""
"Як зазначалося вище, :c:member:`~Py_buffer.buf` може вказувати на будь-яке "
"місце в межах фактичного блоку пам’яті. Експортер може перевірити дійсність "
"буфера за допомогою цієї функції:"

msgid "PIL-style: shape, strides and suboffsets"
msgstr "PIL-стиль: форма, кроки та підзміщення"

msgid ""
"In addition to the regular items, PIL-style arrays can contain pointers that "
"must be followed in order to get to the next element in a dimension. For "
"example, the regular three-dimensional C-array ``char v[2][2][3]`` can also "
"be viewed as an array of 2 pointers to 2 two-dimensional arrays: ``char "
"(*v[2])[2][3]``. In suboffsets representation, those two pointers can be "
"embedded at the start of :c:member:`~Py_buffer.buf`, pointing to two ``char "
"x[2][3]`` arrays that can be located anywhere in memory."
msgstr ""
"Окрім звичайних елементів, масиви у стилі PIL можуть містити вказівники, за "
"якими потрібно слідувати, щоб перейти до наступного елемента у вимірі. "
"Наприклад, звичайний тривимірний C-масив ``char v[2][2][3]`` також можна "
"розглядати як масив із 2 покажчиків на 2 двовимірні масиви: ``char (*v[ 2])"
"[2][3]``. У представленні субзсувів ці два вказівники можуть бути вбудовані "
"на початку :c:member:`~Py_buffer.buf`, вказуючи на два масиви ``char x[2]"
"[3]``, які можуть бути розташовані будь-де в пам’яті."

msgid ""
"Here is a function that returns a pointer to the element in an N-D array "
"pointed to by an N-dimensional index when there are both non-``NULL`` "
"strides and suboffsets::"
msgstr ""
"Ось функція, яка повертає вказівник на елемент у N-D масиві, на який вказує "
"N-вимірний індекс, коли є як кроки, так і підзміщення, відмінні від "
"``NULL``::"

msgid "Buffer-related functions"
msgstr "Функції, пов'язані з буфером"

msgid ""
"Return ``1`` if *obj* supports the buffer interface otherwise ``0``.  When "
"``1`` is returned, it doesn't guarantee that :c:func:`PyObject_GetBuffer` "
"will succeed.  This function always succeeds."
msgstr ""
"Повертає ``1``, якщо *obj* підтримує інтерфейс буфера, інакше ``0``. Коли "
"повертається ``1``, це не гарантує, що :c:func:`PyObject_GetBuffer` буде "
"успішним. Ця функція завжди успішна."

msgid ""
"Send a request to *exporter* to fill in *view* as specified by  *flags*. If "
"the exporter cannot provide a buffer of the exact type, it MUST raise :c:"
"data:`PyExc_BufferError`, set ``view->obj`` to ``NULL`` and return ``-1``."
msgstr ""
"Надішліть запит до *exporter*, щоб заповнити *view*, як зазначено *flags*. "
"Якщо експортер не може надати буфер точного типу, він ПОВИНЕН викликати :c:"
"data:`PyExc_BufferError`, встановити ``view->obj`` на ``NULL`` і повернути "
"``-1``."

msgid ""
"On success, fill in *view*, set ``view->obj`` to a new reference to "
"*exporter* and return 0. In the case of chained buffer providers that "
"redirect requests to a single object, ``view->obj`` MAY refer to this object "
"instead of *exporter* (See :ref:`Buffer Object Structures <buffer-structs>`)."
msgstr ""
"У разі успіху заповніть *view*, встановіть ``view->obj`` на нове посилання "
"на *exporter* і поверніть 0. У випадку зв’язаних постачальників буферів, які "
"перенаправляють запити до одного об’єкта, ``view-> obj`` МОЖЕ посилатися на "
"цей об’єкт замість *exporter* (Див. :ref:`Структури об’єктів буфера <buffer-"
"structs>`)."

msgid ""
"Successful calls to :c:func:`PyObject_GetBuffer` must be paired with calls "
"to :c:func:`PyBuffer_Release`, similar to :c:func:`malloc` and :c:func:"
"`free`. Thus, after the consumer is done with the buffer, :c:func:"
"`PyBuffer_Release` must be called exactly once."
msgstr ""
"Успішні виклики :c:func:`PyObject_GetBuffer` повинні бути поєднані з "
"викликами :c:func:`PyBuffer_Release`, подібно до :c:func:`malloc` і :c:func:"
"`free`. Таким чином, після того, як споживач завершить роботу з буфером, :c:"
"func:`PyBuffer_Release` потрібно викликати рівно один раз."

msgid ""
"Release the buffer *view* and decrement the reference count for ``view-"
">obj``. This function MUST be called when the buffer is no longer being "
"used, otherwise reference leaks may occur."
msgstr ""
"Вивільніть буфер *view* і зменште кількість посилань для ``view->obj``. Цю "
"функцію ПОВИННО викликати, коли буфер більше не використовується, інакше "
"може статися витік посилань."

msgid ""
"It is an error to call this function on a buffer that was not obtained via :"
"c:func:`PyObject_GetBuffer`."
msgstr ""
"Виклик цієї функції в буфері, який не було отримано через :c:func:"
"`PyObject_GetBuffer`, є помилкою."

msgid ""
"Return the implied :c:data:`~Py_buffer.itemsize` from :c:data:`~Py_buffer."
"format`. On error, raise an exception and return -1."
msgstr ""
"Повертає неявний :c:data:`~Py_buffer.itemsize` з :c:data:`~Py_buffer."
"format`. У разі помилки викликає виняток і повертає -1."

msgid ""
"Return ``1`` if the memory defined by the *view* is C-style (*order* is "
"``'C'``) or Fortran-style (*order* is ``'F'``) :term:`contiguous` or either "
"one (*order* is ``'A'``).  Return ``0`` otherwise.  This function always "
"succeeds."
msgstr ""
"Повертає ``1``, якщо пам’ять, визначена *view*, є стилем C (*order* це "
"``'C''``) або стилем Fortran (*order* це ``'F'``) :term:`contiguous` або "
"один (*порядок* це ``'A'``). Інакше поверніть ``0``. Ця функція завжди "
"успішна."

msgid ""
"Get the memory area pointed to by the *indices* inside the given *view*. "
"*indices* must point to an array of ``view->ndim`` indices."
msgstr ""
"Отримайте область пам’яті, на яку вказують *індекси* в даному *виді*. "
"*індекси* повинні вказувати на масив індексів ``view->ndim``."

msgid ""
"Copy contiguous *len* bytes from *buf* to *view*. *fort* can be ``'C'`` or "
"``'F'`` (for C-style or Fortran-style ordering). ``0`` is returned on "
"success, ``-1`` on error."
msgstr ""
"Скопіюйте послідовні *len* байти з *buf* у *view*. *fort* може бути ``'C'`` "
"або ``'F'`` (для впорядкування у стилі C або Fortran). ``0`` повертається в "
"разі успіху, ``-1`` у разі помилки."

msgid ""
"Copy *len* bytes from *src* to its contiguous representation in *buf*. "
"*order* can be ``'C'`` or ``'F'`` or ``'A'`` (for C-style or Fortran-style "
"ordering or either one). ``0`` is returned on success, ``-1`` on error."
msgstr ""
"Скопіюйте *len* байти з *src* до його безперервного представлення в *buf*. "
"*order* може бути ``'C'`` або ``'F'`` або ``'A'`` (для впорядкування в стилі "
"C або Fortran або будь-якого з них). ``0`` повертається в разі успіху, "
"``-1`` у разі помилки."

msgid "This function fails if *len* != *src->len*."
msgstr "Ця функція не працює, якщо *len* != *src->len*."

msgid ""
"Copy data from *src* to *dest* buffer. Can convert between C-style and or "
"Fortran-style buffers."
msgstr ""

msgid "``0`` is returned on success, ``-1`` on error."
msgstr ""

msgid ""
"Fill the *strides* array with byte-strides of a :term:`contiguous` (C-style "
"if *order* is ``'C'`` or Fortran-style if *order* is ``'F'``) array of the "
"given shape with the given number of bytes per element."
msgstr ""
"Заповніть масив *strides* байтовими кроками :term:`contiguous` (у стилі C, "
"якщо *order* має значення ``'C'``, або у стилі Fortran, якщо *order* має "
"значення ``'F'`` ) масив заданої форми із заданою кількістю байтів на "
"елемент."

msgid ""
"Handle buffer requests for an exporter that wants to expose *buf* of size "
"*len* with writability set according to *readonly*. *buf* is interpreted as "
"a sequence of unsigned bytes."
msgstr ""
"Обробляти запити буфера для експортера, який хоче відкрити *buf* розміру "
"*len* із можливістю запису, встановленою відповідно до *readonly*. *buf* "
"інтерпретується як послідовність байтів без знаку."

msgid ""
"The *flags* argument indicates the request type. This function always fills "
"in *view* as specified by flags, unless *buf* has been designated as read-"
"only and :c:macro:`PyBUF_WRITABLE` is set in *flags*."
msgstr ""
"Аргумент *flags* вказує на тип запиту. Ця функція завжди заповнює *view*, як "
"зазначено прапорцями, якщо *buf* не призначено лише для читання і :c:macro:"
"`PyBUF_WRITABLE` встановлено у *flags*."

msgid ""
"On success, set ``view->obj`` to a new reference to *exporter* and return 0. "
"Otherwise, raise :c:data:`PyExc_BufferError`, set ``view->obj`` to ``NULL`` "
"and return ``-1``;"
msgstr ""
"У разі успіху встановіть ``view->obj`` на нове посилання на *exporter* і "
"поверніть 0. В іншому випадку підніміть :c:data:`PyExc_BufferError`, "
"встановіть ``view->obj`` на ``NULL`` і повертає ``-1``;"

msgid ""
"If this function is used as part of a :ref:`getbufferproc <buffer-structs>`, "
"*exporter* MUST be set to the exporting object and *flags* must be passed "
"unmodified. Otherwise, *exporter* MUST be ``NULL``."
msgstr ""
"Якщо ця функція використовується як частина :ref:`getbufferproc <buffer-"
"structs>`, *exporter* ПОВИНЕН бути встановлений на об’єкт експорту, а "
"*flags* мають бути передані без змін. В іншому випадку *exporter* ПОВИНЕН "
"бути ``NULL``."
