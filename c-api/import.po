# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:48+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Importing Modules"
msgstr "Імпорт модулів"

msgid ""
"This is a simplified interface to :c:func:`PyImport_ImportModuleEx` below, "
"leaving the *globals* and *locals* arguments set to ``NULL`` and *level* set "
"to 0.  When the *name* argument contains a dot (when it specifies a "
"submodule of a package), the *fromlist* argument is set to the list "
"``['*']`` so that the return value is the named module rather than the top-"
"level package containing it as would otherwise be the case.  (Unfortunately, "
"this has an additional side effect when *name* in fact specifies a "
"subpackage instead of a submodule: the submodules specified in the package's "
"``__all__`` variable are  loaded.)  Return a new reference to the imported "
"module, or ``NULL`` with an exception set on failure.  A failing import of a "
"module doesn't leave the module in :data:`sys.modules`."
msgstr ""
"Це спрощений інтерфейс для :c:func:`PyImport_ImportModuleEx` нижче, "
"залишаючи аргументи *globals* і *locals* встановленими на ``NULL``, а "
"*level* — на 0. Коли аргумент *name* містить крапку (якщо він визначає "
"підмодуль пакета), аргумент *fromlist* встановлюється на список ``['*']``, "
"так що значення, що повертається, є названим модулем, а не пакетом верхнього "
"рівня, який містить його, як це було б інакше буде так. (На жаль, це має "
"додатковий побічний ефект, коли *name* фактично визначає підпакет замість "
"підмодуля: завантажуються підмодулі, указані в змінній ``__all__`` пакета.) "
"Поверніть нове посилання на імпортований модуль або ``NULL`` з винятком, "
"встановленим у разі помилки. Невдалий імпорт модуля не залишає модуль у :"
"data:`sys.modules`."

msgid "This function always uses absolute imports."
msgstr "Ця функція завжди використовує абсолютний імпорт."

msgid "This function is a deprecated alias of :c:func:`PyImport_ImportModule`."
msgstr "Ця функція є застарілим псевдонімом :c:func:`PyImport_ImportModule`."

msgid ""
"This function used to fail immediately when the import lock was held by "
"another thread.  In Python 3.3 though, the locking scheme switched to per-"
"module locks for most purposes, so this function's special behaviour isn't "
"needed anymore."
msgstr ""
"Раніше ця функція відразу виходила з ладу, коли блокування імпорту "
"утримувалося іншим потоком. Однак у Python 3.3 схема блокування перейшла на "
"блокування по модулю для більшості цілей, тому особлива поведінка цієї "
"функції більше не потрібна."

msgid ""
"Import a module.  This is best described by referring to the built-in Python "
"function :func:`__import__`."
msgstr ""
"Імпортувати модуль. Найкраще це можна описати, звернувшись до вбудованої "
"функції Python :func:`__import__`."

msgid ""
"The return value is a new reference to the imported module or top-level "
"package, or ``NULL`` with an exception set on failure.  Like for :func:"
"`__import__`, the return value when a submodule of a package was requested "
"is normally the top-level package, unless a non-empty *fromlist* was given."
msgstr ""
"Значення, що повертається, є новим посиланням на імпортований модуль або "
"пакет верхнього рівня, або ``NULL`` з винятком, встановленим у разі помилки. "
"Як і для :func:`__import__`, значення, що повертається, коли запитується "
"підмодуль пакету, зазвичай є пакетом верхнього рівня, якщо не було надано "
"непорожній *fromlist*."

msgid ""
"Failing imports remove incomplete module objects, like with :c:func:"
"`PyImport_ImportModule`."
msgstr ""
"Невдалий імпорт видаляє неповні об’єкти модуля, як-от :c:func:"
"`PyImport_ImportModule`."

msgid ""
"Import a module.  This is best described by referring to the built-in Python "
"function :func:`__import__`, as the standard :func:`__import__` function "
"calls this function directly."
msgstr ""
"Імпортувати модуль. Найкраще це можна описати, звернувшись до вбудованої "
"функції Python :func:`__import__`, оскільки стандартна функція :func:"
"`__import__` викликає цю функцію безпосередньо."

msgid ""
"Similar to :c:func:`PyImport_ImportModuleLevelObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
"Подібно до :c:func:`PyImport_ImportModuleLevelObject`, але ім’я є рядком у "
"кодуванні UTF-8 замість об’єкта Unicode."

msgid "Negative values for *level* are no longer accepted."
msgstr "Від’ємні значення для *рівня* більше не приймаються."

msgid ""
"This is a higher-level interface that calls the current \"import hook "
"function\" (with an explicit *level* of 0, meaning absolute import).  It "
"invokes the :func:`__import__` function from the ``__builtins__`` of the "
"current globals.  This means that the import is done using whatever import "
"hooks are installed in the current environment."
msgstr ""
"Це інтерфейс вищого рівня, який викликає поточну \"функцію перехоплення "
"імпорту\" (з явним *рівнем* 0, що означає абсолютний імпорт). Він викликає "
"функцію :func:`__import__` з ``__builtins__`` поточних глобалів. Це означає, "
"що імпорт виконується за допомогою будь-яких хуків імпорту, встановлених у "
"поточному середовищі."

msgid ""
"Reload a module.  Return a new reference to the reloaded module, or ``NULL`` "
"with an exception set on failure (the module still exists in this case)."
msgstr ""
"Перезавантажте модуль. Повертає нове посилання на перезавантажений модуль "
"або ``NULL`` з винятком, встановленим у разі помилки (у цьому випадку модуль "
"все ще існує)."

msgid ""
"Return the module object corresponding to a module name.  The *name* "
"argument may be of the form ``package.module``. First check the modules "
"dictionary if there's one there, and if not, create a new one and insert it "
"in the modules dictionary. Return ``NULL`` with an exception set on failure."
msgstr ""
"Повертає об’єкт модуля, що відповідає імені модуля. Аргумент *name* може "
"мати форму ``package.module``. Спочатку перевірте словник модулів, якщо він "
"там є, а якщо ні, створіть новий і вставте його в словник модулів. Повертає "
"``NULL`` із встановленим винятком у разі помилки."

msgid ""
"This function does not load or import the module; if the module wasn't "
"already loaded, you will get an empty module object. Use :c:func:"
"`PyImport_ImportModule` or one of its variants to import a module.  Package "
"structures implied by a dotted name for *name* are not created if not "
"already present."
msgstr ""
"Ця функція не завантажує та не імпортує модуль; якщо модуль ще не "
"завантажено, ви отримаєте порожній об’єкт модуля. Використовуйте :c:func:"
"`PyImport_ImportModule` або один із його варіантів, щоб імпортувати модуль. "
"Структури пакетів, визначені назвою *name* із крапками, не створюються, якщо "
"вони ще не присутні."

msgid ""
"Similar to :c:func:`PyImport_AddModuleObject`, but the name is a UTF-8 "
"encoded string instead of a Unicode object."
msgstr ""
"Подібно до :c:func:`PyImport_AddModuleObject`, але ім’я є рядком у кодуванні "
"UTF-8 замість об’єкта Юнікод."

msgid ""
"Given a module name (possibly of the form ``package.module``) and a code "
"object read from a Python bytecode file or obtained from the built-in "
"function :func:`compile`, load the module.  Return a new reference to the "
"module object, or ``NULL`` with an exception set if an error occurred.  "
"*name* is removed from :attr:`sys.modules` in error cases, even if *name* "
"was already in :attr:`sys.modules` on entry to :c:func:"
"`PyImport_ExecCodeModule`.  Leaving incompletely initialized modules in :"
"attr:`sys.modules` is dangerous, as imports of such modules have no way to "
"know that the module object is an unknown (and probably damaged with respect "
"to the module author's intents) state."
msgstr ""
"Завантажте модуль із назвою модуля (можливо, у формі ``package.module``) і "
"об’єктом коду, прочитаним із файлу байт-коду Python або отриманим із "
"вбудованої функції :func:`compile`. Повертає нове посилання на об’єкт модуля "
"або ``NULL`` із встановленим винятком, якщо сталася помилка. *ім’я* "
"видаляється з :attr:`sys.modules` у випадках помилки, навіть якщо *ім’я* вже "
"було в :attr:`sys.modules` під час входу в :c:func:"
"`PyImport_ExecCodeModule`. Залишати неповністю ініціалізовані модулі в :attr:"
"`sys.modules` небезпечно, оскільки імпорт таких модулів не має способу "
"дізнатися, що об’єкт модуля є невідомим (і, ймовірно, пошкодженим щодо "
"намірів автора модуля) станом."

msgid ""
"The module's :attr:`__spec__` and :attr:`__loader__` will be set, if not set "
"already, with the appropriate values.  The spec's loader will be set to the "
"module's ``__loader__`` (if set) and to an instance of :class:"
"`SourceFileLoader` otherwise."
msgstr ""
":attr:`__spec__` і :attr:`__loader__` модуля буде встановлено, якщо ще не "
"встановлено, з відповідними значеннями. Завантажувач специфікації буде "
"встановлено на ``__loader__`` модуля (якщо встановлено) та на екземпляр :"
"class:`SourceFileLoader` в іншому випадку."

msgid ""
"The module's :attr:`__file__` attribute will be set to the code object's :c:"
"member:`co_filename`.  If applicable, :attr:`__cached__` will also be set."
msgstr ""
"Атрибут :attr:`__file__` модуля буде встановлено на :c:member:`co_filename` "
"об’єкта коду. Якщо застосовно, також буде встановлено :attr:`__cached__`."

msgid ""
"This function will reload the module if it was already imported.  See :c:"
"func:`PyImport_ReloadModule` for the intended way to reload a module."
msgstr ""
"Ця функція перезавантажить модуль, якщо він уже був імпортований. "
"Перегляньте :c:func:`PyImport_ReloadModule` для передбачуваного способу "
"перезавантаження модуля."

msgid ""
"If *name* points to a dotted name of the form ``package.module``, any "
"package structures not already created will still not be created."
msgstr ""
"Якщо *name* вказує на ім’я з крапками у формі ``package.module``, будь-які "
"ще не створені структури пакунків не будуть створені."

msgid ""
"See also :c:func:`PyImport_ExecCodeModuleEx` and :c:func:"
"`PyImport_ExecCodeModuleWithPathnames`."
msgstr ""
"Дивіться також :c:func:`PyImport_ExecCodeModuleEx` і :c:func:"
"`PyImport_ExecCodeModuleWithPathnames`."

msgid ""
"Like :c:func:`PyImport_ExecCodeModule`, but the :attr:`__file__` attribute "
"of the module object is set to *pathname* if it is non-``NULL``."
msgstr ""
"Подібно до :c:func:`PyImport_ExecCodeModule`, але атрибут :attr:`__file__` "
"об’єкта модуля встановлюється на *pathname*, якщо він не є ``NULL``."

msgid "See also :c:func:`PyImport_ExecCodeModuleWithPathnames`."
msgstr "Дивіться також :c:func:`PyImport_ExecCodeModuleWithPathnames`."

msgid ""
"Like :c:func:`PyImport_ExecCodeModuleEx`, but the :attr:`__cached__` "
"attribute of the module object is set to *cpathname* if it is non-``NULL``.  "
"Of the three functions, this is the preferred one to use."
msgstr ""
"Подібно до :c:func:`PyImport_ExecCodeModuleEx`, але атрибут :attr:"
"`__cached__` об’єкта модуля встановлюється на *cpathname*, якщо він не "
"``NULL``. З усіх трьох функцій найкраще використовувати цю."

msgid ""
"Like :c:func:`PyImport_ExecCodeModuleObject`, but *name*, *pathname* and "
"*cpathname* are UTF-8 encoded strings. Attempts are also made to figure out "
"what the value for *pathname* should be from *cpathname* if the former is "
"set to ``NULL``."
msgstr ""
"Як :c:func:`PyImport_ExecCodeModuleObject`, але *name*, *pathname* і "
"*cpathname* є рядками в кодуванні UTF-8. Також робляться спроби з’ясувати, "
"яким має бути значення *pathname* від *cpathname*, якщо для першого "
"встановлено значення ``NULL``."

msgid ""
"Uses :func:`imp.source_from_cache()` in calculating the source path if only "
"the bytecode path is provided."
msgstr ""
"Використовує :func:`imp.source_from_cache()` для обчислення вихідного шляху, "
"якщо надається лише шлях байт-коду."

msgid ""
"Return the magic number for Python bytecode files (a.k.a. :file:`.pyc` "
"file). The magic number should be present in the first four bytes of the "
"bytecode file, in little-endian byte order. Returns ``-1`` on error."
msgstr ""
"Повертає магічне число для файлів байт-коду Python (він же файл :file:`."
"pyc`). Магічне число має бути присутнім у перших чотирьох байтах файлу байт-"
"коду в порядку байтів у порядку байтів. Повертає ``-1`` у разі помилки."

msgid "Return value of ``-1`` upon failure."
msgstr "Повертає значення \"-1\" у разі помилки."

msgid ""
"Return the magic tag string for :pep:`3147` format Python bytecode file "
"names.  Keep in mind that the value at ``sys.implementation.cache_tag`` is "
"authoritative and should be used instead of this function."
msgstr ""
"Повертає рядок чарівного тегу для імен файлів байт-коду Python у форматі :"
"pep:`3147`. Майте на увазі, що значення в ``sys.implementation.cache_tag`` є "
"авторитетним і має використовуватися замість цієї функції."

msgid ""
"Return the dictionary used for the module administration (a.k.a. ``sys."
"modules``).  Note that this is a per-interpreter variable."
msgstr ""
"Повертає словник, який використовується для адміністрування модуля (він же "
"``sys.modules``). Зверніть увагу, що це змінна для кожного інтерпретатора."

msgid ""
"Return the already imported module with the given name.  If the module has "
"not been imported yet then returns ``NULL`` but does not set an error.  "
"Returns ``NULL`` and sets an error if the lookup failed."
msgstr ""
"Повернути вже імпортований модуль із вказаною назвою. Якщо модуль ще не було "
"імпортовано, повертає ``NULL``, але не встановлює помилку. Повертає ``NULL`` "
"і встановлює помилку, якщо пошук не вдався."

msgid ""
"Return a finder object for a :data:`sys.path`/:attr:`pkg.__path__` item "
"*path*, possibly by fetching it from the :data:`sys.path_importer_cache` "
"dict.  If it wasn't yet cached, traverse :data:`sys.path_hooks` until a hook "
"is found that can handle the path item.  Return ``None`` if no hook could; "
"this tells our caller that the :term:`path based finder` could not find a "
"finder for this path item. Cache the result in :data:`sys."
"path_importer_cache`. Return a new reference to the finder object."
msgstr ""
"Повертає об’єкт пошуку для :data:`sys.path`/:attr:`pkg.__path__` елемента "
"*path*, можливо, шляхом отримання його з :data:`sys.path_importer_cache` "
"dict. Якщо він ще не був кешований, проходьте :data:`sys.path_hooks`, доки "
"не буде знайдено хук, який може обробити елемент шляху. Повертає ``None``, "
"якщо жоден гачок не міг; це повідомляє нашому абоненту, що :term:`path based "
"finder` не може знайти засіб пошуку для цього елемента шляху. Кешуйте "
"результат у :data:`sys.path_importer_cache`. Повернути нове посилання на "
"об’єкт пошуку."

msgid ""
"Load a frozen module named *name*.  Return ``1`` for success, ``0`` if the "
"module is not found, and ``-1`` with an exception set if the initialization "
"failed.  To access the imported module on a successful load, use :c:func:"
"`PyImport_ImportModule`.  (Note the misnomer --- this function would reload "
"the module if it was already imported.)"
msgstr ""
"Завантажте заморожений модуль під назвою *name*. Повертає ``1`` для успіху, "
"``0``, якщо модуль не знайдено, ``-1`` із встановленим винятком, якщо "
"ініціалізація не вдалася. Щоб отримати доступ до імпортованого модуля після "
"успішного завантаження, використовуйте :c:func:`PyImport_ImportModule`. "
"(Зверніть увагу на неправильну назву --- ця функція перезавантажить модуль, "
"якщо його вже було імпортовано.)"

msgid "The ``__file__`` attribute is no longer set on the module."
msgstr "Атрибут ``__file__`` більше не встановлено в модулі."

msgid ""
"Similar to :c:func:`PyImport_ImportFrozenModuleObject`, but the name is a "
"UTF-8 encoded string instead of a Unicode object."
msgstr ""
"Подібно до :c:func:`PyImport_ImportFrozenModuleObject`, але ім’я є рядком у "
"кодуванні UTF-8 замість об’єкта Unicode."

msgid ""
"This is the structure type definition for frozen module descriptors, as "
"generated by the :program:`freeze` utility (see :file:`Tools/freeze/` in the "
"Python source distribution).  Its definition, found in :file:`Include/import."
"h`, is::"
msgstr ""
"Це визначення типу структури для закріплених дескрипторів модулів, створених "
"утилітою :program:`freeze` (див. :file:`Tools/freeze/` у вихідному коді "
"Python). Його визначення, знайдене в :file:`Include/import.h`, таке:"

msgid ""
"The new ``is_package`` field indicates whether the module is a package or "
"not. This replaces setting the ``size`` field to a negative value."
msgstr ""

msgid ""
"This pointer is initialized to point to an array of :c:struct:`_frozen` "
"records, terminated by one whose members are all ``NULL`` or zero.  When a "
"frozen module is imported, it is searched in this table.  Third-party code "
"could play tricks with this to provide a dynamically created collection of "
"frozen modules."
msgstr ""

msgid ""
"Add a single module to the existing table of built-in modules.  This is a "
"convenience wrapper around :c:func:`PyImport_ExtendInittab`, returning "
"``-1`` if the table could not be extended.  The new module can be imported "
"by the name *name*, and uses the function *initfunc* as the initialization "
"function called on the first attempted import.  This should be called "
"before :c:func:`Py_Initialize`."
msgstr ""
"Додайте один модуль до існуючої таблиці вбудованих модулів. Це зручна "
"обгортка навколо :c:func:`PyImport_ExtendInittab`, яка повертає ``-1``, якщо "
"таблицю не можна розширити. Новий модуль можна імпортувати під назвою *name* "
"і використовувати функцію *initfunc* як функцію ініціалізації, викликану під "
"час першої спроби імпорту. Його слід викликати перед :c:func:`Py_Initialize`."

msgid ""
"Structure describing a single entry in the list of built-in modules.  Each "
"of these structures gives the name and initialization function for a module "
"built into the interpreter.  The name is an ASCII encoded string.  Programs "
"which embed Python may use an array of these structures in conjunction with :"
"c:func:`PyImport_ExtendInittab` to provide additional built-in modules. The "
"structure is defined in :file:`Include/import.h` as::"
msgstr ""
"Структура, що описує один запис у списку вбудованих модулів. Кожна з цих "
"структур дає назву та функцію ініціалізації для модуля, вбудованого в "
"інтерпретатор. Ім’я – це рядок у кодуванні ASCII. Програми, які вбудовують "
"Python, можуть використовувати масив цих структур у поєднанні з :c:func:"
"`PyImport_ExtendInittab` для надання додаткових вбудованих модулів. "
"Структура визначена у :file:`Include/import.h` як:"

msgid ""
"Add a collection of modules to the table of built-in modules.  The *newtab* "
"array must end with a sentinel entry which contains ``NULL`` for the :attr:"
"`name` field; failure to provide the sentinel value can result in a memory "
"fault. Returns ``0`` on success or ``-1`` if insufficient memory could be "
"allocated to extend the internal table.  In the event of failure, no modules "
"are added to the internal table.  This must be called before :c:func:"
"`Py_Initialize`."
msgstr ""
"Додати колекцію модулів до таблиці вбудованих модулів. Масив *newtab* має "
"закінчуватися дозорним записом, який містить ``NULL`` для поля :attr:`name`; "
"ненадання дозорного значення може призвести до помилки пам’яті. Повертає "
"``0`` у разі успіху або ``-1``, якщо може бути виділено недостатньо пам’яті "
"для розширення внутрішньої таблиці. У разі збою модулі не додаються до "
"внутрішньої таблиці. Його потрібно викликати перед :c:func:`Py_Initialize`."

msgid ""
"If Python is initialized multiple times, :c:func:`PyImport_AppendInittab` "
"or :c:func:`PyImport_ExtendInittab` must be called before each Python "
"initialization."
msgstr ""
"Якщо Python ініціалізовано кілька разів, перед кожною ініціалізацією Python "
"потрібно викликати :c:func:`PyImport_AppendInittab` або :c:func:"
"`PyImport_ExtendInittab`."
