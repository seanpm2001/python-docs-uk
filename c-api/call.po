# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:47+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Call Protocol"
msgstr "Протокол виклику"

msgid ""
"CPython supports two different calling protocols: *tp_call* and vectorcall."
msgstr "CPython підтримує два різні протоколи виклику: *tp_call* і vectorcall."

msgid "The *tp_call* Protocol"
msgstr "Протокол *tp_call*"

msgid ""
"Instances of classes that set :c:member:`~PyTypeObject.tp_call` are "
"callable. The signature of the slot is::"
msgstr ""
"Примірники класів, які встановлюють :c:member:`~PyTypeObject.tp_call`, можна "
"викликати. Сигнатура слота:"

msgid ""
"A call is made using a tuple for the positional arguments and a dict for the "
"keyword arguments, similarly to ``callable(*args, **kwargs)`` in Python "
"code. *args* must be non-NULL (use an empty tuple if there are no arguments) "
"but *kwargs* may be *NULL* if there are no keyword arguments."
msgstr ""
"Виклик здійснюється за допомогою кортежу для позиційних аргументів і dict "
"для ключових аргументів, подібно до ``callable(*args, **kwargs)`` у коді "
"Python. *args* не має бути NULL (використовуйте порожній кортеж, якщо немає "
"аргументів), але *kwargs* може мати значення *NULL*, якщо немає ключових "
"аргументів."

msgid ""
"This convention is not only used by *tp_call*: :c:member:`~PyTypeObject."
"tp_new` and :c:member:`~PyTypeObject.tp_init` also pass arguments this way."
msgstr ""
"Ця угода використовується не лише *tp_call*: :c:member:`~PyTypeObject."
"tp_new` і :c:member:`~PyTypeObject.tp_init` також передають аргументи таким "
"чином."

msgid ""
"To call an object, use :c:func:`PyObject_Call` or another :ref:`call API "
"<capi-call>`."
msgstr ""
"Щоб викликати об’єкт, використовуйте :c:func:`PyObject_Call` або інший :ref:"
"`API виклику <capi-call>`."

msgid "The Vectorcall Protocol"
msgstr "Протокол Vectorcall"

msgid ""
"The vectorcall protocol was introduced in :pep:`590` as an additional "
"protocol for making calls more efficient."
msgstr ""
"Протокол vectorcall був представлений у :pep:`590` як додатковий протокол "
"для підвищення ефективності викликів."

msgid ""
"As rule of thumb, CPython will prefer the vectorcall for internal calls if "
"the callable supports it. However, this is not a hard rule. Additionally, "
"some third-party extensions use *tp_call* directly (rather than using :c:"
"func:`PyObject_Call`). Therefore, a class supporting vectorcall must also "
"implement :c:member:`~PyTypeObject.tp_call`. Moreover, the callable must "
"behave the same regardless of which protocol is used. The recommended way to "
"achieve this is by setting :c:member:`~PyTypeObject.tp_call` to :c:func:"
"`PyVectorcall_Call`. This bears repeating:"
msgstr ""
"Як правило, CPython віддасть перевагу vectorcall для внутрішніх викликів, "
"якщо виклик підтримує його. Однак це не жорстке правило. Крім того, деякі "
"сторонні розширення використовують безпосередньо *tp_call* (замість "
"використання :c:func:`PyObject_Call`). Таким чином, клас, який підтримує "
"векторний виклик, також повинен реалізовувати :c:member:`~PyTypeObject."
"tp_call`. Крім того, виклик має вести себе однаково незалежно від того, який "
"протокол використовується. Рекомендований спосіб досягти цього — встановити :"
"c:member:`~PyTypeObject.tp_call` на :c:func:`PyVectorcall_Call`. Варто "
"повторити:"

msgid ""
"A class supporting vectorcall **must** also implement :c:member:"
"`~PyTypeObject.tp_call` with the same semantics."
msgstr ""
"Клас, що підтримує векторний виклик, **повинен** також реалізувати :c:member:"
"`~PyTypeObject.tp_call` з тією самою семантикою."

msgid ""
"A class should not implement vectorcall if that would be slower than "
"*tp_call*. For example, if the callee needs to convert the arguments to an "
"args tuple and kwargs dict anyway, then there is no point in implementing "
"vectorcall."
msgstr ""
"Клас не повинен реалізовувати vectorcall, якщо це буде повільніше, ніж "
"*tp_call*. Наприклад, якщо викликаному потрібно перетворити аргументи на "
"кортеж args і kwargs dict у будь-якому випадку, тоді немає сенсу в "
"реалізації vectorcall."

msgid ""
"Classes can implement the vectorcall protocol by enabling the :const:"
"`Py_TPFLAGS_HAVE_VECTORCALL` flag and setting :c:member:`~PyTypeObject."
"tp_vectorcall_offset` to the offset inside the object structure where a "
"*vectorcallfunc* appears. This is a pointer to a function with the following "
"signature:"
msgstr ""
"Класи можуть реалізувати протокол vectorcall, увімкнувши прапорець :const:"
"`Py_TPFLAGS_HAVE_VECTORCALL` і встановивши :c:member:`~PyTypeObject."
"tp_vectorcall_offset` на зміщення всередині структури об’єкта, де "
"з’являється *vectorcallfunc*. Це вказівник на функцію з такою сигнатурою:"

msgid "*callable* is the object being called."
msgstr "*callable* — об’єкт, який викликається."

msgid ""
"*args* is a C array consisting of the positional arguments followed by the"
msgstr ""
"*args* — це масив C, що складається з позиційних аргументів, за якими йде"

msgid ""
"values of the keyword arguments. This can be *NULL* if there are no "
"arguments."
msgstr ""
"значення аргументів ключових слів. Це може бути *NULL*, якщо немає "
"аргументів."

msgid "*nargsf* is the number of positional arguments plus possibly the"
msgstr "*nargsf* — це кількість позиційних аргументів плюс, можливо,"

msgid ""
":const:`PY_VECTORCALL_ARGUMENTS_OFFSET` flag. To get the actual number of "
"positional arguments from *nargsf*, use :c:func:`PyVectorcall_NARGS`."
msgstr ""
":const:`PY_VECTORCALL_ARGUMENTS_OFFSET` прапор. Щоб отримати фактичну "
"кількість позиційних аргументів від *nargsf*, використовуйте :c:func:"
"`PyVectorcall_NARGS`."

msgid "*kwnames* is a tuple containing the names of the keyword arguments;"
msgstr "*kwnames* — це кортеж, що містить імена аргументів ключових слів;"

msgid ""
"in other words, the keys of the kwargs dict. These names must be strings "
"(instances of ``str`` or a subclass) and they must be unique. If there are "
"no keyword arguments, then *kwnames* can instead be *NULL*."
msgstr ""
"іншими словами, ключі kwargs dict. Ці імена мають бути рядками (примірниками "
"``str`` або підкласом) і вони мають бути унікальними. Якщо аргументів "
"ключового слова немає, замість цього *kwnames* може бути *NULL*."

msgid ""
"If this flag is set in a vectorcall *nargsf* argument, the callee is allowed "
"to temporarily change ``args[-1]``. In other words, *args* points to "
"argument 1 (not 0) in the allocated vector. The callee must restore the "
"value of ``args[-1]`` before returning."
msgstr ""
"Якщо цей прапор встановлено в аргументі *nargsf* векторного виклику, "
"викликаному дозволено тимчасово змінювати ``args[-1]``. Іншими словами, "
"*args* вказує на аргумент 1 (а не 0) у виділеному векторі. Викликаний має "
"відновити значення ``args[-1]`` перед поверненням."

msgid ""
"For :c:func:`PyObject_VectorcallMethod`, this flag means instead that "
"``args[0]`` may be changed."
msgstr ""
"Для :c:func:`PyObject_VectorcallMethod` цей прапорець натомість означає, що "
"``args[0]`` можна змінити."

msgid ""
"Whenever they can do so cheaply (without additional allocation), callers are "
"encouraged to use :const:`PY_VECTORCALL_ARGUMENTS_OFFSET`. Doing so will "
"allow callables such as bound methods to make their onward calls (which "
"include a prepended *self* argument) very efficiently."
msgstr ""
"Якщо вони можуть зробити це дешево (без додаткового розподілу), абонентам "
"рекомендується використовувати :const:`PY_VECTORCALL_ARGUMENTS_OFFSET`. Це "
"дозволить викликаним, таким як зв’язані методи, здійснювати свої подальші "
"виклики (які включають доданий аргумент *self*) дуже ефективно."

msgid ""
"To call an object that implements vectorcall, use a :ref:`call API <capi-"
"call>` function as with any other callable. :c:func:`PyObject_Vectorcall` "
"will usually be most efficient."
msgstr ""
"Щоб викликати об’єкт, який реалізує vectorcall, скористайтеся :ref:`call API "
"<capi-call>` функцією, як і будь-якою іншою можливістю виклику. :c:func:"
"`PyObject_Vectorcall` зазвичай буде найефективнішим."

msgid ""
"In CPython 3.8, the vectorcall API and related functions were available "
"provisionally under names with a leading underscore: "
"``_PyObject_Vectorcall``, ``_Py_TPFLAGS_HAVE_VECTORCALL``, "
"``_PyObject_VectorcallMethod``, ``_PyVectorcall_Function``, "
"``_PyObject_CallOneArg``, ``_PyObject_CallMethodNoArgs``, "
"``_PyObject_CallMethodOneArg``. Additionally, ``PyObject_VectorcallDict`` "
"was available as ``_PyObject_FastCallDict``. The old names are still defined "
"as aliases of the new, non-underscored names."
msgstr ""
"У CPython 3.8 API vectorcall і пов’язані функції були тимчасово доступні під "
"іменами з підкресленням на початку: ``_PyObject_Vectorcall``, "
"``_Py_TPFLAGS_HAVE_VECTORCALL``, ``_PyObject_VectorcallMethod``, "
"``_PyVectorcall_Function``, ``_PyObject_CallOneArg``, "
"``_PyObject_CallMethodNoArgs``, ``_PyObject_CallMethodOneArg``. Крім того, "
"``PyObject_VectorcallDict`` був доступний як ``_PyObject_FastCallDict``. "
"Старі імена все ще визначаються як псевдоніми нових імен без підкреслень."

msgid "Recursion Control"
msgstr "Контроль рекурсії"

msgid ""
"When using *tp_call*, callees do not need to worry about :ref:`recursion "
"<recursion>`: CPython uses :c:func:`Py_EnterRecursiveCall` and :c:func:"
"`Py_LeaveRecursiveCall` for calls made using *tp_call*."
msgstr ""
"Під час використання *tp_call* абонентам не потрібно турбуватися про :ref:"
"`recursion <recursion>`: CPython використовує :c:func:"
"`Py_EnterRecursiveCall` і :c:func:`Py_LeaveRecursiveCall` для викликів, "
"здійснених за допомогою *tp_call*."

msgid ""
"For efficiency, this is not the case for calls done using vectorcall: the "
"callee should use *Py_EnterRecursiveCall* and *Py_LeaveRecursiveCall* if "
"needed."
msgstr ""
"Для ефективності це не стосується викликів, виконаних за допомогою "
"vectorcall: виклик має використовувати *Py_EnterRecursiveCall* і "
"*Py_LeaveRecursiveCall*, якщо це необхідно."

msgid "Vectorcall Support API"
msgstr "API підтримки Vectorcall"

msgid ""
"Given a vectorcall *nargsf* argument, return the actual number of arguments. "
"Currently equivalent to::"
msgstr ""
"За наявності аргументу *nargsf* для векторного виклику повертає фактичну "
"кількість аргументів. На даний момент еквівалентно::"

msgid ""
"However, the function ``PyVectorcall_NARGS`` should be used to allow for "
"future extensions."
msgstr ""
"Проте, функція ``PyVectorcall_NARGS`` повинна використовуватися, щоб "
"дозволити майбутні розширення."

msgid ""
"If *op* does not support the vectorcall protocol (either because the type "
"does not or because the specific instance does not), return *NULL*. "
"Otherwise, return the vectorcall function pointer stored in *op*. This "
"function never raises an exception."
msgstr ""
"Якщо *op* не підтримує протокол vectorcall (або тому, що тип не підтримує, "
"або тому, що конкретний екземпляр не підтримує), повертає *NULL*. В іншому "
"випадку поверніть покажчик функції vectorcall, що зберігається в *op*. Ця "
"функція ніколи не викликає винятків."

msgid ""
"This is mostly useful to check whether or not *op* supports vectorcall, "
"which can be done by checking ``PyVectorcall_Function(op) != NULL``."
msgstr ""
"Це здебільшого корисно, щоб перевірити, чи *op* підтримує векторний виклик, "
"що можна зробити, перевіривши ``PyVectorcall_Function(op) != NULL``."

msgid ""
"Call *callable*'s :c:type:`vectorcallfunc` with positional and keyword "
"arguments given in a tuple and dict, respectively."
msgstr ""
"Викликати *callable* :c:type:`vectorcallfunc` з позиційними та ключовими "
"аргументами, заданими у кортежі та dict відповідно."

msgid ""
"This is a specialized function, intended to be put in the :c:member:"
"`~PyTypeObject.tp_call` slot or be used in an implementation of ``tp_call``. "
"It does not check the :const:`Py_TPFLAGS_HAVE_VECTORCALL` flag and it does "
"not fall back to ``tp_call``."
msgstr ""
"Це спеціалізована функція, призначена для розміщення в слоті :c:member:"
"`~PyTypeObject.tp_call` або для використання в реалізації ``tp_call``. Він "
"не перевіряє прапор :const:`Py_TPFLAGS_HAVE_VECTORCALL` і не повертається до "
"``tp_call``."

msgid "Object Calling API"
msgstr "API виклику об’єктів"

msgid ""
"Various functions are available for calling a Python object. Each converts "
"its arguments to a convention supported by the called object – either "
"*tp_call* or vectorcall. In order to do as little conversion as possible, "
"pick one that best fits the format of data you have available."
msgstr ""
"Для виклику об’єкта Python доступні різні функції. Кожен перетворює свої "
"аргументи на конвенцію, яка підтримується викликаним об’єктом – *tp_call* "
"або vectorcall. Щоб зробити якомога менше перетворення, виберіть той, який "
"найкраще відповідає формату доступних даних."

msgid ""
"The following table summarizes the available functions; please see "
"individual documentation for details."
msgstr ""
"У наведеній нижче таблиці підсумовано доступні функції; подробиці див. в "
"індивідуальній документації."

msgid "Function"
msgstr "функція"

msgid "callable"
msgstr "викликний"

msgid "args"
msgstr "арг"

msgid "kwargs"
msgstr "kwargs"

msgid ":c:func:`PyObject_Call`"
msgstr ":c:func:`PyObject_Call`"

msgid "``PyObject *``"
msgstr "``PyObject *``"

msgid "tuple"
msgstr "кортеж"

msgid "dict/``NULL``"
msgstr "dict/``NULL``"

msgid ":c:func:`PyObject_CallNoArgs`"
msgstr ":c:func:`PyObject_CallNoArgs`"

msgid "---"
msgstr "---"

msgid ":c:func:`PyObject_CallOneArg`"
msgstr ":c:func:`PyObject_CallOneArg`"

msgid "1 object"
msgstr "1 об'єкт"

msgid ":c:func:`PyObject_CallObject`"
msgstr ":c:func:`PyObject_CallObject`"

msgid "tuple/``NULL``"
msgstr "кортеж/``NULL``"

msgid ":c:func:`PyObject_CallFunction`"
msgstr ":c:func:`PyObject_CallFunction`"

msgid "format"
msgstr "формат"

msgid ":c:func:`PyObject_CallMethod`"
msgstr ":c:func:`PyObject_CallMethod`"

msgid "obj + ``char*``"
msgstr "obj + ``char*``"

msgid ":c:func:`PyObject_CallFunctionObjArgs`"
msgstr ":c:func:`PyObject_CallFunctionObjArgs`"

msgid "variadic"
msgstr "варіативний"

msgid ":c:func:`PyObject_CallMethodObjArgs`"
msgstr ":c:func:`PyObject_CallMethodObjArgs`"

msgid "obj + name"
msgstr "obj + ім'я"

msgid ":c:func:`PyObject_CallMethodNoArgs`"
msgstr ":c:func:`PyObject_CallMethodNoArgs`"

msgid ":c:func:`PyObject_CallMethodOneArg`"
msgstr ":c:func:`PyObject_CallMethodOneArg`"

msgid ":c:func:`PyObject_Vectorcall`"
msgstr ":c:func:`PyObject_Vectorcall`"

msgid "vectorcall"
msgstr "векторний виклик"

msgid ":c:func:`PyObject_VectorcallDict`"
msgstr ":c:func:`PyObject_VectorcallDict`"

msgid ":c:func:`PyObject_VectorcallMethod`"
msgstr ":c:func:`PyObject_VectorcallMethod`"

msgid "arg + name"
msgstr "аргумент + ім'я"

msgid ""
"Call a callable Python object *callable*, with arguments given by the tuple "
"*args*, and named arguments given by the dictionary *kwargs*."
msgstr ""
"Викликайте викликний об’єкт Python *callable* з аргументами, заданими "
"кортежем *args*, і іменованими аргументами, заданими словником *kwargs*."

msgid ""
"*args* must not be *NULL*; use an empty tuple if no arguments are needed. If "
"no named arguments are needed, *kwargs* can be *NULL*."
msgstr ""
"*args* не має бути *NULL*; використовуйте порожній кортеж, якщо аргументи не "
"потрібні. Якщо іменовані аргументи не потрібні, *kwargs* може бути *NULL*."

msgid ""
"Return the result of the call on success, or raise an exception and return "
"*NULL* on failure."
msgstr ""
"Повернути результат виклику в разі успіху або створити виняток і повернути "
"*NULL* у разі невдачі."

msgid ""
"This is the equivalent of the Python expression: ``callable(*args, "
"**kwargs)``."
msgstr "Це еквівалент виразу Python: ``callable(*args, **kwargs)``."

msgid ""
"Call a callable Python object *callable* without any arguments. It is the "
"most efficient way to call a callable Python object without any argument."
msgstr ""
"Викликати об'єкт Python, який можна викликати, *callable* без аргументів. Це "
"найефективніший спосіб викликати викликаний об’єкт Python без будь-яких "
"аргументів."

msgid ""
"Call a callable Python object *callable* with exactly 1 positional argument "
"*arg* and no keyword arguments."
msgstr ""
"Викликайте об’єкт Python, який можна викликати, *callable*, точно 1 "
"позиційний аргумент *arg* і без ключових аргументів."

msgid ""
"Call a callable Python object *callable*, with arguments given by the tuple "
"*args*.  If no arguments are needed, then *args* can be *NULL*."
msgstr ""
"Викликайте викликний об’єкт Python *callable* з аргументами, заданими "
"кортежем *args*. Якщо аргументи не потрібні, *args* може бути *NULL*."

msgid "This is the equivalent of the Python expression: ``callable(*args)``."
msgstr "Це еквівалент виразу Python: ``callable(*args)``."

msgid ""
"Call a callable Python object *callable*, with a variable number of C "
"arguments. The C arguments are described using a :c:func:`Py_BuildValue` "
"style format string.  The format can be *NULL*, indicating that no arguments "
"are provided."
msgstr ""
"Викликайте об'єкт Python, який можна викликати, *callable*, зі змінною "
"кількістю аргументів C. Аргументи C описані за допомогою рядка формату "
"стилю :c:func:`Py_BuildValue`. Формат може бути *NULL*, що вказує на "
"відсутність аргументів."

msgid ""
"Note that if you only pass :c:expr:`PyObject *` args, :c:func:"
"`PyObject_CallFunctionObjArgs` is a faster alternative."
msgstr ""

msgid "The type of *format* was changed from ``char *``."
msgstr "Тип *format* було змінено з ``char *``."

msgid ""
"Call the method named *name* of object *obj* with a variable number of C "
"arguments.  The C arguments are described by a :c:func:`Py_BuildValue` "
"format string that should produce a tuple."
msgstr ""
"Викличте метод з назвою *name* об’єкта *obj* зі змінною кількістю аргументів "
"C. Аргументи C описуються рядком формату :c:func:`Py_BuildValue`, який має "
"створити кортеж."

msgid "The format can be *NULL*, indicating that no arguments are provided."
msgstr "Формат може бути *NULL*, що вказує на відсутність аргументів."

msgid ""
"This is the equivalent of the Python expression: ``obj.name(arg1, "
"arg2, ...)``."
msgstr "Це еквівалент виразу Python: ``obj.name(arg1, arg2, ...)``."

msgid ""
"Note that if you only pass :c:expr:`PyObject *` args, :c:func:"
"`PyObject_CallMethodObjArgs` is a faster alternative."
msgstr ""

msgid "The types of *name* and *format* were changed from ``char *``."
msgstr "Типи *name* і *format* були змінені з ``char *``."

msgid ""
"Call a callable Python object *callable*, with a variable number of :c:expr:"
"`PyObject *` arguments.  The arguments are provided as a variable number of "
"parameters followed by *NULL*."
msgstr ""

msgid ""
"This is the equivalent of the Python expression: ``callable(arg1, "
"arg2, ...)``."
msgstr "Це еквівалент виразу Python: ``callable(arg1, arg2, ...)``."

msgid ""
"Call a method of the Python object *obj*, where the name of the method is "
"given as a Python string object in *name*.  It is called with a variable "
"number of :c:expr:`PyObject *` arguments.  The arguments are provided as a "
"variable number of parameters followed by *NULL*."
msgstr ""

msgid ""
"Call a method of the Python object *obj* without arguments, where the name "
"of the method is given as a Python string object in *name*."
msgstr ""
"Виклик методу об’єкта Python *obj* без аргументів, де ім’я методу вказано як "
"рядковий об’єкт Python у *name*."

msgid ""
"Call a method of the Python object *obj* with a single positional argument "
"*arg*, where the name of the method is given as a Python string object in "
"*name*."
msgstr ""
"Викличте метод об’єкта Python *obj* за допомогою одного позиційного "
"аргументу *arg*, де ім’я методу вказано як рядковий об’єкт Python у *name*."

msgid ""
"Call a callable Python object *callable*. The arguments are the same as for :"
"c:type:`vectorcallfunc`. If *callable* supports vectorcall_, this directly "
"calls the vectorcall function stored in *callable*."
msgstr ""
"Викликайте викликаний об'єкт Python *callable*. Аргументи такі самі, як і "
"для :c:type:`vectorcallfunc`. Якщо *callable* підтримує vectorcall_, це "
"безпосередньо викликає функцію vectorcall, збережену в *callable*."

msgid ""
"Call *callable* with positional arguments passed exactly as in the "
"vectorcall_ protocol, but with keyword arguments passed as a dictionary "
"*kwdict*. The *args* array contains only the positional arguments."
msgstr ""
"Виклик *callable* з позиційними аргументами, що передаються точно так само, "
"як у протоколі vectorcall_, але з ключовими аргументами, що передаються як "
"словник *kwdict*. Масив *args* містить лише позиційні аргументи."

msgid ""
"Regardless of which protocol is used internally, a conversion of arguments "
"needs to be done. Therefore, this function should only be used if the caller "
"already has a dictionary ready to use for the keyword arguments, but not a "
"tuple for the positional arguments."
msgstr ""
"Незалежно від того, який протокол використовується внутрішньо, необхідно "
"виконати перетворення аргументів. Таким чином, цю функцію слід "
"використовувати, лише якщо у абонента вже є словник, готовий до використання "
"для ключових аргументів, але не кортеж для позиційних аргументів."

msgid ""
"Call a method using the vectorcall calling convention. The name of the "
"method is given as a Python string *name*. The object whose method is called "
"is *args[0]*, and the *args* array starting at *args[1]* represents the "
"arguments of the call. There must be at least one positional argument. "
"*nargsf* is the number of positional arguments including *args[0]*, plus :"
"const:`PY_VECTORCALL_ARGUMENTS_OFFSET` if the value of ``args[0]`` may "
"temporarily be changed. Keyword arguments can be passed just like in :c:func:"
"`PyObject_Vectorcall`."
msgstr ""
"Викликайте метод за допомогою угоди про виклики vectorcall. Ім’я методу "
"задається як *ім’я* рядка Python. Об’єкт, метод якого викликається, — це "
"*args[0]*, а масив *args*, починаючи з *args[1]*, представляє аргументи "
"виклику. Має бути хоча б один позиційний аргумент. *nargsf* — це кількість "
"позиційних аргументів, включаючи *args[0]*, плюс :const:"
"`PY_VECTORCALL_ARGUMENTS_OFFSET`, якщо значення ``args[0]`` може бути "
"тимчасово змінено. Аргументи ключових слів можна передавати так само, як у :"
"c:func:`PyObject_Vectorcall`."

msgid ""
"If the object has the :const:`Py_TPFLAGS_METHOD_DESCRIPTOR` feature, this "
"will call the unbound method object with the full *args* vector as arguments."
msgstr ""
"Якщо об’єкт має функцію :const:`Py_TPFLAGS_METHOD_DESCRIPTOR`, це викличе "
"об’єкт незв’язаного методу з повним вектором *args* як аргументи."

msgid "Call Support API"
msgstr "API виклику служби підтримки"

msgid ""
"Determine if the object *o* is callable.  Return ``1`` if the object is "
"callable and ``0`` otherwise.  This function always succeeds."
msgstr ""
"Визначте, чи можна викликати об’єкт *o*. Повертає ``1``, якщо об’єкт можна "
"викликати, і ``0`` інакше. Ця функція завжди успішна."
