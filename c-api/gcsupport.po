# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:48+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Supporting Cyclic Garbage Collection"
msgstr "Підтримка циклічного збирання сміття"

msgid ""
"Python's support for detecting and collecting garbage which involves "
"circular references requires support from object types which are "
"\"containers\" for other objects which may also be containers.  Types which "
"do not store references to other objects, or which only store references to "
"atomic types (such as numbers or strings), do not need to provide any "
"explicit support for garbage collection."
msgstr ""
"Підтримка Python для виявлення та збирання сміття, яке включає циклічні "
"посилання, вимагає підтримки типів об’єктів, які є \"контейнерами\" для "
"інших об’єктів, які також можуть бути контейнерами. Типи, які не зберігають "
"посилання на інші об’єкти, або які зберігають лише посилання на атомарні "
"типи (такі як числа або рядки), не потребують явної підтримки для збирання "
"сміття."

msgid ""
"To create a container type, the :c:member:`~PyTypeObject.tp_flags` field of "
"the type object must include the :const:`Py_TPFLAGS_HAVE_GC` and provide an "
"implementation of the :c:member:`~PyTypeObject.tp_traverse` handler.  If "
"instances of the type are mutable, a :c:member:`~PyTypeObject.tp_clear` "
"implementation must also be provided."
msgstr ""
"Щоб створити тип контейнера, поле :c:member:`~PyTypeObject.tp_flags` об’єкта "
"типу має містити :const:`Py_TPFLAGS_HAVE_GC` і забезпечувати реалізацію "
"обробника :c:member:`~PyTypeObject.tp_traverse` . Якщо екземпляри типу є "
"змінними, необхідно також надати реалізацію :c:member:`~PyTypeObject."
"tp_clear`."

msgid ""
"Objects with a type with this flag set must conform with the rules "
"documented here.  For convenience these objects will be referred to as "
"container objects."
msgstr ""
"Об’єкти типу з цим прапорцем мають відповідати задокументованим тут "
"правилам. Для зручності ці об'єкти будуть називатися об'єктами-контейнерами."

msgid "Constructors for container types must conform to two rules:"
msgstr "Конструктори для типів контейнерів повинні відповідати двом правилам:"

msgid ""
"The memory for the object must be allocated using :c:func:`PyObject_GC_New` "
"or :c:func:`PyObject_GC_NewVar`."
msgstr ""
"Пам’ять для об’єкта має бути виділена за допомогою :c:func:`PyObject_GC_New` "
"або :c:func:`PyObject_GC_NewVar`."

msgid ""
"Once all the fields which may contain references to other containers are "
"initialized, it must call :c:func:`PyObject_GC_Track`."
msgstr ""
"Після ініціалізації всіх полів, які можуть містити посилання на інші "
"контейнери, він повинен викликати :c:func:`PyObject_GC_Track`."

msgid ""
"Similarly, the deallocator for the object must conform to a similar pair of "
"rules:"
msgstr ""
"Подібним чином, делокатор для об’єкта має відповідати подібній парі правил:"

msgid ""
"Before fields which refer to other containers are invalidated, :c:func:"
"`PyObject_GC_UnTrack` must be called."
msgstr ""
"Перш ніж поля, які посилаються на інші контейнери, стануть недійсними, "
"необхідно викликати :c:func:`PyObject_GC_UnTrack`."

msgid ""
"The object's memory must be deallocated using :c:func:`PyObject_GC_Del`."
msgstr ""
"Пам’ять об’єкта має бути звільнено за допомогою :c:func:`PyObject_GC_Del`."

msgid ""
"If a type adds the Py_TPFLAGS_HAVE_GC, then it *must* implement at least a :"
"c:member:`~PyTypeObject.tp_traverse` handler or explicitly use one from its "
"subclass or subclasses."
msgstr ""
"Якщо тип додає Py_TPFLAGS_HAVE_GC, тоді він *має* реалізувати принаймні "
"обробник :c:member:`~PyTypeObject.tp_traverse` або явно використовувати один "
"із свого підкласу або підкласів."

msgid ""
"When calling :c:func:`PyType_Ready` or some of the APIs that indirectly call "
"it like :c:func:`PyType_FromSpecWithBases` or :c:func:`PyType_FromSpec` the "
"interpreter will automatically populate the :c:member:`~PyTypeObject."
"tp_flags`, :c:member:`~PyTypeObject.tp_traverse` and :c:member:"
"`~PyTypeObject.tp_clear` fields if the type inherits from a class that "
"implements the garbage collector protocol and the child class does *not* "
"include the :const:`Py_TPFLAGS_HAVE_GC` flag."
msgstr ""
"Під час виклику :c:func:`PyType_Ready` або деяких API, які непрямо "
"викликають це як :c:func:`PyType_FromSpecWithBases` або :c:func:"
"`PyType_FromSpec`, інтерпретатор автоматично заповнить Поля :c:member:"
"`~PyTypeObject.tp_flags`, :c:member:`~PyTypeObject.tp_traverse` і :c:member:"
"`~PyTypeObject.tp_clear`, якщо тип успадковується від класу, який реалізує "
"протокол збирача сміття, а дочірній клас *не* включити прапорець :const:"
"`Py_TPFLAGS_HAVE_GC`."

msgid ""
"Analogous to :c:func:`PyObject_New` but for container objects with the :"
"const:`Py_TPFLAGS_HAVE_GC` flag set."
msgstr ""
"Аналогічно :c:func:`PyObject_New`, але для об’єктів-контейнерів зі "
"встановленим прапором :const:`Py_TPFLAGS_HAVE_GC`."

msgid ""
"Analogous to :c:func:`PyObject_NewVar` but for container objects with the :"
"const:`Py_TPFLAGS_HAVE_GC` flag set."
msgstr ""
"Аналогічно :c:func:`PyObject_NewVar`, але для об’єктів-контейнерів зі "
"встановленим прапором :const:`Py_TPFLAGS_HAVE_GC`."

msgid ""
"Resize an object allocated by :c:func:`PyObject_NewVar`.  Returns the "
"resized object or ``NULL`` on failure.  *op* must not be tracked by the "
"collector yet."
msgstr ""
"Змінити розмір об’єкта, виділеного :c:func:`PyObject_NewVar`. Повертає "
"змінений розмір об’єкта або ``NULL`` у разі помилки. *op* ще не повинен "
"відстежуватися колекціонером."

msgid ""
"Adds the object *op* to the set of container objects tracked by the "
"collector.  The collector can run at unexpected times so objects must be "
"valid while being tracked.  This should be called once all the fields "
"followed by the :c:member:`~PyTypeObject.tp_traverse` handler become valid, "
"usually near the end of the constructor."
msgstr ""
"Додає об’єкт *op* до набору об’єктів-контейнерів, які відстежує збирач. "
"Збирач може запускатися в несподіваний час, тому об’єкти мають бути дійсними "
"під час відстеження. Його слід викликати, коли всі поля, за якими йде "
"обробник :c:member:`~PyTypeObject.tp_traverse`, стануть дійсними, як "
"правило, ближче до кінця конструктора."

msgid ""
"Returns non-zero if the object implements the garbage collector protocol, "
"otherwise returns 0."
msgstr ""
"Повертає ненульове значення, якщо об’єкт реалізує протокол збирача сміття, "
"інакше повертає 0."

msgid ""
"The object cannot be tracked by the garbage collector if this function "
"returns 0."
msgstr "Збирач сміття не може відстежувати об’єкт, якщо ця функція повертає 0."

msgid ""
"Returns 1 if the object type of *op* implements the GC protocol and *op* is "
"being currently tracked by the garbage collector and 0 otherwise."
msgstr ""
"Повертає 1, якщо тип об’єкта *op* реалізує протокол GC і *op* зараз "
"відстежується збирачем сміття, і 0 в іншому випадку."

msgid "This is analogous to the Python function :func:`gc.is_tracked`."
msgstr "Це аналогічно функції Python :func:`gc.is_tracked`."

msgid ""
"Returns 1 if the object type of *op* implements the GC protocol and *op* has "
"been already finalized by the garbage collector and 0 otherwise."
msgstr ""
"Повертає 1, якщо тип об’єкта *op* реалізує протокол GC і *op* вже завершено "
"збирачем сміття, і 0 в іншому випадку."

msgid "This is analogous to the Python function :func:`gc.is_finalized`."
msgstr "Це аналогічно функції Python :func:`gc.is_finalized`."

msgid ""
"Releases memory allocated to an object using :c:func:`PyObject_GC_New` or :c:"
"func:`PyObject_GC_NewVar`."
msgstr ""
"Звільняє пам’ять, виділену об’єкту за допомогою :c:func:`PyObject_GC_New` "
"або :c:func:`PyObject_GC_NewVar`."

msgid ""
"Remove the object *op* from the set of container objects tracked by the "
"collector.  Note that :c:func:`PyObject_GC_Track` can be called again on "
"this object to add it back to the set of tracked objects.  The deallocator (:"
"c:member:`~PyTypeObject.tp_dealloc` handler) should call this for the object "
"before any of the fields used by the :c:member:`~PyTypeObject.tp_traverse` "
"handler become invalid."
msgstr ""
"Видаліть об’єкт *op* із набору об’єктів-контейнерів, які відстежує збирач. "
"Зауважте, що :c:func:`PyObject_GC_Track` можна знову викликати для цього "
"об’єкта, щоб додати його назад до набору відстежуваних об’єктів. Deallocator "
"(:c:member:`~PyTypeObject.tp_dealloc` обробник) має викликати це для об’єкта "
"до того, як будь-яке з полів, що використовуються :c:member:`~PyTypeObject."
"tp_traverse` обробником, стане недійсним."

msgid ""
"The :c:func:`_PyObject_GC_TRACK` and :c:func:`_PyObject_GC_UNTRACK` macros "
"have been removed from the public C API."
msgstr ""
"Макроси :c:func:`_PyObject_GC_TRACK` і :c:func:`_PyObject_GC_UNTRACK` "
"видалено з публічного API C."

msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` handler accepts a function "
"parameter of this type:"
msgstr ""
"Обробник :c:member:`~PyTypeObject.tp_traverse` приймає параметр функції "
"такого типу:"

msgid ""
"Type of the visitor function passed to the :c:member:`~PyTypeObject."
"tp_traverse` handler. The function should be called with an object to "
"traverse as *object* and the third parameter to the :c:member:`~PyTypeObject."
"tp_traverse` handler as *arg*.  The Python core uses several visitor "
"functions to implement cyclic garbage detection; it's not expected that "
"users will need to write their own visitor functions."
msgstr ""
"Тип функції відвідувача, переданої обробнику :c:member:`~PyTypeObject."
"tp_traverse`. Функція має бути викликана з об’єктом для проходження як "
"*object* і третім параметром для обробника :c:member:`~PyTypeObject."
"tp_traverse` як *arg*. Ядро Python використовує кілька функцій відвідувачів "
"для реалізації циклічного виявлення сміття; не очікується, що користувачам "
"доведеться писати власні функції відвідувачів."

msgid ""
"The :c:member:`~PyTypeObject.tp_traverse` handler must have the following "
"type:"
msgstr "Обробник :c:member:`~PyTypeObject.tp_traverse` повинен мати такий тип:"

msgid ""
"Traversal function for a container object.  Implementations must call the "
"*visit* function for each object directly contained by *self*, with the "
"parameters to *visit* being the contained object and the *arg* value passed "
"to the handler.  The *visit* function must not be called with a ``NULL`` "
"object argument.  If *visit* returns a non-zero value that value should be "
"returned immediately."
msgstr ""
"Функція обходу для об’єкта-контейнера. Реалізації повинні викликати функцію "
"*visit* для кожного об’єкта, який безпосередньо міститься в *self*, з "
"параметрами *visit*, які містять об’єкт, а значення *arg* передається "
"обробнику. Функцію *visit* не можна викликати з аргументом об’єкта ``NULL``. "
"Якщо *visit* повертає ненульове значення, це значення має бути повернуто "
"негайно."

msgid ""
"To simplify writing :c:member:`~PyTypeObject.tp_traverse` handlers, a :c:"
"func:`Py_VISIT` macro is provided.  In order to use this macro, the :c:"
"member:`~PyTypeObject.tp_traverse` implementation must name its arguments "
"exactly *visit* and *arg*:"
msgstr ""
"Для спрощення написання обробників :c:member:`~PyTypeObject.tp_traverse` "
"передбачено макрос :c:func:`Py_VISIT`. Щоб використовувати цей макрос, "
"реалізація :c:member:`~PyTypeObject.tp_traverse` має назвати свої аргументи "
"точно *visit* і *arg*:"

msgid ""
"If *o* is not ``NULL``, call the *visit* callback, with arguments *o* and "
"*arg*.  If *visit* returns a non-zero value, then return it. Using this "
"macro, :c:member:`~PyTypeObject.tp_traverse` handlers look like::"
msgstr ""
"Якщо *o* не є ``NULL``, викличте зворотній виклик *visit* з аргументами *o* "
"і *arg*. Якщо *visit* повертає ненульове значення, поверніть його. За "
"допомогою цього макросу обробники :c:member:`~PyTypeObject.tp_traverse` "
"виглядають так:"

msgid ""
"The :c:member:`~PyTypeObject.tp_clear` handler must be of the :c:type:"
"`inquiry` type, or ``NULL`` if the object is immutable."
msgstr ""
"Обробник :c:member:`~PyTypeObject.tp_clear` має бути типу :c:type:`inquiry` "
"або ``NULL``, якщо об’єкт є незмінним."

msgid ""
"Drop references that may have created reference cycles.  Immutable objects "
"do not have to define this method since they can never directly create "
"reference cycles.  Note that the object must still be valid after calling "
"this method (don't just call :c:func:`Py_DECREF` on a reference).  The "
"collector will call this method if it detects that this object is involved "
"in a reference cycle."
msgstr ""
"Видалити посилання, які могли створити цикли посилань. Незмінні об’єкти не "
"повинні визначати цей метод, оскільки вони ніколи не можуть безпосередньо "
"створювати еталонні цикли. Зауважте, що об’єкт все ще має бути дійсним після "
"виклику цього методу (не просто викликайте :c:func:`Py_DECREF` за "
"посиланням). Збирач викличе цей метод, якщо виявить, що цей об’єкт бере "
"участь у еталонному циклі."

msgid "Controlling the Garbage Collector State"
msgstr "Контроль стану Garbage Collector"

msgid ""
"The C-API provides the following functions for controlling garbage "
"collection runs."
msgstr "C-API надає такі функції для керування виконанням збирання сміття."

msgid ""
"Perform a full garbage collection, if the garbage collector is enabled. "
"(Note that :func:`gc.collect` runs it unconditionally.)"
msgstr ""
"Виконати повне збирання сміття, якщо ввімкнено збирач сміття. (Зверніть "
"увагу, що :func:`gc.collect` запускає його безумовно.)"

msgid ""
"Returns the number of collected + unreachable objects which cannot be "
"collected. If the garbage collector is disabled or already collecting, "
"returns ``0`` immediately. Errors during garbage collection are passed to :"
"data:`sys.unraisablehook`. This function does not raise exceptions."
msgstr ""
"Повертає кількість зібраних + недосяжних об’єктів, які неможливо зібрати. "
"Якщо збирач сміття вимкнено або вже збирає, негайно повертає ``0``. Помилки "
"під час збирання сміття передаються до :data:`sys.unraisablehook`. Ця "
"функція не викликає винятків."

msgid ""
"Enable the garbage collector: similar to :func:`gc.enable`. Returns the "
"previous state, 0 for disabled and 1 for enabled."
msgstr ""
"Увімкніть збирач сміття: подібно до :func:`gc.enable`. Повертає попередній "
"стан, 0 для вимкнено та 1 для ввімкнено."

msgid ""
"Disable the garbage collector: similar to :func:`gc.disable`. Returns the "
"previous state, 0 for disabled and 1 for enabled."
msgstr ""
"Вимкнути збирач сміття: подібно до :func:`gc.disable`. Повертає попередній "
"стан, 0 для вимкнено та 1 для ввімкнено."

msgid ""
"Query the state of the garbage collector: similar to :func:`gc.isenabled`. "
"Returns the current state, 0 for disabled and 1 for enabled."
msgstr ""
"Запитайте стан збирача сміття: подібно до :func:`gc.isenabled`. Повертає "
"поточний стан, 0 для вимкнено та 1 для ввімкнено."
