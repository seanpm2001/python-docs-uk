# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:50+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Unicode Objects and Codecs"
msgstr "Об’єкти та кодеки Unicode"

msgid "Unicode Objects"
msgstr "Об'єкти Unicode"

msgid ""
"Since the implementation of :pep:`393` in Python 3.3, Unicode objects "
"internally use a variety of representations, in order to allow handling the "
"complete range of Unicode characters while staying memory efficient.  There "
"are special cases for strings where all code points are below 128, 256, or "
"65536; otherwise, code points must be below 1114112 (which is the full "
"Unicode range)."
msgstr ""
"З моменту впровадження :pep:`393` у Python 3.3 об’єкти Unicode внутрішньо "
"використовують різноманітні представлення, щоб дозволити обробку повного "
"діапазону символів Unicode, залишаючись ефективним для пам’яті. Існують "
"особливі випадки для рядків, де всі кодові точки нижчі за 128, 256 або "
"65536; інакше кодові точки повинні бути нижче 1114112 (що є повним "
"діапазоном Unicode)."

msgid ""
":c:expr:`Py_UNICODE*` and UTF-8 representations are created on demand and "
"cached in the Unicode object.  The :c:expr:`Py_UNICODE*` representation is "
"deprecated and inefficient."
msgstr ""

msgid ""
"Due to the transition between the old APIs and the new APIs, Unicode objects "
"can internally be in two states depending on how they were created:"
msgstr ""
"Завдяки переходу між старими і новими API об’єкти Unicode можуть внутрішньо "
"перебувати в двох станах залежно від того, як вони були створені:"

msgid ""
"\"canonical\" Unicode objects are all objects created by a non-deprecated "
"Unicode API.  They use the most efficient representation allowed by the "
"implementation."
msgstr ""
"\"Канонічні\" об’єкти Unicode — це всі об’єкти, створені за допомогою API "
"Unicode, який не підтримується. Вони використовують найбільш ефективне "
"представлення, дозволене реалізацією."

msgid ""
"\"legacy\" Unicode objects have been created through one of the deprecated "
"APIs (typically :c:func:`PyUnicode_FromUnicode`) and only bear the :c:expr:"
"`Py_UNICODE*` representation; you will have to call :c:func:"
"`PyUnicode_READY` on them before calling any other API."
msgstr ""

msgid ""
"The \"legacy\" Unicode object will be removed in Python 3.12 with deprecated "
"APIs. All Unicode objects will be \"canonical\" since then. See :pep:`623` "
"for more information."
msgstr ""
"\"Застарілий\" об’єкт Unicode буде видалено в Python 3.12 із застарілими "
"API. Відтоді всі об’єкти Unicode будуть \"канонічними\". Перегляньте :pep:"
"`623` для отримання додаткової інформації."

msgid "Unicode Type"
msgstr "Тип Unicode"

msgid ""
"These are the basic Unicode object types used for the Unicode implementation "
"in Python:"
msgstr ""
"Ось основні типи об’єктів Unicode, які використовуються для реалізації "
"Unicode в Python:"

msgid ""
"These types are typedefs for unsigned integer types wide enough to contain "
"characters of 32 bits, 16 bits and 8 bits, respectively.  When dealing with "
"single Unicode characters, use :c:type:`Py_UCS4`."
msgstr ""
"Ці типи є визначеннями типів для беззнакових цілих типів, достатньо широких, "
"щоб містити символи 32 біти, 16 бітів і 8 бітів відповідно. При роботі з "
"окремими символами Unicode використовуйте :c:type:`Py_UCS4`."

msgid ""
"This is a typedef of :c:expr:`wchar_t`, which is a 16-bit type or 32-bit "
"type depending on the platform."
msgstr ""

msgid ""
"In previous versions, this was a 16-bit type or a 32-bit type depending on "
"whether you selected a \"narrow\" or \"wide\" Unicode version of Python at "
"build time."
msgstr ""
"У попередніх версіях це був 16-розрядний або 32-розрядний тип залежно від "
"того, чи ви вибрали \"вузьку\" чи \"широку\" версію Unicode Python під час "
"збирання."

msgid ""
"These subtypes of :c:type:`PyObject` represent a Python Unicode object.  In "
"almost all cases, they shouldn't be used directly, since all API functions "
"that deal with Unicode objects take and return :c:type:`PyObject` pointers."
msgstr ""
"Ці підтипи :c:type:`PyObject` представляють об’єкт Python Unicode. Майже у "
"всіх випадках їх не слід використовувати напряму, оскільки всі функції API, "
"які працюють з об’єктами Unicode, приймають і повертають покажчики :c:type:"
"`PyObject`."

msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python Unicode type.  "
"It is exposed to Python code as ``str``."
msgstr ""
"Цей екземпляр :c:type:`PyTypeObject` представляє тип Python Unicode. Він "
"доступний коду Python як ``str``."

msgid ""
"The following APIs are C macros and static inlined functions for fast checks "
"and access to internal read-only data of Unicode objects:"
msgstr ""

msgid ""
"Return true if the object *o* is a Unicode object or an instance of a "
"Unicode subtype.  This function always succeeds."
msgstr ""
"Повертає true, якщо об’єкт *o* є об’єктом Unicode або екземпляром підтипу "
"Unicode. Ця функція завжди успішна."

msgid ""
"Return true if the object *o* is a Unicode object, but not an instance of a "
"subtype.  This function always succeeds."
msgstr ""
"Повертає true, якщо об’єкт *o* є об’єктом Unicode, але не екземпляром "
"підтипу. Ця функція завжди успішна."

msgid ""
"Ensure the string object *o* is in the \"canonical\" representation.  This "
"is required before using any of the access macros described below."
msgstr ""
"Переконайтеся, що рядковий об’єкт *o* знаходиться в \"канонічному\" "
"представленні. Це необхідно зробити перед використанням будь-якого з "
"описаних нижче макросів доступу."

msgid ""
"Returns ``0`` on success and ``-1`` with an exception set on failure, which "
"in particular happens if memory allocation fails."
msgstr ""
"Повертає ``0`` у разі успіху та ``-1`` з винятком, встановленим у випадку "
"невдачі, що, зокрема, трапляється, якщо виділення пам’яті не вдається."

msgid "This API will be removed with :c:func:`PyUnicode_FromUnicode`."
msgstr "Цей API буде видалено за допомогою :c:func:`PyUnicode_FromUnicode`."

msgid ""
"Return the length of the Unicode string, in code points.  *o* has to be a "
"Unicode object in the \"canonical\" representation (not checked)."
msgstr ""
"Повертає довжину рядка Юнікод у кодових точках. *o* має бути об’єктом "
"Unicode у \"канонічному\" представленні (не позначено)."

msgid ""
"Return a pointer to the canonical representation cast to UCS1, UCS2 or UCS4 "
"integer types for direct character access.  No checks are performed if the "
"canonical representation has the correct character size; use :c:func:"
"`PyUnicode_KIND` to select the right macro.  Make sure :c:func:"
"`PyUnicode_READY` has been called before accessing this."
msgstr ""
"Повертайте вказівник на канонічне представлення, перетворене на цілі типи "
"UCS1, UCS2 або UCS4 для прямого доступу до символів. Перевірки не "
"виконуються, якщо канонічне представлення має правильний розмір символів; "
"використовуйте :c:func:`PyUnicode_KIND`, щоб вибрати правильний макрос. "
"Переконайтеся, що :c:func:`PyUnicode_READY` викликано перед тим, як отримати "
"доступ до цього."

msgid "Return values of the :c:func:`PyUnicode_KIND` macro."
msgstr "Повертає значення макросу :c:func:`PyUnicode_KIND`."

msgid "``PyUnicode_WCHAR_KIND`` is deprecated."
msgstr "``PyUnicode_WCHAR_KIND`` застаріло."

msgid ""
"Return one of the PyUnicode kind constants (see above) that indicate how "
"many bytes per character this Unicode object uses to store its data.  *o* "
"has to be a Unicode object in the \"canonical\" representation (not checked)."
msgstr ""
"Повертає одну з констант типу PyUnicode (див. вище), яка вказує, скільки "
"байтів на символ цей об’єкт Unicode використовує для зберігання своїх даних. "
"*o* має бути об’єктом Unicode у \"канонічному\" представленні (не позначено)."

msgid ""
"Return a void pointer to the raw Unicode buffer.  *o* has to be a Unicode "
"object in the \"canonical\" representation (not checked)."
msgstr ""
"Повертає вказівник недійсності на необроблений буфер Unicode. *o* має бути "
"об’єктом Unicode у \"канонічному\" представленні (не позначено)."

msgid ""
"Write into a canonical representation *data* (as obtained with :c:func:"
"`PyUnicode_DATA`).  This function performs no sanity checks, and is intended "
"for usage in loops.  The caller should cache the *kind* value and *data* "
"pointer as obtained from other calls.  *index* is the index in the string "
"(starts at 0) and *value* is the new code point value which should be "
"written to that location."
msgstr ""

msgid ""
"Read a code point from a canonical representation *data* (as obtained with :"
"c:func:`PyUnicode_DATA`).  No checks or ready calls are performed."
msgstr ""
"Прочитайте кодову точку з канонічного представлення *data* (отриманого за "
"допомогою :c:func:`PyUnicode_DATA`). Перевірки чи готові виклики не "
"виконуються."

msgid ""
"Read a character from a Unicode object *o*, which must be in the "
"\"canonical\" representation.  This is less efficient than :c:func:"
"`PyUnicode_READ` if you do multiple consecutive reads."
msgstr ""
"Прочитати символ з об’єкта Unicode *o*, який має бути в \"канонічному\" "
"представленні. Це менш ефективно, ніж :c:func:`PyUnicode_READ`, якщо ви "
"виконуєте кілька послідовних читань."

msgid ""
"Return the maximum code point that is suitable for creating another string "
"based on *o*, which must be in the \"canonical\" representation.  This is "
"always an approximation but more efficient than iterating over the string."
msgstr ""
"Повертає максимальну кодову точку, придатну для створення іншого рядка на "
"основі *o*, який має бути в \"канонічному\" представленні. Це завжди "
"наближення, але ефективніше, ніж ітерація по рядку."

msgid ""
"Return the size of the deprecated :c:type:`Py_UNICODE` representation, in "
"code units (this includes surrogate pairs as 2 units).  *o* has to be a "
"Unicode object (not checked)."
msgstr ""
"Повертає розмір застарілого представлення :c:type:`Py_UNICODE` в одиницях "
"коду (це включає сурогатні пари як 2 одиниці). *o* має бути об’єктом Unicode "
"(не позначено)."

msgid ""
"Part of the old-style Unicode API, please migrate to using :c:func:"
"`PyUnicode_GET_LENGTH`."
msgstr ""
"Частина старого стилю Unicode API, будь ласка, перейдіть на використання :c:"
"func:`PyUnicode_GET_LENGTH`."

msgid ""
"Return the size of the deprecated :c:type:`Py_UNICODE` representation in "
"bytes.  *o* has to be a Unicode object (not checked)."
msgstr ""
"Повертає розмір застарілого представлення :c:type:`Py_UNICODE` в байтах. *o* "
"має бути об’єктом Unicode (не позначено)."

msgid ""
"Return a pointer to a :c:type:`Py_UNICODE` representation of the object.  "
"The returned buffer is always terminated with an extra null code point.  It "
"may also contain embedded null code points, which would cause the string to "
"be truncated when used in most C functions.  The ``AS_DATA`` form casts the "
"pointer to :c:expr:`const char *`.  The *o* argument has to be a Unicode "
"object (not checked)."
msgstr ""

msgid ""
"This function is now inefficient -- because in many cases the :c:type:"
"`Py_UNICODE` representation does not exist and needs to be created -- and "
"can fail (return ``NULL`` with an exception set).  Try to port the code to "
"use the new :c:func:`PyUnicode_nBYTE_DATA` macros or use :c:func:"
"`PyUnicode_WRITE` or :c:func:`PyUnicode_READ`."
msgstr ""

msgid ""
"Part of the old-style Unicode API, please migrate to using the :c:func:"
"`PyUnicode_nBYTE_DATA` family of macros."
msgstr ""
"Частина API старого стилю Unicode, будь ласка, перейдіть на використання "
"сімейства макросів :c:func:`PyUnicode_nBYTE_DATA`."

msgid ""
"Return ``1`` if the string is a valid identifier according to the language "
"definition, section :ref:`identifiers`. Return ``0`` otherwise."
msgstr ""
"Повертає ``1``, якщо рядок є дійсним ідентифікатором відповідно до "
"визначення мови, розділ :ref:`identifiers`. Інакше поверніть ``0``."

msgid ""
"The function does not call :c:func:`Py_FatalError` anymore if the string is "
"not ready."
msgstr ""
"Функція більше не викликає :c:func:`Py_FatalError`, якщо рядок не готовий."

msgid "Unicode Character Properties"
msgstr "Властивості символів Unicode"

msgid ""
"Unicode provides many different character properties. The most often needed "
"ones are available through these macros which are mapped to C functions "
"depending on the Python configuration."
msgstr ""
"Unicode надає багато різних властивостей символів. Найпотрібніші з них "
"доступні через ці макроси, які зіставляються з функціями C залежно від "
"конфігурації Python."

msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a whitespace character."
msgstr "Повертає \"1\" або \"0\" залежно від того, чи *ch* є пробілом."

msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a lowercase character."
msgstr ""
"Повертає \"1\" або \"0\" залежно від того, чи *ch* є символом нижнього "
"регістру."

msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an uppercase character."
msgstr ""
"Повертає ``1`` або ``0`` залежно від того, чи *ch* є символом у верхньому "
"регістрі."

msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a titlecase character."
msgstr ""
"Повертає ``1`` або ``0`` залежно від того, чи *ch* є символом заголовка."

msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a linebreak character."
msgstr ""
"Повертає \"1\" або \"0\" залежно від того, чи є *ch* символом розриву рядка."

msgid "Return ``1`` or ``0`` depending on whether *ch* is a decimal character."
msgstr ""
"Повертає \"1\" або \"0\" залежно від того, чи є *ch* десятковим символом."

msgid "Return ``1`` or ``0`` depending on whether *ch* is a digit character."
msgstr "Повертає \"1\" або \"0\" залежно від того, чи є *ch* символом цифри."

msgid "Return ``1`` or ``0`` depending on whether *ch* is a numeric character."
msgstr ""
"Повертає \"1\" або \"0\" залежно від того, чи є *ch* цифровим символом."

msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphabetic character."
msgstr "Повертає \"1\" або \"0\" залежно від того, чи *ch* є буквою."

msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is an alphanumeric character."
msgstr ""
"Повертає \"1\" або \"0\" залежно від того, чи є *ch* буквено-цифровим "
"символом."

msgid ""
"Return ``1`` or ``0`` depending on whether *ch* is a printable character. "
"Nonprintable characters are those characters defined in the Unicode "
"character database as \"Other\" or \"Separator\", excepting the ASCII space "
"(0x20) which is considered printable.  (Note that printable characters in "
"this context are those which should not be escaped when :func:`repr` is "
"invoked on a string. It has no bearing on the handling of strings written "
"to :data:`sys.stdout` or :data:`sys.stderr`.)"
msgstr ""
"Повертає \"1\" або \"0\" залежно від того, чи є *ch* символом для друку. "
"Символи, що не друкуються, — це символи, визначені в базі даних символів "
"Unicode як \"Інші\" або \"Розділювачі\", за винятком пробілу ASCII (0x20), "
"який вважається придатним для друку. (Зауважте, що друковані символи в цьому "
"контексті – це ті символи, які не слід екранувати, коли :func:`repr` "
"викликається в рядку. Це не впливає на обробку рядків, записаних у :data:"
"`sys.stdout` або :data:`sys.stderr`.)"

msgid "These APIs can be used for fast direct character conversions:"
msgstr ""
"Ці API можна використовувати для швидкого прямого перетворення символів:"

msgid "Return the character *ch* converted to lower case."
msgstr "Повертає символ *ch*, перетворений на нижній регістр."

msgid "This function uses simple case mappings."
msgstr "Ця функція використовує прості відображення регістру."

msgid "Return the character *ch* converted to upper case."
msgstr "Повертає символ *ch*, перетворений у верхній регістр."

msgid "Return the character *ch* converted to title case."
msgstr "Повертає символ *ch*, перетворений на регістр заголовка."

msgid ""
"Return the character *ch* converted to a decimal positive integer.  Return "
"``-1`` if this is not possible.  This macro does not raise exceptions."
msgstr ""
"Повертає символ *ch*, перетворений на десяткове позитивне ціле число. "
"Поверніть ``-1``, якщо це неможливо. Цей макрос не створює винятків."

msgid ""
"Return the character *ch* converted to a single digit integer. Return ``-1`` "
"if this is not possible.  This macro does not raise exceptions."
msgstr ""
"Повертає символ *ch*, перетворений на однозначне ціле число. Поверніть "
"``-1``, якщо це неможливо. Цей макрос не створює винятків."

msgid ""
"Return the character *ch* converted to a double. Return ``-1.0`` if this is "
"not possible.  This macro does not raise exceptions."
msgstr ""
"Повертає символ *ch*, перетворений на подвійну. Поверніть ``-1.0``, якщо це "
"неможливо. Цей макрос не створює винятків."

msgid "These APIs can be used to work with surrogates:"
msgstr "Ці API можна використовувати для роботи із сурогатами:"

msgid "Check if *ch* is a surrogate (``0xD800 <= ch <= 0xDFFF``)."
msgstr "Перевірте, чи *ch* є сурогатом (``0xD800 <= ch <= 0xDFFF``)."

msgid "Check if *ch* is a high surrogate (``0xD800 <= ch <= 0xDBFF``)."
msgstr "Перевірте, чи *ch* є високим сурогатом (``0xD800 <= ch <= 0xDBFF``)."

msgid "Check if *ch* is a low surrogate (``0xDC00 <= ch <= 0xDFFF``)."
msgstr "Перевірте, чи *ch* є низьким сурогатом (``0xDC00 <= ch <= 0xDFFF``)."

msgid ""
"Join two surrogate characters and return a single Py_UCS4 value. *high* and "
"*low* are respectively the leading and trailing surrogates in a surrogate "
"pair."
msgstr ""
"Об’єднайте два сурогатних символи та поверніть одне значення Py_UCS4. "
"*високий* і *низький* є відповідно початковими та кінцевими сурогатами в "
"сурогатній парі."

msgid "Creating and accessing Unicode strings"
msgstr "Створення та доступ до рядків Unicode"

msgid ""
"To create Unicode objects and access their basic sequence properties, use "
"these APIs:"
msgstr ""
"Щоб створити об’єкти Unicode та отримати доступ до їхніх основних "
"властивостей послідовності, використовуйте ці API:"

msgid ""
"Create a new Unicode object.  *maxchar* should be the true maximum code "
"point to be placed in the string.  As an approximation, it can be rounded up "
"to the nearest value in the sequence 127, 255, 65535, 1114111."
msgstr ""
"Створіть новий об’єкт Unicode. *maxchar* має бути справжньою максимальною "
"кодовою точкою, яка буде розміщена в рядку. Приблизно його можна округлити "
"до найближчого значення в послідовності 127, 255, 65535, 1114111."

msgid ""
"This is the recommended way to allocate a new Unicode object.  Objects "
"created using this function are not resizable."
msgstr ""
"Це рекомендований спосіб виділення нового об’єкта Unicode. Розмір об’єктів, "
"створених за допомогою цієї функції, неможливо змінити."

msgid ""
"Create a new Unicode object with the given *kind* (possible values are :c:"
"macro:`PyUnicode_1BYTE_KIND` etc., as returned by :c:func:"
"`PyUnicode_KIND`).  The *buffer* must point to an array of *size* units of "
"1, 2 or 4 bytes per character, as given by the kind."
msgstr ""
"Створіть новий об’єкт Unicode із заданим *kind* (можливі значення: :c:macro:"
"`PyUnicode_1BYTE_KIND` тощо, як повертає :c:func:`PyUnicode_KIND`). *Буфер* "
"має вказувати на масив одиниць *розміру* по 1, 2 або 4 байти на символ, як "
"задано типом."

msgid ""
"If necessary, the input *buffer* is copied and transformed into the "
"canonical representation.  For example, if the *buffer* is a UCS4 string (:c:"
"macro:`PyUnicode_4BYTE_KIND`) and it consists only of codepoints in the UCS1 "
"range, it will be transformed into UCS1 (:c:macro:`PyUnicode_1BYTE_KIND`)."
msgstr ""

msgid ""
"Create a Unicode object from the char buffer *u*.  The bytes will be "
"interpreted as being UTF-8 encoded.  The buffer is copied into the new "
"object. If the buffer is not ``NULL``, the return value might be a shared "
"object, i.e. modification of the data is not allowed."
msgstr ""
"Створіть об’єкт Unicode з буфера char *u*. Байти інтерпретуватимуться як "
"закодовані в UTF-8. Буфер копіюється в новий об'єкт. Якщо буфер не ``NULL``, "
"значення, що повертається, може бути спільним об’єктом, тобто модифікація "
"даних не дозволяється."

msgid ""
"If *u* is ``NULL``, this function behaves like :c:func:"
"`PyUnicode_FromUnicode` with the buffer set to ``NULL``.  This usage is "
"deprecated in favor of :c:func:`PyUnicode_New`, and will be removed in "
"Python 3.12."
msgstr ""
"Якщо *u* має значення ``NULL``, ця функція поводиться як :c:func:"
"`PyUnicode_FromUnicode` з буфером, встановленим на ``NULL``. Це використання "
"застаріло на користь :c:func:`PyUnicode_New` і буде видалено в Python 3.12."

msgid ""
"Create a Unicode object from a UTF-8 encoded null-terminated char buffer *u*."
msgstr ""
"Створіть об’єкт Юнікод із буфера символів *u* із кодуванням UTF-8 із "
"закінченням нулем."

msgid ""
"Take a C :c:func:`printf`\\ -style *format* string and a variable number of "
"arguments, calculate the size of the resulting Python Unicode string and "
"return a string with the values formatted into it.  The variable arguments "
"must be C types and must correspond exactly to the format characters in the "
"*format* ASCII-encoded string. The following format characters are allowed:"
msgstr ""
"Візьміть рядок C :c:func:`printf`\\ -style *format* і змінну кількість "
"аргументів, обчисліть розмір результуючого рядка Python Unicode та поверніть "
"рядок із значеннями, відформатованими в ньому. Змінні аргументи мають бути "
"типу C і точно відповідати символам формату в рядку *format* у кодуванні "
"ASCII. Дозволяються такі символи формату:"

msgid "Format Characters"
msgstr "Формат символів"

msgid "Type"
msgstr "Тип"

msgid "Comment"
msgstr "коментар"

msgid ":attr:`%%`"
msgstr ":attr:`%%`"

msgid "*n/a*"
msgstr "*немає*"

msgid "The literal % character."
msgstr "Літеральний символ %."

msgid ":attr:`%c`"
msgstr ":attr:`%c`"

msgid "int"
msgstr "внутр"

msgid "A single character, represented as a C int."
msgstr "Один символ, представлений як C int."

msgid ":attr:`%d`"
msgstr ":attr:`%d`"

msgid "Equivalent to ``printf(\"%d\")``. [1]_"
msgstr "Еквівалент ``printf(\"%d\")``. [1]_"

msgid ":attr:`%u`"
msgstr ":attr:`%u`"

msgid "unsigned int"
msgstr "unsigned int"

msgid "Equivalent to ``printf(\"%u\")``. [1]_"
msgstr "Еквівалент ``printf(\"%u\")``. [1]_"

msgid ":attr:`%ld`"
msgstr ":attr:`%ld`"

msgid "long"
msgstr "довгота"

msgid "Equivalent to ``printf(\"%ld\")``. [1]_"
msgstr "Еквівалент ``printf(\"%ld\")``. [1]_"

msgid ":attr:`%li`"
msgstr ":attr:`%li`"

msgid "Equivalent to ``printf(\"%li\")``. [1]_"
msgstr "Еквівалент ``printf(\"%li\")``. [1]_"

msgid ":attr:`%lu`"
msgstr ":attr:`%lu`"

msgid "unsigned long"
msgstr "беззнаковий довгий"

msgid "Equivalent to ``printf(\"%lu\")``. [1]_"
msgstr "Еквівалент ``printf(\"%lu\")``. [1]_"

msgid ":attr:`%lld`"
msgstr ":attr:`%lld`"

msgid "long long"
msgstr "довгий довгий"

msgid "Equivalent to ``printf(\"%lld\")``. [1]_"
msgstr "Еквівалент ``printf(\"%lld\")``. [1]_"

msgid ":attr:`%lli`"
msgstr ":attr:`%lli`"

msgid "Equivalent to ``printf(\"%lli\")``. [1]_"
msgstr "Еквівалент ``printf(\"%lli\")``. [1]_"

msgid ":attr:`%llu`"
msgstr ":attr:`%llu`"

msgid "unsigned long long"
msgstr "без знака довгий довгий"

msgid "Equivalent to ``printf(\"%llu\")``. [1]_"
msgstr "Еквівалент ``printf(\"%llu\")``. [1]_"

msgid ":attr:`%zd`"
msgstr ":attr:`%zd`"

msgid ":c:type:`\\ Py_ssize_t`"
msgstr ":c:type:`\\ Py_ssize_t`"

msgid "Equivalent to ``printf(\"%zd\")``. [1]_"
msgstr "Еквівалент ``printf(\"%zd\")``. [1]_"

msgid ":attr:`%zi`"
msgstr ":attr:`%zi`"

msgid "Equivalent to ``printf(\"%zi\")``. [1]_"
msgstr "Еквівалент ``printf(\"%zi\")``. [1]_"

msgid ":attr:`%zu`"
msgstr ":attr:`%zu`"

msgid "size_t"
msgstr "size_t"

msgid "Equivalent to ``printf(\"%zu\")``. [1]_"
msgstr "Еквівалент ``printf(\"%zu\")``. [1]_"

msgid ":attr:`%i`"
msgstr ":attr:`%i`"

msgid "Equivalent to ``printf(\"%i\")``. [1]_"
msgstr "Еквівалент ``printf(\"%i\")``. [1]_"

msgid ":attr:`%x`"
msgstr ":attr:`%x`"

msgid "Equivalent to ``printf(\"%x\")``. [1]_"
msgstr "Еквівалент ``printf(\"%x\")``. [1]_"

msgid ":attr:`%s`"
msgstr ":attr:`%s`"

msgid "const char\\*"
msgstr "const char\\*"

msgid "A null-terminated C character array."
msgstr "Масив символів C із закінченням нулем."

msgid ":attr:`%p`"
msgstr ":attr:`%p`"

msgid "const void\\*"
msgstr "const void\\*"

msgid ""
"The hex representation of a C pointer. Mostly equivalent to "
"``printf(\"%p\")`` except that it is guaranteed to start with the literal "
"``0x`` regardless of what the platform's ``printf`` yields."
msgstr ""
"Шістнадцяткове представлення покажчика C. Здебільшого еквівалентний "
"``printf(\"%p\")`` за винятком того, що він гарантовано починається з "
"літералу ``0x`` незалежно від того, що дає ``printf`` платформи."

msgid ":attr:`%A`"
msgstr ":attr:`%A`"

msgid "PyObject\\*"
msgstr "PyObject\\*"

msgid "The result of calling :func:`ascii`."
msgstr "Результат виклику :func:`ascii`."

msgid ":attr:`%U`"
msgstr ":attr:`%U`"

msgid "A Unicode object."
msgstr "Об'єкт Unicode."

msgid ":attr:`%V`"
msgstr ":attr:`%V`"

msgid "PyObject\\*, const char\\*"
msgstr "PyObject\\*, const char\\*"

msgid ""
"A Unicode object (which may be ``NULL``) and a null-terminated C character "
"array as a second parameter (which will be used, if the first parameter is "
"``NULL``)."
msgstr ""
"Об’єкт Unicode (який може бути ``NULL``) і масив символів C із нульовим "
"закінченням як другий параметр (який використовуватиметься, якщо перший "
"параметр ``NULL``)."

msgid ":attr:`%S`"
msgstr ":attr:`%S`"

msgid "The result of calling :c:func:`PyObject_Str`."
msgstr "Результат виклику :c:func:`PyObject_Str`."

msgid ":attr:`%R`"
msgstr ":attr:`%R`"

msgid "The result of calling :c:func:`PyObject_Repr`."
msgstr "Результат виклику :c:func:`PyObject_Repr`."

msgid ""
"An unrecognized format character causes all the rest of the format string to "
"be copied as-is to the result string, and any extra arguments discarded."
msgstr ""
"Нерозпізнаний символ формату спричиняє копіювання всієї решти рядка формату "
"як є до рядка результату, а всі додаткові аргументи відкидаються."

msgid ""
"The width formatter unit is number of characters rather than bytes. The "
"precision formatter unit is number of bytes for ``\"%s\"`` and ``\"%V\"`` "
"(if the ``PyObject*`` argument is ``NULL``), and a number of characters for "
"``\"%A\"``, ``\"%U\"``, ``\"%S\"``, ``\"%R\"`` and ``\"%V\"`` (if the "
"``PyObject*`` argument is not ``NULL``)."
msgstr ""
"Одиницею форматування ширини є кількість символів, а не байти. Одиницею "
"точного форматування є кількість байтів для ``\"%s\"`` і ``\"%V\"`` (якщо "
"аргумент ``PyObject*`` має значення ``NULL``), і кількість символів для` "
"`\"%A\"``, ``\"%U\"``, ``\"%S\"``, ``\"%R\"`` і ``\"%V\"`` (якщо "
"``PyObject*`` аргумент не є ``NULL``)."

msgid ""
"For integer specifiers (d, u, ld, li, lu, lld, lli, llu, zd, zi, zu, i, x): "
"the 0-conversion flag has effect even when a precision is given."
msgstr ""
"Для специфікаторів цілих чисел (d, u, ld, li, lu, lld, lli, llu, zd, zi, zu, "
"i, x): прапор 0-конверсії діє, навіть якщо задано точність."

msgid "Support for ``\"%lld\"`` and ``\"%llu\"`` added."
msgstr "Додано підтримку ``\"%lld\"`` і ``\"%llu\"``."

msgid "Support for ``\"%li\"``, ``\"%lli\"`` and ``\"%zi\"`` added."
msgstr "Додано підтримку ``\"%li\"``, ``\"%lli\"`` і ``\"%zi\"``."

msgid ""
"Support width and precision formatter for ``\"%s\"``, ``\"%A\"``, "
"``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"`` added."
msgstr ""
"Підтримка ширини та точного форматування для ``\"%s\"``, ``\"%A\"``, "
"``\"%U\"``, ``\"%V\"``, ``\"%S\"``, ``\"%R\"`` додано."

msgid ""
"Identical to :c:func:`PyUnicode_FromFormat` except that it takes exactly two "
"arguments."
msgstr ""
"Ідентичний :c:func:`PyUnicode_FromFormat` за винятком того, що він приймає "
"рівно два аргументи."

msgid "Decode an encoded object *obj* to a Unicode object."
msgstr "Декодуйте закодований об’єкт *obj* в об’єкт Unicode."

msgid ""
":class:`bytes`, :class:`bytearray` and other :term:`bytes-like objects "
"<bytes-like object>` are decoded according to the given *encoding* and using "
"the error handling defined by *errors*. Both can be ``NULL`` to have the "
"interface use the default values (see :ref:`builtincodecs` for details)."
msgstr ""
":class:`bytes`, :class:`bytearray` та інші :term:`bytes-подібні об’єкти "
"<bytes-like object>` декодуються відповідно до заданого *кодування* та з "
"використанням обробки помилок, визначеної *errors*. Обидва можуть бути "
"``NULL``, щоб інтерфейс використовував значення за замовчуванням (дивіться :"
"ref:`builtincodecs` для деталей)."

msgid ""
"All other objects, including Unicode objects, cause a :exc:`TypeError` to be "
"set."
msgstr ""
"Усі інші об’єкти, включно з об’єктами Unicode, викликають встановлення :exc:"
"`TypeError`."

msgid ""
"The API returns ``NULL`` if there was an error.  The caller is responsible "
"for decref'ing the returned objects."
msgstr ""
"API повертає ``NULL``, якщо сталася помилка. Виклик відповідає за "
"декодування повернутих об'єктів."

msgid "Return the length of the Unicode object, in code points."
msgstr "Повертає довжину об’єкта Юнікод у кодових точках."

msgid ""
"Copy characters from one Unicode object into another.  This function "
"performs character conversion when necessary and falls back to :c:func:"
"`memcpy` if possible.  Returns ``-1`` and sets an exception on error, "
"otherwise returns the number of copied characters."
msgstr ""
"Копіювати символи з одного об’єкта Unicode в інший. Ця функція виконує "
"перетворення символів, якщо це необхідно, і повертається до :c:func:"
"`memcpy`, якщо це можливо. Повертає ``-1`` і встановлює виняток у випадку "
"помилки, інакше повертає кількість скопійованих символів."

msgid ""
"Fill a string with a character: write *fill_char* into ``unicode[start:"
"start+length]``."
msgstr ""
"Заповніть рядок символом: напишіть *fill_char* у ``unicode[start:"
"start+length]``."

msgid ""
"Fail if *fill_char* is bigger than the string maximum character, or if the "
"string has more than 1 reference."
msgstr ""
"Помилка, якщо *fill_char* перевищує максимальний символ рядка або якщо рядок "
"має більше ніж 1 посилання."

msgid ""
"Return the number of written character, or return ``-1`` and raise an "
"exception on error."
msgstr ""
"Повертає номер написаного символу або повертає ``-1`` і викликає виняток у "
"разі помилки."

msgid ""
"Write a character to a string.  The string must have been created through :c:"
"func:`PyUnicode_New`.  Since Unicode strings are supposed to be immutable, "
"the string must not be shared, or have been hashed yet."
msgstr ""
"Записати символ у рядок. Рядок має бути створено через :c:func:"
"`PyUnicode_New`. Оскільки рядки Юнікоду мають бути незмінними, рядок не "
"можна надавати спільно або хешувати."

msgid ""
"This function checks that *unicode* is a Unicode object, that the index is "
"not out of bounds, and that the object can be modified safely (i.e. that it "
"its reference count is one)."
msgstr ""
"Ця функція перевіряє, що *unicode* є об’єктом Unicode, що індекс не виходить "
"за межі та чи можна безпечно змінювати об’єкт (тобто чи кількість посилань "
"дорівнює одиниці)."

msgid ""
"Read a character from a string.  This function checks that *unicode* is a "
"Unicode object and the index is not out of bounds, in contrast to :c:func:"
"`PyUnicode_READ_CHAR`, which performs no error checking."
msgstr ""

msgid ""
"Return a substring of *str*, from character index *start* (included) to "
"character index *end* (excluded).  Negative indices are not supported."
msgstr ""
"Повертає підрядок *str* від символьного індексу *start* (включено) до "
"символьного індексу *end* (виключено). Негативні індекси не підтримуються."

msgid ""
"Copy the string *u* into a UCS4 buffer, including a null character, if "
"*copy_null* is set.  Returns ``NULL`` and sets an exception on error (in "
"particular, a :exc:`SystemError` if *buflen* is smaller than the length of "
"*u*).  *buffer* is returned on success."
msgstr ""
"Скопіюйте рядок *u* у буфер UCS4, включаючи нульовий символ, якщо "
"встановлено *copy_null*. Повертає ``NULL`` і встановлює виняток у випадку "
"помилки (зокрема, :exc:`SystemError`, якщо *buflen* менший за довжину *u*). "
"*buffer* повертається в разі успіху."

msgid ""
"Copy the string *u* into a new UCS4 buffer that is allocated using :c:func:"
"`PyMem_Malloc`.  If this fails, ``NULL`` is returned with a :exc:"
"`MemoryError` set.  The returned buffer always has an extra null code point "
"appended."
msgstr ""
"Скопіюйте рядок *u* у новий буфер UCS4, який виділено за допомогою :c:func:"
"`PyMem_Malloc`. Якщо це не вдається, повертається ``NULL`` із набором :exc:"
"`MemoryError`. Повернений буфер завжди має додаткову нульову кодову точку."

msgid "Deprecated Py_UNICODE APIs"
msgstr "Застарілі API Py_UNICODE"

msgid ""
"These API functions are deprecated with the implementation of :pep:`393`. "
"Extension modules can continue using them, as they will not be removed in "
"Python 3.x, but need to be aware that their use can now cause performance "
"and memory hits."
msgstr ""
"Ці функції API застаріли з реалізацією :pep:`393`. Модулі розширення можуть "
"продовжувати використовувати їх, оскільки вони не будуть видалені в Python 3."
"x, але потрібно знати, що їхнє використання тепер може призвести до "
"погіршення продуктивності та пам’яті."

msgid ""
"Create a Unicode object from the Py_UNICODE buffer *u* of the given size. "
"*u* may be ``NULL`` which causes the contents to be undefined. It is the "
"user's responsibility to fill in the needed data.  The buffer is copied into "
"the new object."
msgstr ""
"Створіть об’єкт Unicode з буфера Py_UNICODE *u* заданого розміру. *u* може "
"бути ``NULL``, через що вміст буде невизначеним. Користувач несе "
"відповідальність за заповнення необхідних даних. Буфер копіюється в новий "
"об'єкт."

msgid ""
"If the buffer is not ``NULL``, the return value might be a shared object. "
"Therefore, modification of the resulting Unicode object is only allowed when "
"*u* is ``NULL``."
msgstr ""
"Якщо буфер не ``NULL``, повернуте значення може бути спільним об’єктом. "
"Таким чином, модифікація отриманого об’єкта Unicode дозволена лише тоді, "
"коли *u* має значення ``NULL``."

msgid ""
"If the buffer is ``NULL``, :c:func:`PyUnicode_READY` must be called once the "
"string content has been filled before using any of the access macros such "
"as :c:func:`PyUnicode_KIND`."
msgstr ""
"Якщо буфер має значення ``NULL``, :c:func:`PyUnicode_READY` потрібно "
"викликати після заповнення вмісту рядка перед використанням будь-якого "
"макросу доступу, наприклад :c:func:`PyUnicode_KIND`."

msgid ""
"Part of the old-style Unicode API, please migrate to using :c:func:"
"`PyUnicode_FromKindAndData`, :c:func:`PyUnicode_FromWideChar`, or :c:func:"
"`PyUnicode_New`."
msgstr ""
"Частина API Unicode старого стилю, перейдіть на використання :c:func:"
"`PyUnicode_FromKindAndData`, :c:func:`PyUnicode_FromWideChar` або :c:func:"
"`PyUnicode_New`."

msgid ""
"Return a read-only pointer to the Unicode object's internal :c:type:"
"`Py_UNICODE` buffer, or ``NULL`` on error. This will create the :c:expr:"
"`Py_UNICODE*` representation of the object if it is not yet available. The "
"buffer is always terminated with an extra null code point. Note that the "
"resulting :c:type:`Py_UNICODE` string may also contain embedded null code "
"points, which would cause the string to be truncated when used in most C "
"functions."
msgstr ""

msgid ""
"Part of the old-style Unicode API, please migrate to using :c:func:"
"`PyUnicode_AsUCS4`, :c:func:`PyUnicode_AsWideChar`, :c:func:"
"`PyUnicode_ReadChar` or similar new APIs."
msgstr ""
"Частина API старого стилю Unicode, перейдіть на використання :c:func:"
"`PyUnicode_AsUCS4`, :c:func:`PyUnicode_AsWideChar`, :c:func:"
"`PyUnicode_ReadChar` або подібних нових API."

msgid ""
"Like :c:func:`PyUnicode_AsUnicode`, but also saves the :c:func:`Py_UNICODE` "
"array length (excluding the extra null terminator) in *size*. Note that the "
"resulting :c:expr:`Py_UNICODE*` string may contain embedded null code "
"points, which would cause the string to be truncated when used in most C "
"functions."
msgstr ""

msgid ""
"Return the size of the deprecated :c:type:`Py_UNICODE` representation, in "
"code units (this includes surrogate pairs as 2 units)."
msgstr ""
"Повертає розмір застарілого представлення :c:type:`Py_UNICODE` в одиницях "
"коду (це включає сурогатні пари як 2 одиниці)."

msgid ""
"Copy an instance of a Unicode subtype to a new true Unicode object if "
"necessary. If *obj* is already a true Unicode object (not a subtype), return "
"the reference with incremented refcount."
msgstr ""
"Якщо необхідно, скопіюйте екземпляр підтипу Unicode до нового справжнього "
"об’єкта Unicode. Якщо *obj* вже є справжнім об’єктом Юнікод (а не підтипом), "
"поверніть посилання зі збільшеним числом посилань."

msgid ""
"Objects other than Unicode or its subtypes will cause a :exc:`TypeError`."
msgstr ""
"Об’єкти, відмінні від Unicode або його підтипів, викличуть :exc:`TypeError`."

msgid "Locale Encoding"
msgstr "Кодування мови"

msgid ""
"The current locale encoding can be used to decode text from the operating "
"system."
msgstr ""
"Поточне кодування мови можна використовувати для декодування тексту з "
"операційної системи."

msgid ""
"Decode a string from UTF-8 on Android and VxWorks, or from the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The decoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``.  *str* must end with a "
"null character but cannot contain embedded null characters."
msgstr ""
"Декодуйте рядок з UTF-8 на Android і VxWorks або з поточного кодування мови "
"на інших платформах. Підтримуваними обробниками помилок є ``\"strict\"`` і "
"``\"surrogateescape\"`` (:pep:`383`). Декодер використовує ``\"strict\"`` "
"обробник помилок, якщо *errors* має значення ``NULL``. *str* має "
"закінчуватися нульовим символом, але не може містити вбудовані нульові "
"символи."

msgid ""
"Use :c:func:`PyUnicode_DecodeFSDefaultAndSize` to decode a string from :c:"
"data:`Py_FileSystemDefaultEncoding` (the locale encoding read at Python "
"startup)."
msgstr ""
"Використовуйте :c:func:`PyUnicode_DecodeFSDefaultAndSize`, щоб декодувати "
"рядок із :c:data:`Py_FileSystemDefaultEncoding` (кодування локалі, яке "
"читається під час запуску Python)."

msgid "This function ignores the :ref:`Python UTF-8 Mode <utf8-mode>`."
msgstr "Ця функція ігнорує :ref:`Режим Python UTF-8 <utf8-mode>`."

msgid "The :c:func:`Py_DecodeLocale` function."
msgstr "Функція :c:func:`Py_DecodeLocale`."

msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, :c:func:"
"`Py_DecodeLocale` was used for the ``surrogateescape``, and the current "
"locale encoding was used for ``strict``."
msgstr ""
"Функція тепер також використовує поточне кодування мови для обробника "
"помилок ``surrogateescape``, за винятком Android. Раніше :c:func:"
"`Py_DecodeLocale` використовувався для ``surrogateescape``, а поточне "
"кодування мови використовувалося для ``strict``."

msgid ""
"Similar to :c:func:`PyUnicode_DecodeLocaleAndSize`, but compute the string "
"length using :c:func:`strlen`."
msgstr ""
"Подібно до :c:func:`PyUnicode_DecodeLocaleAndSize`, але обчислюйте довжину "
"рядка за допомогою :c:func:`strlen`."

msgid ""
"Encode a Unicode object to UTF-8 on Android and VxWorks, or to the current "
"locale encoding on other platforms. The supported error handlers are "
"``\"strict\"`` and ``\"surrogateescape\"`` (:pep:`383`). The encoder uses "
"``\"strict\"`` error handler if *errors* is ``NULL``. Return a :class:"
"`bytes` object. *unicode* cannot contain embedded null characters."
msgstr ""
"Закодуйте об’єкт Unicode до UTF-8 на Android і VxWorks або до поточного "
"кодування мови на інших платформах. Підтримуваними обробниками помилок є "
"``\"strict\"`` і ``\"surrogateescape\"`` (:pep:`383`). Кодер використовує "
"``\"strict\"`` обробник помилок, якщо *errors* має значення ``NULL``. "
"Повертає об’єкт :class:`bytes`. *unicode* не може містити вбудовані нульові "
"символи."

msgid ""
"Use :c:func:`PyUnicode_EncodeFSDefault` to encode a string to :c:data:"
"`Py_FileSystemDefaultEncoding` (the locale encoding read at Python startup)."
msgstr ""
"Використовуйте :c:func:`PyUnicode_EncodeFSDefault`, щоб закодувати рядок у :"
"c:data:`Py_FileSystemDefaultEncoding` (кодування локалі, яке читається під "
"час запуску Python)."

msgid "The :c:func:`Py_EncodeLocale` function."
msgstr "Функція :c:func:`Py_EncodeLocale`."

msgid ""
"The function now also uses the current locale encoding for the "
"``surrogateescape`` error handler, except on Android. Previously, :c:func:"
"`Py_EncodeLocale` was used for the ``surrogateescape``, and the current "
"locale encoding was used for ``strict``."
msgstr ""
"Функція тепер також використовує поточне кодування мови для обробника "
"помилок ``surrogateescape``, за винятком Android. Раніше :c:func:"
"`Py_EncodeLocale` використовувався для ``surrogateescape``, а поточне "
"кодування мови використовувалося для ``strict``."

msgid "File System Encoding"
msgstr "Кодування файлової системи"

msgid ""
"To encode and decode file names and other environment strings, :c:data:"
"`Py_FileSystemDefaultEncoding` should be used as the encoding, and :c:data:"
"`Py_FileSystemDefaultEncodeErrors` should be used as the error handler (:pep:"
"`383` and :pep:`529`). To encode file names to :class:`bytes` during "
"argument parsing, the ``\"O&\"`` converter should be used, passing :c:func:"
"`PyUnicode_FSConverter` as the conversion function:"
msgstr ""
"Для кодування та декодування імен файлів та інших рядків середовища слід "
"використовувати :c:data:`Py_FileSystemDefaultEncoding` як кодування, а :c:"
"data:`Py_FileSystemDefaultEncodeErrors` — як обробник помилок (:pep:`383` і :"
"pep:`529`). Щоб кодувати імена файлів у :class:`bytes` під час аналізу "
"аргументів, слід використовувати конвертер ``\"O&\"``, передаючи :c:func:"
"`PyUnicode_FSConverter` як функцію перетворення:"

msgid ""
"ParseTuple converter: encode :class:`str` objects -- obtained directly or "
"through the :class:`os.PathLike` interface -- to :class:`bytes` using :c:"
"func:`PyUnicode_EncodeFSDefault`; :class:`bytes` objects are output as-is. "
"*result* must be a :c:expr:`PyBytesObject*` which must be released when it "
"is no longer used."
msgstr ""

msgid "Accepts a :term:`path-like object`."
msgstr "Приймає :term:`path-like object`."

msgid ""
"To decode file names to :class:`str` during argument parsing, the ``\"O&\"`` "
"converter should be used, passing :c:func:`PyUnicode_FSDecoder` as the "
"conversion function:"
msgstr ""
"Щоб декодувати імена файлів у :class:`str` під час синтаксичного аналізу "
"аргументів, слід використовувати конвертер ``\"O&\"``, передаючи :c:func:"
"`PyUnicode_FSDecoder` як функцію перетворення:"

msgid ""
"ParseTuple converter: decode :class:`bytes` objects -- obtained either "
"directly or indirectly through the :class:`os.PathLike` interface -- to :"
"class:`str` using :c:func:`PyUnicode_DecodeFSDefaultAndSize`; :class:`str` "
"objects are output as-is. *result* must be a :c:expr:`PyUnicodeObject*` "
"which must be released when it is no longer used."
msgstr ""

msgid "Decode a string from the :term:`filesystem encoding and error handler`."
msgstr "Декодуйте рядок із :term:`filesystem encoding and error handler`."

msgid ""
"If :c:data:`Py_FileSystemDefaultEncoding` is not set, fall back to the "
"locale encoding."
msgstr ""
"Якщо :c:data:`Py_FileSystemDefaultEncoding` не встановлено, поверніться до "
"кодування мови."

msgid ""
":c:data:`Py_FileSystemDefaultEncoding` is initialized at startup from the "
"locale encoding and cannot be modified later. If you need to decode a string "
"from the current locale encoding, use :c:func:"
"`PyUnicode_DecodeLocaleAndSize`."
msgstr ""
":c:data:`Py_FileSystemDefaultEncoding` ініціалізується під час запуску з "
"кодування мови та не може бути змінено пізніше. Якщо вам потрібно декодувати "
"рядок із поточного кодування мови, використовуйте :c:func:"
"`PyUnicode_DecodeLocaleAndSize`."

msgid "Use :c:data:`Py_FileSystemDefaultEncodeErrors` error handler."
msgstr ""
"Використовуйте обробник помилок :c:data:`Py_FileSystemDefaultEncodeErrors`."

msgid ""
"Decode a null-terminated string from the :term:`filesystem encoding and "
"error handler`."
msgstr ""
"Декодуйте рядок із нульовим закінченням із :term:`filesystem encoding and "
"error handler`."

msgid ""
"Use :c:func:`PyUnicode_DecodeFSDefaultAndSize` if you know the string length."
msgstr ""
"Використовуйте :c:func:`PyUnicode_DecodeFSDefaultAndSize`, якщо вам відома "
"довжина рядка."

msgid ""
"Encode a Unicode object to :c:data:`Py_FileSystemDefaultEncoding` with the :"
"c:data:`Py_FileSystemDefaultEncodeErrors` error handler, and return :class:"
"`bytes`. Note that the resulting :class:`bytes` object may contain null "
"bytes."
msgstr ""
"Закодуйте об’єкт Юнікод у :c:data:`Py_FileSystemDefaultEncoding` за "
"допомогою обробника помилок :c:data:`Py_FileSystemDefaultEncodeErrors` і "
"поверніть :class:`bytes`. Зауважте, що отриманий об’єкт :class:`bytes` може "
"містити нульові байти."

msgid ""
":c:data:`Py_FileSystemDefaultEncoding` is initialized at startup from the "
"locale encoding and cannot be modified later. If you need to encode a string "
"to the current locale encoding, use :c:func:`PyUnicode_EncodeLocale`."
msgstr ""
":c:data:`Py_FileSystemDefaultEncoding` ініціалізується під час запуску з "
"кодування мови та не може бути змінено пізніше. Якщо вам потрібно закодувати "
"рядок до поточного кодування мови, використовуйте :c:func:"
"`PyUnicode_EncodeLocale`."

msgid "wchar_t Support"
msgstr "Підтримка wchar_t"

msgid ":c:expr:`wchar_t` support for platforms which support it:"
msgstr ""

msgid ""
"Create a Unicode object from the :c:expr:`wchar_t` buffer *w* of the given "
"*size*. Passing ``-1`` as the *size* indicates that the function must itself "
"compute the length, using wcslen. Return ``NULL`` on failure."
msgstr ""

msgid ""
"Copy the Unicode object contents into the :c:expr:`wchar_t` buffer *w*.  At "
"most *size* :c:expr:`wchar_t` characters are copied (excluding a possibly "
"trailing null termination character).  Return the number of :c:expr:"
"`wchar_t` characters copied or ``-1`` in case of an error.  Note that the "
"resulting :c:expr:`wchar_t*` string may or may not be null-terminated.  It "
"is the responsibility of the caller to make sure that the :c:expr:`wchar_t*` "
"string is null-terminated in case this is required by the application. Also, "
"note that the :c:expr:`wchar_t*` string might contain null characters, which "
"would cause the string to be truncated when used with most C functions."
msgstr ""

msgid ""
"Convert the Unicode object to a wide character string. The output string "
"always ends with a null character. If *size* is not ``NULL``, write the "
"number of wide characters (excluding the trailing null termination "
"character) into *\\*size*. Note that the resulting :c:expr:`wchar_t` string "
"might contain null characters, which would cause the string to be truncated "
"when used with most C functions. If *size* is ``NULL`` and the :c:expr:"
"`wchar_t*` string contains null characters a :exc:`ValueError` is raised."
msgstr ""

msgid ""
"Returns a buffer allocated by :c:func:`PyMem_Alloc` (use :c:func:"
"`PyMem_Free` to free it) on success. On error, returns ``NULL`` and "
"*\\*size* is undefined. Raises a :exc:`MemoryError` if memory allocation is "
"failed."
msgstr ""
"У разі успіху повертає буфер, виділений :c:func:`PyMem_Alloc` "
"(використовуйте :c:func:`PyMem_Free`, щоб звільнити його). У разі помилки "
"повертає ``NULL`` і *\\*size* не визначено. Викликає :exc:`MemoryError`, "
"якщо виділення пам’яті не вдалося."

msgid ""
"Raises a :exc:`ValueError` if *size* is ``NULL`` and the :c:expr:`wchar_t*` "
"string contains null characters."
msgstr ""

msgid "Built-in Codecs"
msgstr "Вбудовані кодеки"

msgid ""
"Python provides a set of built-in codecs which are written in C for speed. "
"All of these codecs are directly usable via the following functions."
msgstr ""
"Python надає набір вбудованих кодеків, написаних на C для швидкості. Усі ці "
"кодеки можна безпосередньо використовувати за допомогою наведених нижче "
"функцій."

msgid ""
"Many of the following APIs take two arguments encoding and errors, and they "
"have the same semantics as the ones of the built-in :func:`str` string "
"object constructor."
msgstr ""
"Багато з наведених нижче API приймають кодування двох аргументів і помилки, "
"і вони мають таку саму семантику, як і вбудовані конструктори рядкових "
"об’єктів :func:`str`."

msgid ""
"Setting encoding to ``NULL`` causes the default encoding to be used which is "
"UTF-8.  The file system calls should use :c:func:`PyUnicode_FSConverter` for "
"encoding file names. This uses the variable :c:data:"
"`Py_FileSystemDefaultEncoding` internally. This variable should be treated "
"as read-only: on some systems, it will be a pointer to a static string, on "
"others, it will change at run-time (such as when the application invokes "
"setlocale)."
msgstr ""
"Встановлення кодування на ``NULL`` призводить до використання кодування за "
"умовчанням, яке є UTF-8. Виклики файлової системи мають використовувати :c:"
"func:`PyUnicode_FSConverter` для кодування імен файлів. Тут використовується "
"змінна :c:data:`Py_FileSystemDefaultEncoding` внутрішньо. Цю змінну слід "
"розглядати як доступну лише для читання: на деяких системах вона буде "
"вказівником на статичний рядок, на інших вона змінюватиметься під час "
"виконання (наприклад, коли програма викликає setlocale)."

msgid ""
"Error handling is set by errors which may also be set to ``NULL`` meaning to "
"use the default handling defined for the codec.  Default error handling for "
"all built-in codecs is \"strict\" (:exc:`ValueError` is raised)."
msgstr ""
"Обробка помилок встановлюється помилками, які також можуть мати значення "
"``NULL``, що означає використання обробки за замовчуванням, визначеної для "
"кодека. Обробка помилок за замовчуванням для всіх вбудованих кодеків є "
"\"суворою\" (:exc:`ValueError` викликається)."

msgid ""
"The codecs all use a similar interface.  Only deviations from the following "
"generic ones are documented for simplicity."
msgstr ""
"Усі кодеки використовують подібний інтерфейс. Для простоти документуються "
"лише відхилення від наступних загальних."

msgid "Generic Codecs"
msgstr "Загальні кодеки"

msgid "These are the generic codec APIs:"
msgstr "Це загальні кодеки API:"

msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string *s*. "
"*encoding* and *errors* have the same meaning as the parameters of the same "
"name in the :func:`str` built-in function.  The codec to be used is looked "
"up using the Python codec registry.  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Створіть об’єкт Unicode, декодуючи *size* байти закодованого рядка *s*. "
"*encoding* і *errors* мають те саме значення, що й однойменні параметри у "
"вбудованій функції :func:`str`. Кодек, який буде використовуватися, "
"шукається за допомогою реєстру кодеків Python. Повертає ``NULL``, якщо кодек "
"викликав виняткову ситуацію."

msgid ""
"Encode a Unicode object and return the result as Python bytes object. "
"*encoding* and *errors* have the same meaning as the parameters of the same "
"name in the Unicode :meth:`~str.encode` method. The codec to be used is "
"looked up using the Python codec registry. Return ``NULL`` if an exception "
"was raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode та поверніть результат як об’єкт Python bytes. "
"*encoding* і *errors* мають те саме значення, що й однойменні параметри в "
"методі Unicode :meth:`~str.encode`. Кодек, який буде використовуватися, "
"шукається за допомогою реєстру кодеків Python. Повертає ``NULL``, якщо кодек "
"викликав виняткову ситуацію."

msgid "UTF-8 Codecs"
msgstr "Кодеки UTF-8"

msgid "These are the UTF-8 codec APIs:"
msgstr "Це API кодека UTF-8:"

msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-8 encoded string "
"*s*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Створіть об’єкт Unicode, декодуючи *size* байти рядка *s* у кодуванні UTF-8. "
"Повертає ``NULL``, якщо кодек викликав виняткову ситуацію."

msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF8`. If "
"*consumed* is not ``NULL``, trailing incomplete UTF-8 byte sequences will "
"not be treated as an error. Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Якщо *consumed* дорівнює ``NULL``, поводьтеся як :c:func:"
"`PyUnicode_DecodeUTF8`. Якщо *consumed* не має значення ``NULL``, кінцеві "
"неповні послідовності байтів UTF-8 не розглядатимуться як помилка. Ці байти "
"не будуть декодовані, а кількість декодованих байтів зберігатиметься в "
"*спожитих*."

msgid ""
"Encode a Unicode object using UTF-8 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою UTF-8 і поверніть результат як об’єкт "
"Python bytes. Обробка помилок \"строга\". Повертає ``NULL``, якщо кодек "
"викликав виняткову ситуацію."

msgid ""
"Return a pointer to the UTF-8 encoding of the Unicode object, and store the "
"size of the encoded representation (in bytes) in *size*.  The *size* "
"argument can be ``NULL``; in this case no size will be stored.  The returned "
"buffer always has an extra null byte appended (not included in *size*), "
"regardless of whether there are any other null code points."
msgstr ""
"Поверніть вказівник на кодування UTF-8 об’єкта Unicode та збережіть розмір "
"закодованого представлення (у байтах) у *size*. Аргумент *size* може бути "
"``NULL``; у цьому випадку розмір не буде збережено. До поверненого буфера "
"завжди додається додатковий нульовий байт (не включений у *size*), незалежно "
"від того, чи є інші нульові кодові точки."

msgid ""
"In the case of an error, ``NULL`` is returned with an exception set and no "
"*size* is stored."
msgstr ""
"У разі помилки повертається ``NULL`` із набором винятків і *розмір* не "
"зберігається."

msgid ""
"This caches the UTF-8 representation of the string in the Unicode object, "
"and subsequent calls will return a pointer to the same buffer.  The caller "
"is not responsible for deallocating the buffer. The buffer is deallocated "
"and pointers to it become invalid when the Unicode object is garbage "
"collected."
msgstr ""
"Це кешує представлення UTF-8 рядка в об’єкті Unicode, а наступні виклики "
"повертатимуть вказівник на той самий буфер. Абонент не несе відповідальності "
"за звільнення буфера. Буфер звільняється, і покажчики на нього стають "
"недійсними, коли об’єкт Unicode збирається як сміття."

msgid "The return type is now ``const char *`` rather of ``char *``."
msgstr "Тип повернення тепер ``const char *``, а не ``char *``."

msgid "This function is a part of the :ref:`limited API <stable>`."
msgstr "Ця функція є частиною :ref:`limited API <stable>`."

msgid "As :c:func:`PyUnicode_AsUTF8AndSize`, but does not store the size."
msgstr "Як :c:func:`PyUnicode_AsUTF8AndSize`, але не зберігає розмір."

msgid "UTF-32 Codecs"
msgstr "Кодеки UTF-32"

msgid "These are the UTF-32 codec APIs:"
msgstr "Це API кодеків UTF-32:"

msgid ""
"Decode *size* bytes from a UTF-32 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"Декодуйте байти *size* із рядка буфера, закодованого в UTF-32, і повертайте "
"відповідний об’єкт Unicode. *errors* (якщо не ``NULL``) визначає обробку "
"помилок. За замовчуванням встановлено \"суворий\"."

msgid ""
"If *byteorder* is non-``NULL``, the decoder starts decoding using the given "
"byte order::"
msgstr ""
"Якщо *byteorder* не ``NULL``, декодер починає декодування, використовуючи "
"вказаний порядок байтів::"

msgid ""
"If ``*byteorder`` is zero, and the first four bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output."
msgstr ""
"Якщо ``*byteorder`` дорівнює нулю, а перші чотири байти вхідних даних є "
"міткою порядку байтів (BOM), декодер перемикається на цей порядок байтів і "
"BOM не копіюється в результуючий рядок Unicode. Якщо ``*byteorder`` дорівнює "
"``-1`` або ``1``, будь-яка позначка порядку байтів копіюється до виводу."

msgid ""
"After completion, *\\*byteorder* is set to the current byte order at the end "
"of input data."
msgstr ""
"Після завершення *\\*byteorder* встановлюється на поточний порядок байтів у "
"кінці вхідних даних."

msgid "If *byteorder* is ``NULL``, the codec starts in native order mode."
msgstr ""
"Якщо *byteorder* дорівнює ``NULL``, кодек запускається в режимі власного "
"порядку."

msgid "Return ``NULL`` if an exception was raised by the codec."
msgstr "Повертає ``NULL``, якщо кодек викликав виняткову ситуацію."

msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF32`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF32Stateful` will not "
"treat trailing incomplete UTF-32 byte sequences (such as a number of bytes "
"not divisible by four) as an error. Those bytes will not be decoded and the "
"number of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Якщо *consumed* дорівнює ``NULL``, поводьтеся як :c:func:"
"`PyUnicode_DecodeUTF32`. Якщо *consumed* не дорівнює ``NULL``, :c:func:"
"`PyUnicode_DecodeUTF32Stateful` не розглядатиме кінцеві неповні "
"послідовності байтів UTF-32 (наприклад, кількість байтів, що не ділиться на "
"чотири) як помилку. Ці байти не будуть декодовані, а кількість декодованих "
"байтів зберігатиметься в *спожитих*."

msgid ""
"Return a Python byte string using the UTF-32 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Повертає байтовий рядок Python, використовуючи кодування UTF-32 у рідному "
"порядку байтів. Рядок завжди починається з позначки BOM. Обробка помилок "
"\"строга\". Повертає ``NULL``, якщо кодек викликав виняткову ситуацію."

msgid "UTF-16 Codecs"
msgstr "Кодеки UTF-16"

msgid "These are the UTF-16 codec APIs:"
msgstr "Це API кодека UTF-16:"

msgid ""
"Decode *size* bytes from a UTF-16 encoded buffer string and return the "
"corresponding Unicode object.  *errors* (if non-``NULL``) defines the error "
"handling. It defaults to \"strict\"."
msgstr ""
"Декодуйте байти *size* із рядка буфера, закодованого в UTF-16, і повертайте "
"відповідний об’єкт Unicode. *errors* (якщо не ``NULL``) визначає обробку "
"помилок. За замовчуванням встановлено \"суворий\"."

msgid ""
"If ``*byteorder`` is zero, and the first two bytes of the input data are a "
"byte order mark (BOM), the decoder switches to this byte order and the BOM "
"is not copied into the resulting Unicode string.  If ``*byteorder`` is "
"``-1`` or ``1``, any byte order mark is copied to the output (where it will "
"result in either a ``\\ufeff`` or a ``\\ufffe`` character)."
msgstr ""
"Якщо ``*byteorder`` дорівнює нулю, а перші два байти вхідних даних є міткою "
"порядку байтів (BOM), декодер перемикається на цей порядок байтів і BOM не "
"копіюється в результуючий рядок Unicode. Якщо ``*byteorder`` дорівнює ``-1`` "
"або ``1``, будь-яка позначка порядку байтів копіюється до виводу (де це "
"призведе до ``\\ufeff`` або ``\\ufffe`` символ)."

msgid ""
"After completion, ``*byteorder`` is set to the current byte order at the end "
"of input data."
msgstr ""
"Після завершення ``*byteorder`` встановлюється на поточний порядок байтів у "
"кінці вхідних даних."

msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF16`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeUTF16Stateful` will not "
"treat trailing incomplete UTF-16 byte sequences (such as an odd number of "
"bytes or a split surrogate pair) as an error. Those bytes will not be "
"decoded and the number of bytes that have been decoded will be stored in "
"*consumed*."
msgstr ""
"Якщо *consumed* дорівнює ``NULL``, поводьтеся як :c:func:"
"`PyUnicode_DecodeUTF16`. Якщо *consumed* не дорівнює ``NULL``, :c:func:"
"`PyUnicode_DecodeUTF16Stateful` не розглядатиме кінцеві неповні "
"послідовності байтів UTF-16 (наприклад, непарну кількість байтів або "
"розділену сурогатну пару) як помилку. Ці байти не будуть декодовані, а "
"кількість декодованих байтів зберігатиметься в *спожитих*."

msgid ""
"Return a Python byte string using the UTF-16 encoding in native byte order. "
"The string always starts with a BOM mark.  Error handling is \"strict\". "
"Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Повертає байтовий рядок Python, використовуючи кодування UTF-16 у рідному "
"порядку байтів. Рядок завжди починається з позначки BOM. Обробка помилок "
"\"строга\". Повертає ``NULL``, якщо кодек викликав виняткову ситуацію."

msgid "UTF-7 Codecs"
msgstr "Кодеки UTF-7"

msgid "These are the UTF-7 codec APIs:"
msgstr "Це API кодека UTF-7:"

msgid ""
"Create a Unicode object by decoding *size* bytes of the UTF-7 encoded string "
"*s*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Створіть об’єкт Unicode, декодуючи *size* байти рядка *s* у кодуванні UTF-7. "
"Повертає ``NULL``, якщо кодек викликав виняткову ситуацію."

msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeUTF7`.  If "
"*consumed* is not ``NULL``, trailing incomplete UTF-7 base-64 sections will "
"not be treated as an error.  Those bytes will not be decoded and the number "
"of bytes that have been decoded will be stored in *consumed*."
msgstr ""
"Якщо *consumed* дорівнює ``NULL``, поводьтеся як :c:func:"
"`PyUnicode_DecodeUTF7`. Якщо *consumed* не дорівнює ``NULL``, кінцеві "
"неповні розділи UTF-7 base-64 не розглядатимуться як помилка. Ці байти не "
"будуть декодовані, а кількість декодованих байтів зберігатиметься в "
"*спожитих*."

msgid "Unicode-Escape Codecs"
msgstr "Кодеки Unicode-Escape"

msgid "These are the \"Unicode Escape\" codec APIs:"
msgstr "Це API кодека \"Unicode Escape\":"

msgid ""
"Create a Unicode object by decoding *size* bytes of the Unicode-Escape "
"encoded string *s*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Створіть об’єкт Unicode, декодуючи *size* байти рядка *s*, закодованого "
"Unicode-Escape. Повертає ``NULL``, якщо кодек викликав виняткову ситуацію."

msgid ""
"Encode a Unicode object using Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою Unicode-Escape та поверніть результат "
"як об’єкт bytes. Обробка помилок \"строга\". Повертає ``NULL``, якщо кодек "
"викликав виняткову ситуацію."

msgid "Raw-Unicode-Escape Codecs"
msgstr "Кодеки Raw-Unicode-Escape"

msgid "These are the \"Raw Unicode Escape\" codec APIs:"
msgstr "Це API кодека \"Raw Unicode Escape\":"

msgid ""
"Create a Unicode object by decoding *size* bytes of the Raw-Unicode-Escape "
"encoded string *s*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Створіть об’єкт Unicode, декодуючи *size* байти рядка *s*, закодованого Raw-"
"Unicode-Escape. Повертає ``NULL``, якщо кодек викликав виняткову ситуацію."

msgid ""
"Encode a Unicode object using Raw-Unicode-Escape and return the result as a "
"bytes object.  Error handling is \"strict\".  Return ``NULL`` if an "
"exception was raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою Raw-Unicode-Escape та поверніть "
"результат як об’єкт bytes. Обробка помилок \"строга\". Повертає ``NULL``, "
"якщо кодек викликав виняткову ситуацію."

msgid "Latin-1 Codecs"
msgstr "Кодеки Latin-1"

msgid ""
"These are the Latin-1 codec APIs: Latin-1 corresponds to the first 256 "
"Unicode ordinals and only these are accepted by the codecs during encoding."
msgstr ""
"Це API кодека Latin-1: Latin-1 відповідає першим 256 порядковим номерам "
"Unicode, і лише вони приймаються кодеками під час кодування."

msgid ""
"Create a Unicode object by decoding *size* bytes of the Latin-1 encoded "
"string *s*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Створіть об’єкт Unicode, декодуючи *size* байти рядка *s* у кодуванні "
"Latin-1. Повертає ``NULL``, якщо кодек викликав виняткову ситуацію."

msgid ""
"Encode a Unicode object using Latin-1 and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою Latin-1 і поверніть результат як "
"об’єкт Python bytes. Обробка помилок \"строга\". Повертає ``NULL``, якщо "
"кодек викликав виняткову ситуацію."

msgid "ASCII Codecs"
msgstr "Кодеки ASCII"

msgid ""
"These are the ASCII codec APIs.  Only 7-bit ASCII data is accepted. All "
"other codes generate errors."
msgstr ""
"Це API кодеків ASCII. Приймаються лише 7-бітні дані ASCII. Усі інші коди "
"генерують помилки."

msgid ""
"Create a Unicode object by decoding *size* bytes of the ASCII encoded string "
"*s*.  Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Створіть об’єкт Unicode, декодуючи *size* байти рядка *s* у кодуванні ASCII. "
"Повертає ``NULL``, якщо кодек викликав виняткову ситуацію."

msgid ""
"Encode a Unicode object using ASCII and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою ASCII і поверніть результат як об’єкт "
"Python bytes. Обробка помилок \"строга\". Повертає ``NULL``, якщо кодек "
"викликав виняткову ситуацію."

msgid "Character Map Codecs"
msgstr "Кодеки карти символів"

msgid ""
"This codec is special in that it can be used to implement many different "
"codecs (and this is in fact what was done to obtain most of the standard "
"codecs included in the :mod:`encodings` package). The codec uses mappings to "
"encode and decode characters.  The mapping objects provided must support "
"the :meth:`__getitem__` mapping interface; dictionaries and sequences work "
"well."
msgstr ""
"Цей кодек особливий тим, що його можна використовувати для реалізації "
"багатьох різних кодеків (і саме це було зроблено, щоб отримати більшість "
"стандартних кодеків, включених до пакета :mod:`encodings`). Кодек "
"використовує відображення для кодування та декодування символів. Надані "
"об’єкти відображення мають підтримувати інтерфейс відображення :meth:"
"`__getitem__`; словники та послідовності працюють добре."

msgid "These are the mapping codec APIs:"
msgstr "Це API кодека відображення:"

msgid ""
"Create a Unicode object by decoding *size* bytes of the encoded string *s* "
"using the given *mapping* object.  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Створіть об’єкт Unicode, декодуючи *size* байти закодованого рядка *s* за "
"допомогою заданого об’єкта *mapping*. Повертає ``NULL``, якщо кодек викликав "
"виняткову ситуацію."

msgid ""
"If *mapping* is ``NULL``, Latin-1 decoding will be applied.  Else *mapping* "
"must map bytes ordinals (integers in the range from 0 to 255) to Unicode "
"strings, integers (which are then interpreted as Unicode ordinals) or "
"``None``.  Unmapped data bytes -- ones which cause a :exc:`LookupError`, as "
"well as ones which get mapped to ``None``, ``0xFFFE`` or ``'\\ufffe'``, are "
"treated as undefined mappings and cause an error."
msgstr ""
"Якщо *mapping* має значення ``NULL``, буде застосовано декодування Latin-1. "
"Інакше *відображення* має зіставляти порядкові номери байтів (цілі числа в "
"діапазоні від 0 до 255) на рядки Unicode, цілі числа (які потім "
"інтерпретуються як порядкові номери Unicode) або ``None``. Невідображені "
"байти даних – ті, які викликають :exc:`LookupError`, а також ті, які "
"відображаються на ``None``, ``0xFFFE`` або ``'\\ufffe``, розглядаються як "
"невизначені відображення і викликати помилку."

msgid ""
"Encode a Unicode object using the given *mapping* object and return the "
"result as a bytes object.  Error handling is \"strict\".  Return ``NULL`` if "
"an exception was raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою даного об’єкта *mapping* і поверніть "
"результат як об’єкт bytes. Обробка помилок \"строга\". Повертає ``NULL``, "
"якщо кодек викликав виняткову ситуацію."

msgid ""
"The *mapping* object must map Unicode ordinal integers to bytes objects, "
"integers in the range from 0 to 255 or ``None``.  Unmapped character "
"ordinals (ones which cause a :exc:`LookupError`) as well as mapped to "
"``None`` are treated as \"undefined mapping\" and cause an error."
msgstr ""
"Об’єкт *mapping* має зіставляти порядкові цілі числа Unicode з об’єктами "
"bytes, цілі числа в діапазоні від 0 до 255 або ``None``. Невідображені "
"порядкові символи (які спричиняють :exc:`LookupError`), а також відображені "
"на ``None`` розглядаються як \"невизначене відображення\" та викликають "
"помилку."

msgid "The following codec API is special in that maps Unicode to Unicode."
msgstr ""
"Наступний кодек API є особливим у тому, що відображає Unicode на Unicode."

msgid ""
"Translate a string by applying a character mapping table to it and return "
"the resulting Unicode object. Return ``NULL`` if an exception was raised by "
"the codec."
msgstr ""
"Перекладіть рядок, застосувавши до нього таблицю зіставлення символів і "
"поверніть отриманий об’єкт Unicode. Повертає ``NULL``, якщо кодек викликав "
"виняткову ситуацію."

msgid ""
"The mapping table must map Unicode ordinal integers to Unicode ordinal "
"integers or ``None`` (causing deletion of the character)."
msgstr ""
"Таблиця відображення має зіставляти порядкові цілі числа Unicode з "
"порядковими цілими числами Unicode або \"Немає\" (спричиняючи видалення "
"символу)."

msgid ""
"Mapping tables need only provide the :meth:`__getitem__` interface; "
"dictionaries and sequences work well.  Unmapped character ordinals (ones "
"which cause a :exc:`LookupError`) are left untouched and are copied as-is."
msgstr ""
"Таблиці відображення повинні надавати лише інтерфейс :meth:`__getitem__`; "
"словники та послідовності працюють добре. Незіставлені порядкові символи "
"(які викликають :exc:`LookupError`) залишаються недоторканими та копіюються "
"як є."

msgid ""
"*errors* has the usual meaning for codecs. It may be ``NULL`` which "
"indicates to use the default error handling."
msgstr ""
"*помилки* має звичайне значення для кодеків. Це може бути ``NULL``, що "
"вказує на використання стандартної обробки помилок."

msgid "MBCS codecs for Windows"
msgstr "Кодеки MBCS для Windows"

msgid ""
"These are the MBCS codec APIs. They are currently only available on Windows "
"and use the Win32 MBCS converters to implement the conversions.  Note that "
"MBCS (or DBCS) is a class of encodings, not just one.  The target encoding "
"is defined by the user settings on the machine running the codec."
msgstr ""
"Це API кодека MBCS. Наразі вони доступні лише у Windows і використовують "
"конвертери Win32 MBCS для реалізації перетворень. Зауважте, що MBCS (або "
"DBCS) — це клас кодувань, а не одне. Цільове кодування визначається "
"налаштуваннями користувача на машині, на якій працює кодек."

msgid ""
"Create a Unicode object by decoding *size* bytes of the MBCS encoded string "
"*s*. Return ``NULL`` if an exception was raised by the codec."
msgstr ""
"Створіть об’єкт Unicode, декодуючи *size* байти рядка *s* у кодуванні MBCS. "
"Повертає ``NULL``, якщо кодек викликав виняткову ситуацію."

msgid ""
"If *consumed* is ``NULL``, behave like :c:func:`PyUnicode_DecodeMBCS`. If "
"*consumed* is not ``NULL``, :c:func:`PyUnicode_DecodeMBCSStateful` will not "
"decode trailing lead byte and the number of bytes that have been decoded "
"will be stored in *consumed*."
msgstr ""
"Якщо *consumed* дорівнює ``NULL``, поводьтеся як :c:func:"
"`PyUnicode_DecodeMBCS`. Якщо *consumed* не дорівнює ``NULL``, :c:func:"
"`PyUnicode_DecodeMBCSStateful` не декодуватиме кінцевий провідний байт, а "
"кількість декодованих байтів зберігатиметься в *consumed*."

msgid ""
"Encode a Unicode object using MBCS and return the result as Python bytes "
"object.  Error handling is \"strict\".  Return ``NULL`` if an exception was "
"raised by the codec."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою MBCS і поверніть результат як об’єкт "
"Python bytes. Обробка помилок \"строга\". Повертає ``NULL``, якщо кодек "
"викликав виняткову ситуацію."

msgid ""
"Encode the Unicode object using the specified code page and return a Python "
"bytes object.  Return ``NULL`` if an exception was raised by the codec. Use :"
"c:data:`CP_ACP` code page to get the MBCS encoder."
msgstr ""
"Закодуйте об’єкт Unicode за допомогою вказаної кодової сторінки та поверніть "
"об’єкт Python bytes. Повертає ``NULL``, якщо кодек викликав виняткову "
"ситуацію. Використовуйте кодову сторінку :c:data:`CP_ACP`, щоб отримати "
"кодувальник MBCS."

msgid "Methods & Slots"
msgstr "Методи та слоти"

msgid "Methods and Slot Functions"
msgstr "Методи та функції слота"

msgid ""
"The following APIs are capable of handling Unicode objects and strings on "
"input (we refer to them as strings in the descriptions) and return Unicode "
"objects or integers as appropriate."
msgstr ""
"Наступні API здатні обробляти об’єкти Unicode та рядки на вхідних даних (ми "
"називаємо їх рядками в описах) і повертати об’єкти Unicode або цілі числа "
"відповідно."

msgid "They all return ``NULL`` or ``-1`` if an exception occurs."
msgstr ""
"Усі вони повертають ``NULL`` або ``-1``, якщо виникає виняткова ситуація."

msgid "Concat two strings giving a new Unicode string."
msgstr "Concat два рядки дають новий рядок Unicode."

msgid ""
"Split a string giving a list of Unicode strings.  If *sep* is ``NULL``, "
"splitting will be done at all whitespace substrings.  Otherwise, splits "
"occur at the given separator.  At most *maxsplit* splits will be done.  If "
"negative, no limit is set.  Separators are not included in the resulting "
"list."
msgstr ""
"Розділити рядок, що дасть список рядків Unicode. Якщо *sep* дорівнює "
"``NULL``, розділення буде виконано на всіх пробільних підрядках. В іншому "
"випадку на даному сепараторі відбуваються розбивання. Буде виконано не "
"більше ніж *maxsplit*. Якщо значення від’ємне, обмеження не встановлено. "
"Розділювачі не включені в отриманий список."

msgid ""
"Split a Unicode string at line breaks, returning a list of Unicode strings. "
"CRLF is considered to be one line break.  If *keepend* is ``0``, the line "
"break characters are not included in the resulting strings."
msgstr ""
"Розділіть рядок Unicode на розриви рядків, повертаючи список рядків Unicode. "
"CRLF вважається розривом одного рядка. Якщо *keepend* дорівнює ``0``, "
"символи розриву рядка не включаються в отримані рядки."

msgid ""
"Join a sequence of strings using the given *separator* and return the "
"resulting Unicode string."
msgstr ""
"З’єднайте послідовність рядків за допомогою заданого *роздільника* та "
"поверніть отриманий рядок Unicode."

msgid ""
"Return ``1`` if *substr* matches ``str[start:end]`` at the given tail end "
"(*direction* == ``-1`` means to do a prefix match, *direction* == ``1`` a "
"suffix match), ``0`` otherwise. Return ``-1`` if an error occurred."
msgstr ""
"Повертає ``1``, якщо *substr* збігається з ``str[start:end]`` у вказаному "
"кінці (*direction* == ``-1`` означає збіг префікса, *direction* == ``1`` "
"відповідає суфіксу), ``0`` інакше. Повертає ``-1``, якщо сталася помилка."

msgid ""
"Return the first position of *substr* in ``str[start:end]`` using the given "
"*direction* (*direction* == ``1`` means to do a forward search, *direction* "
"== ``-1`` a backward search).  The return value is the index of the first "
"match; a value of ``-1`` indicates that no match was found, and ``-2`` "
"indicates that an error occurred and an exception has been set."
msgstr ""
"Повертає першу позицію *substr* у ``str[start:end]``, використовуючи заданий "
"*напрям* (*напрямок* == ``1`` означає пошук вперед, *напрямок* == ``-1`` "
"пошук назад). Повернене значення є індексом першого збігу; значення ``-1`` "
"вказує на те, що відповідності не знайдено, а ``-2`` вказує на те, що "
"сталася помилка та встановлено виняток."

msgid ""
"Return the first position of the character *ch* in ``str[start:end]`` using "
"the given *direction* (*direction* == ``1`` means to do a forward search, "
"*direction* == ``-1`` a backward search).  The return value is the index of "
"the first match; a value of ``-1`` indicates that no match was found, and "
"``-2`` indicates that an error occurred and an exception has been set."
msgstr ""
"Повертає першу позицію символу *ch* у ``str[start:end]``, використовуючи "
"вказаний *напрямок* (*напрямок* == ``1`` означає пошук вперед, *напрямок* == "
"``-1`` пошук у зворотному напрямку). Повернене значення є індексом першого "
"збігу; значення ``-1`` вказує на те, що відповідності не знайдено, а ``-2`` "
"вказує на те, що сталася помилка та встановлено виняток."

msgid "*start* and *end* are now adjusted to behave like ``str[start:end]``."
msgstr ""
"*start* і *end* тепер налаштовані так, щоб поводитися як ``str[start:end]``."

msgid ""
"Return the number of non-overlapping occurrences of *substr* in ``str[start:"
"end]``.  Return ``-1`` if an error occurred."
msgstr ""
"Повертає кількість неперекриваючих входжень *substr* у ``str[start:end]``. "
"Повертає ``-1``, якщо сталася помилка."

msgid ""
"Replace at most *maxcount* occurrences of *substr* in *str* with *replstr* "
"and return the resulting Unicode object. *maxcount* == ``-1`` means replace "
"all occurrences."
msgstr ""
"Замініть щонайбільше *maxcount* входжень *substr* у *str* на *replstr* і "
"поверніть отриманий об’єкт Unicode. *maxcount* == ``-1`` означає заміну всіх "
"входжень."

msgid ""
"Compare two strings and return ``-1``, ``0``, ``1`` for less than, equal, "
"and greater than, respectively."
msgstr ""
"Порівняйте два рядки та поверніть ``-1``, ``0``, ``1`` для меншого, рівного "
"та більшого відповідно."

msgid ""
"This function returns ``-1`` upon failure, so one should call :c:func:"
"`PyErr_Occurred` to check for errors."
msgstr ""
"Ця функція повертає ``-1`` у разі помилки, тому слід викликати :c:func:"
"`PyErr_Occurred`, щоб перевірити наявність помилок."

msgid ""
"Compare a Unicode object, *uni*, with *string* and return ``-1``, ``0``, "
"``1`` for less than, equal, and greater than, respectively. It is best to "
"pass only ASCII-encoded strings, but the function interprets the input "
"string as ISO-8859-1 if it contains non-ASCII characters."
msgstr ""
"Порівняйте об’єкт Unicode, *uni*, з *string* і поверніть ``-1``, ``0``, "
"``1`` для меншого, рівного та більшого відповідно. Найкраще передавати лише "
"рядки в кодуванні ASCII, але функція інтерпретує вхідний рядок як "
"ISO-8859-1, якщо він містить символи, відмінні від ASCII."

msgid "This function does not raise exceptions."
msgstr "Ця функція не викликає винятків."

msgid "Rich compare two Unicode strings and return one of the following:"
msgstr "Rich порівнює два рядки Unicode та повертає одне з наступного:"

msgid "``NULL`` in case an exception was raised"
msgstr "``NULL`` у разі виникнення винятку"

msgid ":const:`Py_True` or :const:`Py_False` for successful comparisons"
msgstr ":const:`Py_True` або :const:`Py_False` для успішних порівнянь"

msgid ":const:`Py_NotImplemented` in case the type combination is unknown"
msgstr ":const:`Py_NotImplemented` у випадку, якщо комбінація типів невідома"

msgid ""
"Possible values for *op* are :const:`Py_GT`, :const:`Py_GE`, :const:"
"`Py_EQ`, :const:`Py_NE`, :const:`Py_LT`, and :const:`Py_LE`."
msgstr ""
"Можливі значення для *op*: :const:`Py_GT`, :const:`Py_GE`, :const:`Py_EQ`, :"
"const:`Py_NE`, :const:`Py_LT` і :const:`Py_LE`."

msgid ""
"Return a new string object from *format* and *args*; this is analogous to "
"``format % args``."
msgstr ""
"Повертає новий рядковий об’єкт із *format* і *args*; це аналогічно ``format "
"% args``."

msgid ""
"Check whether *element* is contained in *container* and return true or false "
"accordingly."
msgstr ""
"Перевірте, чи *елемент* міститься в *контейнері*, і поверніть відповідно "
"true або false."

msgid ""
"*element* has to coerce to a one element Unicode string. ``-1`` is returned "
"if there was an error."
msgstr ""
"*element* має привести до одноелементного рядка Unicode. ``-1`` "
"повертається, якщо була помилка."

msgid ""
"Intern the argument *\\*string* in place.  The argument must be the address "
"of a pointer variable pointing to a Python Unicode string object.  If there "
"is an existing interned string that is the same as *\\*string*, it sets "
"*\\*string* to it (decrementing the reference count of the old string object "
"and incrementing the reference count of the interned string object), "
"otherwise it leaves *\\*string* alone and interns it (incrementing its "
"reference count). (Clarification: even though there is a lot of talk about "
"reference counts, think of this function as reference-count-neutral; you own "
"the object after the call if and only if you owned it before the call.)"
msgstr ""
"Інтернувати аргумент *\\*рядок* на місці. Аргумент має бути адресою змінної "
"покажчика, що вказує на рядковий об’єкт Python Unicode. Якщо існує "
"вбудований рядок, який збігається з *\\*string*, він встановлює для нього "
"*\\*string* (зменшуючи кількість посилань старого рядкового об’єкта та "
"збільшуючи кількість посилань вбудованого рядкового об’єкта), інакше він "
"залишає *\\*рядок* у спокої та інтернує його (збільшуючи його кількість "
"посилань). (Роз’яснення: незважаючи на те, що багато говорять про підрахунок "
"посилань, сприймайте цю функцію як нейтральну до підрахунку посилань; ви "
"володієте об’єктом після виклику тоді і тільки тоді, коли він вам належав до "
"виклику.)"

msgid ""
"A combination of :c:func:`PyUnicode_FromString` and :c:func:"
"`PyUnicode_InternInPlace`, returning either a new Unicode string object that "
"has been interned, or a new (\"owned\") reference to an earlier interned "
"string object with the same value."
msgstr ""
"Комбінація :c:func:`PyUnicode_FromString` і :c:func:"
"`PyUnicode_InternInPlace`, що повертає новий об’єкт рядка Unicode, який було "
"інтерновано, або нове (\"власне\") посилання на попередній об’єкт "
"інтернованого рядка з те саме значення."
