# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:49+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Initialization, Finalization, and Threads"
msgstr "Ініціалізація, фіналізація та потоки"

msgid "See also :ref:`Python Initialization Configuration <init-config>`."
msgstr "Дивіться також :ref:`Конфігурація ініціалізації Python <init-config>`."

msgid "Before Python Initialization"
msgstr "Перед ініціалізацією Python"

msgid ""
"In an application embedding  Python, the :c:func:`Py_Initialize` function "
"must be called before using any other Python/C API functions; with the "
"exception of a few functions and the :ref:`global configuration variables "
"<global-conf-vars>`."
msgstr ""
"У програмі, яка вбудовує Python, функція :c:func:`Py_Initialize` має бути "
"викликана перед використанням будь-яких інших функцій API Python/C; за "
"винятком кількох функцій і :ref:`глобальних змінних конфігурації <global-"
"conf-vars>`."

msgid ""
"The following functions can be safely called before Python is initialized:"
msgstr "Наступні функції можна безпечно викликати до ініціалізації Python:"

msgid "Configuration functions:"
msgstr "Функції конфігурації:"

msgid ":c:func:`PyImport_AppendInittab`"
msgstr ":c:func:`PyImport_AppendInittab`"

msgid ":c:func:`PyImport_ExtendInittab`"
msgstr ":c:func:`PyImport_ExtendInittab`"

msgid ":c:func:`PyInitFrozenExtensions`"
msgstr ":c:func:`PyInitFrozenExtensions`"

msgid ":c:func:`PyMem_SetAllocator`"
msgstr ":c:func:`PyMem_SetAllocator`"

msgid ":c:func:`PyMem_SetupDebugHooks`"
msgstr ":c:func:`PyMem_SetupDebugHooks`"

msgid ":c:func:`PyObject_SetArenaAllocator`"
msgstr ":c:func:`PyObject_SetArenaAllocator`"

msgid ":c:func:`Py_SetPath`"
msgstr ":c:func:`Py_SetPath`"

msgid ":c:func:`Py_SetProgramName`"
msgstr ":c:func:`Py_SetProgramName`"

msgid ":c:func:`Py_SetPythonHome`"
msgstr ":c:func:`Py_SetPythonHome`"

msgid ":c:func:`Py_SetStandardStreamEncoding`"
msgstr ":c:func:`Py_SetStandardStreamEncoding`"

msgid ":c:func:`PySys_AddWarnOption`"
msgstr ":c:func:`PySys_AddWarnOption`"

msgid ":c:func:`PySys_AddXOption`"
msgstr ":c:func:`PySys_AddXOption`"

msgid ":c:func:`PySys_ResetWarnOptions`"
msgstr ":c:func:`PySys_ResetWarnOptions`"

msgid "Informative functions:"
msgstr "Інформативні функції:"

msgid ":c:func:`Py_IsInitialized`"
msgstr ":c:func:`Py_IsInitialized`"

msgid ":c:func:`PyMem_GetAllocator`"
msgstr ":c:func:`PyMem_GetAllocator`"

msgid ":c:func:`PyObject_GetArenaAllocator`"
msgstr ":c:func:`PyObject_GetArenaAllocator`"

msgid ":c:func:`Py_GetBuildInfo`"
msgstr ":c:func:`Py_GetBuildInfo`"

msgid ":c:func:`Py_GetCompiler`"
msgstr ":c:func:`Py_GetCompiler`"

msgid ":c:func:`Py_GetCopyright`"
msgstr ":c:func:`Py_GetCopyright`"

msgid ":c:func:`Py_GetPlatform`"
msgstr ":c:func:`Py_GetPlatform`"

msgid ":c:func:`Py_GetVersion`"
msgstr ":c:func:`Py_GetVersion`"

msgid "Utilities:"
msgstr "Утиліти:"

msgid ":c:func:`Py_DecodeLocale`"
msgstr ":c:func:`Py_DecodeLocale`"

msgid "Memory allocators:"
msgstr "Розподільники пам'яті:"

msgid ":c:func:`PyMem_RawMalloc`"
msgstr ":c:func:`PyMem_RawMalloc`"

msgid ":c:func:`PyMem_RawRealloc`"
msgstr ":c:func:`PyMem_RawRealloc`"

msgid ":c:func:`PyMem_RawCalloc`"
msgstr ":c:func:`PyMem_RawCalloc`"

msgid ":c:func:`PyMem_RawFree`"
msgstr ":c:func:`PyMem_RawFree`"

msgid ""
"The following functions **should not be called** before :c:func:"
"`Py_Initialize`: :c:func:`Py_EncodeLocale`, :c:func:`Py_GetPath`, :c:func:"
"`Py_GetPrefix`, :c:func:`Py_GetExecPrefix`, :c:func:"
"`Py_GetProgramFullPath`, :c:func:`Py_GetPythonHome`, :c:func:"
"`Py_GetProgramName` and :c:func:`PyEval_InitThreads`."
msgstr ""
"Наступні функції **не слід викликати** до :c:func:`Py_Initialize`: :c:func:"
"`Py_EncodeLocale`, :c:func:`Py_GetPath`, :c:func:`Py_GetPrefix`, :c:func:"
"`Py_GetExecPrefix`, :c:func:`Py_GetProgramFullPath`, :c:func:"
"`Py_GetPythonHome`, :c:func:`Py_GetProgramName` і :c:func:"
"`PyEval_InitThreads`."

msgid "Global configuration variables"
msgstr "Глобальні змінні конфігурації"

msgid ""
"Python has variables for the global configuration to control different "
"features and options. By default, these flags are controlled by :ref:"
"`command line options <using-on-interface-options>`."
msgstr ""
"Python має змінні для глобальної конфігурації для керування різними "
"функціями та параметрами. За замовчуванням ці позначки контролюються :ref:"
"`параметрами командного рядка <using-on-interface-options>`."

msgid ""
"When a flag is set by an option, the value of the flag is the number of "
"times that the option was set. For example, ``-b`` sets :c:data:"
"`Py_BytesWarningFlag` to 1 and ``-bb`` sets :c:data:`Py_BytesWarningFlag` to "
"2."
msgstr ""
"Коли параметр встановлює прапор, значення прапора дорівнює кількості разів, "
"коли цей параметр було встановлено. Наприклад, ``-b`` встановлює :c:data:"
"`Py_BytesWarningFlag` на 1, а ``-bb`` встановлює :c:data:"
"`Py_BytesWarningFlag` на 2."

msgid ""
"Issue a warning when comparing :class:`bytes` or :class:`bytearray` with :"
"class:`str` or :class:`bytes` with :class:`int`.  Issue an error if greater "
"or equal to ``2``."
msgstr ""
"Видає попередження, коли порівнює :class:`bytes` або :class:`bytearray` з :"
"class:`str` або :class:`bytes` з :class:`int`. Видає помилку, якщо більше "
"або дорівнює ``2``."

msgid "Set by the :option:`-b` option."
msgstr "Встановлюється параметром :option:`-b`."

msgid ""
"Turn on parser debugging output (for expert only, depending on compilation "
"options)."
msgstr ""
"Увімкніть вихід налагодження аналізатора (лише для експерта, залежно від "
"параметрів компіляції)."

msgid ""
"Set by the :option:`-d` option and the :envvar:`PYTHONDEBUG` environment "
"variable."
msgstr ""
"Встановлюється параметром :option:`-d` і змінною середовища :envvar:"
"`PYTHONDEBUG`."

msgid ""
"If set to non-zero, Python won't try to write ``.pyc`` files on the import "
"of source modules."
msgstr ""
"Якщо встановлено ненульове значення, Python не намагатиметься записати файли "
"``.pyc`` під час імпорту вихідних модулів."

msgid ""
"Set by the :option:`-B` option and the :envvar:`PYTHONDONTWRITEBYTECODE` "
"environment variable."
msgstr ""
"Встановлюється параметром :option:`-B` і змінною середовища :envvar:"
"`PYTHONDONTWRITEBYTECODE`."

msgid ""
"Suppress error messages when calculating the module search path in :c:func:"
"`Py_GetPath`."
msgstr ""
"Придушити повідомлення про помилки під час обчислення шляху пошуку модуля в :"
"c:func:`Py_GetPath`."

msgid "Private flag used by ``_freeze_module`` and ``frozenmain`` programs."
msgstr ""

msgid ""
"Set to ``1`` if the :envvar:`PYTHONHASHSEED` environment variable is set to "
"a non-empty string."
msgstr ""
"Установіть значення ``1``, якщо змінна середовища :envvar:`PYTHONHASHSEED` "
"має значення непорожнього рядка."

msgid ""
"If the flag is non-zero, read the :envvar:`PYTHONHASHSEED` environment "
"variable to initialize the secret hash seed."
msgstr ""
"Якщо прапорець відмінний від нуля, прочитайте змінну середовища :envvar:"
"`PYTHONHASHSEED`, щоб ініціалізувати секретне початкове значення хешу."

msgid ""
"Ignore all :envvar:`PYTHON*` environment variables, e.g. :envvar:"
"`PYTHONPATH` and :envvar:`PYTHONHOME`, that might be set."
msgstr ""
"Ігноруйте всі змінні середовища :envvar:`PYTHON*`, напр. :envvar:"
"`PYTHONPATH` і :envvar:`PYTHONHOME`, які можуть бути встановлені."

msgid "Set by the :option:`-E` and :option:`-I` options."
msgstr "Встановлюється параметрами :option:`-E` і :option:`-I`."

msgid ""
"When a script is passed as first argument or the :option:`-c` option is "
"used, enter interactive mode after executing the script or the command, even "
"when :data:`sys.stdin` does not appear to be a terminal."
msgstr ""
"Якщо сценарій передається як перший аргумент або використовується параметр :"
"option:`-c`, увійдіть в інтерактивний режим після виконання сценарію або "
"команди, навіть якщо :data:`sys.stdin` не виглядає як термінал."

msgid ""
"Set by the :option:`-i` option and the :envvar:`PYTHONINSPECT` environment "
"variable."
msgstr ""
"Встановлюється параметром :option:`-i` і змінною середовища :envvar:"
"`PYTHONINSPECT`."

msgid "Set by the :option:`-i` option."
msgstr "Встановлюється параметром :option:`-i`."

msgid ""
"Run Python in isolated mode. In isolated mode :data:`sys.path` contains "
"neither the script's directory nor the user's site-packages directory."
msgstr ""
"Запустіть Python в ізольованому режимі. В ізольованому режимі :data:`sys."
"path` не містить ані каталогу сценарію, ані каталогу сайту-пакетів "
"користувача."

msgid "Set by the :option:`-I` option."
msgstr "Встановлюється параметром :option:`-I`."

msgid ""
"If the flag is non-zero, use the ``mbcs`` encoding with ``replace`` error "
"handler, instead of the UTF-8 encoding with ``surrogatepass`` error handler, "
"for the :term:`filesystem encoding and error handler`."
msgstr ""
"Якщо прапорець відмінний від нуля, використовуйте кодування ``mbcs`` із "
"обробником помилок ``replace``, замість кодування UTF-8 із ``surrogatepass`` "
"обробником помилок, для :term:`filesystem encoding and error handler`."

msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSFSENCODING` environment "
"variable is set to a non-empty string."
msgstr ""
"Установіть значення ``1``, якщо змінна середовища :envvar:"
"`PYTHONLEGACYWINDOWSFSENCODING` має значення непорожнього рядка."

msgid "See :pep:`529` for more details."
msgstr "Дивіться :pep:`529` для більш детальної інформації."

msgid ":ref:`Availability <availability>`: Windows."
msgstr ":ref:`Наявність <availability>`: Windows."

msgid ""
"If the flag is non-zero, use :class:`io.FileIO` instead of :class:"
"`WindowsConsoleIO` for :mod:`sys` standard streams."
msgstr ""
"Якщо прапор не нульовий, використовуйте :class:`io.FileIO` замість :class:"
"`WindowsConsoleIO` для :mod:`sys` стандартних потоків."

msgid ""
"Set to ``1`` if the :envvar:`PYTHONLEGACYWINDOWSSTDIO` environment variable "
"is set to a non-empty string."
msgstr ""
"Установіть значення ``1``, якщо змінна середовища :envvar:"
"`PYTHONLEGACYWINDOWSSTDIO` має значення непорожнього рядка."

msgid "See :pep:`528` for more details."
msgstr "Дивіться :pep:`528` для більш детальної інформації."

msgid ""
"Disable the import of the module :mod:`site` and the site-dependent "
"manipulations of :data:`sys.path` that it entails.  Also disable these "
"manipulations if :mod:`site` is explicitly imported later (call :func:`site."
"main` if you want them to be triggered)."
msgstr ""
"Вимкніть імпорт модуля :mod:`site` і залежні від сайту маніпуляції :data:"
"`sys.path`, які він передбачає. Також вимкніть ці маніпуляції, якщо :mod:"
"`site` буде явно імпортовано пізніше (викличте :func:`site.main`, якщо ви "
"хочете, щоб вони були активовані)."

msgid "Set by the :option:`-S` option."
msgstr "Встановлюється параметром :option:`-S`."

msgid ""
"Don't add the :data:`user site-packages directory <site.USER_SITE>` to :data:"
"`sys.path`."
msgstr ""
"Не додавайте каталог :data:`user site-packages <site.USER_SITE>` до :data:"
"`sys.path`."

msgid ""
"Set by the :option:`-s` and :option:`-I` options, and the :envvar:"
"`PYTHONNOUSERSITE` environment variable."
msgstr ""
"Встановлюється параметрами :option:`-s` і :option:`-I`, а також змінною "
"середовища :envvar:`PYTHONNOUSERSITE`."

msgid ""
"Set by the :option:`-O` option and the :envvar:`PYTHONOPTIMIZE` environment "
"variable."
msgstr ""
"Встановлюється параметром :option:`-O` і змінною середовища :envvar:"
"`PYTHONOPTIMIZE`."

msgid ""
"Don't display the copyright and version messages even in interactive mode."
msgstr ""
"Не відображайте повідомлення про авторські права та версію навіть в "
"інтерактивному режимі."

msgid "Set by the :option:`-q` option."
msgstr "Встановлюється параметром :option:`-q`."

msgid "Force the stdout and stderr streams to be unbuffered."
msgstr "Примусово розбуферизувати потоки stdout і stderr."

msgid ""
"Set by the :option:`-u` option and the :envvar:`PYTHONUNBUFFERED` "
"environment variable."
msgstr ""
"Встановлюється параметром :option:`-u` і змінною середовища :envvar:"
"`PYTHONUNBUFFERED`."

msgid ""
"Print a message each time a module is initialized, showing the place "
"(filename or built-in module) from which it is loaded.  If greater or equal "
"to ``2``, print a message for each file that is checked for when searching "
"for a module. Also provides information on module cleanup at exit."
msgstr ""
"Друкувати повідомлення кожного разу, коли модуль ініціалізовано, із "
"зазначенням місця (ім’я файлу чи вбудованого модуля), з якого він "
"завантажується. Якщо більше або дорівнює ``2``, друкувати повідомлення для "
"кожного файлу, який перевіряється під час пошуку модуля. Також надає "
"інформацію про очищення модуля при виході."

msgid ""
"Set by the :option:`-v` option and the :envvar:`PYTHONVERBOSE` environment "
"variable."
msgstr ""
"Встановлюється параметром :option:`-v` і змінною середовища :envvar:"
"`PYTHONVERBOSE`."

msgid "Initializing and finalizing the interpreter"
msgstr "Ініціалізація та завершення інтерпретатора"

msgid ""
"Initialize the Python interpreter.  In an application embedding  Python, "
"this should be called before using any other Python/C API functions; see :"
"ref:`Before Python Initialization <pre-init-safe>` for the few exceptions."
msgstr ""
"Ініціалізація інтерпретатора Python. У програмі, що вбудовує Python, це слід "
"викликати перед використанням будь-яких інших функцій API Python/C; див. :"
"ref:`Перед ініціалізацією Python <pre-init-safe>` для кількох винятків."

msgid ""
"This initializes the table of loaded modules (``sys.modules``), and creates "
"the fundamental modules :mod:`builtins`, :mod:`__main__` and :mod:`sys`.  It "
"also initializes the module search path (``sys.path``). It does not set "
"``sys.argv``; use :c:func:`PySys_SetArgvEx` for that.  This is a no-op when "
"called for a second time (without calling :c:func:`Py_FinalizeEx` first).  "
"There is no return value; it is a fatal error if the initialization fails."
msgstr ""
"Це ініціалізує таблицю завантажених модулів (``sys.modules``) і створює "
"фундаментальні модулі :mod:`builtins`, :mod:`__main__` і :mod:`sys`. Він "
"також ініціалізує шлях пошуку модуля (``sys.path``). Він не встановлює ``sys."
"argv``; використовуйте для цього :c:func:`PySys_SetArgvEx`. Під час другого "
"виклику це не виконується (без першого виклику :c:func:`Py_FinalizeEx`). "
"Немає значення, що повертається; це фатальна помилка, якщо ініціалізація не "
"вдається."

msgid ""
"On Windows, changes the console mode from ``O_TEXT`` to ``O_BINARY``, which "
"will also affect non-Python uses of the console using the C Runtime."
msgstr ""
"У Windows змінює режим консолі з ``O_TEXT`` на ``O_BINARY``, що також вплине "
"на використання консолі не на Python за допомогою C Runtime."

msgid ""
"This function works like :c:func:`Py_Initialize` if *initsigs* is ``1``. If "
"*initsigs* is ``0``, it skips initialization registration of signal "
"handlers, which might be useful when Python is embedded."
msgstr ""
"Ця функція працює як :c:func:`Py_Initialize`, якщо *initsigs* дорівнює "
"``1``. Якщо *initsigs* дорівнює ``0``, він пропускає реєстрацію "
"ініціалізації обробників сигналів, що може бути корисним, якщо Python "
"вбудовано."

msgid ""
"Return true (nonzero) when the Python interpreter has been initialized, "
"false (zero) if not.  After :c:func:`Py_FinalizeEx` is called, this returns "
"false until :c:func:`Py_Initialize` is called again."
msgstr ""
"Повертає істину (не нуль), якщо інтерпретатор Python ініціалізовано, і false "
"(нуль), якщо ні. Після виклику :c:func:`Py_FinalizeEx` повертається false, "
"доки :c:func:`Py_Initialize` не буде викликано знову."

msgid ""
"Undo all initializations made by :c:func:`Py_Initialize` and subsequent use "
"of Python/C API functions, and destroy all sub-interpreters (see :c:func:"
"`Py_NewInterpreter` below) that were created and not yet destroyed since the "
"last call to :c:func:`Py_Initialize`.  Ideally, this frees all memory "
"allocated by the Python interpreter.  This is a no-op when called for a "
"second time (without calling :c:func:`Py_Initialize` again first).  Normally "
"the return value is ``0``.  If there were errors during finalization "
"(flushing buffered data), ``-1`` is returned."
msgstr ""
"Скасуйте всі ініціалізації, зроблені :c:func:`Py_Initialize` і подальше "
"використання функцій Python/C API, і знищіть усі підінтерпретатори (див. :c:"
"func:`Py_NewInterpreter` нижче), які були створені та ще не знищені після "
"останній виклик :c:func:`Py_Initialize`. В ідеалі це звільняє всю пам’ять, "
"виділену інтерпретатором Python. Під час повторного виклику це не "
"виконується (без повторного виклику :c:func:`Py_Initialize`). Зазвичай "
"повертається значення ``0``. Якщо були помилки під час фіналізації (скидання "
"буферизованих даних), повертається ``-1``."

msgid ""
"This function is provided for a number of reasons.  An embedding application "
"might want to restart Python without having to restart the application "
"itself. An application that has loaded the Python interpreter from a "
"dynamically loadable library (or DLL) might want to free all memory "
"allocated by Python before unloading the DLL. During a hunt for memory leaks "
"in an application a developer might want to free all memory allocated by "
"Python before exiting from the application."
msgstr ""
"Ця функція передбачена з кількох причин. Програма для вбудовування може "
"захотіти перезапустити Python без необхідності перезапускати саму програму. "
"Програма, яка завантажила інтерпретатор Python із динамічно завантажуваної "
"бібліотеки (або DLL), може захотіти звільнити всю пам’ять, виділену Python, "
"перед вивантаженням DLL. Під час пошуку витоків пам’яті в програмі розробник "
"може захотіти звільнити всю пам’ять, виділену Python, перш ніж вийти з "
"програми."

msgid ""
"**Bugs and caveats:** The destruction of modules and objects in modules is "
"done in random order; this may cause destructors (:meth:`__del__` methods) "
"to fail when they depend on other objects (even functions) or modules.  "
"Dynamically loaded extension modules loaded by Python are not unloaded.  "
"Small amounts of memory allocated by the Python interpreter may not be freed "
"(if you find a leak, please report it).  Memory tied up in circular "
"references between objects is not freed.  Some memory allocated by extension "
"modules may not be freed.  Some extensions may not work properly if their "
"initialization routine is called more than once; this can happen if an "
"application calls :c:func:`Py_Initialize` and :c:func:`Py_FinalizeEx` more "
"than once."
msgstr ""
"**Помилки та застереження:** Знищення модулів і об’єктів у модулях "
"виконується у випадковому порядку; це може призвести до збою деструкторів (:"
"meth:`__del__` методів), коли вони залежать від інших об’єктів (навіть "
"функцій) або модулів. Динамічно завантажувані модулі розширення, завантажені "
"Python, не вивантажуються. Невеликі обсяги пам’яті, виділені інтерпретатором "
"Python, можуть не звільнитися (якщо ви виявите витік, повідомте про це). "
"Пам'ять, зв'язана циклічними посиланнями між об'єктами, не звільняється. "
"Частина пам’яті, виділеної модулями розширення, може не звільнятися. Деякі "
"розширення можуть не працювати належним чином, якщо їхня процедура "
"ініціалізації викликається кілька разів; це може статися, якщо програма "
"викликає :c:func:`Py_Initialize` і :c:func:`Py_FinalizeEx` більше одного "
"разу."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"_PySys_ClearAuditHooks`` with no arguments."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``cpython._PySys_ClearAuditHooks`` "
"без аргументів."

msgid ""
"This is a backwards-compatible version of :c:func:`Py_FinalizeEx` that "
"disregards the return value."
msgstr ""
"Це зворотно сумісна версія :c:func:`Py_FinalizeEx`, яка не враховує "
"значення, що повертається."

msgid "Process-wide parameters"
msgstr "Параметри для всього процесу"

msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"stdio_encoding` and :c:member:`PyConfig.stdio_errors` should be used "
"instead, see :ref:`Python Initialization Configuration <init-config>`."
msgstr ""

msgid ""
"This function should be called before :c:func:`Py_Initialize`, if it is "
"called at all. It specifies which encoding and error handling to use with "
"standard IO, with the same meanings as in :func:`str.encode`."
msgstr ""
"Цю функцію слід викликати перед :c:func:`Py_Initialize`, якщо вона взагалі "
"викликається. Він визначає, яке кодування та обробку помилок використовувати "
"зі стандартним вводом-виводом із тим самим значенням, що й у :func:`str."
"encode`."

msgid ""
"It overrides :envvar:`PYTHONIOENCODING` values, and allows embedding code to "
"control IO encoding when the environment variable does not work."
msgstr ""
"Він замінює значення :envvar:`PYTHONIOENCODING` і дозволяє вставляти код для "
"керування кодуванням вводу/виводу, коли змінна середовища не працює."

msgid ""
"*encoding* and/or *errors* may be ``NULL`` to use :envvar:`PYTHONIOENCODING` "
"and/or default values (depending on other settings)."
msgstr ""
"*кодування* та/або *помилки* можуть бути ``NULL`` для використання :envvar:"
"`PYTHONIOENCODING` та/або значень за замовчуванням (залежно від інших "
"налаштувань)."

msgid ""
"Note that :data:`sys.stderr` always uses the \"backslashreplace\" error "
"handler, regardless of this (or any other) setting."
msgstr ""
"Зауважте, що :data:`sys.stderr` завжди використовує обробник помилок "
"\"backslashreplace\", незалежно від цього (або будь-якого іншого) параметра."

msgid ""
"If :c:func:`Py_FinalizeEx` is called, this function will need to be called "
"again in order to affect subsequent calls to :c:func:`Py_Initialize`."
msgstr ""
"Якщо викликається :c:func:`Py_FinalizeEx`, цю функцію потрібно буде "
"викликати знову, щоб вплинути на наступні виклики :c:func:`Py_Initialize`."

msgid ""
"Returns ``0`` if successful, a nonzero value on error (e.g. calling after "
"the interpreter has already been initialized)."
msgstr ""
"У разі успіху повертає ``0``, відмінне від нуля значення в разі помилки "
"(наприклад, виклик після того, як інтерпретатор уже ініціалізовано)."

msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"program_name` should be used instead, see :ref:`Python Initialization "
"Configuration <init-config>`."
msgstr ""

msgid ""
"This function should be called before :c:func:`Py_Initialize` is called for "
"the first time, if it is called at all.  It tells the interpreter the value "
"of the ``argv[0]`` argument to the :c:func:`main` function of the program "
"(converted to wide characters). This is used by :c:func:`Py_GetPath` and "
"some other functions below to find the Python run-time libraries relative to "
"the interpreter executable.  The default value is ``'python'``.  The "
"argument should point to a zero-terminated wide character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"Цю функцію слід викликати перед першим викликом :c:func:`Py_Initialize`, "
"якщо вона взагалі викликається. Він повідомляє інтерпретатору значення "
"аргументу ``argv[0]`` для функції :c:func:`main` програми (перетворене на "
"широкі символи). Це використовується :c:func:`Py_GetPath` та деякими іншими "
"функціями нижче для пошуку бібліотек часу виконання Python відносно "
"виконуваного файлу інтерпретатора. Значення за замовчуванням - ``'python'``. "
"Аргумент має вказувати на широкий символьний рядок із нульовим закінченням у "
"статичній пам’яті, вміст якої не змінюватиметься протягом виконання "
"програми. Жоден код інтерпретатора Python не змінить вміст цього сховища."

msgid ""
"Use :c:func:`Py_DecodeLocale` to decode a bytes string to get a :c:expr:"
"`wchar_*` string."
msgstr ""

msgid ""
"Return the program name set with :c:func:`Py_SetProgramName`, or the "
"default. The returned string points into static storage; the caller should "
"not modify its value."
msgstr ""
"Повертає назву програми, встановлену за допомогою :c:func:"
"`Py_SetProgramName`, або за замовчуванням. Повернений рядок вказує на "
"статичне сховище; абонент не повинен змінювати його значення."

msgid ""
"This function should not be called before :c:func:`Py_Initialize`, otherwise "
"it returns ``NULL``."
msgstr ""
"Цю функцію не слід викликати перед :c:func:`Py_Initialize`, інакше вона "
"повертає ``NULL``."

msgid "It now returns ``NULL`` if called before :c:func:`Py_Initialize`."
msgstr ""
"Тепер він повертає ``NULL``, якщо викликаний перед :c:func:`Py_Initialize`."

msgid ""
"Return the *prefix* for installed platform-independent files. This is "
"derived through a number of complicated rules from the program name set "
"with :c:func:`Py_SetProgramName` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the prefix is "
"``'/usr/local'``. The returned string points into static storage; the caller "
"should not modify its value.  This corresponds to the :makevar:`prefix` "
"variable in the top-level :file:`Makefile` and the ``--prefix`` argument to "
"the :program:`configure` script at build time.  The value is available to "
"Python code as ``sys.prefix``. It is only useful on Unix.  See also the next "
"function."
msgstr ""
"Повертає *префікс* для встановлених незалежних від платформи файлів. Це "
"виводиться через низку складних правил із назви програми, встановленої за "
"допомогою :c:func:`Py_SetProgramName` та деяких змінних середовища; "
"наприклад, якщо назва програми ``'/usr/local/bin/python'``, префікс ``'/usr/"
"local'``. Повернений рядок вказує на статичне сховище; абонент не повинен "
"змінювати його значення. Це відповідає змінній :makevar:`prefix` у :file:"
"`Makefile` верхнього рівня та аргументу ``--prefix`` сценарію :program:"
"`configure` під час збирання. Значення доступне для коду Python як ``sys."
"prefix``. Це корисно лише в Unix. Дивіться також наступну функцію."

msgid ""
"Return the *exec-prefix* for installed platform-*dependent* files.  This is "
"derived through a number of complicated rules from the program name set "
"with :c:func:`Py_SetProgramName` and some environment variables; for "
"example, if the program name is ``'/usr/local/bin/python'``, the exec-prefix "
"is ``'/usr/local'``.  The returned string points into static storage; the "
"caller should not modify its value.  This corresponds to the :makevar:"
"`exec_prefix` variable in the top-level :file:`Makefile` and the ``--exec-"
"prefix`` argument to the :program:`configure` script at build  time.  The "
"value is available to Python code as ``sys.exec_prefix``.  It is only useful "
"on Unix."
msgstr ""
"Повертає *префікс exec* для встановлених *залежних* від платформи файлів. Це "
"виводиться через низку складних правил із назви програми, встановленої за "
"допомогою :c:func:`Py_SetProgramName` та деяких змінних середовища; "
"наприклад, якщо назва програми ``'/usr/local/bin/python'``, префікс exec ``'/"
"usr/local'``. Повернений рядок вказує на статичне сховище; абонент не "
"повинен змінювати його значення. Це відповідає змінній :makevar:"
"`exec_prefix` у :file:`Makefile` верхнього рівня та аргументу ``--exec-"
"prefix`` сценарію :program:`configure` під час збирання. Значення доступне "
"для коду Python як ``sys.exec_prefix``. Це корисно лише в Unix."

msgid ""
"Background: The exec-prefix differs from the prefix when platform dependent "
"files (such as executables and shared libraries) are installed in a "
"different directory tree.  In a typical installation, platform dependent "
"files may be installed in the :file:`/usr/local/plat` subtree while platform "
"independent may be installed in :file:`/usr/local`."
msgstr ""
"Довідкова інформація: префікс exec відрізняється від префікса, коли залежні "
"від платформи файли (такі як виконувані файли та спільні бібліотеки) "
"інстальовано в іншому дереві каталогів. У типовій інсталяції залежні від "
"платформи файли можна інсталювати у піддереві :file:`/usr/local/plat`, а "
"незалежні від платформи — у :file:`/usr/local`."

msgid ""
"Generally speaking, a platform is a combination of hardware and software "
"families, e.g.  Sparc machines running the Solaris 2.x operating system are "
"considered the same platform, but Intel machines running Solaris 2.x are "
"another platform, and Intel machines running Linux are yet another "
"platform.  Different major revisions of the same operating system generally "
"also form different platforms.  Non-Unix operating systems are a different "
"story; the installation strategies on those systems are so different that "
"the prefix and exec-prefix are meaningless, and set to the empty string. "
"Note that compiled Python bytecode files are platform independent (but not "
"independent from the Python version by which they were compiled!)."
msgstr ""
"Загалом, платформа – це комбінація сімейства апаратного та програмного "
"забезпечення, напр. Машини Sparc під керуванням операційної системи Solaris "
"2.x вважаються тією самою платформою, але машини Intel під керуванням "
"Solaris 2.x є іншою платформою, а машини Intel під керуванням Linux є ще "
"іншою платформою. Різні основні версії однієї операційної системи, як "
"правило, створюють різні платформи. Інша історія — операційні системи, "
"відмінні від Unix; стратегії встановлення в цих системах настільки різні, що "
"префікс і префікс exec не мають сенсу та встановлюються як порожній рядок. "
"Зауважте, що скомпільовані файли байт-коду Python не залежать від платформи "
"(але не залежать від версії Python, за допомогою якої вони були "
"скомпільовані!)."

msgid ""
"System administrators will know how to configure the :program:`mount` or :"
"program:`automount` programs to share :file:`/usr/local` between platforms "
"while having :file:`/usr/local/plat` be a different filesystem for each "
"platform."
msgstr ""
"Системні адміністратори знатимуть, як налаштувати програми :program:`mount` "
"або :program:`automount` для спільного використання :file:`/usr/local` між "
"платформами, використовуючи :file:`/usr/local/plat` різні файлові системи "
"для кожної платформи."

msgid ""
"Return the full program name of the Python executable; this is  computed as "
"a side-effect of deriving the default module search path  from the program "
"name (set by :c:func:`Py_SetProgramName` above). The returned string points "
"into static storage; the caller should not modify its value.  The value is "
"available to Python code as ``sys.executable``."
msgstr ""
"Повертає повну назву програми виконуваного файлу Python; це обчислюється як "
"побічний ефект отримання шляху пошуку модуля за замовчуванням з назви "
"програми (встановленої :c:func:`Py_SetProgramName` вище). Повернений рядок "
"вказує на статичне сховище; абонент не повинен змінювати його значення. "
"Значення доступне для коду Python як ``sys.executable``."

msgid ""
"Return the default module search path; this is computed from the program "
"name (set by :c:func:`Py_SetProgramName` above) and some environment "
"variables. The returned string consists of a series of directory names "
"separated by a platform dependent delimiter character.  The delimiter "
"character is ``':'`` on Unix and macOS, ``';'`` on Windows.  The returned "
"string points into static storage; the caller should not modify its value.  "
"The list :data:`sys.path` is initialized with this value on interpreter "
"startup; it can be (and usually is) modified later to change the search path "
"for loading modules."
msgstr ""
"Повертає стандартний шлях пошуку модуля; це обчислюється з назви програми "
"(встановленої :c:func:`Py_SetProgramName` вище) і деяких змінних середовища. "
"Повернений рядок складається з назв каталогів, розділених символом-"
"роздільником, що залежить від платформи. Роздільником є ``':''`` в Unix і "
"macOS, ``';''`` у Windows. Повернений рядок вказує на статичне сховище; "
"абонент не повинен змінювати його значення. Список :data:`sys.path` "
"ініціалізується цим значенням під час запуску інтерпретатора; його можна (і "
"зазвичай так) змінити пізніше, щоб змінити шлях пошуку для завантаження "
"модулів."

msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"module_search_paths` and :c:member:`PyConfig.module_search_paths_set` should "
"be used instead, see :ref:`Python Initialization Configuration <init-"
"config>`."
msgstr ""

msgid ""
"Set the default module search path.  If this function is called before :c:"
"func:`Py_Initialize`, then :c:func:`Py_GetPath` won't attempt to compute a "
"default search path but uses the one provided instead.  This is useful if "
"Python is embedded by an application that has full knowledge of the location "
"of all modules.  The path components should be separated by the platform "
"dependent delimiter character, which is ``':'`` on Unix and macOS, ``';'`` "
"on Windows."
msgstr ""
"Встановіть шлях пошуку модуля за замовчуванням. Якщо ця функція викликається "
"перед :c:func:`Py_Initialize`, тоді :c:func:`Py_GetPath` не намагатиметься "
"обчислити шлях пошуку за замовчуванням, а замість цього використовуватиме "
"наданий. Це корисно, якщо Python вбудовано програмою, яка має повні "
"відомості про розташування всіх модулів. Компоненти шляху мають бути "
"розділені залежним від платформи символом роздільника, яким є ``':''`` в "
"Unix і macOS, ``';''`` у Windows."

msgid ""
"This also causes :data:`sys.executable` to be set to the program full path "
"(see :c:func:`Py_GetProgramFullPath`) and for :data:`sys.prefix` and :data:"
"`sys.exec_prefix` to be empty.  It is up to the caller to modify these if "
"required after calling :c:func:`Py_Initialize`."
msgstr ""
"Це також призводить до того, що для :data:`sys.executable` буде встановлено "
"повний шлях до програми (див. :c:func:`Py_GetProgramFullPath`), а для :data:"
"`sys.prefix` і :data:`sys.exec_prefix` — бути порожнім. Користувач, який "
"викликає, може змінити їх, якщо потрібно, після виклику :c:func:"
"`Py_Initialize`."

msgid ""
"The path argument is copied internally, so the caller may free it after the "
"call completes."
msgstr ""
"Аргумент шляху копіюється всередину, тому абонент може звільнити його після "
"завершення виклику."

msgid ""
"The program full path is now used for :data:`sys.executable`, instead of the "
"program name."
msgstr ""
"Тепер для :data:`sys.executable` використовується повний шлях до програми "
"замість назви програми."

msgid ""
"Return the version of this Python interpreter.  This is a string that looks "
"something like ::"
msgstr ""
"Повернути версію цього інтерпретатора Python. Це рядок, який виглядає "
"приблизно так::"

msgid ""
"The first word (up to the first space character) is the current Python "
"version; the first characters are the major and minor version separated by a "
"period.  The returned string points into static storage; the caller should "
"not modify its value.  The value is available to Python code as :data:`sys."
"version`."
msgstr ""
"Перше слово (до першого символу пробілу) є поточною версією Python; перші "
"символи — це головна та другорядна версії, розділені крапкою. Повернений "
"рядок вказує на статичне сховище; абонент не повинен змінювати його "
"значення. Значення доступне для коду Python як :data:`sys.version`."

msgid "See also the :c:var:`Py_Version` constant."
msgstr ""

msgid ""
"Return the platform identifier for the current platform.  On Unix, this is "
"formed from the \"official\" name of the operating system, converted to "
"lower case, followed by the major revision number; e.g., for Solaris 2.x, "
"which is also known as SunOS 5.x, the value is ``'sunos5'``.  On macOS, it "
"is ``'darwin'``.  On Windows, it is ``'win'``.  The returned string points "
"into static storage; the caller should not modify its value.  The value is "
"available to Python code as ``sys.platform``."
msgstr ""
"Повертає ідентифікатор платформи для поточної платформи. В Unix це "
"формується з \"офіційної\" назви операційної системи, перетвореної на нижній "
"регістр, за якою йде основний номер версії; наприклад, для Solaris 2.x, яка "
"також відома як SunOS 5.x, значенням є ``'sunos5``. У macOS це ``'darwin'``. "
"У Windows це ``'win'``. Повернений рядок вказує на статичне сховище; абонент "
"не повинен змінювати його значення. Значення доступне для коду Python як "
"``sys.platform``."

msgid ""
"Return the official copyright string for the current Python version, for "
"example"
msgstr ""
"Поверніть, наприклад, офіційний рядок авторських прав для поточної версії "
"Python"

msgid "``'Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"
msgstr ""
"``'Авторське право 1991-1995 Stichting Mathematisch Centrum, Amsterdam'``"

msgid ""
"The returned string points into static storage; the caller should not modify "
"its value.  The value is available to Python code as ``sys.copyright``."
msgstr ""
"Повернений рядок вказує на статичне сховище; абонент не повинен змінювати "
"його значення. Значення доступне для коду Python як ``sys.copyright``."

msgid ""
"Return an indication of the compiler used to build the current Python "
"version, in square brackets, for example::"
msgstr ""
"Повертає вказівку компілятора, використаного для створення поточної версії "
"Python, у квадратних дужках, наприклад::"

msgid ""
"The returned string points into static storage; the caller should not modify "
"its value.  The value is available to Python code as part of the variable "
"``sys.version``."
msgstr ""
"Повернений рядок вказує на статичне сховище; абонент не повинен змінювати "
"його значення. Значення доступне для коду Python як частина змінної ``sys."
"version``."

msgid ""
"Return information about the sequence number and build date and time  of the "
"current Python interpreter instance, for example ::"
msgstr ""
"Повертає інформацію про порядковий номер, дату й час збирання поточного "
"екземпляра інтерпретатора Python, наприклад::"

msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"argv`, :c:member:`PyConfig.parse_argv` and :c:member:`PyConfig.safe_path` "
"should be used instead, see :ref:`Python Initialization Configuration <init-"
"config>`."
msgstr ""

msgid ""
"Set :data:`sys.argv` based on *argc* and *argv*.  These parameters are "
"similar to those passed to the program's :c:func:`main` function with the "
"difference that the first entry should refer to the script file to be "
"executed rather than the executable hosting the Python interpreter.  If "
"there isn't a script that will be run, the first entry in *argv* can be an "
"empty string.  If this function fails to initialize :data:`sys.argv`, a "
"fatal condition is signalled using :c:func:`Py_FatalError`."
msgstr ""
"Встановити :data:`sys.argv` на основі *argc* і *argv*. Ці параметри подібні "
"до тих, що передаються до функції програми :c:func:`main` з тією різницею, "
"що перший запис має посилатися на файл сценарію, який буде виконано, а не на "
"виконуваний файл, у якому розміщено інтерпретатор Python. Якщо сценарію, "
"який буде запущено, немає, перший запис у *argv* може бути порожнім рядком. "
"Якщо цій функції не вдається ініціалізувати :data:`sys.argv`, за допомогою :"
"c:func:`Py_FatalError` повідомляється про фатальну умову."

msgid ""
"If *updatepath* is zero, this is all the function does.  If *updatepath* is "
"non-zero, the function also modifies :data:`sys.path` according to the "
"following algorithm:"
msgstr ""
"Якщо *updatepath* дорівнює нулю, це все, що функція робить. Якщо "
"*updatepath* відмінний від нуля, функція також змінює :data:`sys.path` "
"відповідно до наступного алгоритму:"

msgid ""
"If the name of an existing script is passed in ``argv[0]``, the absolute "
"path of the directory where the script is located is prepended to :data:`sys."
"path`."
msgstr ""
"Якщо ім’я існуючого сценарію передається в ``argv[0]``, абсолютний шлях до "
"каталогу, де розташований сценарій, додається до :data:`sys.path`."

msgid ""
"Otherwise (that is, if *argc* is ``0`` or ``argv[0]`` doesn't point to an "
"existing file name), an empty string is prepended to :data:`sys.path`, which "
"is the same as prepending the current working directory (``\".\"``)."
msgstr ""
"В іншому випадку (тобто, якщо *argc* дорівнює ``0`` або ``argv[0]`` не "
"вказує на існуюче ім’я файлу), до :data:`sys.path` додається порожній рядок, "
"що те саме, що додавати поточний робочий каталог (``\".\"``)."

msgid ""
"See also :c:member:`PyConfig.orig_argv` and :c:member:`PyConfig.argv` "
"members of the :ref:`Python Initialization Configuration <init-config>`."
msgstr ""

msgid ""
"It is recommended that applications embedding the Python interpreter for "
"purposes other than executing a single script pass ``0`` as *updatepath*, "
"and update :data:`sys.path` themselves if desired. See `CVE-2008-5983 "
"<https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-5983>`_."
msgstr ""
"Рекомендується, щоб програми, які вбудовують інтерпретатор Python для цілей, "
"відмінних від виконання одного сценарію, передавали ``0`` як *updatepath* і "
"оновлювали :data:`sys.path` самостійно, якщо це потрібно. Див. "
"`CVE-2008-5983 <https://cve.mitre.org/cgi-bin/cvename.cgi?"
"name=CVE-2008-5983>`_."

msgid ""
"On versions before 3.1.3, you can achieve the same effect by manually "
"popping the first :data:`sys.path` element after having called :c:func:"
"`PySys_SetArgv`, for example using::"
msgstr ""
"У версіях до 3.1.3 ви можете досягти того самого ефекту, вручну витягнувши "
"перший елемент :data:`sys.path` після виклику :c:func:`PySys_SetArgv`, "
"наприклад, використовуючи::"

msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"argv` and :c:member:`PyConfig.parse_argv` should be used instead, see :ref:"
"`Python Initialization Configuration <init-config>`."
msgstr ""

msgid ""
"This function works like :c:func:`PySys_SetArgvEx` with *updatepath* set to "
"``1`` unless the :program:`python` interpreter was started with the :option:"
"`-I`."
msgstr ""
"Ця функція працює як :c:func:`PySys_SetArgvEx` з *updatepath*, встановленим "
"на ``1``, якщо інтерпретатор :program:`python` не було запущено з :option:`-"
"I`."

msgid "The *updatepath* value depends on :option:`-I`."
msgstr "Значення *updatepath* залежить від :option:`-I`."

msgid ""
"This API is kept for backward compatibility: setting :c:member:`PyConfig."
"home` should be used instead, see :ref:`Python Initialization Configuration "
"<init-config>`."
msgstr ""

msgid ""
"Set the default \"home\" directory, that is, the location of the standard "
"Python libraries.  See :envvar:`PYTHONHOME` for the meaning of the argument "
"string."
msgstr ""
"Встановіть типовий \"домашній\" каталог, тобто розташування стандартних "
"бібліотек Python. Дивіться :envvar:`PYTHONHOME` для визначення значення "
"рядка аргументу."

msgid ""
"The argument should point to a zero-terminated character string in static "
"storage whose contents will not change for the duration of the program's "
"execution.  No code in the Python interpreter will change the contents of "
"this storage."
msgstr ""
"Аргумент має вказувати на символьний рядок із нульовим закінченням у "
"статичному сховищі, вміст якого не змінюватиметься протягом виконання "
"програми. Жоден код інтерпретатора Python не змінить вміст цього сховища."

msgid ""
"Return the default \"home\", that is, the value set by a previous call to :c:"
"func:`Py_SetPythonHome`, or the value of the :envvar:`PYTHONHOME` "
"environment variable if it is set."
msgstr ""
"Повертає типовий \"home\", тобто значення, встановлене попереднім викликом :"
"c:func:`Py_SetPythonHome`, або значення змінної середовища :envvar:"
"`PYTHONHOME`, якщо воно встановлено."

msgid "Thread State and the Global Interpreter Lock"
msgstr "Стан потоку та глобальне блокування інтерпретатора"

msgid ""
"The Python interpreter is not fully thread-safe.  In order to support multi-"
"threaded Python programs, there's a global lock, called the :term:`global "
"interpreter lock` or :term:`GIL`, that must be held by the current thread "
"before it can safely access Python objects. Without the lock, even the "
"simplest operations could cause problems in a multi-threaded program: for "
"example, when two threads simultaneously increment the reference count of "
"the same object, the reference count could end up being incremented only "
"once instead of twice."
msgstr ""
"Інтерпретатор Python не є повністю потокобезпечним. Щоб підтримувати "
"багатопотокові програми Python, існує глобальне блокування, яке називається :"
"term:`global interpreter lock` або :term:`GIL`, яке має утримуватися "
"поточним потоком, перш ніж він зможе безпечно отримати доступ до об’єктів "
"Python. Без блокування навіть найпростіші операції можуть спричинити "
"проблеми в багатопотоковій програмі: наприклад, коли два потоки одночасно "
"збільшують кількість посилань на один і той же об’єкт, кількість посилань "
"може збільшитися лише один раз, а не двічі."

msgid ""
"Therefore, the rule exists that only the thread that has acquired the :term:"
"`GIL` may operate on Python objects or call Python/C API functions. In order "
"to emulate concurrency of execution, the interpreter regularly tries to "
"switch threads (see :func:`sys.setswitchinterval`).  The lock is also "
"released around potentially blocking I/O operations like reading or writing "
"a file, so that other Python threads can run in the meantime."
msgstr ""
"Тому існує правило, згідно з яким лише потік, який отримав :term:`GIL`, може "
"працювати з об’єктами Python або викликати функції API Python/C. Щоб "
"імітувати паралельне виконання, інтерпретатор регулярно намагається "
"перемикати потоки (див. :func:`sys.setswitchinterval`). Блокування також "
"знімається навколо можливого блокування операцій введення-виведення, таких "
"як читання або запис файлу, щоб тим часом могли працювати інші потоки Python."

msgid ""
"The Python interpreter keeps some thread-specific bookkeeping information "
"inside a data structure called :c:type:`PyThreadState`.  There's also one "
"global variable pointing to the current :c:type:`PyThreadState`: it can be "
"retrieved using :c:func:`PyThreadState_Get`."
msgstr ""
"Інтерпретатор Python зберігає певну облікову інформацію про потоки в "
"структурі даних під назвою :c:type:`PyThreadState`. Існує також одна "
"глобальна змінна, яка вказує на поточний :c:type:`PyThreadState`: її можна "
"отримати за допомогою :c:func:`PyThreadState_Get`."

msgid "Releasing the GIL from extension code"
msgstr "Реліз GIL від коду розширення"

msgid ""
"Most extension code manipulating the :term:`GIL` has the following simple "
"structure::"
msgstr ""
"Більшість кодів розширення, які маніпулюють :term:`GIL`, мають таку просту "
"структуру:"

msgid "This is so common that a pair of macros exists to simplify it::"
msgstr ""
"Це настільки поширене явище, що для його спрощення існує пара макросів:"

msgid ""
"The :c:macro:`Py_BEGIN_ALLOW_THREADS` macro opens a new block and declares a "
"hidden local variable; the :c:macro:`Py_END_ALLOW_THREADS` macro closes the "
"block."
msgstr ""
"Макрос :c:macro:`Py_BEGIN_ALLOW_THREADS` відкриває новий блок і оголошує "
"приховану локальну змінну; макрос :c:macro:`Py_END_ALLOW_THREADS` закриває "
"блок."

msgid "The block above expands to the following code::"
msgstr "Блок вище розширюється до наступного коду::"

msgid ""
"Here is how these functions work: the global interpreter lock is used to "
"protect the pointer to the current thread state.  When releasing the lock "
"and saving the thread state, the current thread state pointer must be "
"retrieved before the lock is released (since another thread could "
"immediately acquire the lock and store its own thread state in the global "
"variable). Conversely, when acquiring the lock and restoring the thread "
"state, the lock must be acquired before storing the thread state pointer."
msgstr ""
"Ось як ці функції працюють: глобальне блокування інтерпретатора "
"використовується для захисту вказівника на поточний стан потоку. При знятті "
"блокування та збереженні стану потоку вказівник поточного стану потоку "
"повинен бути отриманий до зняття блокування (оскільки інший потік може "
"негайно отримати блокування та зберегти свій власний стан потоку в "
"глобальній змінній). І навпаки, під час отримання блокування та відновлення "
"стану потоку, блокування має бути отримано перед збереженням покажчика стану "
"потоку."

msgid ""
"Calling system I/O functions is the most common use case for releasing the "
"GIL, but it can also be useful before calling long-running computations "
"which don't need access to Python objects, such as compression or "
"cryptographic functions operating over memory buffers.  For example, the "
"standard :mod:`zlib` and :mod:`hashlib` modules release the GIL when "
"compressing or hashing data."
msgstr ""
"Виклик системних функцій вводу-виводу є найпоширенішим варіантом "
"використання для випуску GIL, але він також може бути корисним перед "
"викликом тривалих обчислень, яким не потрібен доступ до об’єктів Python, "
"таких як стиснення або криптографічні функції, що працюють над буферами "
"пам’яті. Наприклад, стандартні модулі :mod:`zlib` і :mod:`hashlib` "
"звільняють GIL під час стиснення або хешування даних."

msgid "Non-Python created threads"
msgstr "Потоки, створені не на Python"

msgid ""
"When threads are created using the dedicated Python APIs (such as the :mod:"
"`threading` module), a thread state is automatically associated to them and "
"the code showed above is therefore correct.  However, when threads are "
"created from C (for example by a third-party library with its own thread "
"management), they don't hold the GIL, nor is there a thread state structure "
"for them."
msgstr ""
"Коли потоки створюються за допомогою спеціальних API Python (таких як "
"модуль :mod:`threading`), стан потоку автоматично пов’язується з ними, і "
"код, показаний вище, є правильним. Однак, коли потоки створюються з C "
"(наприклад, сторонньою бібліотекою з власним керуванням потоками), вони не "
"містять GIL, а також для них не існує структури стану потоку."

msgid ""
"If you need to call Python code from these threads (often this will be part "
"of a callback API provided by the aforementioned third-party library), you "
"must first register these threads with the interpreter by creating a thread "
"state data structure, then acquiring the GIL, and finally storing their "
"thread state pointer, before you can start using the Python/C API.  When you "
"are done, you should reset the thread state pointer, release the GIL, and "
"finally free the thread state data structure."
msgstr ""
"Якщо вам потрібно викликати код Python із цих потоків (часто це буде "
"частиною API зворотного виклику, наданого вищезгаданою сторонньою "
"бібліотекою), ви повинні спочатку зареєструвати ці потоки в інтерпретаторі, "
"створивши структуру даних стану потоку, а потім отримати GIL і, нарешті, "
"збереження покажчика стану потоку, перш ніж ви зможете почати "
"використовувати API Python/C. Коли ви закінчите, ви повинні скинути "
"вказівник стану потоку, звільнити GIL і, нарешті, звільнити структуру даних "
"стану потоку."

msgid ""
"The :c:func:`PyGILState_Ensure` and :c:func:`PyGILState_Release` functions "
"do all of the above automatically.  The typical idiom for calling into "
"Python from a C thread is::"
msgstr ""
"Функції :c:func:`PyGILState_Ensure` і :c:func:`PyGILState_Release` виконують "
"усе вищезазначене автоматично. Типова ідіома виклику Python із потоку C:"

msgid ""
"Note that the ``PyGILState_*`` functions assume there is only one global "
"interpreter (created automatically by :c:func:`Py_Initialize`).  Python "
"supports the creation of additional interpreters (using :c:func:"
"`Py_NewInterpreter`), but mixing multiple interpreters and the "
"``PyGILState_*`` API is unsupported."
msgstr ""

msgid "Cautions about fork()"
msgstr "Застереження щодо fork()"

msgid ""
"Another important thing to note about threads is their behaviour in the face "
"of the C :c:func:`fork` call. On most systems with :c:func:`fork`, after a "
"process forks only the thread that issued the fork will exist.  This has a "
"concrete impact both on how locks must be handled and on all stored state in "
"CPython's runtime."
msgstr ""
"Ще одна важлива річ, на яку слід звернути увагу щодо потоків, це їхня "
"поведінка перед викликом C :c:func:`fork`. У більшості систем із :c:func:"
"`fork` після розгалуження процесу існуватиме лише потік, який видав "
"розгалуження. Це має конкретний вплив як на те, як потрібно обробляти "
"блокування, так і на весь збережений стан у середовищі виконання CPython."

msgid ""
"The fact that only the \"current\" thread remains means any locks held by "
"other threads will never be released. Python solves this for :func:`os.fork` "
"by acquiring the locks it uses internally before the fork, and releasing "
"them afterwards. In addition, it resets any :ref:`lock-objects` in the "
"child. When extending or embedding Python, there is no way to inform Python "
"of additional (non-Python) locks that need to be acquired before or reset "
"after a fork. OS facilities such as :c:func:`pthread_atfork` would need to "
"be used to accomplish the same thing. Additionally, when extending or "
"embedding Python, calling :c:func:`fork` directly rather than through :func:"
"`os.fork` (and returning to or calling into Python) may result in a deadlock "
"by one of Python's internal locks being held by a thread that is defunct "
"after the fork. :c:func:`PyOS_AfterFork_Child` tries to reset the necessary "
"locks, but is not always able to."
msgstr ""
"Той факт, що залишається лише \"поточний\" потік, означає, що будь-які "
"блокування, утримувані іншими потоками, ніколи не будуть звільнені. Python "
"вирішує це для :func:`os.fork`, отримуючи блокування, які він використовує "
"всередині перед розгалуженням, і звільняє їх після. Крім того, він скидає "
"будь-які :ref:`lock-objects` у дочірньому. Під час розширення або "
"вбудовування Python немає способу повідомити Python про додаткові (не "
"Python) блокування, які потрібно отримати до або скинути після розгалуження. "
"Такі засоби ОС, як :c:func:`pthread_atfork`, потрібно буде використовувати, "
"щоб виконати те ж саме. Крім того, під час розширення або вбудовування "
"Python виклик :c:func:`fork` безпосередньо, а не через :func:`os.fork` (і "
"повернення або виклик у Python) може призвести до тупикової блокування через "
"одне з внутрішніх блокувань Python утримується ниткою, яка не існує після "
"розгалуження. :c:func:`PyOS_AfterFork_Child` намагається скинути необхідні "
"блокування, але не завжди може."

msgid ""
"The fact that all other threads go away also means that CPython's runtime "
"state there must be cleaned up properly, which :func:`os.fork` does.  This "
"means finalizing all other :c:type:`PyThreadState` objects belonging to the "
"current interpreter and all other :c:type:`PyInterpreterState` objects.  Due "
"to this and the special nature of the :ref:`\"main\" interpreter <sub-"
"interpreter-support>`, :c:func:`fork` should only be called in that "
"interpreter's \"main\" thread, where the CPython global runtime was "
"originally initialized. The only exception is if :c:func:`exec` will be "
"called immediately after."
msgstr ""
"Той факт, що всі інші потоки зникають, також означає, що стан виконання "
"CPython там має бути належним чином очищено, що й робить :func:`os.fork`. Це "
"означає завершення всіх інших об’єктів :c:type:`PyThreadState`, що належать "
"поточному інтерпретатору, і всіх інших об’єктів :c:type:"
"`PyInterpreterState`. Через це та особливу природу :ref:`\"main\" "
"інтерпретатора <sub-interpreter-support>`, :c:func:`fork` слід викликати "
"лише в тому \"main\" потоці цього інтерпретатора, де початково "
"ініціалізовано глобальне середовище виконання CPython. Єдиним винятком є те, "
"що :c:func:`exec` буде викликано одразу після."

msgid "High-level API"
msgstr "API високого рівня"

msgid ""
"These are the most commonly used types and functions when writing C "
"extension code, or when embedding the Python interpreter:"
msgstr ""
"Це типи та функції, які найчастіше використовуються під час написання коду "
"розширення C або під час вбудовування інтерпретатора Python:"

msgid ""
"This data structure represents the state shared by a number of cooperating "
"threads.  Threads belonging to the same interpreter share their module "
"administration and a few other internal items. There are no public members "
"in this structure."
msgstr ""
"Ця структура даних представляє стан, спільний для кількох взаємодіючих "
"потоків. Потоки, що належать одному інтерпретатору, спільно використовують "
"адміністрування модуля та кілька інших внутрішніх елементів. У цій структурі "
"немає громадських учасників."

msgid ""
"Threads belonging to different interpreters initially share nothing, except "
"process state like available memory, open file descriptors and such.  The "
"global interpreter lock is also shared by all threads, regardless of to "
"which interpreter they belong."
msgstr ""
"Потоки, що належать різним інтерпретаторам, спочатку нічого спільного не "
"мають, окрім стану процесу, наприклад доступної пам’яті, відкритих файлових "
"дескрипторів тощо. Глобальне блокування інтерпретатора також "
"використовується для всіх потоків, незалежно від того, до якого "
"інтерпретатора вони належать."

msgid ""
"This data structure represents the state of a single thread.  The only "
"public data member is :attr:`interp` (:c:expr:`PyInterpreterState *`), which "
"points to this thread's interpreter state."
msgstr ""

msgid "Deprecated function which does nothing."
msgstr "Застаріла функція, яка нічого не робить."

msgid ""
"In Python 3.6 and older, this function created the GIL if it didn't exist."
msgstr ""
"У Python 3.6 і старіших версіях ця функція створювала GIL, якщо його не "
"існувало."

msgid "The function now does nothing."
msgstr "Тепер функція нічого не робить."

msgid ""
"This function is now called by :c:func:`Py_Initialize()`, so you don't have "
"to call it yourself anymore."
msgstr ""
"Ця функція тепер викликається :c:func:`Py_Initialize()`, тому вам більше не "
"потрібно викликати її самостійно."

msgid ""
"This function cannot be called before :c:func:`Py_Initialize()` anymore."
msgstr "Цю функцію більше не можна викликати до :c:func:`Py_Initialize()`."

msgid ""
"Returns a non-zero value if :c:func:`PyEval_InitThreads` has been called.  "
"This function can be called without holding the GIL, and therefore can be "
"used to avoid calls to the locking API when running single-threaded."
msgstr ""
"Повертає ненульове значення, якщо було викликано :c:func:"
"`PyEval_InitThreads`. Цю функцію можна викликати без утримання GIL, і тому "
"її можна використовувати, щоб уникнути викликів API блокування під час "
"однопотокового виконання."

msgid "The :term:`GIL` is now initialized by :c:func:`Py_Initialize()`."
msgstr ""
":term:`GIL` тепер ініціалізовано за допомогою :c:func:`Py_Initialize()`."

msgid ""
"Release the global interpreter lock (if it has been created) and reset the "
"thread state to ``NULL``, returning the previous thread state (which is not "
"``NULL``).  If the lock has been created, the current thread must have "
"acquired it."
msgstr ""
"Звільніть глобальне блокування інтерпретатора (якщо його було створено) і "
"скиньте стан потоку до ``NULL``, повертаючи попередній стан потоку (який не "
"є ``NULL``). Якщо блокування було створено, поточний потік повинен отримати "
"його."

msgid ""
"Acquire the global interpreter lock (if it has been created) and set the "
"thread state to *tstate*, which must not be ``NULL``.  If the lock has been "
"created, the current thread must not have acquired it, otherwise deadlock "
"ensues."
msgstr ""
"Отримайте глобальне блокування інтерпретатора (якщо його було створено) і "
"встановіть стан потоку на *tstate*, який не має бути ``NULL``. Якщо "
"блокування було створено, поточний потік не повинен отримати його, інакше "
"виникає взаємоблокування."

msgid ""
"Calling this function from a thread when the runtime is finalizing will "
"terminate the thread, even if the thread was not created by Python. You can "
"use :c:func:`_Py_IsFinalizing` or :func:`sys.is_finalizing` to check if the "
"interpreter is in process of being finalized before calling this function to "
"avoid unwanted termination."
msgstr ""
"Виклик цієї функції з потоку під час завершення виконання призведе до "
"завершення потоку, навіть якщо він не був створений Python. Ви можете "
"використовувати :c:func:`_Py_IsFinalizing` або :func:`sys.is_finalizing`, "
"щоб перевірити, чи завершується інтерпретатор перед викликом цієї функції, "
"щоб уникнути небажаного завершення."

msgid ""
"Return the current thread state.  The global interpreter lock must be held. "
"When the current thread state is ``NULL``, this issues a fatal error (so "
"that the caller needn't check for ``NULL``)."
msgstr ""
"Повертає поточний стан потоку. Необхідно утримувати глобальне блокування "
"інтерпретатора. Коли поточний стан потоку ``NULL``, це викликає фатальну "
"помилку (тому абоненту не потрібно перевіряти ``NULL``)."

msgid ""
"Swap the current thread state with the thread state given by the argument "
"*tstate*, which may be ``NULL``.  The global interpreter lock must be held "
"and is not released."
msgstr ""
"Замінити поточний стан потоку на стан потоку, заданий аргументом *tstate*, "
"який може бути ``NULL``. Глобальне блокування інтерпретатора має бути "
"утримано та не звільнене."

msgid ""
"The following functions use thread-local storage, and are not compatible "
"with sub-interpreters:"
msgstr ""
"Наступні функції використовують локальне сховище потоків і несумісні з "
"підінтерпретаторами:"

msgid ""
"Ensure that the current thread is ready to call the Python C API regardless "
"of the current state of Python, or of the global interpreter lock. This may "
"be called as many times as desired by a thread as long as each call is "
"matched with a call to :c:func:`PyGILState_Release`. In general, other "
"thread-related APIs may be used between :c:func:`PyGILState_Ensure` and :c:"
"func:`PyGILState_Release` calls as long as the thread state is restored to "
"its previous state before the Release().  For example, normal usage of the :"
"c:macro:`Py_BEGIN_ALLOW_THREADS` and :c:macro:`Py_END_ALLOW_THREADS` macros "
"is acceptable."
msgstr ""
"Переконайтеся, що поточний потік готовий викликати API Python C незалежно "
"від поточного стану Python або глобального блокування інтерпретатора. Це "
"може бути викликано скільки завгодно разів потоком, якщо кожен виклик "
"відповідає виклику :c:func:`PyGILState_Release`. Загалом, між викликами :c:"
"func:`PyGILState_Ensure` і :c:func:`PyGILState_Release` можна "
"використовувати інші пов’язані з потоками API, якщо стан потоку відновлено "
"до попереднього стану до Release(). Наприклад, нормальне використання "
"макросів :c:macro:`Py_BEGIN_ALLOW_THREADS` і :c:macro:`Py_END_ALLOW_THREADS` "
"є прийнятним."

msgid ""
"The return value is an opaque \"handle\" to the thread state when :c:func:"
"`PyGILState_Ensure` was called, and must be passed to :c:func:"
"`PyGILState_Release` to ensure Python is left in the same state. Even though "
"recursive calls are allowed, these handles *cannot* be shared - each unique "
"call to :c:func:`PyGILState_Ensure` must save the handle for its call to :c:"
"func:`PyGILState_Release`."
msgstr ""
"Значення, що повертається, є непрозорим \"дескриптором\" стану потоку під "
"час виклику :c:func:`PyGILState_Ensure`, і його потрібно передати в :c:func:"
"`PyGILState_Release`, щоб Python залишався в тому самому стані. Незважаючи "
"на те, що рекурсивні виклики дозволені, ці дескриптори *не можна* спільно "
"використовувати — кожен унікальний виклик :c:func:`PyGILState_Ensure` "
"повинен зберігати дескриптор для свого виклику :c:func:`PyGILState_Release`."

msgid ""
"When the function returns, the current thread will hold the GIL and be able "
"to call arbitrary Python code.  Failure is a fatal error."
msgstr ""
"Коли функція повертається, поточний потік зберігатиме GIL і зможе викликати "
"довільний код Python. Невдача є фатальною помилкою."

msgid ""
"Release any resources previously acquired.  After this call, Python's state "
"will be the same as it was prior to the corresponding :c:func:"
"`PyGILState_Ensure` call (but generally this state will be unknown to the "
"caller, hence the use of the GILState API)."
msgstr ""
"Вивільніть будь-які раніше отримані ресурси. Після цього виклику стан Python "
"буде таким же, як і до відповідного виклику :c:func:`PyGILState_Ensure` (але "
"зазвичай цей стан буде невідомий абоненту, тому використовується GILState "
"API)."

msgid ""
"Every call to :c:func:`PyGILState_Ensure` must be matched by a call to :c:"
"func:`PyGILState_Release` on the same thread."
msgstr ""
"Кожен виклик :c:func:`PyGILState_Ensure` має відповідати виклику :c:func:"
"`PyGILState_Release` у тому самому потоці."

msgid ""
"Get the current thread state for this thread.  May return ``NULL`` if no "
"GILState API has been used on the current thread.  Note that the main thread "
"always has such a thread-state, even if no auto-thread-state call has been "
"made on the main thread.  This is mainly a helper/diagnostic function."
msgstr ""
"Отримати поточний стан потоку для цього потоку. Може повертати ``NULL``, "
"якщо API GILState не використовувався в поточному потоці. Зверніть увагу, що "
"основний потік завжди має такий стан потоку, навіть якщо в основному потоці "
"не було зроблено виклик автоматичного стану потоку. Це в основному допоміжна/"
"діагностична функція."

msgid ""
"Return ``1`` if the current thread is holding the GIL and ``0`` otherwise. "
"This function can be called from any thread at any time. Only if it has had "
"its Python thread state initialized and currently is holding the GIL will it "
"return ``1``. This is mainly a helper/diagnostic function.  It can be useful "
"for example in callback contexts or memory allocation functions when knowing "
"that the GIL is locked can allow the caller to perform sensitive actions or "
"otherwise behave differently."
msgstr ""
"Повертає ``1``, якщо поточний потік містить GIL, і ``0`` інакше. Цю функцію "
"можна викликати з будь-якого потоку в будь-який час. Лише якщо він "
"ініціалізував стан потоку Python і зараз утримує GIL, він поверне ``1``. Це "
"в основному допоміжна/діагностична функція. Це може бути корисно, наприклад, "
"у контекстах зворотного виклику або функціях виділення пам’яті, коли знання "
"про те, що GIL заблоковано, може дозволити абоненту виконувати конфіденційні "
"дії або іншим чином поводитися по-іншому."

msgid ""
"The following macros are normally used without a trailing semicolon; look "
"for example usage in the Python source distribution."
msgstr ""
"Наступні макроси зазвичай використовуються без крапки з комою в кінці; "
"подивіться, наприклад, використання в вихідному дистрибутиві Python."

msgid ""
"This macro expands to ``{ PyThreadState *_save; _save = PyEval_SaveThread();"
"``. Note that it contains an opening brace; it must be matched with a "
"following :c:macro:`Py_END_ALLOW_THREADS` macro.  See above for further "
"discussion of this macro."
msgstr ""
"Цей макрос розширюється до ``{ PyThreadState *_save; _save = "
"PyEval_SaveThread();``. Зауважте, що він містить відкриваючу дужку; він "
"повинен відповідати наступному макросу :c:macro:`Py_END_ALLOW_THREADS`. "
"Дивіться вище для подальшого обговорення цього макросу."

msgid ""
"This macro expands to ``PyEval_RestoreThread(_save); }``. Note that it "
"contains a closing brace; it must be matched with an earlier :c:macro:"
"`Py_BEGIN_ALLOW_THREADS` macro.  See above for further discussion of this "
"macro."
msgstr ""
"Цей макрос розширюється до ``PyEval_RestoreThread(_save); }``. Зверніть "
"увагу, що він містить закриваючу дужку; він повинен відповідати попередньому "
"макросу :c:macro:`Py_BEGIN_ALLOW_THREADS`. Дивіться вище для подальшого "
"обговорення цього макросу."

msgid ""
"This macro expands to ``PyEval_RestoreThread(_save);``: it is equivalent to :"
"c:macro:`Py_END_ALLOW_THREADS` without the closing brace."
msgstr ""
"Цей макрос розширюється до ``PyEval_RestoreThread(_save);``: він "
"еквівалентний :c:macro:`Py_END_ALLOW_THREADS` без закриваючої дужки."

msgid ""
"This macro expands to ``_save = PyEval_SaveThread();``: it is equivalent to :"
"c:macro:`Py_BEGIN_ALLOW_THREADS` without the opening brace and variable "
"declaration."
msgstr ""
"Цей макрос розширюється до ``_save = PyEval_SaveThread();``: він "
"еквівалентний :c:macro:`Py_BEGIN_ALLOW_THREADS` без відкриваючої дужки та "
"оголошення змінної."

msgid "Low-level API"
msgstr "API низького рівня"

msgid ""
"All of the following functions must be called after :c:func:`Py_Initialize`."
msgstr ""
"Усі наведені нижче функції мають викликатися після :c:func:`Py_Initialize`."

msgid ":c:func:`Py_Initialize()` now initializes the :term:`GIL`."
msgstr ":c:func:`Py_Initialize()` тепер ініціалізує :term:`GIL`."

msgid ""
"Create a new interpreter state object.  The global interpreter lock need not "
"be held, but may be held if it is necessary to serialize calls to this "
"function."
msgstr ""
"Створіть новий об’єкт стану інтерпретатора. Глобальне блокування "
"інтерпретатора не потрібно утримувати, але можна утримувати, якщо необхідно "
"серіалізувати виклики цієї функції."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"PyInterpreterState_New`` with no arguments."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``cpython.PyInterpreterState_New`` "
"без аргументів."

msgid ""
"Reset all information in an interpreter state object.  The global "
"interpreter lock must be held."
msgstr ""
"Скинути всю інформацію в об’єкті стану інтерпретатора. Необхідно утримувати "
"глобальне блокування інтерпретатора."

msgid ""
"Raises an :ref:`auditing event <auditing>` ``cpython."
"PyInterpreterState_Clear`` with no arguments."
msgstr ""
"Викликає :ref:`подію аудиту <auditing>` ``cpython.PyInterpreterState_Clear`` "
"без аргументів."

msgid ""
"Destroy an interpreter state object.  The global interpreter lock need not "
"be held.  The interpreter state must have been reset with a previous call "
"to :c:func:`PyInterpreterState_Clear`."
msgstr ""
"Знищити об’єкт стану інтерпретатора. Глобальне блокування інтерпретатора не "
"потрібно утримувати. Стан інтерпретатора має бути скинуто за допомогою "
"попереднього виклику :c:func:`PyInterpreterState_Clear`."

msgid ""
"Create a new thread state object belonging to the given interpreter object. "
"The global interpreter lock need not be held, but may be held if it is "
"necessary to serialize calls to this function."
msgstr ""
"Створіть новий об’єкт стану потоку, що належить даному об’єкту "
"інтерпретатора. Глобальне блокування інтерпретатора не потрібно утримувати, "
"але можна утримувати, якщо необхідно серіалізувати виклики цієї функції."

msgid ""
"Reset all information in a thread state object.  The global interpreter lock "
"must be held."
msgstr ""
"Скинути всю інформацію в об’єкті стану потоку. Необхідно утримувати "
"глобальне блокування інтерпретатора."

msgid ""
"This function now calls the :c:member:`PyThreadState.on_delete` callback. "
"Previously, that happened in :c:func:`PyThreadState_Delete`."
msgstr ""
"Ця функція тепер викликає зворотний виклик :c:member:`PyThreadState."
"on_delete`. Раніше це траплялося в :c:func:`PyThreadState_Delete`."

msgid ""
"Destroy a thread state object.  The global interpreter lock need not be "
"held. The thread state must have been reset with a previous call to :c:func:"
"`PyThreadState_Clear`."
msgstr ""
"Знищити об’єкт стану потоку. Глобальне блокування інтерпретатора не потрібно "
"утримувати. Стан потоку має бути скинуто попереднім викликом :c:func:"
"`PyThreadState_Clear`."

msgid ""
"Destroy the current thread state and release the global interpreter lock. "
"Like :c:func:`PyThreadState_Delete`, the global interpreter lock need not be "
"held. The thread state must have been reset with a previous call to :c:func:"
"`PyThreadState_Clear`."
msgstr ""
"Знищити поточний стан потоку та зняти глобальне блокування інтерпретатора. "
"Як і :c:func:`PyThreadState_Delete`, глобальне блокування інтерпретатора не "
"потрібно утримувати. Стан потоку має бути скинуто попереднім викликом :c:"
"func:`PyThreadState_Clear`."

msgid "Get the current frame of the Python thread state *tstate*."
msgstr "Отримати поточний кадр стану потоку Python *tstate*."

msgid ""
"Return a :term:`strong reference`. Return ``NULL`` if no frame is currently "
"executing."
msgstr ""
"Повертає :term:`strong reference`. Повертає ``NULL``, якщо наразі не "
"виконується жоден кадр."

msgid "See also :c:func:`PyEval_GetFrame`."
msgstr "Дивіться також :c:func:`PyEval_GetFrame`."

msgid "*tstate* must not be ``NULL``."
msgstr "*tstate* не має бути ``NULL``."

msgid ""
"Get the unique thread state identifier of the Python thread state *tstate*."
msgstr "Отримайте унікальний ідентифікатор стану потоку Python *tstate*."

msgid "Get the interpreter of the Python thread state *tstate*."
msgstr "Отримайте інтерпретатор стану потоку Python *tstate*."

msgid "Suspend tracing and profiling in the Python thread state *tstate*."
msgstr ""

msgid "Resume them using the :c:func:`PyThreadState_LeaveTracing` function."
msgstr ""

msgid ""
"Resume tracing and profiling in the Python thread state *tstate* suspended "
"by the :c:func:`PyThreadState_EnterTracing` function."
msgstr ""

msgid ""
"See also :c:func:`PyEval_SetTrace` and :c:func:`PyEval_SetProfile` functions."
msgstr ""

msgid "Get the current interpreter."
msgstr "Отримати поточний перекладач."

msgid ""
"Issue a fatal error if there no current Python thread state or no current "
"interpreter. It cannot return NULL."
msgstr ""
"Видає фатальну помилку, якщо немає поточного стану потоку Python або "
"поточного інтерпретатора. Він не може повертати NULL."

msgid "The caller must hold the GIL."
msgstr "Абонент повинен тримати GIL."

msgid ""
"Return the interpreter's unique ID.  If there was any error in doing so then "
"``-1`` is returned and an error is set."
msgstr ""
"Повернути унікальний ідентифікатор перекладача. Якщо під час цього сталася "
"якась помилка, повертається ``-1`` і встановлюється помилка."

msgid ""
"Return a dictionary in which interpreter-specific data may be stored. If "
"this function returns ``NULL`` then no exception has been raised and the "
"caller should assume no interpreter-specific dict is available."
msgstr ""
"Повертає словник, у якому можуть зберігатися дані інтерпретатора. Якщо ця "
"функція повертає ``NULL``, це означає, що жодного винятку не було викликано, "
"і абонент повинен припустити, що недоступний dict інтерпретатора."

msgid ""
"This is not a replacement for :c:func:`PyModule_GetState()`, which "
"extensions should use to store interpreter-specific state information."
msgstr ""
"Це не заміна :c:func:`PyModule_GetState()`, який розширення мають "
"використовувати для зберігання інформації про стан інтерпретатора."

msgid "Type of a frame evaluation function."
msgstr "Тип функції оцінки фрейму."

msgid ""
"The *throwflag* parameter is used by the ``throw()`` method of generators: "
"if non-zero, handle the current exception."
msgstr ""
"Параметр *throwflag* використовується методом ``throw()`` генераторів: якщо "
"він відмінний від нуля, обробити поточний виняток."

msgid "The function now takes a *tstate* parameter."
msgstr "Тепер функція приймає параметр *tstate*."

msgid ""
"The *frame* parameter changed from ``PyFrameObject*`` to "
"``_PyInterpreterFrame*``."
msgstr ""

msgid "Get the frame evaluation function."
msgstr "Отримати функцію оцінки фрейму."

msgid "See the :pep:`523` \"Adding a frame evaluation API to CPython\"."
msgstr "Перегляньте :pep:`523` \"Додавання API оцінки фрейму до CPython\"."

msgid "Set the frame evaluation function."
msgstr "Встановіть функцію оцінки кадру."

msgid ""
"Return a dictionary in which extensions can store thread-specific state "
"information.  Each extension should use a unique key to use to store state "
"in the dictionary.  It is okay to call this function when no current thread "
"state is available. If this function returns ``NULL``, no exception has been "
"raised and the caller should assume no current thread state is available."
msgstr ""
"Повертає словник, у якому розширення можуть зберігати інформацію про стан "
"потоку. Кожне розширення має використовувати унікальний ключ для збереження "
"стану в словнику. Цю функцію можна викликати, якщо поточний стан потоку "
"недоступний. Якщо ця функція повертає ``NULL``, це означає, що жодного "
"винятку не було викликано, і абонент повинен вважати, що поточний стан "
"потоку недоступний."

msgid ""
"Asynchronously raise an exception in a thread. The *id* argument is the "
"thread id of the target thread; *exc* is the exception object to be raised. "
"This function does not steal any references to *exc*. To prevent naive "
"misuse, you must write your own C extension to call this.  Must be called "
"with the GIL held. Returns the number of thread states modified; this is "
"normally one, but will be zero if the thread id isn't found.  If *exc* is :"
"const:`NULL`, the pending exception (if any) for the thread is cleared. This "
"raises no exceptions."
msgstr ""
"Асинхронно викликати виняток у потоці. Аргумент *id* — це ідентифікатор "
"цільового потоку; *exc* — об’єкт винятку, який потрібно викликати. Ця "
"функція не викрадає жодних посилань на *exc*. Щоб запобігти простому "
"неправильному використанню, ви повинні написати власне розширення C для "
"виклику цього. Потрібно викликати з GIL. Повертає кількість змінених станів "
"потоку; зазвичай це одиниця, але буде нулем, якщо ідентифікатор потоку не "
"знайдено. Якщо *exc* дорівнює :const:`NULL`, незавершений виняток (якщо є) "
"для потоку очищається. Це не викликає винятків."

msgid ""
"The type of the *id* parameter changed from :c:expr:`long` to :c:expr:"
"`unsigned long`."
msgstr ""

msgid ""
"Acquire the global interpreter lock and set the current thread state to "
"*tstate*, which must not be ``NULL``.  The lock must have been created "
"earlier. If this thread already has the lock, deadlock ensues."
msgstr ""
"Отримайте глобальне блокування інтерпретатора та встановіть поточний стан "
"потоку на *tstate*, який не має бути ``NULL``. Замок повинен бути створений "
"раніше. Якщо цей потік уже має блокування, виникає взаємоблокування."

msgid ""
"Updated to be consistent with :c:func:`PyEval_RestoreThread`, :c:func:"
"`Py_END_ALLOW_THREADS`, and :c:func:`PyGILState_Ensure`, and terminate the "
"current thread if called while the interpreter is finalizing."
msgstr ""
"Оновлено для узгодження з :c:func:`PyEval_RestoreThread`, :c:func:"
"`Py_END_ALLOW_THREADS` і :c:func:`PyGILState_Ensure`, а також завершує "
"поточний потік, якщо він викликається, поки інтерпретатор завершує роботу."

msgid ""
":c:func:`PyEval_RestoreThread` is a higher-level function which is always "
"available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_RestoreThread` — це функція вищого рівня, яка завжди "
"доступна (навіть якщо потоки не ініціалізовано)."

msgid ""
"Reset the current thread state to ``NULL`` and release the global "
"interpreter lock.  The lock must have been created earlier and must be held "
"by the current thread.  The *tstate* argument, which must not be ``NULL``, "
"is only used to check that it represents the current thread state --- if it "
"isn't, a fatal error is reported."
msgstr ""
"Скиньте поточний стан потоку на ``NULL`` і звільніть глобальне блокування "
"інтерпретатора. Блокування має бути створено раніше та утримуватися поточним "
"потоком. Аргумент *tstate*, який не має бути ``NULL``, використовується лише "
"для перевірки того, що він представляє поточний стан потоку --- якщо це не "
"так, повідомляється про фатальну помилку."

msgid ""
":c:func:`PyEval_SaveThread` is a higher-level function which is always "
"available (even when threads have not been initialized)."
msgstr ""
":c:func:`PyEval_SaveThread` — це функція вищого рівня, яка завжди доступна "
"(навіть якщо потоки не ініціалізовано)."

msgid ""
"Acquire the global interpreter lock.  The lock must have been created "
"earlier. If this thread already has the lock, a deadlock ensues."
msgstr ""
"Отримайте глобальне блокування інтерпретатора. Замок повинен бути створений "
"раніше. Якщо цей потік уже має блокування, виникає взаємоблокування."

msgid ""
"This function does not update the current thread state.  Please use :c:func:"
"`PyEval_RestoreThread` or :c:func:`PyEval_AcquireThread` instead."
msgstr ""
"Ця функція не оновлює поточний стан потоку. Натомість використовуйте :c:func:"
"`PyEval_RestoreThread` або :c:func:`PyEval_AcquireThread`."

msgid ""
"Release the global interpreter lock.  The lock must have been created "
"earlier."
msgstr ""
"Звільніть глобальне блокування інтерпретатора. Замок повинен бути створений "
"раніше."

msgid ""
"This function does not update the current thread state.  Please use :c:func:"
"`PyEval_SaveThread` or :c:func:`PyEval_ReleaseThread` instead."
msgstr ""
"Ця функція не оновлює поточний стан потоку. Натомість використовуйте :c:func:"
"`PyEval_SaveThread` або :c:func:`PyEval_ReleaseThread`."

msgid "Sub-interpreter support"
msgstr "Підтримка субінтерпретатора"

msgid ""
"While in most uses, you will only embed a single Python interpreter, there "
"are cases where you need to create several independent interpreters in the "
"same process and perhaps even in the same thread. Sub-interpreters allow you "
"to do that."
msgstr ""
"Хоча в більшості випадків ви вбудовуєте лише один інтерпретатор Python, є "
"випадки, коли вам потрібно створити кілька незалежних інтерпретаторів в "
"одному процесі і, можливо, навіть в одному потоці. Суб-інтерпретатори "
"дозволяють це зробити."

msgid ""
"The \"main\" interpreter is the first one created when the runtime "
"initializes. It is usually the only Python interpreter in a process.  Unlike "
"sub-interpreters, the main interpreter has unique process-global "
"responsibilities like signal handling.  It is also responsible for execution "
"during runtime initialization and is usually the active interpreter during "
"runtime finalization.  The :c:func:`PyInterpreterState_Main` function "
"returns a pointer to its state."
msgstr ""
"\"Головний\" інтерпретатор є першим, який створюється під час ініціалізації "
"середовища виконання. Зазвичай це єдиний інтерпретатор Python у процесі. На "
"відміну від субінтерпретаторів, головний інтерпретатор має унікальні "
"глобальні обов’язки процесу, такі як обробка сигналів. Він також відповідає "
"за виконання під час ініціалізації середовища виконання та зазвичай є "
"активним інтерпретатором під час завершення виконання. Функція :c:func:"
"`PyInterpreterState_Main` повертає вказівник на його стан."

msgid ""
"You can switch between sub-interpreters using the :c:func:"
"`PyThreadState_Swap` function. You can create and destroy them using the "
"following functions:"
msgstr ""
"Ви можете перемикатися між підінтерпретаторами за допомогою функції :c:func:"
"`PyThreadState_Swap`. Ви можете створювати та знищувати їх за допомогою "
"таких функцій:"

msgid ""
"Create a new sub-interpreter.  This is an (almost) totally separate "
"environment for the execution of Python code.  In particular, the new "
"interpreter has separate, independent versions of all imported modules, "
"including the fundamental modules :mod:`builtins`, :mod:`__main__` and :mod:"
"`sys`.  The table of loaded modules (``sys.modules``) and the module search "
"path (``sys.path``) are also separate.  The new environment has no ``sys."
"argv`` variable.  It has new standard I/O stream file objects ``sys.stdin``, "
"``sys.stdout`` and ``sys.stderr`` (however these refer to the same "
"underlying file descriptors)."
msgstr ""
"Створіть новий підінтерпретатор. Це (майже) повністю окреме середовище для "
"виконання коду Python. Зокрема, новий інтерпретатор має окремі незалежні "
"версії всіх імпортованих модулів, включаючи фундаментальні модулі :mod:"
"`builtins`, :mod:`__main__` і :mod:`sys`. Таблиця завантажених модулів "
"(``sys.modules``) і шлях пошуку модуля (``sys.path``) також окремі. Нове "
"середовище не має змінної ``sys.argv``. Він має нові стандартні файлові "
"об’єкти потоку вводу/виводу ``sys.stdin``, ``sys.stdout`` і ``sys.stderr`` "
"(однак вони посилаються на ті самі основні дескриптори файлів)."

msgid ""
"The return value points to the first thread state created in the new sub-"
"interpreter.  This thread state is made in the current thread state. Note "
"that no actual thread is created; see the discussion of thread states "
"below.  If creation of the new interpreter is unsuccessful, ``NULL`` is "
"returned; no exception is set since the exception state is stored in the "
"current thread state and there may not be a current thread state.  (Like all "
"other Python/C API functions, the global interpreter lock must be held "
"before calling this function and is still held when it returns; however, "
"unlike most other Python/C API functions, there needn't be a current thread "
"state on entry.)"
msgstr ""
"Повернене значення вказує на перший стан потоку, створений у новому "
"підінтерпретаторі. Цей стан потоку створюється в поточному стані потоку. "
"Зауважте, що фактичний потік не створюється; дивіться обговорення станів "
"потоку нижче. Якщо створення нового інтерпретатора не вдається, повертається "
"``NULL``; виняток не встановлено, оскільки стан винятку зберігається в "
"поточному стані потоку, і поточного стану потоку може не бути. (Як і всі "
"інші функції Python/C API, глобальне блокування інтерпретатора має бути "
"утримано перед викликом цієї функції та все ще утримується, коли вона "
"повертається; однак, на відміну від більшості інших функцій Python/C API, не "
"потрібно мати поточний стан потоку на вхід.)"

msgid "Extension modules are shared between (sub-)interpreters as follows:"
msgstr ""
"Модулі розширення розподіляються між (під)інтерпретаторами наступним чином:"

msgid ""
"For modules using multi-phase initialization, e.g. :c:func:"
"`PyModule_FromDefAndSpec`, a separate module object is created and "
"initialized for each interpreter. Only C-level static and global variables "
"are shared between these module objects."
msgstr ""
"Для модулів, які використовують багатофазову ініціалізацію, напр. :c:func:"
"`PyModule_FromDefAndSpec`, окремий об’єкт модуля створюється та "
"ініціалізується для кожного інтерпретатора. Лише статичні та глобальні "
"змінні рівня C використовуються між цими об’єктами модуля."

msgid ""
"For modules using single-phase initialization, e.g. :c:func:"
"`PyModule_Create`, the first time a particular extension is imported, it is "
"initialized normally, and a (shallow) copy of its module's dictionary is "
"squirreled away. When the same extension is imported by another "
"(sub-)interpreter, a new module is initialized and filled with the contents "
"of this copy; the extension's ``init`` function is not called. Objects in "
"the module's dictionary thus end up shared across (sub-)interpreters, which "
"might cause unwanted behavior (see `Bugs and caveats`_ below)."
msgstr ""
"Для модулів, які використовують однофазну ініціалізацію, напр. :c:func:"
"`PyModule_Create`, коли конкретне розширення імпортується вперше, воно "
"ініціалізується звичайним чином, а (неглибока) копія словника його модуля "
"видаляється. Коли те саме розширення імпортується іншим "
"(під)інтерпретатором, новий модуль ініціалізується та заповнюється вмістом "
"цієї копії; функція ``init`` розширення не викликається. Таким чином, "
"об’єкти в словнику модуля розподіляються між (суб-)інтерпретаторами, що може "
"спричинити небажану поведінку (див. `Bugs and caveats`_  нижче)."

msgid ""
"Note that this is different from what happens when an extension is imported "
"after the interpreter has been completely re-initialized by calling :c:func:"
"`Py_FinalizeEx` and :c:func:`Py_Initialize`; in that case, the extension's "
"``initmodule`` function *is* called again. As with multi-phase "
"initialization, this means that only C-level static and global variables are "
"shared between these modules."
msgstr ""
"Зауважте, що це відрізняється від того, що відбувається, коли розширення "
"імпортується після повної повторної ініціалізації інтерпретатора викликом :c:"
"func:`Py_FinalizeEx` і :c:func:`Py_Initialize`; у цьому випадку функція "
"``initmodule`` розширення *викликається* знову. Як і у випадку з "
"багатофазною ініціалізацією, це означає, що ці модулі спільно використовують "
"лише статичні та глобальні змінні рівня C."

msgid ""
"Destroy the (sub-)interpreter represented by the given thread state. The "
"given thread state must be the current thread state.  See the discussion of "
"thread states below.  When the call returns, the current thread state is "
"``NULL``.  All thread states associated with this interpreter are "
"destroyed.  (The global interpreter lock must be held before calling this "
"function and is still held when it returns.)  :c:func:`Py_FinalizeEx` will "
"destroy all sub-interpreters that haven't been explicitly destroyed at that "
"point."
msgstr ""
"Знищити (суб-)інтерпретатор, представлений даним станом потоку. Даний стан "
"потоку має бути поточним станом потоку. Дивіться обговорення станів потоку "
"нижче. Коли виклик повертається, поточний стан потоку ``NULL``. Усі стани "
"потоку, пов’язані з цим інтерпретатором, знищуються. (Глобальне блокування "
"інтерпретатора має бути утримано перед викликом цієї функції та все ще "
"утримується, коли вона повертається.) :c:func:`Py_FinalizeEx` знищить усі "
"підінтерпретатори, які не були явно знищені на цьому етапі."

msgid "Bugs and caveats"
msgstr "Помилки та застереження"

msgid ""
"Because sub-interpreters (and the main interpreter) are part of the same "
"process, the insulation between them isn't perfect --- for example, using "
"low-level file operations like  :func:`os.close` they can (accidentally or "
"maliciously) affect each other's open files.  Because of the way extensions "
"are shared between (sub-)interpreters, some extensions may not work "
"properly; this is especially likely when using single-phase initialization "
"or (static) global variables. It is possible to insert objects created in "
"one sub-interpreter into a namespace of another (sub-)interpreter; this "
"should be avoided if possible."
msgstr ""
"Оскільки субінтерпретатори (і головний інтерпретатор) є частиною одного "
"процесу, ізоляція між ними не є ідеальною --- наприклад, використовуючи "
"низькорівневі файлові операції, такі як :func:`os.close`, вони можуть "
"(випадково або зловмисно) впливають на відкриті файли один одного. Через те, "
"як розширення розподіляються між (під)інтерпретаторами, деякі розширення "
"можуть не працювати належним чином; це особливо ймовірно при використанні "
"однофазної ініціалізації або (статичних) глобальних змінних. Можна вставляти "
"об’єкти, створені в одному суб-інтерпретаторі, у простір імен іншого "
"(суб-)інтерпретатора; цього слід уникати, якщо це можливо."

msgid ""
"Special care should be taken to avoid sharing user-defined functions, "
"methods, instances or classes between sub-interpreters, since import "
"operations executed by such objects may affect the wrong (sub-)interpreter's "
"dictionary of loaded modules. It is equally important to avoid sharing "
"objects from which the above are reachable."
msgstr ""
"Слід приділяти особливу увагу уникненню спільного використання визначених "
"користувачем функцій, методів, екземплярів або класів між "
"підінтерпретаторами, оскільки операції імпорту, які виконуються такими "
"об’єктами, можуть вплинути на неправильний (під)інтерпретатор словник "
"завантажених модулів. Не менш важливо уникати спільного використання "
"об’єктів, з яких доступні вищевказані."

msgid ""
"Also note that combining this functionality with ``PyGILState_*`` APIs is "
"delicate, because these APIs assume a bijection between Python thread states "
"and OS-level threads, an assumption broken by the presence of sub-"
"interpreters. It is highly recommended that you don't switch sub-"
"interpreters between a pair of matching :c:func:`PyGILState_Ensure` and :c:"
"func:`PyGILState_Release` calls. Furthermore, extensions (such as :mod:"
"`ctypes`) using these APIs to allow calling of Python code from non-Python "
"created threads will probably be broken when using sub-interpreters."
msgstr ""

msgid "Asynchronous Notifications"
msgstr "Асинхронні сповіщення"

msgid ""
"A mechanism is provided to make asynchronous notifications to the main "
"interpreter thread.  These notifications take the form of a function pointer "
"and a void pointer argument."
msgstr ""
"Надається механізм для створення асинхронних сповіщень головному потоку "
"інтерпретатора. Ці сповіщення приймають форму вказівника функції та "
"аргументу вказівника void."

msgid ""
"Schedule a function to be called from the main interpreter thread.  On "
"success, ``0`` is returned and *func* is queued for being called in the main "
"thread.  On failure, ``-1`` is returned without setting any exception."
msgstr ""
"Заплануйте виклик функції з основного потоку інтерпретатора. У разі успіху "
"повертається ``0`` і *func* ставиться в чергу для виклику в основному "
"потоці. У разі помилки повертається ``-1`` без встановлення винятків."

msgid ""
"When successfully queued, *func* will be *eventually* called from the main "
"interpreter thread with the argument *arg*.  It will be called "
"asynchronously with respect to normally running Python code, but with both "
"these conditions met:"
msgstr ""
"Після успішного розміщення в черзі *func* буде *зрештою* викликано з "
"основного потоку інтерпретатора з аргументом *arg*. Його буде викликано "
"асинхронно щодо нормально запущеного коду Python, але з дотриманням обох цих "
"умов:"

msgid "on a :term:`bytecode` boundary;"
msgstr "на межі :term:`bytecode`;"

msgid ""
"with the main thread holding the :term:`global interpreter lock` (*func* can "
"therefore use the full C API)."
msgstr ""
"з головним потоком, який утримує :term:`global interpreter lock` (*func* "
"може використовувати повний C API)."

msgid ""
"*func* must return ``0`` on success, or ``-1`` on failure with an exception "
"set.  *func* won't be interrupted to perform another asynchronous "
"notification recursively, but it can still be interrupted to switch threads "
"if the global interpreter lock is released."
msgstr ""
"*func* має повернути ``0`` у разі успіху або ``-1`` у разі помилки з набором "
"винятків. *func* не буде перервано для рекурсивного виконання іншого "
"асинхронного сповіщення, але його все одно можна перервати для перемикання "
"потоків, якщо глобальне блокування інтерпретатора звільнено."

msgid ""
"This function doesn't need a current thread state to run, and it doesn't "
"need the global interpreter lock."
msgstr ""
"Цій функції не потрібен поточний стан потоку для запуску, і їй не потрібне "
"блокування глобального інтерпретатора."

msgid ""
"To call this function in a subinterpreter, the caller must hold the GIL. "
"Otherwise, the function *func* can be scheduled to be called from the wrong "
"interpreter."
msgstr ""
"Щоб викликати цю функцію в підінтерпретаторі, абонент, що викликає, повинен "
"мати GIL. В іншому випадку функція *func* може бути запланована для виклику "
"з неправильного інтерпретатора."

msgid ""
"This is a low-level function, only useful for very special cases. There is "
"no guarantee that *func* will be called as quick as possible.  If the main "
"thread is busy executing a system call, *func* won't be called before the "
"system call returns.  This function is generally **not** suitable for "
"calling Python code from arbitrary C threads.  Instead, use the :ref:"
"`PyGILState API<gilstate>`."
msgstr ""
"Це функція низького рівня, корисна лише в дуже особливих випадках. Немає "
"гарантії, що *func* буде викликано якомога швидше. Якщо основний потік "
"зайнятий виконанням системного виклику, *func* не буде викликано до "
"повернення системного виклику. Ця функція зазвичай **не** підходить для "
"виклику коду Python із довільних потоків C. Замість цього використовуйте :"
"ref:`PyGILState API <gilstate>`."

msgid ""
"If this function is called in a subinterpreter, the function *func* is now "
"scheduled to be called from the subinterpreter, rather than being called "
"from the main interpreter. Each subinterpreter now has its own list of "
"scheduled calls."
msgstr ""
"Якщо ця функція викликається у підінтерпретаторі, функція *func* тепер "
"запланована для виклику з підінтерпретатора, а не з основного "
"інтерпретатора. Кожен субінтерпретатор тепер має власний список запланованих "
"викликів."

msgid "Profiling and Tracing"
msgstr "Профілювання та трасування"

msgid ""
"The Python interpreter provides some low-level support for attaching "
"profiling and execution tracing facilities.  These are used for profiling, "
"debugging, and coverage analysis tools."
msgstr ""
"Інтерпретатор Python надає деяку низькорівневу підтримку для підключення "
"засобів профілювання та трасування виконання. Вони використовуються для "
"інструментів профілювання, налагодження та аналізу покриття."

msgid ""
"This C interface allows the profiling or tracing code to avoid the overhead "
"of calling through Python-level callable objects, making a direct C function "
"call instead.  The essential attributes of the facility have not changed; "
"the interface allows trace functions to be installed per-thread, and the "
"basic events reported to the trace function are the same as had been "
"reported to the Python-level trace functions in previous versions."
msgstr ""
"Цей інтерфейс C дозволяє коду профілювання або трасування уникнути накладних "
"витрат на виклик через викликані об’єкти на рівні Python, замість цього "
"здійснюючи прямий виклик функції C. Основні атрибути закладу не змінилися; "
"інтерфейс дозволяє встановлювати функції трасування для кожного потоку, а "
"основні події, які повідомляються у функцію трасування, є такими самими, як "
"повідомлялося функціям трасування на рівні Python у попередніх версіях."

msgid ""
"The type of the trace function registered using :c:func:`PyEval_SetProfile` "
"and :c:func:`PyEval_SetTrace`. The first parameter is the object passed to "
"the registration function as *obj*, *frame* is the frame object to which the "
"event pertains, *what* is one of the constants :const:`PyTrace_CALL`, :const:"
"`PyTrace_EXCEPTION`, :const:`PyTrace_LINE`, :const:`PyTrace_RETURN`, :const:"
"`PyTrace_C_CALL`, :const:`PyTrace_C_EXCEPTION`, :const:`PyTrace_C_RETURN`, "
"or :const:`PyTrace_OPCODE`, and *arg* depends on the value of *what*:"
msgstr ""
"Тип функції трасування, зареєстрованої за допомогою :c:func:"
"`PyEval_SetProfile` і :c:func:`PyEval_SetTrace`. Перший параметр — це "
"об’єкт, переданий у функцію реєстрації як *obj*, *frame* — об’єкт фрейму, до "
"якого відноситься подія, *what* — одна з констант :const:`PyTrace_CALL`, :"
"const:`PyTrace_EXCEPTION` , :const:`PyTrace_LINE`, :const:`PyTrace_RETURN`, :"
"const:`PyTrace_C_CALL`, :const:`PyTrace_C_EXCEPTION`, :const:"
"`PyTrace_C_RETURN` або :const:`PyTrace_OPCODE`, і *arg* залежить від "
"значення *що*:"

msgid "Value of *what*"
msgstr "Значення *чого*"

msgid "Meaning of *arg*"
msgstr "Значення *arg*"

msgid ":const:`PyTrace_CALL`"
msgstr ":const:`PyTrace_CALL`"

msgid "Always :c:data:`Py_None`."
msgstr "Завжди :c:data:`Py_None`."

msgid ":const:`PyTrace_EXCEPTION`"
msgstr ":const:`PyTrace_EXCEPTION`"

msgid "Exception information as returned by :func:`sys.exc_info`."
msgstr "Інформація про винятки, яку повертає :func:`sys.exc_info`."

msgid ":const:`PyTrace_LINE`"
msgstr ":const:`PyTrace_LINE`"

msgid ":const:`PyTrace_RETURN`"
msgstr ":const:`PyTrace_RETURN`"

msgid ""
"Value being returned to the caller, or ``NULL`` if caused by an exception."
msgstr ""
"Значення, що повертається абоненту, або ``NULL``, якщо викликано винятком."

msgid ":const:`PyTrace_C_CALL`"
msgstr ":const:`PyTrace_C_CALL`"

msgid "Function object being called."
msgstr "Об’єкт функції, що викликається."

msgid ":const:`PyTrace_C_EXCEPTION`"
msgstr ":const:`PyTrace_C_EXCEPTION`"

msgid ":const:`PyTrace_C_RETURN`"
msgstr ":const:`PyTrace_C_RETURN`"

msgid ":const:`PyTrace_OPCODE`"
msgstr ":const:`PyTrace_OPCODE`"

msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"a new call to a function or method is being reported, or a new entry into a "
"generator. Note that the creation of the iterator for a generator function "
"is not reported as there is no control transfer to the Python bytecode in "
"the corresponding frame."
msgstr ""
"Значення параметра *what* для функції :c:type:`Py_tracefunc`, коли "
"повідомляється про новий виклик функції чи методу або новий запис у "
"генераторі. Зауважте, що створення ітератора для функції генератора не "
"повідомляється, оскільки немає передачі керування до байт-коду Python у "
"відповідному кадрі."

msgid ""
"The value of the *what* parameter to a :c:type:`Py_tracefunc` function when "
"an exception has been raised.  The callback function is called with this "
"value for *what* when after any bytecode is processed after which the "
"exception becomes set within the frame being executed.  The effect of this "
"is that as exception propagation causes the Python stack to unwind, the "
"callback is called upon return to each frame as the exception propagates.  "
"Only trace functions receives these events; they are not needed by the "
"profiler."
msgstr ""
"Значення параметра *what* для функції :c:type:`Py_tracefunc`, коли виникає "
"виняткова ситуація. Функція зворотного виклику викликається з цим значенням "
"для *what*, коли після обробки будь-якого байт-коду, після чого виняток стає "
"встановленим у кадрі, що виконується. Наслідком цього є те, що коли "
"розповсюдження винятку спричиняє розгортання стека Python, зворотний виклик "
"викликається після повернення до кожного кадру під час поширення винятку. "
"Лише функції трасування отримують ці події; вони не потрібні профайлеру."

msgid ""
"The value passed as the *what* parameter to a :c:type:`Py_tracefunc` "
"function (but not a profiling function) when a line-number event is being "
"reported. It may be disabled for a frame by setting :attr:`f_trace_lines` to "
"*0* on that frame."
msgstr ""
"Значення, передане як параметр *what* до функції :c:type:`Py_tracefunc` (але "
"не функції профілювання), коли повідомляється про подію номера рядка. Його "
"можна вимкнути для кадру, встановивши :attr:`f_trace_lines` на *0* для цього "
"кадру."

msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a call is about to return."
msgstr ""
"Значення для параметра *what* для :c:type:`Py_tracefunc` функціонує, коли "
"виклик збирається повернутися."

msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function is about to be called."
msgstr ""
"Значення параметра *what* для функцій :c:type:`Py_tracefunc`, коли має бути "
"викликана функція C."

msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has raised an exception."
msgstr ""
"Значення для параметра *what* для функцій :c:type:`Py_tracefunc`, коли "
"функція C викликала виняткову ситуацію."

msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions when "
"a C function has returned."
msgstr ""
"Значення для параметра *what* для функцій :c:type:`Py_tracefunc`, коли "
"функція C повертає."

msgid ""
"The value for the *what* parameter to :c:type:`Py_tracefunc` functions (but "
"not profiling functions) when a new opcode is about to be executed.  This "
"event is not emitted by default: it must be explicitly requested by setting :"
"attr:`f_trace_opcodes` to *1* on the frame."
msgstr ""
"Значення параметра *what* для функцій :c:type:`Py_tracefunc` (але не для "
"функцій профілювання), коли має бути виконано новий код операції. Ця подія "
"не генерується за замовчуванням: її потрібно явно запитати, встановивши для :"
"attr:`f_trace_opcodes` значення *1* у кадрі."

msgid ""
"Set the profiler function to *func*.  The *obj* parameter is passed to the "
"function as its first parameter, and may be any Python object, or ``NULL``.  "
"If the profile function needs to maintain state, using a different value for "
"*obj* for each thread provides a convenient and thread-safe place to store "
"it.  The profile function is called for all monitored events except :const:"
"`PyTrace_LINE` :const:`PyTrace_OPCODE` and :const:`PyTrace_EXCEPTION`."
msgstr ""
"Встановіть для функції профайлера значення *func*. Параметр *obj* "
"передається функції як її перший параметр і може бути будь-яким об’єктом "
"Python або ``NULL``. Якщо функція профілю потребує підтримки стану, "
"використання іншого значення для *obj* для кожного потоку забезпечує зручне "
"та безпечне для потоку місце для його зберігання. Функція профілю "
"викликається для всіх відстежуваних подій, крім :const:`PyTrace_LINE` :const:"
"`PyTrace_OPCODE` і :const:`PyTrace_EXCEPTION`."

msgid "See also the :func:`sys.setprofile` function."
msgstr ""

msgid "The caller must hold the :term:`GIL`."
msgstr "Абонент повинен утримувати :term:`GIL`."

msgid ""
"Set the tracing function to *func*.  This is similar to :c:func:"
"`PyEval_SetProfile`, except the tracing function does receive line-number "
"events and per-opcode events, but does not receive any event related to C "
"function objects being called.  Any trace function registered using :c:func:"
"`PyEval_SetTrace` will not receive :const:`PyTrace_C_CALL`, :const:"
"`PyTrace_C_EXCEPTION` or :const:`PyTrace_C_RETURN` as a value for the *what* "
"parameter."
msgstr ""
"Встановіть для функції трасування значення *func*. Це схоже на :c:func:"
"`PyEval_SetProfile`, за винятком того, що функція трасування отримує події "
"номерів рядків і події кожного коду операції, але не отримує жодних подій, "
"пов’язаних із викликом об’єктів функції C. Будь-яка функція трасування, "
"зареєстрована за допомогою :c:func:`PyEval_SetTrace`, не отримає :const:"
"`PyTrace_C_CALL`, :const:`PyTrace_C_EXCEPTION` або :const:`PyTrace_C_RETURN` "
"як значення для параметра *what*."

msgid "See also the :func:`sys.settrace` function."
msgstr ""

msgid "Advanced Debugger Support"
msgstr "Розширена підтримка налагоджувача"

msgid ""
"These functions are only intended to be used by advanced debugging tools."
msgstr ""
"Ці функції призначені лише для використання розширеними інструментами "
"налагодження."

msgid ""
"Return the interpreter state object at the head of the list of all such "
"objects."
msgstr ""
"Повертає об’єкт стану інтерпретатора на початку списку всіх таких об’єктів."

msgid "Return the main interpreter state object."
msgstr "Повертає основний об'єкт стану інтерпретатора."

msgid ""
"Return the next interpreter state object after *interp* from the list of all "
"such objects."
msgstr ""
"Повертає наступний об’єкт стану інтерпретатора після *interp* зі списку всіх "
"таких об’єктів."

msgid ""
"Return the pointer to the first :c:type:`PyThreadState` object in the list "
"of threads associated with the interpreter *interp*."
msgstr ""
"Поверніть вказівник на перший об’єкт :c:type:`PyThreadState` у списку "
"потоків, пов’язаних з інтерпретатором *interp*."

msgid ""
"Return the next thread state object after *tstate* from the list of all such "
"objects belonging to the same :c:type:`PyInterpreterState` object."
msgstr ""
"Повертає наступний об’єкт стану потоку після *tstate* зі списку всіх таких "
"об’єктів, що належать до того самого об’єкта :c:type:`PyInterpreterState`."

msgid "Thread Local Storage Support"
msgstr "Підтримка потокового локального сховища"

msgid ""
"The Python interpreter provides low-level support for thread-local storage "
"(TLS) which wraps the underlying native TLS implementation to support the "
"Python-level thread local storage API (:class:`threading.local`).  The "
"CPython C level APIs are similar to those offered by pthreads and Windows: "
"use a thread key and functions to associate a :c:expr:`void*` value per "
"thread."
msgstr ""

msgid ""
"The GIL does *not* need to be held when calling these functions; they supply "
"their own locking."
msgstr ""
"GIL *не* потрібно утримувати під час виклику цих функцій; вони забезпечують "
"власний замок."

msgid ""
"Note that :file:`Python.h` does not include the declaration of the TLS APIs, "
"you need to include :file:`pythread.h` to use thread-local storage."
msgstr ""
"Зауважте, що :file:`Python.h` не містить оголошення TLS API, вам потрібно "
"включити :file:`pythread.h`, щоб використовувати локальне сховище потоків."

msgid ""
"None of these API functions handle memory management on behalf of the :c:"
"expr:`void*` values.  You need to allocate and deallocate them yourself. If "
"the :c:expr:`void*` values happen to be :c:expr:`PyObject*`, these functions "
"don't do refcount operations on them either."
msgstr ""

msgid "Thread Specific Storage (TSS) API"
msgstr "API для спеціального зберігання потоків (TSS)."

msgid ""
"TSS API is introduced to supersede the use of the existing TLS API within "
"the CPython interpreter.  This API uses a new type :c:type:`Py_tss_t` "
"instead of :c:expr:`int` to represent thread keys."
msgstr ""

msgid "\"A New C-API for Thread-Local Storage in CPython\" (:pep:`539`)"
msgstr ""
"\"Новий C-API для локального зберігання потоків у CPython\" (:pep:`539`)"

msgid ""
"This data structure represents the state of a thread key, the definition of "
"which may depend on the underlying TLS implementation, and it has an "
"internal field representing the key's initialization state.  There are no "
"public members in this structure."
msgstr ""
"Ця структура даних представляє стан ключа потоку, визначення якого може "
"залежати від базової реалізації TLS, і вона має внутрішнє поле, що "
"представляє стан ініціалізації ключа. У цій структурі немає громадських "
"учасників."

msgid ""
"When :ref:`Py_LIMITED_API <stable>` is not defined, static allocation of "
"this type by :c:macro:`Py_tss_NEEDS_INIT` is allowed."
msgstr ""
"Якщо :ref:`Py_LIMITED_API <stable>` не визначено, статичний розподіл цього "
"типу за допомогою :c:macro:`Py_tss_NEEDS_INIT` дозволений."

msgid ""
"This macro expands to the initializer for :c:type:`Py_tss_t` variables. Note "
"that this macro won't be defined with :ref:`Py_LIMITED_API <stable>`."
msgstr ""
"Цей макрос розширюється до ініціалізатора для змінних :c:type:`Py_tss_t`. "
"Зауважте, що цей макрос не буде визначено за допомогою :ref:`Py_LIMITED_API "
"<stable>`."

msgid "Dynamic Allocation"
msgstr "Динамічний розподіл"

msgid ""
"Dynamic allocation of the :c:type:`Py_tss_t`, required in extension modules "
"built with :ref:`Py_LIMITED_API <stable>`, where static allocation of this "
"type is not possible due to its implementation being opaque at build time."
msgstr ""
"Динамічне розміщення :c:type:`Py_tss_t`, необхідне в модулях розширення, "
"створених за допомогою :ref:`Py_LIMITED_API <stable>`, де статичне "
"розміщення цього типу неможливе через те, що його реалізація непрозора під "
"час створення."

msgid ""
"Return a value which is the same state as a value initialized with :c:macro:"
"`Py_tss_NEEDS_INIT`, or ``NULL`` in the case of dynamic allocation failure."
msgstr ""
"Повертає значення, яке є таким самим станом, як і значення, ініціалізоване "
"за допомогою :c:macro:`Py_tss_NEEDS_INIT` або ``NULL`` у разі помилки "
"динамічного розподілу."

msgid ""
"Free the given *key* allocated by :c:func:`PyThread_tss_alloc`, after first "
"calling :c:func:`PyThread_tss_delete` to ensure any associated thread locals "
"have been unassigned. This is a no-op if the *key* argument is ``NULL``."
msgstr ""

msgid ""
"A freed key becomes a dangling pointer. You should reset the key to ``NULL``."
msgstr ""

msgid "Methods"
msgstr "методи"

msgid ""
"The parameter *key* of these functions must not be ``NULL``.  Moreover, the "
"behaviors of :c:func:`PyThread_tss_set` and :c:func:`PyThread_tss_get` are "
"undefined if the given :c:type:`Py_tss_t` has not been initialized by :c:"
"func:`PyThread_tss_create`."
msgstr ""
"Параметр *key* цих функцій не має бути ``NULL``. Крім того, поведінка :c:"
"func:`PyThread_tss_set` і :c:func:`PyThread_tss_get` є невизначеною, якщо "
"даний :c:type:`Py_tss_t` не був ініціалізований :c:func:"
"`PyThread_tss_create`."

msgid ""
"Return a non-zero value if the given :c:type:`Py_tss_t` has been initialized "
"by :c:func:`PyThread_tss_create`."
msgstr ""
"Повертає ненульове значення, якщо заданий :c:type:`Py_tss_t` ініціалізовано :"
"c:func:`PyThread_tss_create`."

msgid ""
"Return a zero value on successful initialization of a TSS key.  The behavior "
"is undefined if the value pointed to by the *key* argument is not "
"initialized by :c:macro:`Py_tss_NEEDS_INIT`.  This function can be called "
"repeatedly on the same key -- calling it on an already initialized key is a "
"no-op and immediately returns success."
msgstr ""
"Повертає нульове значення в разі успішної ініціалізації ключа TSS. Поведінка "
"не визначена, якщо значення, на яке вказує аргумент *key*, не "
"ініціалізовано :c:macro:`Py_tss_NEEDS_INIT`. Цю функцію можна викликати "
"неодноразово для одного і того ж ключа — виклик її для вже ініціалізованого "
"ключа є безопераційним і негайно повертає успіх."

msgid ""
"Destroy a TSS key to forget the values associated with the key across all "
"threads, and change the key's initialization state to uninitialized.  A "
"destroyed key is able to be initialized again by :c:func:"
"`PyThread_tss_create`. This function can be called repeatedly on the same "
"key -- calling it on an already destroyed key is a no-op."
msgstr ""
"Знищіть ключ TSS, щоб забути значення, пов’язані з ключем у всіх потоках, і "
"змініть стан ініціалізації ключа на неініціалізований. Знищений ключ можна "
"знову ініціалізувати за допомогою :c:func:`PyThread_tss_create`. Цю функцію "
"можна багаторазово викликати для одного і того ж ключа – виклик її для вже "
"знищеного ключа є безопераційним."

msgid ""
"Return a zero value to indicate successfully associating a :c:expr:`void*` "
"value with a TSS key in the current thread.  Each thread has a distinct "
"mapping of the key to a :c:expr:`void*` value."
msgstr ""

msgid ""
"Return the :c:expr:`void*` value associated with a TSS key in the current "
"thread.  This returns ``NULL`` if no value is associated with the key in the "
"current thread."
msgstr ""

msgid "Thread Local Storage (TLS) API"
msgstr "API локального зберігання потоків (TLS)."

msgid ""
"This API is superseded by :ref:`Thread Specific Storage (TSS) API <thread-"
"specific-storage-api>`."
msgstr ""
"Цей API замінено :ref:`API спеціального зберігання потоків (TSS) <thread-"
"specific-storage-api>`."

msgid ""
"This version of the API does not support platforms where the native TLS key "
"is defined in a way that cannot be safely cast to ``int``.  On such "
"platforms, :c:func:`PyThread_create_key` will return immediately with a "
"failure status, and the other TLS functions will all be no-ops on such "
"platforms."
msgstr ""
"Ця версія API не підтримує платформи, де власний ключ TLS визначено таким "
"чином, що його неможливо безпечно перевести в ``int``. На таких платформах :"
"c:func:`PyThread_create_key` негайно повернеться зі статусом помилки, а всі "
"інші функції TLS будуть безопераційними на таких платформах."

msgid ""
"Due to the compatibility problem noted above, this version of the API should "
"not be used in new code."
msgstr ""
"Через проблему сумісності, зазначену вище, цю версію API не слід "
"використовувати в новому коді."
