# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:48+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "String conversion and formatting"
msgstr "Перетворення та форматування рядків"

msgid "Functions for number conversion and formatted string output."
msgstr "Функції для перетворення чисел і виведення форматованого рядка."

msgid ""
"Output not more than *size* bytes to *str* according to the format string "
"*format* and the extra arguments. See the Unix man page :manpage:"
"`snprintf(3)`."
msgstr ""
"Виводити не більше *size* байтів до *str* відповідно до рядка формату "
"*format* і додаткових аргументів. Перегляньте сторінку довідки Unix :manpage:"
"`snprintf(3)`."

msgid ""
"Output not more than *size* bytes to *str* according to the format string "
"*format* and the variable argument list *va*. Unix man page :manpage:"
"`vsnprintf(3)`."
msgstr ""
"Виводити не більше *size* байтів до *str* відповідно до рядка формату "
"*format* і списку змінних аргументів *va*. Довідкова сторінка Unix :manpage:"
"`vsnprintf(3)`."

msgid ""
":c:func:`PyOS_snprintf` and :c:func:`PyOS_vsnprintf` wrap the Standard C "
"library functions :c:func:`snprintf` and :c:func:`vsnprintf`. Their purpose "
"is to guarantee consistent behavior in corner cases, which the Standard C "
"functions do not."
msgstr ""
":c:func:`PyOS_snprintf` і :c:func:`PyOS_vsnprintf` обгортають стандартні "
"функції бібліотеки C :c:func:`snprintf` і :c:func:`vsnprintf`. Їх мета "
"полягає в тому, щоб гарантувати послідовну поведінку в кутових випадках, "
"чого немає у стандартних функціях C."

msgid ""
"The wrappers ensure that ``str[size-1]`` is always ``'\\0'`` upon return. "
"They never write more than *size* bytes (including the trailing ``'\\0'``) "
"into str. Both functions require that ``str != NULL``, ``size > 0``, "
"``format != NULL`` and ``size < INT_MAX``. Note that this means there is no "
"equivalent to the C99 ``n = snprintf(NULL, 0, ...)`` which would determine "
"the necessary buffer size."
msgstr ""

msgid ""
"The return value (*rv*) for these functions should be interpreted as follows:"
msgstr ""
"Повернене значення (*rv*) для цих функцій слід інтерпретувати таким чином:"

msgid ""
"When ``0 <= rv < size``, the output conversion was successful and *rv* "
"characters were written to *str* (excluding the trailing ``'\\0'`` byte at "
"``str[rv]``)."
msgstr ""
"Коли ``0 <= rv < size``, вихідне перетворення було успішним і *rv* символи "
"були записані в *str* (за винятком кінцевого байта ``'\\0''`` у "
"``str[rv]`` )."

msgid ""
"When ``rv >= size``, the output conversion was truncated and a buffer with "
"``rv + 1`` bytes would have been needed to succeed. ``str[size-1]`` is "
"``'\\0'`` in this case."
msgstr ""
"Коли rv >= size, вихідне перетворення було скорочено, і для успіху "
"знадобився буфер із rv + 1 байтами. ``str[size-1]`` у цьому випадку є "
"``'\\0''``."

msgid ""
"When ``rv < 0``, \"something bad happened.\" ``str[size-1]`` is ``'\\0'`` in "
"this case too, but the rest of *str* is undefined. The exact cause of the "
"error depends on the underlying platform."
msgstr ""
"Коли ``rv < 0``, \"сталося щось погане\". ``str[size-1]`` у цьому випадку "
"також є ``'\\0''``, але решта *str* не визначена. Точна причина помилки "
"залежить від основної платформи."

msgid ""
"The following functions provide locale-independent string to number "
"conversions."
msgstr ""
"Наступні функції забезпечують перетворення рядка в число, незалежне від "
"локалі."

msgid ""
"Convert a string ``s`` to a :c:expr:`double`, raising a Python exception on "
"failure.  The set of accepted strings corresponds to the set of strings "
"accepted by Python's :func:`float` constructor, except that ``s`` must not "
"have leading or trailing whitespace. The conversion is independent of the "
"current locale."
msgstr ""

msgid ""
"If ``endptr`` is ``NULL``, convert the whole string.  Raise :exc:"
"`ValueError` and return ``-1.0`` if the string is not a valid representation "
"of a floating-point number."
msgstr ""
"Якщо ``endptr`` має значення ``NULL``, перетворити весь рядок. Викликайте :"
"exc:`ValueError` і повертайте ``-1.0``, якщо рядок не є дійсним "
"представленням числа з плаваючою комою."

msgid ""
"If endptr is not ``NULL``, convert as much of the string as possible and set "
"``*endptr`` to point to the first unconverted character.  If no initial "
"segment of the string is the valid representation of a floating-point "
"number, set ``*endptr`` to point to the beginning of the string, raise "
"ValueError, and return ``-1.0``."
msgstr ""
"Якщо endptr не дорівнює NULL, перетворіть якомога більшу частину рядка та "
"встановіть ``*endptr`` так, щоб він вказував на перший неперетворений "
"символ. Якщо жоден початковий сегмент рядка не є дійсним представленням "
"числа з плаваючою комою, установіть ``*endptr``, щоб вказувати на початок "
"рядка, викликайте ValueError і поверніть ``-1.0``."

msgid ""
"If ``s`` represents a value that is too large to store in a float (for "
"example, ``\"1e500\"`` is such a string on many platforms) then if "
"``overflow_exception`` is ``NULL`` return ``Py_HUGE_VAL`` (with an "
"appropriate sign) and don't set any exception.  Otherwise, "
"``overflow_exception`` must point to a Python exception object; raise that "
"exception and return ``-1.0``.  In both cases, set ``*endptr`` to point to "
"the first character after the converted value."
msgstr ""
"Якщо ``s`` представляє значення, яке є надто великим для зберігання в float "
"(наприклад, ``\"1e500\"`` є таким рядком на багатьох платформах), тоді "
"``overflow_exception`` має значення ``NULL`` поверніть ``Py_HUGE_VAL`` (з "
"відповідним знаком) і не встановлюйте винятків. В іншому випадку "
"``overflow_exception`` має вказувати на об’єкт винятку Python; викликати цей "
"виняток і повернути ``-1.0``. В обох випадках встановіть ``*endptr``, щоб "
"вказувати на перший символ після перетвореного значення."

msgid ""
"If any other error occurs during the conversion (for example an out-of-"
"memory error), set the appropriate Python exception and return ``-1.0``."
msgstr ""
"Якщо під час перетворення виникає будь-яка інша помилка (наприклад, помилка "
"браку пам’яті), установіть відповідний виняток Python і поверніть ``-1.0``."

msgid ""
"Convert a :c:expr:`double` *val* to a string using supplied *format_code*, "
"*precision*, and *flags*."
msgstr ""

msgid ""
"*format_code* must be one of ``'e'``, ``'E'``, ``'f'``, ``'F'``, ``'g'``, "
"``'G'`` or ``'r'``.  For ``'r'``, the supplied *precision* must be 0 and is "
"ignored.  The ``'r'`` format code specifies the standard :func:`repr` format."
msgstr ""
"*format_code* має бути одним із ``'e'``, ``'E'``, ``'f'``, ``'F'``, ``'g'``, "
"``'G'`` або ``'r''``. Для ``'r'`` надана *точність* має бути 0 і "
"ігнорується. Код формату ``'r'`` визначає стандартний формат :func:`repr`."

msgid ""
"*flags* can be zero or more of the values ``Py_DTSF_SIGN``, "
"``Py_DTSF_ADD_DOT_0``, or ``Py_DTSF_ALT``, or-ed together:"
msgstr ""
"*flags* може мати нуль або більше значень ``Py_DTSF_SIGN``, "
"``Py_DTSF_ADD_DOT_0`` або ``Py_DTSF_ALT``, або об’єднані разом:"

msgid ""
"``Py_DTSF_SIGN`` means to always precede the returned string with a sign "
"character, even if *val* is non-negative."
msgstr ""
"``Py_DTSF_SIGN`` означає, що перед поверненим рядком завжди ставиться знак, "
"навіть якщо *val* є невід’ємним."

msgid ""
"``Py_DTSF_ADD_DOT_0`` means to ensure that the returned string will not look "
"like an integer."
msgstr ""
"``Py_DTSF_ADD_DOT_0`` означає, що повернутий рядок не буде виглядати як ціле "
"число."

msgid ""
"``Py_DTSF_ALT`` means to apply \"alternate\" formatting rules.  See the "
"documentation for the :c:func:`PyOS_snprintf` ``'#'`` specifier for details."
msgstr ""
"``Py_DTSF_ALT`` означає застосування \"альтернативних\" правил форматування. "
"Перегляньте документацію для специфікатора :c:func:`PyOS_snprintf` ``'#''`` "
"для отримання детальної інформації."

msgid ""
"If *ptype* is non-``NULL``, then the value it points to will be set to one "
"of ``Py_DTST_FINITE``, ``Py_DTST_INFINITE``, or ``Py_DTST_NAN``, signifying "
"that *val* is a finite number, an infinite number, or not a number, "
"respectively."
msgstr ""
"Якщо *ptype* не є ``NULL``, тоді значення, на яке він вказує, буде "
"встановлено на одне з ``Py_DTST_FINITE``, ``Py_DTST_INFINITE`` або "
"``Py_DTST_NAN``, що означає, що *val* є кінцеве число, нескінченне число або "
"не число відповідно."

msgid ""
"The return value is a pointer to *buffer* with the converted string or "
"``NULL`` if the conversion failed. The caller is responsible for freeing the "
"returned string by calling :c:func:`PyMem_Free`."
msgstr ""
"Поверненим значенням є вказівник на *buffer* із перетвореним рядком або "
"``NULL``, якщо перетворення не вдалося. Виклик відповідає за звільнення "
"повернутого рядка шляхом виклику :c:func:`PyMem_Free`."

msgid ""
"Case insensitive comparison of strings. The function works almost "
"identically to :c:func:`strcmp` except that it ignores the case."
msgstr ""
"Порівняння рядків без урахування регістру. Функція працює майже ідентично :c:"
"func:`strcmp`, за винятком того, що вона ігнорує регістр."

msgid ""
"Case insensitive comparison of strings. The function works almost "
"identically to :c:func:`strncmp` except that it ignores the case."
msgstr ""
"Порівняння рядків без урахування регістру. Функція працює майже ідентично :c:"
"func:`strncmp`, за винятком того, що вона ігнорує регістр."
