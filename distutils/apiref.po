# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:51+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "API Reference"
msgstr "Довідник з API"

msgid "`New and changed setup.py arguments in setuptools`_"
msgstr "`Нові та змінені аргументи setup.py в setuptools`_"

msgid ""
"The ``setuptools`` project adds new capabilities to the ``setup`` function "
"and other APIs, makes the API consistent across different Python versions, "
"and is hence recommended over using ``distutils`` directly."
msgstr ""
"Проект ``setuptools`` додає нові можливості до функції ``setup`` та інших "
"інтерфейсів API, робить API узгодженим для різних версій Python, і тому "
"рекомендується замість безпосереднього використання ``distutils``."

msgid ""
"This document is being retained solely until the ``setuptools`` "
"documentation at https://setuptools.readthedocs.io/en/latest/setuptools.html "
"independently covers all of the relevant information currently included here."
msgstr ""
"Цей документ зберігається лише до тих пір, поки документація ``setuptools`` "
"за адресою https://setuptools.readthedocs.io/en/latest/setuptools.html "
"окремо не охопить всю відповідну інформацію, яка зараз включена тут."

msgid ":mod:`distutils.core` --- Core Distutils functionality"
msgstr ":mod:`distutils.core` --- Основні функції Distutils"

msgid ""
"The :mod:`distutils.core` module is the only module that needs to be "
"installed to use the Distutils. It provides the :func:`setup` (which is "
"called from the setup script). Indirectly provides the  :class:`distutils."
"dist.Distribution` and :class:`distutils.cmd.Command` class."
msgstr ""
"Модуль :mod:`distutils.core` — це єдиний модуль, який потрібно встановити "
"для використання Distutils. Він забезпечує :func:`setup` (який викликається "
"зі сценарію налаштування). Опосередковано надає клас :class:`distutils.dist."
"Distribution` і :class:`distutils.cmd.Command`."

msgid ""
"The basic do-everything function that does most everything you could ever "
"ask for from a Distutils method."
msgstr ""
"Основна функція \"зроби все\", яка робить майже все, що ви можете попросити "
"від методу Distutils."

msgid ""
"The setup function takes a large number of arguments. These are laid out in "
"the following table."
msgstr ""
"Функція налаштування приймає велику кількість аргументів. Вони наведені в "
"наступній таблиці."

msgid "argument name"
msgstr "назва аргументу"

msgid "value"
msgstr "значення"

msgid "type"
msgstr "типу"

msgid "*name*"
msgstr "*ім'я*"

msgid "The name of the package"
msgstr "Назва пакета"

msgid "a string"
msgstr "рядок"

msgid "*version*"
msgstr "*версія*"

msgid "The version number of the package; see :mod:`distutils.version`"
msgstr "номер версії пакета; див. :mod:`distutils.version`"

msgid "*description*"
msgstr "*опис*"

msgid "A single line describing the package"
msgstr "Один рядок, що описує пакет"

msgid "*long_description*"
msgstr "*довгий_опис*"

msgid "Longer description of the package"
msgstr "Довший опис пакету"

msgid "*author*"
msgstr "*автор*"

msgid "The name of the package author"
msgstr "Ім'я автора пакета"

msgid "*author_email*"
msgstr "*email_автора*"

msgid "The email address of the package author"
msgstr "Адреса електронної пошти автора пакета"

msgid "*maintainer*"
msgstr "*супроводжувач*"

msgid ""
"The name of the current maintainer, if different from the author. Note that "
"if the maintainer is provided, distutils will use it as the author in :file:"
"`PKG-INFO`"
msgstr ""
"Ім'я поточного супроводжуючого, якщо воно відрізняється від автора. "
"Зауважте, що якщо супроводжувач надано, distutils використовуватиме його як "
"автора у :file:`PKG-INFO`"

msgid "*maintainer_email*"
msgstr "*email_maintainer_email*"

msgid ""
"The email address of the current maintainer, if different from the author"
msgstr ""
"Електронна адреса поточного супроводжуючого, якщо вона відрізняється від "
"автора"

msgid "*url*"
msgstr "*url*"

msgid "A URL for the package (homepage)"
msgstr "URL-адреса пакета (домашня сторінка)"

msgid "*download_url*"
msgstr "*URL-адреса_завантаження*"

msgid "A URL to download the package"
msgstr "URL-адреса для завантаження пакета"

msgid "*packages*"
msgstr "*пакети*"

msgid "A list of Python packages that distutils will manipulate"
msgstr "Список пакетів Python, якими distutils працюватиме"

msgid "a list of strings"
msgstr "список рядків"

msgid "*py_modules*"
msgstr "*py_modules*"

msgid "A list of Python modules that distutils will manipulate"
msgstr "Список модулів Python, якими distutils працюватиме"

msgid "*scripts*"
msgstr "*скрипти*"

msgid "A list of standalone script files to be built and installed"
msgstr ""
"Список автономних файлів сценаріїв, які потрібно створити та встановити"

msgid "*ext_modules*"
msgstr "*ext_modules*"

msgid "A list of Python extensions to be built"
msgstr "Список розширень Python для створення"

msgid "a list of instances of :class:`distutils.core.Extension`"
msgstr "список екземплярів :class:`distutils.core.Extension`"

msgid "*classifiers*"
msgstr "*класифікатори*"

msgid "A list of categories for the package"
msgstr "Список категорій для пакета"

msgid ""
"a list of strings; valid classifiers are listed on `PyPI <https://pypi.org/"
"classifiers>`_."
msgstr ""
"список рядків; дійсні класифікатори перераховані на `PyPI <https://pypi.org/"
"classifiers>`_."

msgid "*distclass*"
msgstr "*distclass*"

msgid "the :class:`Distribution` class to use"
msgstr "клас :class:`Distribution` для використання"

msgid "a subclass of :class:`distutils.core.Distribution`"
msgstr "підклас :class:`distutils.core.Distribution`"

msgid "*script_name*"
msgstr "*script_name*"

msgid "The name of the setup.py script - defaults to ``sys.argv[0]``"
msgstr "Назва сценарію setup.py - за умовчанням ``sys.argv[0]``"

msgid "*script_args*"
msgstr "*script_args*"

msgid "Arguments to supply to the setup script"
msgstr "Аргументи для налаштування сценарію"

msgid "*options*"
msgstr "*опції*"

msgid "default options for the setup script"
msgstr "параметри за замовчуванням для сценарію налаштування"

msgid "a dictionary"
msgstr "словник"

msgid "*license*"
msgstr "*ліцензія*"

msgid "The license for the package"
msgstr "Ліцензія на пакет"

msgid "*keywords*"
msgstr "*ключові слова*"

msgid "Descriptive meta-data, see :pep:`314`"
msgstr "Описові метадані див. :pep:`314`"

msgid "a list of strings or a comma-separated string"
msgstr "список рядків або рядок, розділений комами"

msgid "*platforms*"
msgstr "*платформи*"

msgid "*cmdclass*"
msgstr "*cmdclass*"

msgid "A mapping of command names to :class:`Command` subclasses"
msgstr "Відображення назв команд на підкласи :class:`Command`"

msgid "*data_files*"
msgstr "*файли_даних*"

msgid "A list of data files to install"
msgstr "Список файлів даних для встановлення"

msgid "a list"
msgstr "список"

msgid "*package_dir*"
msgstr "*package_dir*"

msgid "A mapping of package to directory names"
msgstr "Відображення пакета в іменах каталогу"

msgid ""
"Run a setup script in a somewhat controlled environment, and return  the :"
"class:`distutils.dist.Distribution` instance that drives things.   This is "
"useful if you need to find out the distribution meta-data  (passed as "
"keyword args from *script* to :func:`setup`), or  the contents of the config "
"files or command-line."
msgstr ""
"Запустіть сценарій налаштування в дещо контрольованому середовищі та "
"поверніть екземпляр :class:`distutils.dist.Distribution`, який керує діями. "
"Це корисно, якщо вам потрібно дізнатися метадані розповсюдження (передані як "
"аргументи ключового слова від *script* до :func:`setup`), або вміст "
"конфігураційних файлів чи командного рядка."

msgid ""
"*script_name* is a file that will be read and run with :func:`exec`.  ``sys."
"argv[0]`` will be replaced with *script* for the duration of the call.  "
"*script_args* is a list of strings; if supplied, ``sys.argv[1:]`` will be "
"replaced by *script_args* for the duration  of the call."
msgstr ""
"*script_name* — це файл, який читатиметься та запускатиметься за допомогою :"
"func:`exec`. ``sys.argv[0]`` буде замінено на *script* на час виклику. "
"*script_args* — це список рядків; якщо надано, ``sys.argv[1:]`` буде "
"замінено на *script_args* протягом тривалості виклику."

msgid ""
"*stop_after* tells :func:`setup` when to stop processing; possible  values:"
msgstr ""
"*stop_after* повідомляє :func:`setup`, коли зупинити обробку; можливі "
"значення:"

msgid "description"
msgstr "опис"

msgid "*init*"
msgstr "*у цьому*"

msgid ""
"Stop after the :class:`Distribution` instance has been created  and "
"populated with the keyword arguments to :func:`setup`"
msgstr ""
"Зупиніться після того, як екземпляр :class:`Distribution` буде створено та "
"заповнено ключовими аргументами для :func:`setup`"

msgid "*config*"
msgstr "*конфігурація*"

msgid ""
"Stop after config files have been parsed (and their data stored in the :"
"class:`Distribution` instance)"
msgstr ""
"Зупинити після аналізу конфігураційних файлів (і їх даних, збережених в "
"екземплярі :class:`Distribution`)"

msgid "*commandline*"
msgstr "*командний рядок*"

msgid ""
"Stop after the command-line (``sys.argv[1:]`` or  *script_args*) have been "
"parsed (and the data stored in the :class:`Distribution` instance.)"
msgstr ""
"Зупиніться після аналізу командного рядка (``sys.argv[1:]`` або "
"*script_args*) (і даних, збережених в екземплярі :class:`Distribution`)."

msgid "*run*"
msgstr "*бігти*"

msgid ""
"Stop after all commands have been run (the same as  if :func:`setup` had "
"been called in the usual way). This is the default value."
msgstr ""
"Зупиніться після виконання всіх команд (так само, якби :func:`setup` було "
"викликано звичайним способом). Це значення за умовчанням."

msgid ""
"In addition, the :mod:`distutils.core` module exposed a number of  classes "
"that live elsewhere."
msgstr ""
"Крім того, модуль :mod:`distutils.core` відкрив низку класів, які живуть в "
"інших місцях."

msgid ":class:`~distutils.extension.Extension` from :mod:`distutils.extension`"
msgstr ":class:`~distutils.extension.Extension` з :mod:`distutils.extension`"

msgid ":class:`~distutils.cmd.Command` from :mod:`distutils.cmd`"
msgstr ":class:`~distutils.cmd.Command` з :mod:`distutils.cmd`"

msgid ":class:`~distutils.dist.Distribution` from :mod:`distutils.dist`"
msgstr ":class:`~distutils.dist.Distribution` з :mod:`distutils.dist`"

msgid ""
"A short description of each of these follows, but see the relevant module "
"for the full reference."
msgstr ""
"Нижче наведено короткий опис кожного з них, але повну довідку див. у "
"відповідному модулі."

msgid ""
"The Extension class describes a single C or C++ extension module in a setup "
"script. It accepts the following keyword arguments in its constructor:"
msgstr ""
"Клас Extension описує один модуль розширення C або C++ у сценарії "
"налаштування. Він приймає такі ключові аргументи у своєму конструкторі:"

msgid ""
"the full name of the extension, including any packages --- ie. *not* a "
"filename or pathname, but Python dotted name"
msgstr ""
"повна назва розширення, включаючи будь-які пакети --- тобто. *не* ім’я файлу "
"чи шлях, а ім’я Python із крапками"

msgid "*sources*"
msgstr "*джерела*"

msgid ""
"list of source filenames, relative to the distribution root (where the setup "
"script lives), in Unix form (slash-separated) for portability. Source files "
"may be C, C++, SWIG (.i), platform-specific resource files, or whatever else "
"is recognized by the :command:`build_ext` command as source for a Python "
"extension."
msgstr ""
"список імен вихідних файлів відносно кореня розповсюдження (де знаходиться "
"сценарій встановлення), у формі Unix (розділені скісною рискою) для "
"переносимості. Вихідними файлами можуть бути C, C++, SWIG (.i), файли "
"ресурсів для певної платформи або будь-які інші файли, які розпізнаються "
"командою :command:`build_ext` як джерело для розширення Python."

msgid "*include_dirs*"
msgstr "*include_dirs*"

msgid ""
"list of directories to search for C/C++ header files (in Unix form for "
"portability)"
msgstr ""
"список каталогів для пошуку файлів заголовків C/C++ (у формі Unix для "
"переносимості)"

msgid "*define_macros*"
msgstr "*define_macros*"

msgid ""
"list of macros to define; each macro is defined using a 2-tuple ``(name, "
"value)``, where *value* is either the string to define it to or ``None`` to "
"define it without a particular value (equivalent of ``#define FOO`` in "
"source or :option:`!-DFOO` on Unix C compiler command line)"
msgstr ""
"список макросів для визначення; кожен макрос визначається за допомогою 2-"
"кортежу ``(ім’я, значення)``, де *value* є або рядком для його визначення, "
"або ``None``, щоб визначити його без певного значення (еквівалент ``# "
"визначте FOO`` у джерелі або :option:`!-DFOO` в командному рядку компілятора "
"Unix C)"

msgid "a list of tuples"
msgstr "список кортежів"

msgid "*undef_macros*"
msgstr "*undef_macros*"

msgid "list of macros to undefine explicitly"
msgstr "список макросів для явного скасування визначення"

msgid "*library_dirs*"
msgstr "*library_dirs*"

msgid "list of directories to search for C/C++ libraries at link time"
msgstr "список каталогів для пошуку бібліотек C/C++ під час підключення"

msgid "*libraries*"
msgstr "*бібліотеки*"

msgid "list of library names (not filenames or paths) to link against"
msgstr ""
"список імен бібліотек (не імен файлів чи шляхів), з якими потрібно посилатися"

msgid "*runtime_library_dirs*"
msgstr "*каталоги_бібліотеки_запуску*"

msgid ""
"list of directories to search for C/C++ libraries at run time (for shared "
"extensions, this is when the extension is loaded)"
msgstr ""
"список каталогів для пошуку бібліотек C/C++ під час виконання (для спільних "
"розширень це час завантаження розширення)"

msgid "*extra_objects*"
msgstr "*додаткові_об'єкти*"

msgid ""
"list of extra files to link with (eg. object files not implied by 'sources', "
"static library that must be explicitly specified, binary resource files, "
"etc.)"
msgstr ""
"список додаткових файлів, з якими можна зв’язатися (наприклад, об’єктні "
"файли, які не передбачаються \"джерелами\", статична бібліотека, яку "
"необхідно вказати явно, двійкові файли ресурсів тощо)"

msgid "*extra_compile_args*"
msgstr "*extra_compile_args*"

msgid ""
"any extra platform- and compiler-specific information to use when compiling "
"the source files in 'sources'. For platforms and compilers where a command "
"line makes sense, this is typically a list of command-line arguments, but "
"for other platforms it could be anything."
msgstr ""
"будь-яка додаткова інформація про платформу та компілятор для використання "
"під час компіляції вихідних файлів у \"джерелах\". Для платформ і "
"компіляторів, де командний рядок має сенс, це зазвичай список аргументів "
"командного рядка, але для інших платформ це може бути будь-що."

msgid "*extra_link_args*"
msgstr "*extra_link_args*"

msgid ""
"any extra platform- and compiler-specific information to use when linking "
"object files together to create the extension (or to create a new static "
"Python interpreter). Similar interpretation as for 'extra_compile_args'."
msgstr ""
"будь-яка додаткова інформація про платформу та компілятор, яку можна "
"використовувати під час зв’язування об’єктних файлів разом для створення "
"розширення (або для створення нового статичного інтерпретатора Python). "
"Інтерпретація подібна до 'extra_compile_args'."

msgid "*export_symbols*"
msgstr "*export_symbols*"

msgid ""
"list of symbols to be exported from a shared extension. Not used on all "
"platforms, and not generally necessary for Python extensions, which "
"typically export exactly one symbol: ``init`` + extension_name."
msgstr ""
"список символів, які потрібно експортувати зі спільного розширення. Не "
"використовується на всіх платформах і не є загалом необхідним для розширень "
"Python, які зазвичай експортують лише один символ: ``init`` + extension_name."

msgid "*depends*"
msgstr "*залежить*"

msgid "list of files that the extension depends on"
msgstr "список файлів, від яких залежить розширення"

msgid "*language*"
msgstr "*мову*"

msgid ""
"extension language (i.e. ``'c'``, ``'c++'``, ``'objc'``). Will be detected "
"from the source extensions if not provided."
msgstr ""
"мова розширення (тобто ``'c'``, ``'c++'``, ``'objc'``). Буде виявлено з "
"вихідних розширень, якщо їх не надано."

msgid "*optional*"
msgstr "*необов'язково*"

msgid ""
"specifies that a build failure in the extension should not abort the build "
"process, but simply skip the extension."
msgstr ""
"вказує, що помилка збірки в розширенні не повинна переривати процес збірки, "
"а просто пропускати розширення."

msgid "a boolean"
msgstr "логічне значення"

msgid ""
"On Unix, C extensions are no longer linked to libpython except on Android "
"and Cygwin."
msgstr ""
"В Unix розширення C більше не пов’язані з libpython, за винятком Android і "
"Cygwin."

msgid ""
"A :class:`Distribution` describes how to build, install and package up a "
"Python software package."
msgstr ""
":class:`Distribution` описує, як створити, встановити та запакувати "
"програмний пакет Python."

msgid ""
"See the :func:`setup` function for a list of keyword arguments accepted  by "
"the Distribution constructor. :func:`setup` creates a Distribution instance."
msgstr ""
"Перегляньте функцію :func:`setup`, щоб переглянути список ключових "
"аргументів, які приймає конструктор розподілу. :func:`setup` створює "
"екземпляр Distribution."

msgid ""
":class:`~distutils.core.Distribution` now warns if ``classifiers``, "
"``keywords`` and ``platforms`` fields are not specified as a list or a "
"string."
msgstr ""
":class:`~distutils.core.Distribution` тепер попереджає, якщо поля "
"``класифікатори``, ``ключові слова`` та ``платформи`` не вказані як список "
"або рядок."

msgid ""
"A :class:`Command` class (or rather, an instance of one of its subclasses) "
"implement a single distutils command."
msgstr ""
"Клас :class:`Command` (точніше, екземпляр одного з його підкласів) реалізує "
"одну команду distutils."

msgid ":mod:`distutils.ccompiler` --- CCompiler base class"
msgstr ":mod:`distutils.ccompiler` --- базовий клас CCompiler"

msgid ""
"This module provides the abstract base class for the :class:`CCompiler` "
"classes.  A :class:`CCompiler` instance can be used for all the compile  and "
"link steps needed to build a single project. Methods are provided to  set "
"options for the compiler --- macro definitions, include directories,  link "
"path, libraries and the like."
msgstr ""
"Цей модуль надає абстрактний базовий клас для класів :class:`CCompiler`. "
"Екземпляр :class:`CCompiler` можна використовувати для всіх кроків "
"компіляції та зв’язування, необхідних для створення одного проекту. "
"Надаються методи для встановлення опцій для компілятора --- визначень "
"макросів, включення каталогів, шляхів посилань, бібліотек тощо."

msgid "This module provides the following functions."
msgstr "Цей модуль забезпечує такі функції."

msgid ""
"Generate linker options for searching library directories and linking with "
"specific libraries.  *libraries* and *library_dirs* are, respectively, lists "
"of library names (not filenames!) and search directories.  Returns a list of "
"command-line options suitable for use with some compiler (depending on the "
"two format strings passed in)."
msgstr ""
"Створення параметрів компонувальника для пошуку каталогів бібліотек і "
"зв’язування з певними бібліотеками. *libraries* і *library_dirs* — це, "
"відповідно, списки імен бібліотек (а не імен файлів!) і каталогів пошуку. "
"Повертає список параметрів командного рядка, придатних для використання з "
"деяким компілятором (залежно від двох переданих рядків формату)."

msgid ""
"Generate C pre-processor options (:option:`!-D`, :option:`!-U`, :option:`!-"
"I`) as used by at least two types of compilers: the typical Unix compiler "
"and Visual C++. *macros* is the usual thing, a list of 1- or 2-tuples, where "
"``(name,)`` means undefine (:option:`!-U`) macro *name*, and ``(name, "
"value)`` means define (:option:`!-D`) macro *name* to *value*.  "
"*include_dirs* is just a list of directory names to be added to the header "
"file search path (:option:`!-I`). Returns a list of command-line options "
"suitable for either Unix compilers or Visual C++."
msgstr ""
"Згенеруйте параметри попереднього процесора C (:option:`!-D`, :option:`!-"
"U`, :option:`!-I`), які використовуються принаймні двома типами "
"компіляторів: типовим компілятором Unix і Visual C++. *макроси* — це "
"звичайна річ, список 1- або 2-кортежів, де ``(name,)`` означає undefine (:"
"option:`!-U`) макрос *name*, а ``(name, значення)`` означає визначення (:"
"option:`!-D`) *назви* макросу на *значення*. *include_dirs* — це лише список "
"імен каталогів, які потрібно додати до шляху пошуку файлу заголовка (:option:"
"`!-I`). Повертає список параметрів командного рядка, придатних для "
"компіляторів Unix або Visual C++."

msgid "Determine the default compiler to use for the given platform."
msgstr "Визначте компілятор за замовчуванням для даної платформи."

msgid ""
"*osname* should be one of the standard Python OS names (i.e. the ones "
"returned by ``os.name``) and *platform* the common value returned by ``sys."
"platform`` for the platform in question."
msgstr ""
"*osname* має бути одним із стандартних імен ОС Python (тобто тих, які "
"повертає ``os.name``), а *platform* — загальне значення, яке повертає ``sys."
"platform`` для відповідної платформи."

msgid ""
"The default values are ``os.name`` and ``sys.platform`` in case the "
"parameters are not given."
msgstr ""
"Значеннями за замовчуванням є ``os.name`` і ``sys.platform``, якщо параметри "
"не вказано."

msgid ""
"Factory function to generate an instance of some CCompiler subclass for the "
"supplied platform/compiler combination. *plat* defaults to ``os.name`` (eg. "
"``'posix'``, ``'nt'``), and *compiler*  defaults to the default compiler for "
"that platform. Currently only ``'posix'`` and ``'nt'`` are supported, and "
"the default compilers are \"traditional Unix interface\" (:class:"
"`UnixCCompiler` class) and Visual C++ (:class:`MSVCCompiler` class).  Note "
"that it's perfectly possible to ask for a Unix compiler object under "
"Windows, and a Microsoft compiler object under Unix---if you supply a value "
"for *compiler*, *plat* is ignored."
msgstr ""
"Фабрична функція для створення екземпляра деякого підкласу CCompiler для "
"наданої комбінації платформа/компілятор. *plat* за замовчуванням має ``os."
"name`` (наприклад, ``'posix'``, ``'nt'``), а *compiler* за замовчуванням "
"використовує компілятор за замовчуванням для цієї платформи. Наразі "
"підтримуються лише ``'posix'`` і ``'nt'``, а компіляторами за замовчуванням "
"є \"традиційний інтерфейс Unix\" (:class:`UnixCCompiler` клас) і Visual C++ "
"(:class:`MSVCCompiler` клас ). Зауважте, що цілком можливо запросити об’єкт "
"компілятора Unix під Windows і об’єкт компілятора Microsoft під Unix --- "
"якщо ви вказуєте значення для *compiler*, *plat* ігнорується."

msgid ""
"Print list of available compilers (used by the :option:`!--help-compiler` "
"options to :command:`build`, :command:`build_ext`, :command:`build_clib`)."
msgstr ""
"Надрукувати список доступних компіляторів (використовується параметрами :"
"option:`!--help-compiler` для :command:`build`, :command:`build_ext`, :"
"command:`build_clib`)."

msgid ""
"The abstract base class :class:`CCompiler` defines the interface that  must "
"be implemented by real compiler classes.  The class also has  some utility "
"methods used by several compiler classes."
msgstr ""
"Абстрактний базовий клас :class:`CCompiler` визначає інтерфейс, який має "
"бути реалізований реальними класами компілятора. Клас також має деякі "
"корисні методи, які використовуються кількома класами компілятора."

msgid ""
"The basic idea behind a compiler abstraction class is that each instance can "
"be used for all the compile/link steps in building a single project.  Thus, "
"attributes common to all of those compile and link steps --- include "
"directories, macros to define, libraries to link against, etc. --- are "
"attributes of the compiler instance.  To allow for variability in how "
"individual files are treated, most of those attributes may be varied on a "
"per-compilation or per-link basis."
msgstr ""
"Основна ідея класу абстракції компілятора полягає в тому, що кожен екземпляр "
"можна використовувати для всіх етапів компіляції/зв’язування в створенні "
"одного проекту. Таким чином, атрибути, загальні для всіх цих етапів "
"компіляції та зв’язування --- включають каталоги, макроси для визначення, "
"бібліотеки для зв’язування тощо --- є атрибутами примірника компілятора. Щоб "
"уможливити варіативність у тому, як обробляються окремі файли, більшість із "
"цих атрибутів можна змінювати для кожної компіляції чи кожного посилання."

msgid ""
"The constructor for each subclass creates an instance of the Compiler "
"object. Flags are *verbose* (show verbose output), *dry_run* (don't actually "
"execute the steps) and *force* (rebuild everything, regardless of "
"dependencies). All of these flags default to ``0`` (off). Note that you "
"probably don't want to instantiate :class:`CCompiler` or one of its "
"subclasses directly - use the :func:`distutils.CCompiler.new_compiler` "
"factory function instead."
msgstr ""
"Конструктор для кожного підкласу створює екземпляр об’єкта Compiler. "
"Прапори: *verbose* (показати докладний вихід), *dry_run* (фактично не "
"виконувати кроки) і *force* (перебудувати все, незалежно від залежностей). "
"Усі ці прапорці за замовчуванням мають значення ``0`` (вимкнено). Зауважте, "
"що ви, мабуть, не бажаєте створювати екземпляр :class:`CCompiler` або один "
"із його підкласів напряму - використовуйте натомість фабричну функцію :func:"
"`distutils.CCompiler.new_compiler`."

msgid ""
"The following methods allow you to manually alter compiler options for  the "
"instance of the Compiler class."
msgstr ""
"Наступні методи дозволяють вручну змінювати параметри компілятора для "
"екземпляра класу Compiler."

msgid ""
"Add *dir* to the list of directories that will be searched for header files. "
"The compiler is instructed to search directories in the order in which they "
"are supplied by successive calls to :meth:`add_include_dir`."
msgstr ""
"Додайте *dir* до списку каталогів, у яких здійснюватиметься пошук файлів "
"заголовків. Компілятор отримує вказівку шукати каталоги в тому порядку, в "
"якому вони надаються послідовними викликами :meth:`add_include_dir`."

msgid ""
"Set the list of directories that will be searched to *dirs* (a list of "
"strings). Overrides any preceding calls to :meth:`add_include_dir`; "
"subsequent calls to :meth:`add_include_dir` add to the list passed to :meth:"
"`set_include_dirs`. This does not affect any list of standard include "
"directories that the compiler may search by default."
msgstr ""
"Встановіть список каталогів, у яких здійснюватиметься пошук, як *dirs* "
"(список рядків). Перевизначає будь-які попередні виклики :meth:"
"`add_include_dir`; наступні виклики :meth:`add_include_dir` додають до "
"списку, переданого :meth:`set_include_dirs`. Це не впливає на список "
"каталогів стандартного включення, які компілятор може шукати за "
"замовчуванням."

msgid ""
"Add *libname* to the list of libraries that will be included in all links "
"driven by this compiler object.  Note that *libname* should \\*not\\* be the "
"name of a file containing a library, but the name of the library itself: the "
"actual filename will be inferred by the linker, the compiler, or the "
"compiler class (depending on the platform)."
msgstr ""
"Додайте *libname* до списку бібліотек, які будуть включені в усі посилання, "
"керовані цим об’єктом компілятора. Зауважте, що *libname* має \\*не\\* бути "
"назвою файлу, що містить бібліотеку, а назвою самої бібліотеки: фактичне "
"ім’я файлу буде визначено компонувальником, компілятором або класом "
"компілятора (залежно від платформа)."

msgid ""
"The linker will be instructed to link against libraries in the order they "
"were supplied to :meth:`add_library` and/or :meth:`set_libraries`.  It is "
"perfectly valid to duplicate library names; the linker will be instructed to "
"link against libraries as many times as they are mentioned."
msgstr ""
"Пов’язувач отримає вказівку зв’язувати бібліотеки в тому порядку, в якому "
"вони були надані в :meth:`add_library` та/або :meth:`set_libraries`. Цілком "
"допустимо дублювати імена бібліотек; компонувальник отримає вказівку "
"створити зв’язок із бібліотеками стільки разів, скільки вони згадуються."

msgid ""
"Set the list of libraries to be included in all links driven by this "
"compiler object to *libnames* (a list of strings).  This does not affect any "
"standard system libraries that the linker may include by default."
msgstr ""
"Встановіть список бібліотек, які будуть включені в усі посилання, керовані "
"цим об’єктом компілятора, як *libnames* (список рядків). Це не впливає на "
"стандартні системні бібліотеки, які компонувальник може включати за "
"замовчуванням."

msgid ""
"Add *dir* to the list of directories that will be searched for libraries "
"specified to :meth:`add_library` and :meth:`set_libraries`.  The linker will "
"be instructed to search for libraries in the order they are supplied to :"
"meth:`add_library_dir` and/or :meth:`set_library_dirs`."
msgstr ""
"Додайте *dir* до списку каталогів, у яких здійснюватиметься пошук бібліотек, "
"указаних у :meth:`add_library` і :meth:`set_libraries`. Пов’язувач отримає "
"вказівку шукати бібліотеки в тому порядку, в якому вони надані в :meth:"
"`add_library_dir` та/або :meth:`set_library_dirs`."

msgid ""
"Set the list of library search directories to *dirs* (a list of strings).  "
"This does not affect any standard library search path that the linker may "
"search by default."
msgstr ""
"Встановіть список каталогів пошуку бібліотек на *dirs* (список рядків). Це "
"не впливає на будь-який стандартний шлях пошуку бібліотеки, який "
"компонувальник може шукати за замовчуванням."

msgid ""
"Add *dir* to the list of directories that will be searched for shared "
"libraries at runtime."
msgstr ""
"Додайте *dir* до списку каталогів, у яких здійснюватиметься пошук спільних "
"бібліотек під час виконання."

msgid ""
"Set the list of directories to search for shared libraries at runtime to "
"*dirs* (a list of strings).  This does not affect any standard search path "
"that the runtime linker may search by default."
msgstr ""
"Встановіть список каталогів для пошуку спільних бібліотек під час виконання "
"на *dirs* (список рядків). Це не впливає на будь-який стандартний шлях "
"пошуку, який компонувальник під час виконання може шукати за замовчуванням."

msgid ""
"Define a preprocessor macro for all compilations driven by this compiler "
"object. The optional parameter *value* should be a string; if it is not "
"supplied, then the macro will be defined without an explicit value and the "
"exact outcome depends on the compiler used."
msgstr ""
"Визначте макрос препроцесора для всіх компіляцій, керованих цим об’єктом "
"компілятора. Додатковий параметр *value* має бути рядком; якщо він не "
"наданий, то макрос буде визначено без явного значення, і точний результат "
"залежить від використовуваного компілятора."

msgid ""
"Undefine a preprocessor macro for all compilations driven by this compiler "
"object.  If the same macro is defined by :meth:`define_macro` and undefined "
"by :meth:`undefine_macro` the last call takes precedence (including multiple "
"redefinitions or undefinitions).  If the macro is redefined/undefined on a "
"per-compilation basis (ie. in the call to :meth:`compile`), then that takes "
"precedence."
msgstr ""
"Скасуйте визначення макросу препроцесора для всіх компіляцій, керованих цим "
"об’єктом компілятора. Якщо той самий макрос визначено :meth:`define_macro` і "
"не визначено :meth:`undefine_macro`, останній виклик має перевагу (включно з "
"кількома перевизначеннями або невизначеннями). Якщо макрос перевизначено/не "
"визначено на основі кожної компіляції (тобто під час виклику :meth:"
"`compile`), то він має перевагу."

msgid ""
"Add *object* to the list of object files (or analogues, such as explicitly "
"named library files or the output of \"resource compilers\") to be included "
"in every link driven by this compiler object."
msgstr ""
"Додайте *об’єкт* до списку об’єктних файлів (або аналогів, таких як "
"бібліотечні файли з явною назвою або вихідні дані \"компіляторів "
"ресурсів\"), які будуть включені в кожне посилання, кероване цим об’єктом "
"компілятора."

msgid ""
"Set the list of object files (or analogues) to be included in every link to "
"*objects*.  This does not affect any standard object files that the linker "
"may include by default (such as system libraries)."
msgstr ""
"Встановіть список об’єктних файлів (або аналогів), які будуть включені до "
"кожного посилання на *об’єкти*. Це не впливає на будь-які стандартні "
"об’єктні файли, які компонувальник може включати за замовчуванням "
"(наприклад, системні бібліотеки)."

msgid ""
"The following methods implement methods for autodetection of compiler  "
"options, providing some functionality similar to GNU :program:`autoconf`."
msgstr ""
"Наступні методи реалізують методи для автоматичного визначення параметрів "
"компілятора, надаючи деякі функції, подібні до GNU :program:`autoconf`."

msgid ""
"Detect the language of a given file, or list of files. Uses the  instance "
"attributes :attr:`language_map` (a dictionary), and  :attr:`language_order` "
"(a list) to do the job."
msgstr ""
"Визначити мову певного файлу або списку файлів. Використовує атрибути "
"екземпляра :attr:`language_map` (словник) і :attr:`language_order` (список) "
"для виконання завдання."

msgid ""
"Search the specified list of directories for a static or shared library file "
"*lib* and return the full path to that file.  If *debug* is true, look for a "
"debugging version (if that makes sense on the current platform).  Return "
"``None`` if *lib* wasn't found in any of the specified directories."
msgstr ""
"Знайдіть у вказаному списку каталогів файл статичної або спільної бібліотеки "
"*lib* і поверніть повний шлях до цього файлу. Якщо *debug* має значення "
"true, знайдіть версію для налагодження (якщо це має сенс на поточній "
"платформі). Повертає ``None``, якщо *lib* не знайдено в жодному з указаних "
"каталогів."

msgid ""
"Return a boolean indicating whether *funcname* is supported on the current "
"platform.  The optional arguments can be used to augment the compilation "
"environment by providing additional include files and paths and libraries "
"and paths."
msgstr ""
"Повертає логічне значення, яке вказує, чи підтримується *funcname* на "
"поточній платформі. Необов’язкові аргументи можна використовувати для "
"розширення середовища компіляції шляхом надання додаткових файлів і шляхів, "
"а також бібліотек і шляхів."

msgid ""
"Return the compiler option to add *dir* to the list of directories searched "
"for libraries."
msgstr ""
"Повернути опцію компілятора, щоб додати *dir* до списку каталогів, у яких "
"шукаються бібліотеки."

msgid ""
"Return the compiler option to add *lib* to the list of libraries linked into "
"the shared library or executable."
msgstr ""
"Поверніть опцію компілятора, щоб додати *lib* до списку бібліотек, "
"пов’язаних із спільною бібліотекою або виконуваним файлом."

msgid ""
"Return the compiler option to add *dir* to the list of directories searched "
"for runtime libraries."
msgstr ""
"Поверніть опцію компілятора, щоб додати *dir* до списку каталогів, у яких "
"шукаються бібліотеки середовища виконання."

msgid ""
"Define the executables (and options for them) that will be run to perform "
"the various stages of compilation.  The exact set of executables that may be "
"specified here depends on the compiler class (via the 'executables' class "
"attribute), but most will have:"
msgstr ""
"Визначте виконувані файли (і параметри для них), які будуть запущені для "
"виконання різних етапів компіляції. Точний набір виконуваних файлів, який "
"можна вказати тут, залежить від класу компілятора (через атрибут класу "
"'executables'), але більшість матиме:"

msgid "attribute"
msgstr "атрибут"

msgid "*compiler*"
msgstr "*компілятор*"

msgid "the C/C++ compiler"
msgstr "компілятор C/C++"

msgid "*linker_so*"
msgstr "*linker_so*"

msgid "linker used to create shared objects and libraries"
msgstr ""
"компонувальник, який використовується для створення спільних об’єктів і "
"бібліотек"

msgid "*linker_exe*"
msgstr "*linker_exe*"

msgid "linker used to create binary executables"
msgstr ""
"компонувальник, який використовується для створення двійкових виконуваних "
"файлів"

msgid "*archiver*"
msgstr "*архіватор*"

msgid "static library creator"
msgstr "творець статичної бібліотеки"

msgid ""
"On platforms with a command-line (Unix, DOS/Windows), each of these is a "
"string that will be split into executable name and (optional) list of "
"arguments. (Splitting the string is done similarly to how Unix shells "
"operate: words are delimited by spaces, but quotes and backslashes can "
"override this.  See :func:`distutils.util.split_quoted`.)"
msgstr ""
"На платформах із командним рядком (Unix, DOS/Windows) кожен із них є рядком, "
"який буде розділено на ім’я виконуваного файлу та (необов’язковий) список "
"аргументів. (Поділ рядка виконується подібно до того, як працюють оболонки "
"Unix: слова розділені пробілами, але лапки та зворотні косі риски можуть "
"замінити це. Див. :func:`distutils.util.split_quoted`.)"

msgid "The following methods invoke stages in the build process."
msgstr "Наступні методи викликають етапи процесу побудови."

msgid ""
"Compile one or more source files. Generates object files (e.g.  transforms "
"a :file:`.c` file to a :file:`.o` file.)"
msgstr ""
"Скомпілюйте один або кілька вихідних файлів. Створює об’єктні файли "
"(наприклад, перетворює файл :file:`.c` на файл :file:`.o`.)"

msgid ""
"*sources* must be a list of filenames, most likely C/C++ files, but in "
"reality anything that can be handled by a particular compiler and compiler "
"class (eg. :class:`MSVCCompiler` can handle resource files in *sources*).  "
"Return a list of object filenames, one per source filename in *sources*.  "
"Depending on the implementation, not all source files will necessarily be "
"compiled, but all corresponding object filenames will be returned."
msgstr ""
"*джерела* мають бути списком імен файлів, швидше за все файлів C/C++, але "
"насправді все, що може оброблятися певним компілятором і класом компілятора "
"(наприклад, :class:`MSVCCompiler` може обробляти файли ресурсів у "
"*джерелах*) . Повертає список імен файлів об’єктів, по одному на ім’я "
"вихідного файлу в *джерелах*. Залежно від реалізації, не всі вихідні файли "
"обов’язково будуть скомпільовані, але будуть повернуті всі відповідні імена "
"файлів об’єктів."

msgid ""
"If *output_dir* is given, object files will be put under it, while retaining "
"their original path component.  That is, :file:`foo/bar.c` normally compiles "
"to :file:`foo/bar.o` (for a Unix implementation); if *output_dir* is "
"*build*, then it would compile to :file:`build/foo/bar.o`."
msgstr ""
"Якщо задано *output_dir*, об’єктні файли буде розміщено під ним, зберігаючи "
"при цьому їхній початковий компонент шляху. Тобто :file:`foo/bar.c` зазвичай "
"компілюється до :file:`foo/bar.o` (для реалізації Unix); якщо *output_dir* є "
"*build*, тоді він скомпілюється до :file:`build/foo/bar.o`."

msgid ""
"*macros*, if given, must be a list of macro definitions.  A macro definition "
"is either a ``(name, value)`` 2-tuple or a ``(name,)`` 1-tuple. The former "
"defines a macro; if the value is ``None``, the macro is defined without an "
"explicit value.  The 1-tuple case undefines a macro.  Later definitions/"
"redefinitions/undefinitions take precedence."
msgstr ""
"*макроси*, якщо вказано, мають бути списком визначень макросів. Визначення "
"макросу – це 2-кортеж ``(ім’я, значення)\" або 1-кортеж ``(ім’я,)``. Перший "
"визначає макрос; якщо значенням є ``None``, макрос визначено без явного "
"значення. Випадок 1-кортежу не визначає макрос. Пізніші визначення/"
"перевизначення/невизначення мають пріоритет."

msgid ""
"*include_dirs*, if given, must be a list of strings, the directories to add "
"to the default include file search path for this compilation only."
msgstr ""
"*include_dirs*, якщо задано, має бути списком рядків, каталогів, які "
"потрібно додати до шляху пошуку файлів за замовчуванням лише для цієї "
"компіляції."

msgid ""
"*debug* is a boolean; if true, the compiler will be instructed to output "
"debug symbols in (or alongside) the object file(s)."
msgstr ""
"*debug* є логічним; якщо істина, компілятор отримає вказівку вивести символи "
"налагодження в (або поруч) з об’єктним файлом(ами)."

msgid ""
"*extra_preargs* and *extra_postargs* are implementation-dependent. On "
"platforms that have the notion of a command-line (e.g. Unix, DOS/Windows), "
"they are most likely lists of strings: extra command-line arguments to "
"prepend/append to the compiler command line.  On other platforms, consult "
"the implementation class documentation.  In any event, they are intended as "
"an escape hatch for those occasions when the abstract compiler framework "
"doesn't cut the mustard."
msgstr ""
"*extra_preargs* і *extra_postargs* залежать від реалізації. На платформах, "
"які мають поняття командного рядка (наприклад, Unix, DOS/Windows), це, "
"швидше за все, списки рядків: додаткові аргументи командного рядка для "
"додавання перед/до командного рядка компілятора. На інших платформах "
"зверніться до документації класу реалізації. У будь-якому випадку, вони "
"призначені як аварійний люк у тих випадках, коли структура абстрактного "
"компілятора не вирішує проблеми."

msgid ""
"*depends*, if given, is a list of filenames that all targets depend on.  If "
"a source file is older than any file in depends, then the source file will "
"be recompiled.  This supports dependency tracking, but only at a coarse "
"granularity."
msgstr ""
"*depends*, якщо вказано, це список імен файлів, від яких залежать усі цілі. "
"Якщо вихідний файл старіший за будь-який файл у залежностях, вихідний файл "
"буде перекомпільовано. Це підтримує відстеження залежностей, але лише з "
"грубою деталізацією."

msgid "Raises :exc:`CompileError` on failure."
msgstr "Викликає :exc:`CompileError` у разі помилки."

msgid ""
"Link a bunch of stuff together to create a static library file. The \"bunch "
"of stuff\" consists of the list of object files supplied as *objects*, the "
"extra object files supplied to :meth:`add_link_object` and/or :meth:"
"`set_link_objects`, the libraries supplied to :meth:`add_library` and/or :"
"meth:`set_libraries`, and the libraries supplied as *libraries* (if any)."
msgstr ""
"Зв’яжіть купу матеріалів разом, щоб створити файл статичної бібліотеки. "
"\"Кучка речей\" складається зі списку об’єктних файлів, наданих як "
"*objects*, додаткових об’єктних файлів, наданих у :meth:`add_link_object` та/"
"або :meth:`set_link_objects`, бібліотек, наданих у :meth:`add_library` та/"
"або :meth:`set_libraries`, а також бібліотеки, що надаються як *бібліотеки* "
"(якщо такі є)."

msgid ""
"*output_libname* should be a library name, not a filename; the filename will "
"be inferred from the library name.  *output_dir* is the directory where the "
"library file will be put."
msgstr ""
"*output_libname* має бути назвою бібліотеки, а не назвою файлу; ім'я файлу "
"буде виведено з назви бібліотеки. *output_dir* - це каталог, куди буде "
"розміщено файл бібліотеки."

msgid ""
"*debug* is a boolean; if true, debugging information will be included in the "
"library (note that on most platforms, it is the compile step where this "
"matters: the *debug* flag is included here just for consistency)."
msgstr ""
"*debug* є логічним; якщо true, інформація про налагодження буде включена в "
"бібліотеку (зауважте, що на більшості платформ це має значення на етапі "
"компіляції: прапор *debug* включено тут лише для узгодженості)."

msgid ""
"*target_lang* is the target language for which the given objects are being "
"compiled. This allows specific linkage time treatment of certain languages."
msgstr ""
"*target_lang* — цільова мова, для якої компілюються ці об’єкти. Це дозволяє "
"обробку певних мов у певний час зв’язування."

msgid "Raises :exc:`LibError` on failure."
msgstr "Викликає :exc:`LibError` у разі помилки."

msgid ""
"Link a bunch of stuff together to create an executable or shared library "
"file."
msgstr ""
"Пов’яжіть купу матеріалів разом, щоб створити виконуваний файл або файл "
"спільної бібліотеки."

msgid ""
"The \"bunch of stuff\" consists of the list of object files supplied as "
"*objects*. *output_filename* should be a filename.  If *output_dir* is "
"supplied, *output_filename* is relative to it (i.e. *output_filename* can "
"provide directory components if needed)."
msgstr ""
"\"Кучка речей\" складається зі списку об'єктних файлів, які надаються як "
"*об'єкти*. *вихідна_назва_файлу* має бути назвою файлу. Якщо вказано "
"*output_dir*, *output_filename* є відносно нього (тобто *output_filename* "
"може надати компоненти каталогу, якщо це необхідно)."

msgid ""
"*libraries* is a list of libraries to link against.  These are library "
"names, not filenames, since they're translated into filenames in a platform-"
"specific way (eg. *foo* becomes :file:`libfoo.a` on Unix and :file:`foo.lib` "
"on DOS/Windows).  However, they can include a directory component, which "
"means the linker will look in that specific directory rather than searching "
"all the normal locations."
msgstr ""
"*libraries* — це список бібліотек, з якими можна посилатися. Це назви "
"бібліотек, а не назви файлів, оскільки вони перекладаються на назви файлів "
"залежно від платформи (наприклад, *foo* стає :file:`libfoo.a` в Unix і :file:"
"`foo.lib` в DOS/ вікна). Однак вони можуть містити компонент каталогу, що "
"означає, що компонувальник шукатиме в цьому конкретному каталозі, а не "
"шукатиме у всіх звичайних місцях."

msgid ""
"*library_dirs*, if supplied, should be a list of directories to search for "
"libraries that were specified as bare library names (ie. no directory "
"component).  These are on top of the system default and those supplied to :"
"meth:`add_library_dir` and/or :meth:`set_library_dirs`.  "
"*runtime_library_dirs* is a list of directories that will be embedded into "
"the shared library and used to search for other shared libraries that "
"\\*it\\* depends on at run-time.  (This may only be relevant on Unix.)"
msgstr ""
"*library_dirs*, якщо надається, має бути списком каталогів для пошуку "
"бібліотек, які були вказані як голі імена бібліотек (тобто без компонента "
"каталогу). Вони є поверх системних стандартних і тих, що надаються до :meth:"
"`add_library_dir` та/або :meth:`set_library_dirs`. *runtime_library_dirs* — "
"це список каталогів, які будуть вбудовані в спільну бібліотеку та "
"використовуватимуться для пошуку інших спільних бібліотек, від яких "
"\\*вона\\* залежить під час виконання. (Це може бути актуальним лише для "
"Unix.)"

msgid ""
"*export_symbols* is a list of symbols that the shared library will export. "
"(This appears to be relevant only on Windows.)"
msgstr ""
"*export_symbols* — це список символів, які буде експортовано спільною "
"бібліотекою. (Здається, це стосується лише Windows.)"

msgid ""
"*debug* is as for :meth:`compile` and :meth:`create_static_lib`,  with the "
"slight distinction that it actually matters on most platforms (as opposed "
"to :meth:`create_static_lib`, which includes a *debug* flag mostly for "
"form's sake)."
msgstr ""
"*debug* — це те саме, що стосується :meth:`compile` і :meth:"
"`create_static_lib`, з тією невеликою різницею, що це насправді має значення "
"на більшості платформ (на відміну від :meth:`create_static_lib`, який "
"переважно містить прапорець *debug* заради форми)."

msgid ""
"*extra_preargs* and *extra_postargs* are as for :meth:`compile`  (except of "
"course that they supply command-line arguments for the particular linker "
"being used)."
msgstr ""
"*extra_preargs* і *extra_postargs* схожі на :meth:`compile` (звісно, за "
"винятком того, що вони надають аргументи командного рядка для конкретного "
"використовуваного компонувальника)."

msgid "Raises :exc:`LinkError` on failure."
msgstr "Викликає :exc:`LinkError` у разі помилки."

msgid ""
"Link an executable.  *output_progname* is the name of the file executable, "
"while *objects* are a list of object filenames to link in. Other arguments  "
"are as for the :meth:`link` method."
msgstr ""
"Посилання на виконуваний файл. *output_progname* — це ім’я виконуваного "
"файлу, тоді як *objects* — це список імен файлів об’єктів для посилань. Інші "
"аргументи такі ж, як і для методу :meth:`link`."

msgid ""
"Link a shared library. *output_libname* is the name of the output  library, "
"while *objects* is a list of object filenames to link in.  Other arguments "
"are as for the :meth:`link` method."
msgstr ""
"Пов’язати спільну бібліотеку. *output_libname* — це ім’я вихідної "
"бібліотеки, тоді як *objects* — це список імен файлів об’єктів для посилань. "
"Інші аргументи такі ж, як і для методу :meth:`link`."

msgid ""
"Link a shared object. *output_filename* is the name of the shared object "
"that will be created, while *objects* is a list of object filenames  to link "
"in. Other arguments are as for the :meth:`link` method."
msgstr ""
"Пов’язати спільний об’єкт. *output_filename* — це ім’я спільного об’єкта, "
"який буде створено, тоді як *objects* — це список імен файлів об’єктів для "
"посилань. Інші аргументи такі ж, як і для методу :meth:`link`."

msgid ""
"Preprocess a single C/C++ source file, named in *source*. Output will be "
"written to file named *output_file*, or *stdout* if *output_file* not "
"supplied. *macros* is a list of macro definitions as for :meth:`compile`, "
"which will augment the macros set with :meth:`define_macro` and :meth:"
"`undefine_macro`. *include_dirs* is a list of directory names that will be "
"added to the  default list, in the same way as :meth:`add_include_dir`."
msgstr ""
"Попередньо обробіть один вихідний файл C/C++, названий у *source*. Вихідні "
"дані буде записано у файл з назвою *output_file* або *stdout*, якщо "
"*output_file* не надано. *макроси* — це список визначень макросів, як для :"
"meth:`compile`, який доповнює набір макросів за допомогою :meth:"
"`define_macro` і :meth:`undefine_macro`. *include_dirs* — це список імен "
"каталогів, які буде додано до списку за замовчуванням так само, як :meth:"
"`add_include_dir`."

msgid "Raises :exc:`PreprocessError` on failure."
msgstr "Викликає :exc:`PreprocessError` у разі помилки."

msgid ""
"The following utility methods are defined by the :class:`CCompiler` class, "
"for use by the various concrete subclasses."
msgstr ""
"Наступні службові методи визначені класом :class:`CCompiler` для "
"використання різними конкретними підкласами."

msgid ""
"Returns the filename of the executable for the given *basename*.  Typically "
"for non-Windows platforms this is the same as the basename,  while Windows "
"will get a :file:`.exe` added."
msgstr ""
"Повертає назву виконуваного файлу для заданого *базового імені*. Зазвичай "
"для платформ, відмінних від Windows, це те саме, що й базове ім’я, у той час "
"як Windows додаватиме :file:`.exe`."

msgid ""
"Returns the filename for the given library name on the current platform. On "
"Unix a library with *lib_type* of ``'static'`` will typically  be of the "
"form :file:`liblibname.a`, while a *lib_type* of ``'dynamic'``  will be of "
"the form :file:`liblibname.so`."
msgstr ""
"Повертає назву файлу для заданої назви бібліотеки на поточній платформі. В "
"Unix бібліотека з *lib_type* ``'static'`` зазвичай матиме форму :file:"
"`liblibname.a`, тоді як *lib_type* ``'dynamic'`` матиме форму: файл:"
"`liblibname.so`."

msgid ""
"Returns the name of the object files for the given source files. "
"*source_filenames* should be a list of filenames."
msgstr ""
"Повертає назву об’єктних файлів для заданих вихідних файлів. "
"*source_filenames* має бути списком імен файлів."

msgid ""
"Returns the name of a shared object file for the given file name *basename*."
msgstr "Повертає назву файлу спільного об’єкта для заданого імені *basename*."

msgid ""
"Invokes :func:`distutils.util.execute`. This method invokes a  Python "
"function *func* with the given arguments *args*, after  logging and taking "
"into account the *dry_run* flag."
msgstr ""
"Викликає :func:`distutils.util.execute`. Цей метод викликає функцію Python "
"*func* із заданими аргументами *args* після реєстрації та з урахуванням "
"прапора *dry_run*."

msgid ""
"Invokes :func:`distutils.util.spawn`. This invokes an external  process to "
"run the given command."
msgstr ""
"Викликає :func:`distutils.util.spawn`. Це викликає зовнішній процес для "
"виконання даної команди."

msgid ""
"Invokes :func:`distutils.dir_util.mkpath`. This creates a directory  and any "
"missing ancestor directories."
msgstr ""
"Викликає :func:`distutils.dir_util.mkpath`. Це створює каталог і будь-які "
"відсутні каталоги предків."

msgid "Invokes :meth:`distutils.file_util.move_file`. Renames *src* to  *dst*."
msgstr ""
"Викликає :meth:`distutils.file_util.move_file`. Перейменовує *src* на *dst*."

msgid "Write a message using :func:`distutils.log.debug`."
msgstr "Напишіть повідомлення за допомогою :func:`distutils.log.debug`."

msgid "Write a warning message *msg* to standard error."
msgstr "Напишіть попередження *msg* до стандартної помилки."

msgid ""
"If the *debug* flag is set on this :class:`CCompiler` instance, print  *msg* "
"to standard output, otherwise do nothing."
msgstr ""
"Якщо на цьому екземплярі :class:`CCompiler` встановлено прапор *debug*, "
"виведіть *msg* у стандартний вихід, інакше нічого не робіть."

msgid ":mod:`distutils.unixccompiler` --- Unix C Compiler"
msgstr ":mod:`distutils.unixccompiler` --- Компілятор Unix C"

msgid ""
"This module provides the :class:`UnixCCompiler` class, a subclass of :class:"
"`CCompiler` that handles the typical Unix-style command-line  C compiler:"
msgstr ""
"Цей модуль надає клас :class:`UnixCCompiler`, підклас :class:`CCompiler`, "
"який обробляє типовий компілятор командного рядка C у стилі Unix:"

msgid "macros defined with :option:`!-Dname[=value]`"
msgstr "макроси, визначені за допомогою :option:`!-Dname[=value]`"

msgid "macros undefined with :option:`!-Uname`"
msgstr "макроси невизначені з :option:`!-Uname`"

msgid "include search directories specified with :option:`!-Idir`"
msgstr "включати каталоги пошуку, визначені за допомогою :option:`!-Idir`"

msgid "libraries specified with :option:`!-llib`"
msgstr "бібліотеки, визначені за допомогою :option:`!-llib`"

msgid "library search directories specified with :option:`!-Ldir`"
msgstr "каталоги пошуку бібліотек, указані за допомогою :option:`!-Ldir`"

msgid ""
"compile handled by :program:`cc` (or similar) executable with :option:`!-c` "
"option: compiles :file:`.c` to :file:`.o`"
msgstr ""
"компілюється за допомогою :program:`cc` (або подібного) виконуваного файлу з "
"опцією :option:`!-c`: компілює :file:`.c` до :file:`.o`"

msgid ""
"link static library handled by :program:`ar` command (possibly with :program:"
"`ranlib`)"
msgstr ""
"зв’язати статичну бібліотеку, яка обробляється командою :program:`ar` "
"(можливо, за допомогою :program:`ranlib`)"

msgid "link shared library handled by :program:`cc` :option:`!-shared`"
msgstr ""
"посилання на спільну бібліотеку обробляється :program:`cc` :option:`!-shared`"

msgid ":mod:`distutils.msvccompiler` --- Microsoft Compiler"
msgstr ":mod:`distutils.msvccompiler` --- Компілятор Microsoft"

msgid ""
"This module provides :class:`MSVCCompiler`, an implementation of the "
"abstract :class:`CCompiler` class for Microsoft Visual Studio. Typically, "
"extension modules need to be compiled with the same compiler that was used "
"to compile Python. For Python 2.3 and earlier, the compiler was Visual "
"Studio 6. For Python 2.4 and 2.5, the compiler is Visual Studio .NET 2003."
msgstr ""
"Цей модуль забезпечує :class:`MSVCCompiler`, реалізацію абстрактного :class:"
"`CCompiler` класу для Microsoft Visual Studio. Як правило, модулі розширення "
"потрібно скомпілювати за допомогою того самого компілятора, який "
"використовувався для компіляції Python. Для Python 2.3 і раніших версій "
"компілятором була Visual Studio 6. Для Python 2.4 і 2.5 компілятором була "
"Visual Studio .NET 2003."

msgid ""
":class:`MSVCCompiler` will normally choose the right compiler, linker etc. "
"on its own. To override this choice, the environment variables "
"*DISTUTILS_USE_SDK* and *MSSdk* must be both set. *MSSdk* indicates that the "
"current environment has been setup by the SDK's ``SetEnv.Cmd`` script, or "
"that the environment variables had been registered when the SDK was "
"installed; *DISTUTILS_USE_SDK* indicates that the distutils user has made an "
"explicit choice to override the compiler selection by :class:`MSVCCompiler`."
msgstr ""
":class:`MSVCCompiler` зазвичай самостійно вибере правильний компілятор, "
"компонувальник тощо. Щоб перевизначити цей вибір, потрібно встановити обидві "
"змінні середовища *DISTUTILS_USE_SDK* і *MSSdk*. *MSSdk* вказує на те, що "
"поточне середовище було налаштовано за допомогою сценарію ``SetEnv.Cmd`` SDK "
"або що змінні середовища були зареєстровані під час встановлення SDK; "
"*DISTUTILS_USE_SDK* вказує, що користувач distutils зробив явний вибір "
"перевизначити вибір компілятора за допомогою :class:`MSVCCompiler`."

msgid ":mod:`distutils.bcppcompiler` --- Borland Compiler"
msgstr ":mod:`distutils.bcppcompiler` --- Компілятор Borland"

msgid ""
"This module provides :class:`BorlandCCompiler`, a subclass of the abstract :"
"class:`CCompiler` class for the Borland C++ compiler."
msgstr ""
"Цей модуль надає :class:`BorlandCCompiler`, підклас абстрактного :class:"
"`CCompiler` класу для компілятора Borland C++."

msgid ":mod:`distutils.cygwincompiler` --- Cygwin Compiler"
msgstr ":mod:`distutils.cygwincompiler` --- компілятор Cygwin"

msgid ""
"This module provides the :class:`CygwinCCompiler` class, a subclass of :"
"class:`UnixCCompiler` that handles the Cygwin port of the GNU C compiler to "
"Windows.  It also contains the Mingw32CCompiler class which handles the "
"mingw32 port of GCC (same as cygwin in no-cygwin mode)."
msgstr ""
"Цей модуль надає клас :class:`CygwinCCompiler`, підклас :class:"
"`UnixCCompiler`, який обробляє порт Cygwin компілятора GNU C для Windows. "
"Він також містить клас Mingw32CCompiler, який обробляє порт mingw32 GCC (те "
"саме, що cygwin у режимі без cygwin)."

msgid ":mod:`distutils.archive_util` ---  Archiving utilities"
msgstr ":mod:`distutils.archive_util` --- Утиліти архівування"

msgid ""
"This module provides a few functions for creating archive files, such as "
"tarballs or zipfiles."
msgstr ""
"Цей модуль надає кілька функцій для створення архівних файлів, таких як tar-"
"файли або zip-файли."

msgid ""
"Create an archive file (eg. ``zip`` or ``tar``).  *base_name*  is the name "
"of the file to create, minus any format-specific extension;  *format* is the "
"archive format: one of ``zip``, ``tar``, ``gztar``, ``bztar``, ``xztar``, or "
"``ztar``. *root_dir* is a directory that will be the root directory of the "
"archive; ie. we typically ``chdir`` into *root_dir* before  creating the "
"archive.  *base_dir* is the directory where we start  archiving from; ie. "
"*base_dir* will be the common prefix of all files and directories in the "
"archive.  *root_dir* and *base_dir* both default to the current directory. "
"Returns the name of the archive file."
msgstr ""
"Створіть архівний файл (наприклад, ``zip`` або ``tar``). *base_name* — це "
"ім’я файлу, який потрібно створити, за вирахуванням розширення, що залежить "
"від формату; *format* — це формат архіву: один із ``zip``, ``tar``, "
"``gztar``, ``bztar``, ``xztar`` або ``ztar``. *root_dir* – це каталог, який "
"буде кореневим каталогом архіву; тобто. ми зазвичай ``chdir`` в *root_dir* "
"перед створенням архіву. *base_dir* - це каталог, з якого ми починаємо "
"архівування; тобто. *base_dir* буде загальним префіксом для всіх файлів і "
"каталогів в архіві. *root_dir* і *base_dir* за замовчуванням є поточним "
"каталогом. Повертає назву архівного файлу."

msgid "Added support for the ``xztar`` format."
msgstr "Додано підтримку формату ``xztar``."

msgid ""
"'Create an (optional compressed) archive as a tar file from all files in and "
"under *base_dir*. *compress* must be ``'gzip'`` (the default), ``'bzip2'``, "
"``'xz'``, ``'compress'``, or ``None``.  For the ``'compress'`` method the "
"compression utility named by :program:`compress` must be on the default "
"program search path, so this is probably Unix-specific.  The output tar file "
"will be named :file:`base_dir.tar`, possibly plus the appropriate "
"compression extension (``.gz``, ``.bz2``, ``.xz`` or ``.Z``).  Return the "
"output filename."
msgstr ""
"\"Створіть (необов’язково стиснутий) архів як файл tar з усіх файлів у "
"*base_dir* та під ним. *compress* має бути ``'gzip'`` (за замовчуванням), "
"``'bzip2'``, ``'xz'``, ``'compress'`` або ``None``. Для методу "
"``'стиснення''`` утиліта стиснення, названа :program:`compress`, має бути на "
"шляху пошуку програми за замовчуванням, тому це, ймовірно, специфічно для "
"Unix. Вихідний файл tar матиме назву :file:`base_dir.tar`, можливо, з "
"додаванням відповідного розширення стиснення (``.gz``, ``.bz2``, ``.xz`` або "
"``.Z`` ). Повернути назву вихідного файлу."

msgid "Added support for the ``xz`` compression."
msgstr "Додано підтримку стиснення ``xz``."

msgid ""
"Create a zip file from all files in and under *base_dir*.  The output zip "
"file will be named *base_name* + :file:`.zip`.  Uses either the  :mod:"
"`zipfile` Python module (if available) or the InfoZIP :file:`zip`  utility "
"(if installed and found on the default search path).  If neither  tool is "
"available, raises :exc:`DistutilsExecError`.   Returns the name of the "
"output zip file."
msgstr ""
"Створіть файл zip з усіх файлів у *base_dir* і під ним. Вихідний zip-файл "
"матиме назву *base_name* + :file:`.zip`. Використовує або модуль :mod:"
"`zipfile` Python (якщо доступний), або утиліту InfoZIP :file:`zip` (якщо "
"встановлено та знайдено на шляху пошуку за умовчанням). Якщо жоден "
"інструмент недоступний, викликає :exc:`DistutilsExecError`. Повертає назву "
"вихідного zip-файлу."

msgid ":mod:`distutils.dep_util` --- Dependency checking"
msgstr ":mod:`distutils.dep_util` --- Перевірка залежностей"

msgid ""
"This module provides functions for performing simple, timestamp-based "
"dependency of files and groups of files; also, functions based entirely  on "
"such timestamp dependency analysis."
msgstr ""
"Цей модуль надає функції для виконання простої залежності файлів і груп "
"файлів на основі часових позначок; також функції, повністю засновані на "
"такому аналізі залежностей часових позначок."

msgid ""
"Return true if *source* exists and is more recently modified than *target*, "
"or if *source* exists and *target* doesn't. Return false if both exist and "
"*target* is the same age or newer  than *source*. Raise :exc:"
"`DistutilsFileError` if *source* does not exist."
msgstr ""
"Повертає істину, якщо *джерело* існує та змінено нещодавно, ніж *ціль*, або "
"якщо *джерело* існує, а *ціль* ні. Повертає false, якщо обидва існують і "
"*ціль* має той самий вік або новіший, ніж *джерело*. Викликати :exc:"
"`DistutilsFileError`, якщо *джерело* не існує."

msgid ""
"Walk two filename lists in parallel, testing if each source is newer than "
"its corresponding target.  Return a pair of lists (*sources*, *targets*) "
"where source is newer than target, according to the semantics of :func:"
"`newer`."
msgstr ""
"Перегляньте два списки імен файлів паралельно, перевіряючи, чи кожне джерело "
"є новішим за відповідну ціль. Повертає пару списків (*джерела*, *цілі*), де "
"джерело є новішим за ціль, відповідно до семантики :func:`newer`."

msgid ""
"Return true if *target* is out-of-date with respect to any file listed in "
"*sources*.  In other words, if *target* exists and is newer than every file "
"in *sources*, return false; otherwise return true. *missing* controls what "
"we do when a source file is missing; the default (``'error'``) is to blow up "
"with an :exc:`OSError` from  inside :func:`os.stat`; if it is ``'ignore'``, "
"we silently drop any missing source files; if it is ``'newer'``, any missing "
"source files make us assume that *target* is out-of-date (this is handy in "
"\"dry-run\" mode: it'll make you pretend to carry out commands that wouldn't "
"work because inputs are missing, but that doesn't matter because you're not "
"actually going to run the commands)."
msgstr ""
"Повертає true, якщо *target* застарів щодо будь-якого файлу, зазначеного в "
"*джерелах*. Іншими словами, якщо *target* існує і є новішим за всі файли в "
"*sources*, поверніть false; інакше повертає true. *missing* контролює те, що "
"ми робимо, коли вихідний файл відсутній; за замовчуванням (``'помилка'``) "
"вибухає з :exc:`OSError` зсередини :func:`os.stat`; якщо це ``'ignore''``, "
"ми мовчки видаляємо всі відсутні джерельні файли; якщо він ``'новіший'``, "
"будь-які відсутні вихідні файли змушують нас вважати, що *target* застарів "
"(це зручно в режимі \"сухого запуску\": це змусить вас вдавати, що ви "
"виконуєте команди це не спрацює, оскільки вхідні дані відсутні, але це не "
"має значення, оскільки ви насправді не збираєтеся виконувати команди)."

msgid ":mod:`distutils.dir_util` --- Directory tree operations"
msgstr ":mod:`distutils.dir_util` --- Операції з деревом каталогів"

msgid ""
"This module provides functions for operating on directories and trees of "
"directories."
msgstr ""
"Цей модуль надає функції для роботи з каталогами та деревами каталогів."

msgid ""
"Create a directory and any missing ancestor directories.  If the directory "
"already exists (or if *name* is the empty string, which means the current "
"directory, which of course exists), then do nothing.  Raise :exc:"
"`DistutilsFileError` if unable to create some directory along the way (eg. "
"some sub-path exists, but is a file rather than a directory).  If *verbose* "
"is true, print a one-line summary of each mkdir to stdout.  Return the list "
"of directories actually created."
msgstr ""
"Створіть каталог і будь-які відсутні каталоги предків. Якщо каталог уже "
"існує (або якщо *name* є порожнім рядком, що означає поточний каталог, який, "
"звичайно, існує), тоді нічого не робити. Викликати :exc:"
"`DistutilsFileError`, якщо неможливо створити певний каталог (наприклад, "
"якийсь підшлях існує, але це файл, а не каталог). Якщо *verbose* має "
"значення true, вивести однорядковий підсумок кожного mkdir у стандартний "
"вихід. Повертає список фактично створених каталогів."

msgid ""
"Create all the empty directories under *base_dir* needed to put *files* "
"there. *base_dir* is just the name of a directory which doesn't necessarily "
"exist yet; *files* is a list of filenames to be interpreted relative to "
"*base_dir*. *base_dir* + the directory portion of every file in *files* will "
"be created if it doesn't already exist.  *mode*, *verbose* and *dry_run* "
"flags  are as for :func:`mkpath`."
msgstr ""
"Створіть усі порожні каталоги в *base_dir*, необхідні для розміщення туди "
"*файлів*. *base_dir* — це просто назва каталогу, який ще не обов’язково "
"існує; *files* — це список імен файлів, які слід інтерпретувати відносно "
"*base_dir*. *base_dir* + частина каталогу кожного файлу в *files* буде "
"створена, якщо вона ще не існує. Прапори *mode*, *verbose* і *dry_run* такі "
"ж, як і для :func:`mkpath`."

msgid ""
"Copy an entire directory tree *src* to a new location *dst*.  Both *src* and "
"*dst* must be directory names.  If *src* is not a directory, raise :exc:"
"`DistutilsFileError`.  If *dst* does  not exist, it is created with :func:"
"`mkpath`.  The end result of the  copy is that every file in *src* is copied "
"to *dst*, and  directories under *src* are recursively copied to *dst*. "
"Return the list of files that were copied or might have been copied, using "
"their output name. The return value is unaffected by *update* or *dry_run*: "
"it is simply the list of all files under *src*, with the names changed to be "
"under *dst*."
msgstr ""
"Скопіюйте все дерево каталогів *src* до нового розташування *dst*. І *src*, "
"і *dst* мають бути іменами каталогів. Якщо *src* не є каталогом, викликайте :"
"exc:`DistutilsFileError`. Якщо *dst* не існує, він створюється за допомогою :"
"func:`mkpath`. Кінцевим результатом копіювання є те, що кожен файл у *src* "
"копіюється в *dst*, а каталоги в *src* рекурсивно копіюються в *dst*. "
"Повертає список файлів, які були скопійовані або могли бути скопійовані, "
"використовуючи їхні вихідні назви. На повернене значення не впливають "
"*update* або *dry_run*: це просто список усіх файлів у *src*, імена яких "
"змінено на *dst*."

msgid ""
"*preserve_mode* and *preserve_times* are the same as for :func:`distutils."
"file_util.copy_file`; note that they only apply to regular files, not to "
"directories.  If *preserve_symlinks* is true, symlinks will be copied as "
"symlinks (on platforms that support them!); otherwise (the default), the "
"destination of the symlink will be copied.  *update* and *verbose* are the "
"same as for :func:`copy_file`."
msgstr ""
"*preserve_mode* і *preserve_times* такі самі, як і для :func:`distutils."
"file_util.copy_file`; зауважте, що вони застосовуються лише до звичайних "
"файлів, а не до каталогів. Якщо *preserve_symlinks* має значення true, "
"символічні посилання буде скопійовано як символічні посилання (на "
"платформах, які їх підтримують!); інакше (за замовчуванням) місце "
"призначення символічного посилання буде скопійовано. *update* і *verbose* "
"такі самі, як і для :func:`copy_file`."

msgid ""
"Files in *src* that begin with :file:`.nfs` are skipped (more information on "
"these files is available in answer D2 of the `NFS FAQ page <http://nfs."
"sourceforge.net/#section_d>`_)."
msgstr ""
"Файли в *src*, які починаються з :file:`.nfs`, пропускаються (додаткову "
"інформацію про ці файли можна знайти у відповіді D2 на сторінці `NFS FAQ "
"<http://nfs.sourceforge.net/#section_d>`_)."

msgid "NFS files are ignored."
msgstr "Файли NFS ігноруються."

msgid ""
"Recursively remove *directory* and all files and directories underneath it. "
"Any errors are ignored (apart from being reported to ``sys.stdout`` if "
"*verbose* is true)."
msgstr ""
"Рекурсивно видаліть *каталог* і всі файли та каталоги під ним. Будь-які "
"помилки ігноруються (крім повідомлень у ``sys.stdout``, якщо *verbose* має "
"значення true)."

msgid ":mod:`distutils.file_util` --- Single file operations"
msgstr ":mod:`distutils.file_util` --- Операції з одним файлом"

msgid ""
"This module contains some utility functions for operating on individual "
"files."
msgstr ""
"Цей модуль містить деякі службові функції для роботи з окремими файлами."

msgid ""
"Copy file *src* to *dst*. If *dst* is a directory, then *src* is copied "
"there with the same name; otherwise, it must be a filename. (If the file "
"exists, it will be ruthlessly clobbered.) If *preserve_mode* is true (the "
"default), the file's mode (type and permission bits, or whatever is "
"analogous on the current platform) is copied. If *preserve_times* is true "
"(the default), the last-modified and last-access times are copied as well. "
"If *update* is true, *src* will only be copied if *dst* does not exist, or "
"if *dst* does exist but is older than *src*."
msgstr ""
"Скопіюйте файл *src* в *dst*. Якщо *dst* є каталогом, то *src* копіюється "
"туди з таким же ім’ям; інакше це має бути ім'я файлу. (Якщо файл існує, його "
"буде безжально знищено.) Якщо *preserve_mode* має значення true (за "
"замовчуванням), режим файлу (тип і біти дозволу або щось аналогічне на "
"поточній платформі) копіюється. Якщо *preserve_times* має значення true (за "
"замовчуванням), час останньої зміни та останнього доступу також копіюється. "
"Якщо *update* має значення true, *src* буде скопійовано, лише якщо *dst* не "
"існує, або якщо *dst* існує, але він старіший за *src*."

msgid ""
"*link* allows you to make hard links (using :func:`os.link`) or symbolic "
"links (using :func:`os.symlink`) instead of copying: set it to ``'hard'`` or "
"``'sym'``; if it is ``None`` (the default), files are copied. Don't set "
"*link* on systems that don't support it: :func:`copy_file` doesn't check if "
"hard or symbolic linking is available.  It uses :func:`_copy_file_contents` "
"to copy file contents."
msgstr ""
"*link* дозволяє створювати жорсткі посилання (за допомогою :func:`os.link`) "
"або символічні посилання (за допомогою :func:`os.symlink`) замість "
"копіювання: установіть значення ``'hard'`` або ``'сим'``; якщо значення "
"``None`` (за замовчуванням), файли копіюються. Не встановлюйте *посилання* "
"на системах, які його не підтримують: :func:`copy_file` не перевіряє "
"наявність жорсткого чи символічного зв’язування. Він використовує :func:"
"`_copy_file_contents` для копіювання вмісту файлу."

msgid ""
"Return a tuple ``(dest_name, copied)``: *dest_name* is the actual  name of "
"the output file, and *copied* is true if the file was copied  (or would have "
"been copied, if *dry_run* true)."
msgstr ""
"Повертає кортеж ``(dest_name, copied)``: *dest_name* є фактичною назвою "
"вихідного файлу, а *copied* має значення true, якщо файл було скопійовано "
"(або було б скопійовано, якщо *dry_run* true)."

msgid ""
"Move file *src* to *dst*. If *dst* is a directory, the file will be moved "
"into it with the same name; otherwise, *src* is just renamed to *dst*.  "
"Returns the new full name of the file."
msgstr ""
"Перемістити файл *src* до *dst*. Якщо *dst* є каталогом, файл буде "
"переміщено до нього з таким же ім'ям; інакше *src* просто перейменовується "
"на *dst*. Повертає нову повну назву файлу."

msgid ""
"Handles cross-device moves on Unix using :func:`copy_file`.  What about "
"other systems?"
msgstr ""
"Обробляє переміщення між пристроями в Unix за допомогою :func:`copy_file`. А "
"як щодо інших систем?"

msgid ""
"Create a file called *filename* and write *contents* (a sequence of strings "
"without line terminators) to it."
msgstr ""
"Створіть файл під назвою *filename* і запишіть у нього *contents* "
"(послідовність рядків без символів закінчення рядків)."

msgid ":mod:`distutils.util` --- Miscellaneous other utility functions"
msgstr ":mod:`distutils.util` --- Інші інші службові функції"

msgid ""
"This module contains other assorted bits and pieces that don't fit into  any "
"other utility module."
msgstr ""
"Цей модуль містить інші різні частини, які не підходять до жодного іншого "
"службового модуля."

msgid ""
"Return a string that identifies the current platform.  This is used mainly "
"to distinguish platform-specific build directories and platform-specific "
"built distributions.  Typically includes the OS name and version and the "
"architecture (as supplied by 'os.uname()'), although the exact information "
"included depends on the OS; e.g., on Linux, the kernel version isn't "
"particularly important."
msgstr ""
"Повертає рядок, що ідентифікує поточну платформу. Це використовується в "
"основному для того, щоб розрізнити каталоги збірок для певної платформи та "
"побудовані дистрибутиви для конкретної платформи. Зазвичай включає назву та "
"версію ОС та архітектуру (як надає 'os.uname()'), хоча точна включена "
"інформація залежить від ОС; наприклад, у Linux версія ядра не особливо "
"важлива."

msgid "Examples of returned values:"
msgstr "Приклади повернених значень:"

msgid "``linux-i586``"
msgstr "``linux-i586``"

msgid "``linux-alpha``"
msgstr "``linux-альфа``"

msgid "``solaris-2.6-sun4u``"
msgstr "``solaris-2.6-sun4u``"

msgid "For non-POSIX platforms, currently just returns ``sys.platform``."
msgstr ""
"Для платформ, відмінних від POSIX, наразі повертає лише ``sys.platform``."

msgid ""
"For macOS systems the OS version reflects the minimal version on which "
"binaries will run (that is, the value of ``MACOSX_DEPLOYMENT_TARGET`` during "
"the build of Python), not the OS version of the current system."
msgstr ""
"Для систем macOS версія ОС відображає мінімальну версію, на якій "
"запускатимуться двійкові файли (тобто значення ``MACOSX_DEPLOYMENT_TARGET`` "
"під час збирання Python), а не версію ОС поточної системи."

msgid ""
"For universal binary builds on macOS the architecture value reflects the "
"universal binary status instead of the architecture of the current "
"processor. For 32-bit universal binaries the architecture is ``fat``, for 64-"
"bit universal binaries the architecture is ``fat64``, and for 4-way "
"universal binaries the architecture is ``universal``. Starting from Python "
"2.7 and Python 3.2 the architecture ``fat3`` is used for a 3-way universal "
"build (ppc, i386, x86_64) and ``intel`` is used for a universal build with "
"the i386 and x86_64 architectures"
msgstr ""
"Для універсальних двійкових збірок на macOS значення архітектури відображає "
"статус універсального двійкового файлу замість архітектури поточного "
"процесора. Для 32-розрядних універсальних двійкових файлів архітектура "
"``fat``, для 64-розрядних універсальних двійкових файлів архітектура "
"``fat64``, а для 4-сторонніх універсальних двійкових файлів архітектура "
"``universal``. Починаючи з Python 2.7 і Python 3.2, архітектура ``fat3`` "
"використовується для тристоронньої універсальної збірки (ppc, i386, x86_64), "
"а ``intel`` використовується для універсальної збірки з архітектурами i386 і "
"x86_64"

msgid "Examples of returned values on macOS:"
msgstr "Приклади повернених значень у macOS:"

msgid "``macosx-10.3-ppc``"
msgstr "``macosx-10.3-ppc``"

msgid "``macosx-10.3-fat``"
msgstr "``macosx-10.3-fat``"

msgid "``macosx-10.5-universal``"
msgstr "``macosx-10.5-universal``"

msgid "``macosx-10.6-intel``"
msgstr "``macosx-10.6-intel``"

msgid ""
"For AIX, Python 3.9 and later return a string starting with \"aix\", "
"followed by additional fields (separated by ``'-'``) that represent the "
"combined values of AIX Version, Release and Technology Level (first field), "
"Build Date (second field), and bit-size (third field). Python 3.8 and "
"earlier returned only a single additional field with the AIX Version and "
"Release."
msgstr ""
"Для AIX Python 3.9 і пізніших версій повертає рядок, що починається з "
"\"aix\", за яким ідуть додаткові поля (розділені \"-\"), які представляють "
"об’єднані значення версії AIX, випуску та рівня технології (перше поле), "
"Build Дата (друге поле) і бітовий розмір (третє поле). Python 3.8 і "
"попередні версії повертали лише одне додаткове поле з версією та випуском "
"AIX."

msgid "Examples of returned values on AIX:"
msgstr "Приклади повернених значень в AIX:"

msgid ""
"``aix-5307-0747-32`` # 32-bit build on AIX ``oslevel -s``: 5300-07-00-0000"
msgstr ""
"``aix-5307-0747-32`` # 32-розрядна збірка на AIX ``oslevel -s``: "
"5300-07-00-0000"

msgid ""
"``aix-7105-1731-64`` # 64-bit build on AIX ``oslevel -s``: 7100-05-01-1731"
msgstr ""
"``aix-7105-1731-64`` # 64-розрядна збірка на AIX ``oslevel -s``: "
"7100-05-01-1731"

msgid "``aix-7.2``          # Legacy form reported in Python 3.8 and earlier"
msgstr "``aix-7.2`` # Застаріла форма, представлена в Python 3.8 і раніше"

msgid ""
"The AIX platform string format now also includes the technology level, build "
"date, and ABI bit-size."
msgstr ""
"Формат рядка платформи AIX тепер також включає рівень технології, дату "
"збірки та бітовий розмір ABI."

msgid ""
"Return 'pathname' as a name that will work on the native filesystem, i.e. "
"split it on '/' and put it back together again using the current directory "
"separator. Needed because filenames in the setup script are always supplied "
"in Unix style, and have to be converted to the local convention before we "
"can actually use them in the filesystem.  Raises :exc:`ValueError` on non-"
"Unix-ish systems if *pathname* either  starts or ends with a slash."
msgstr ""
"Поверніть \"pathname\" як ім’я, яке працюватиме у рідній файловій системі, "
"тобто розділіть його на \"/\" і знову об’єднайте, використовуючи поточний "
"роздільник каталогів. Необхідно, тому що імена файлів у сценарії "
"встановлення завжди надаються у стилі Unix і мають бути перетворені "
"відповідно до локальної угоди, перш ніж ми зможемо фактично використовувати "
"їх у файловій системі. Викликає :exc:`ValueError` на системах, що не "
"підтримують Unix, якщо *шлях* починається або закінчується скісною рискою."

msgid ""
"Return *pathname* with *new_root* prepended.  If *pathname* is relative, "
"this is equivalent to ``os.path.join(new_root,pathname)`` Otherwise, it "
"requires making *pathname* relative and then joining the two, which is "
"tricky on DOS/Windows."
msgstr ""
"Повернути *pathname* з *new_root* перед початком. Якщо *pathname* є "
"відносним, це еквівалентно ``os.path.join(new_root,pathname)``. В іншому "
"випадку потрібно зробити *pathname* відносним, а потім об’єднати два, що "
"складно в DOS/Windows."

msgid ""
"Ensure that 'os.environ' has all the environment variables we guarantee that "
"users can use in config files, command-line options, etc.  Currently this "
"includes:"
msgstr ""
"Переконайтеся, що \"os.environ\" містить усі змінні середовища, які ми "
"гарантуємо, що користувачі можуть використовувати у файлах конфігурації, "
"параметрах командного рядка тощо. Наразі це включає:"

msgid ":envvar:`HOME` - user's home directory (Unix only)"
msgstr ":envvar:`HOME` - домашній каталог користувача (тільки для Unix)"

msgid ""
":envvar:`PLAT` - description of the current platform, including hardware and "
"OS (see :func:`get_platform`)"
msgstr ""
":envvar:`PLAT` - опис поточної платформи, включаючи обладнання та ОС (див. :"
"func:`get_platform`)"

msgid ""
"Perform shell/Perl-style variable substitution on *s*.  Every occurrence of "
"``$`` followed by a name is considered a variable, and variable is "
"substituted by the value found in the *local_vars* dictionary, or in ``os."
"environ`` if it's not in *local_vars*. *os.environ* is first checked/"
"augmented to guarantee that it contains certain values: see :func:"
"`check_environ`.  Raise :exc:`ValueError` for any variables not found in "
"either *local_vars* or ``os.environ``."
msgstr ""
"Виконайте підстановку змінної у стилі shell/Perl на *s*. Кожне входження "
"``$``, після якого йде ім’я, вважається змінною, а змінна замінюється "
"значенням, знайденим у словнику *local_vars* або в ``os.environ``, якщо його "
"немає в *local_vars*. *os.environ* спочатку перевіряється/доповнюється, щоб "
"гарантувати, що він містить певні значення: див. :func:`check_environ`. "
"Викликати :exc:`ValueError` для будь-яких змінних, не знайдених ні в "
"*local_vars*, ні в ``os.environ``."

msgid ""
"Note that this is not a full-fledged string interpolation function. A valid "
"``$variable`` can consist only of upper and lower case letters, numbers and "
"an underscore. No { } or ( ) style quoting is available."
msgstr ""

msgid ""
"Split a string up according to Unix shell-like rules for quotes and "
"backslashes. In short: words are delimited by spaces, as long as those "
"spaces are not escaped by a backslash, or inside a quoted string. Single and "
"double quotes are equivalent, and the quote characters can be backslash-"
"escaped.  The backslash is stripped from any two-character escape sequence, "
"leaving only the escaped character.  The quote characters are stripped from "
"any quoted string.  Returns a list of words."
msgstr ""
"Розділіть рядок відповідно до правил оболонки Unix для лапок і зворотних "
"косих риск. Коротше кажучи: слова розділені пробілами, якщо ці пробіли не "
"виділені зворотною скісною рискою або всередині рядка в лапках. Одинарні та "
"подвійні лапки еквівалентні, а символи лапок можна екранувати зворотною "
"скісною рискою. Зворотний слеш видаляється з будь-якої послідовності "
"екранування з двох символів, залишаючи лише екранований символ. Символи "
"лапок видаляються з будь-якого рядка в лапках. Повертає список слів."

msgid ""
"Perform some action that affects the outside world (for instance, writing to "
"the filesystem).  Such actions are special because they are disabled by the "
"*dry_run* flag.  This method takes  care of all that bureaucracy for you; "
"all you have to do is supply the function to call and an argument tuple for "
"it (to embody the \"external action\" being performed), and an optional "
"message to print."
msgstr ""
"Виконайте певну дію, яка впливає на зовнішній світ (наприклад, запис у "
"файлову систему). Такі дії є особливими, тому що вони вимкнені прапором "
"*dry_run*. Цей метод подбає про всю цю бюрократію за вас; все, що вам "
"потрібно зробити, це надати функцію для виклику та кортеж аргументів для неї "
"(щоб втілити \"зовнішню дію\", що виконується), і додаткове повідомлення для "
"друку."

msgid "Convert a string representation of truth to true (1) or false (0)."
msgstr ""
"Перетворення рядкового представлення правди в істину (1) або хибність (0)."

msgid ""
"True values are ``y``, ``yes``, ``t``, ``true``, ``on``  and ``1``; false "
"values are ``n``, ``no``, ``f``, ``false``,  ``off`` and ``0``.  Raises :exc:"
"`ValueError` if *val*  is anything else."
msgstr ""
"Справжніми значеннями є ``y``, ``yes``, ``t``, ``true``, ``on`` і ``1``; "
"помилковими значеннями є ``n``, ``no``, ``f``, ``false``, ``off`` і ``0``. "
"Викликає :exc:`ValueError`, якщо *val* є чимось іншим."

msgid ""
"Byte-compile a collection of Python source files to :file:`.pyc` files in a :"
"file:`__pycache__` subdirectory (see :pep:`3147` and :pep:`488`). *py_files* "
"is a list of files to compile; any files that don't end in :file:`.py` are "
"silently skipped.  *optimize* must be one of the following:"
msgstr ""
"Байтова компіляція колекції вихідних файлів Python у файли :file:`.pyc` у "
"підкаталозі :file:`__pycache__` (див. :pep:`3147` і :pep:`488`). *py_files* "
"— список файлів для компіляції; будь-які файли, які не закінчуються на :file:"
"`.py` мовчки пропускаються. *optimize* має бути одним із таких:"

msgid "``0`` - don't optimize"
msgstr "``0`` - не оптимізувати"

msgid "``1`` - normal optimization (like ``python -O``)"
msgstr "``1`` - звичайна оптимізація (наприклад, ``python -O``)"

msgid "``2`` - extra optimization (like ``python -OO``)"
msgstr "``2`` - додаткова оптимізація (наприклад, ``python -OO``)"

msgid "If *force* is true, all files are recompiled regardless of timestamps."
msgstr ""
"Якщо *force* має значення true, усі файли перекомпільовуються незалежно від "
"позначок часу."

msgid ""
"The source filename encoded in each :term:`bytecode` file defaults to the "
"filenames listed in *py_files*; you can modify these with *prefix* and "
"*basedir*. *prefix* is a string that will be stripped off of each source "
"filename, and *base_dir* is a directory name that will be prepended (after "
"*prefix* is stripped).  You can supply either or both (or neither) of "
"*prefix* and *base_dir*, as you wish."
msgstr ""
"Ім’я вихідного файлу, закодоване в кожному файлі :term:`bytecode`, за "
"замовчуванням відповідає назвам файлів, указаним у *py_files*; ви можете "
"змінити їх за допомогою *prefix* і *basedir*. *префікс* — це рядок, який "
"буде видалено з імені кожного вихідного файлу, а *base_dir* — це ім’я "
"каталогу, яке буде додано перед (після видалення *префікса*). Ви можете "
"вказати один або обидва (або жоден) з *prefix* і *base_dir*, як хочете."

msgid ""
"If *dry_run* is true, doesn't actually do anything that would affect the "
"filesystem."
msgstr ""
"Якщо *dry_run* має значення true, фактично не робить нічого, що могло б "
"вплинути на файлову систему."

msgid ""
"Byte-compilation is either done directly in this interpreter process with "
"the standard :mod:`py_compile` module, or indirectly by writing a temporary "
"script and executing it.  Normally, you should let :func:`byte_compile` "
"figure out to use direct compilation or not (see the source for details).  "
"The *direct* flag is used by the script generated in indirect mode; unless "
"you know what you're doing, leave it set to ``None``."
msgstr ""
"Компіляція байтів виконується або безпосередньо в цьому процесі "
"інтерпретатора за допомогою стандартного модуля :mod:`py_compile`, або "
"опосередковано шляхом написання тимчасового сценарію та його виконання. "
"Зазвичай ви повинні дозволити :func:`byte_compile` визначити, "
"використовувати пряму компіляцію чи ні (дивіться джерело для деталей). "
"Прапор *прямий* використовується сценарієм, згенерованим у непрямому режимі; "
"Якщо ви не знаєте, що робите, залиште значення ``None``."

msgid ""
"Create ``.pyc`` files with an :func:`import magic tag <imp.get_tag>` in "
"their name, in a :file:`__pycache__` subdirectory instead of files without "
"tag in the current directory."
msgstr ""
"Створюйте файли ``.pyc`` із :func:`магічним тегом імпорту <imp.get_tag>` у "
"своєму імені в підкаталозі :file:`__pycache__` замість файлів без тегу в "
"поточному каталозі."

msgid "Create ``.pyc`` files according to :pep:`488`."
msgstr "Створіть файли ``.pyc`` відповідно до :pep:`488`."

msgid ""
"Return a version of *header* escaped for inclusion in an :rfc:`822` header, "
"by ensuring there are 8 spaces space after each newline. Note that it does "
"no other modification of the string."
msgstr ""
"Повертає екрановану версію *заголовка* для включення в заголовок :rfc:`822`, "
"переконавшись, що після кожного нового рядка є 8 пробілів. Зауважте, що він "
"не виконує інших модифікацій рядка."

msgid ":mod:`distutils.dist` --- The Distribution class"
msgstr ":mod:`distutils.dist` --- Клас розподілу"

msgid ""
"This module provides the :class:`~distutils.core.Distribution` class, which "
"represents the module distribution being built/installed/distributed."
msgstr ""
"Цей модуль надає клас :class:`~distutils.core.Distribution`, який "
"представляє дистрибутив модуля, який створюється/встановлюється/"
"розповсюджується."

msgid ":mod:`distutils.extension` --- The Extension class"
msgstr ":mod:`distutils.extension` --- Клас розширення"

msgid ""
"This module provides the :class:`Extension` class, used to describe C/C++ "
"extension modules in setup scripts."
msgstr ""
"Цей модуль надає клас :class:`Extension`, який використовується для опису "
"модулів розширення C/C++ у сценаріях налаштування."

msgid ":mod:`distutils.debug` --- Distutils debug mode"
msgstr ":mod:`distutils.debug` --- Режим налагодження Distutils"

msgid "This module provides the DEBUG flag."
msgstr "Цей модуль надає позначку DEBUG."

msgid ":mod:`distutils.errors` --- Distutils exceptions"
msgstr ":mod:`distutils.errors` --- винятки Distutils"

msgid ""
"Provides exceptions used by the Distutils modules.  Note that Distutils "
"modules may raise standard exceptions; in particular, SystemExit is usually "
"raised for errors that are obviously the end-user's fault (eg. bad command-"
"line arguments)."
msgstr ""
"Надає винятки, які використовуються модулями Distutils. Зауважте, що модулі "
"Distutils можуть викликати стандартні винятки; зокрема, SystemExit зазвичай "
"викликається для помилок, які, очевидно, є помилкою кінцевого користувача "
"(наприклад, неправильні аргументи командного рядка)."

msgid ""
"This module is safe to use in ``from ... import *`` mode; it only exports "
"symbols whose names start with ``Distutils`` and end with ``Error``."
msgstr ""
"Цей модуль безпечно використовувати в режимі ``from ... import *``; він "
"експортує лише символи, імена яких починаються з ``Distutils`` і "
"закінчуються ``Error``."

msgid ""
":mod:`distutils.fancy_getopt` --- Wrapper around the standard getopt module"
msgstr ""
":mod:`distutils.fancy_getopt` --- Обгортка навколо стандартного модуля getopt"

msgid ""
"This module provides a wrapper around the standard :mod:`getopt`  module "
"that provides the following additional features:"
msgstr ""
"Цей модуль надає оболонку стандартного модуля :mod:`getopt`, яка надає "
"наступні додаткові функції:"

msgid "short and long options are tied together"
msgstr "короткі і довгі варіанти зв'язуються разом"

msgid ""
"options have help strings, so :func:`fancy_getopt` could potentially  create "
"a complete usage summary"
msgstr ""
"параметри мають рядки довідки, тому :func:`fancy_getopt` потенційно може "
"створити повний підсумок використання"

msgid "options set attributes of a passed-in object"
msgstr "параметри встановлюють атрибути переданого об'єкта"

msgid ""
"boolean options can have \"negative aliases\" --- eg. if :option:`!--quiet` "
"is the \"negative alias\" of :option:`!--verbose`, then :option:`!--quiet` "
"on the command line sets *verbose* to false."
msgstr ""
"логічні параметри можуть мати \"негативні псевдоніми\" --- наприклад. якщо :"
"option:`!--quiet` є \"негативним псевдонімом\" :option:`!--verbose`, тоді :"
"option:`!--quiet` у командному рядку встановлює для *verbose* значення false."

msgid ""
"Wrapper function. *options* is a list of ``(long_option, short_option, "
"help_string)`` 3-tuples as described in the constructor for :class:"
"`FancyGetopt`. *negative_opt* should be a dictionary mapping option names to "
"option names, both the key and value should be in the *options* list. "
"*object* is an object which will be used to store values (see the :meth:"
"`getopt` method of the :class:`FancyGetopt` class). *args* is the argument "
"list. Will use ``sys.argv[1:]`` if you  pass ``None`` as *args*."
msgstr ""
"Функція обгортки. *options* — це список ``(long_option, short_option, "
"help_string)`` 3-кортежів, як описано в конструкторі для :class:"
"`FancyGetopt`. *negative_opt* має бути словником, який зіставляє назви "
"параметрів з назвами параметрів, і ключ, і значення мають бути в списку "
"*параметрів*. *object* — це об’єкт, який використовуватиметься для "
"зберігання значень (дивіться метод :meth:`getopt` класу :class:"
"`FancyGetopt`). *args* — список аргументів. Використовуватиме ``sys."
"argv[1:]``, якщо ви передасте ``None`` як *args*."

msgid "Wraps *text* to less than *width* wide."
msgstr "Переносить *текст* на ширину менше *ширини*."

msgid ""
"The option_table is a list of 3-tuples: ``(long_option, short_option, "
"help_string)``"
msgstr ""
"Таблиця_опцій — це список із трьох кортежів: ``(long_option, short_option, "
"help_string)``"

msgid ""
"If an option takes an argument, its *long_option* should have ``'='`` "
"appended; *short_option* should just be a single character, no ``':'`` in "
"any case. *short_option* should be ``None`` if a *long_option*  doesn't have "
"a corresponding *short_option*. All option tuples must have long options."
msgstr ""
"Якщо параметр приймає аргумент, до його *long_option* має бути додано "
"``'='``; *short_option* має бути лише одним символом, ні в якому разі не "
"``':''``. *short_option* має бути ``None``, якщо *long_option* не має "
"відповідного *short_option*. Усі кортежі параметрів повинні мати довгі "
"параметри."

msgid "The :class:`FancyGetopt` class provides the following methods:"
msgstr "Клас :class:`FancyGetopt` надає такі методи:"

msgid "Parse command-line options in args. Store as attributes on *object*."
msgstr ""
"Розібрати параметри командного рядка в args. Зберігати як атрибути на "
"*об’єкті*."

msgid ""
"If *args* is ``None`` or not supplied, uses ``sys.argv[1:]``.  If *object* "
"is ``None`` or not supplied, creates a new :class:`OptionDummy` instance, "
"stores option values there, and returns a tuple ``(args, object)``.  If "
"*object* is supplied, it is modified in place and :func:`getopt` just "
"returns *args*; in both cases, the returned *args* is a modified copy of the "
"passed-in *args* list, which is left untouched."
msgstr ""
"Якщо *args* має значення ``None`` або не надається, використовується ``sys."
"argv[1:]``. Якщо *object* має значення ``None`` або не надано, створює новий "
"екземпляр :class:`OptionDummy`, зберігає там значення параметрів і повертає "
"кортеж ``(args, object)``. Якщо надається *object*, він змінюється на місці, "
"і :func:`getopt` просто повертає *args*; в обох випадках повернутий *args* є "
"модифікованою копією переданого списку *args*, який залишається недоторканим."

msgid ""
"Returns the list of ``(option, value)`` tuples processed by the previous run "
"of :meth:`getopt`  Raises :exc:`RuntimeError` if :meth:`getopt` hasn't been "
"called yet."
msgstr ""
"Повертає список кортежів ``(option, value)``, оброблених попереднім "
"запуском :meth:`getopt` Викликає :exc:`RuntimeError`, якщо :meth:`getopt` ще "
"не було викликано."

msgid ""
"Generate help text (a list of strings, one per suggested line of output) "
"from the option table for this :class:`FancyGetopt` object."
msgstr ""
"Згенеруйте довідковий текст (список рядків, по одному на запропонований "
"рядок виводу) з таблиці параметрів для цього об’єкта :class:`FancyGetopt`."

msgid "If supplied, prints the supplied *header* at the top of the help."
msgstr "Якщо надається, друкує наданий *заголовок* у верхній частині довідки."

msgid ":mod:`distutils.filelist` --- The FileList class"
msgstr ":mod:`distutils.filelist` --- Клас FileList"

msgid ""
"This module provides the :class:`FileList` class, used for poking about the "
"filesystem and building lists of files."
msgstr ""
"Цей модуль надає клас :class:`FileList`, який використовується для вивчення "
"файлової системи та створення списків файлів."

msgid ":mod:`distutils.log` --- Simple :pep:`282`-style logging"
msgstr ":mod:`distutils.log` --- Просте журналювання у стилі :pep:`282`"

msgid ":mod:`distutils.spawn` --- Spawn a sub-process"
msgstr ":mod:`distutils.spawn` --- Створення підпроцесу"

msgid ""
"This module provides the :func:`spawn` function, a front-end to  various "
"platform-specific functions for launching another program in a  sub-process. "
"Also provides :func:`find_executable` to search the path for a given "
"executable name."
msgstr ""
"Цей модуль надає функцію :func:`spawn`, інтерфейс для різних функцій, "
"специфічних для платформи, для запуску іншої програми в підпроцесі. Також "
"надає :func:`find_executable` для пошуку шляху для вказаного імені "
"виконуваного файлу."

msgid ":mod:`distutils.sysconfig` --- System configuration information"
msgstr ":mod:`distutils.sysconfig` --- Інформація про конфігурацію системи"

msgid ":mod:`distutils.sysconfig` has been merged into :mod:`sysconfig`."
msgstr ":mod:`distutils.sysconfig` було об’єднано в :mod:`sysconfig`."

msgid ""
"The :mod:`distutils.sysconfig` module provides access to Python's low-level "
"configuration information.  The specific configuration variables available "
"depend heavily on the platform and configuration. The specific variables "
"depend on the build process for the specific version of Python being run; "
"the variables are those found in the :file:`Makefile` and configuration "
"header that are installed with Python on Unix systems.  The configuration "
"header is called :file:`pyconfig.h` for Python versions starting with 2.2, "
"and :file:`config.h` for earlier versions of Python."
msgstr ""
"Модуль :mod:`distutils.sysconfig` забезпечує доступ до низькорівневої "
"конфігураційної інформації Python. Конкретні доступні змінні конфігурації "
"значною мірою залежать від платформи та конфігурації. Конкретні змінні "
"залежать від процесу збирання для конкретної версії Python, що виконується; "
"змінні знаходяться в :file:`Makefile` та заголовку конфігурації, які "
"встановлено разом з Python у системах Unix. Заголовок конфігурації "
"називається :file:`pyconfig.h` для версій Python, починаючи з 2.2, і :file:"
"`config.h` для попередніх версій Python."

msgid ""
"Some additional functions are provided which perform some useful "
"manipulations for other parts of the :mod:`distutils` package."
msgstr ""
"Надаються деякі додаткові функції, які виконують деякі корисні маніпуляції "
"для інших частин пакета :mod:`distutils`."

msgid "The result of ``os.path.normpath(sys.prefix)``."
msgstr "Результат ``os.path.normpath(sys.prefix)``."

msgid "The result of ``os.path.normpath(sys.exec_prefix)``."
msgstr "Результат ``os.path.normpath(sys.exec_prefix)``."

msgid ""
"Return the value of a single variable.  This is equivalent to "
"``get_config_vars().get(name)``."
msgstr ""
"Повертає значення однієї змінної. Це еквівалентно ``get_config_vars()."
"get(name)``."

msgid ""
"Return a set of variable definitions.  If there are no arguments, this "
"returns a dictionary mapping names of configuration variables to values.  If "
"arguments are provided, they should be strings, and the return value will be "
"a sequence giving the associated values. If a given name does not have a "
"corresponding value, ``None`` will be included for that variable."
msgstr ""
"Повертає набір визначень змінних. Якщо аргументів немає, повертається "
"словник, який зіставляє імена змінних конфігурації зі значеннями. Якщо "
"надано аргументи, вони мають бути рядками, а значення, що повертається, буде "
"послідовністю, що надає пов’язані значення. Якщо задане ім’я не має "
"відповідного значення, для цієї змінної буде включено значення \"Немає\"."

msgid ""
"Return the full path name of the configuration header.  For Unix, this will "
"be the header generated by the :program:`configure` script; for other "
"platforms the header will have been supplied directly by the Python source "
"distribution.  The file is a platform-specific text file."
msgstr ""
"Повертає повну назву шляху до заголовка конфігурації. Для Unix це буде "
"заголовок, згенерований сценарієм :program:`configure`; для інших платформ "
"заголовок буде надано безпосередньо вихідним кодом Python. Файл є текстовим "
"файлом для конкретної платформи."

msgid ""
"Return the full path name of the :file:`Makefile` used to build Python.  For "
"Unix, this will be a file generated by the :program:`configure` script; the "
"meaning for other platforms will vary.  The file is a platform-specific text "
"file, if it exists. This function is only useful on POSIX platforms."
msgstr ""
"Повертає повну назву шляху до :file:`Makefile`, який використовується для "
"створення Python. Для Unix це буде файл, згенерований сценарієм :program:"
"`configure`; значення для інших платформ буде іншим. Файл є текстовим файлом "
"певної платформи, якщо він існує. Ця функція корисна лише на платформах "
"POSIX."

msgid ""
"The following functions are deprecated together with this module and they "
"have no direct replacement."
msgstr ""
"Наступні функції застаріли разом із цим модулем і не мають прямої заміни."

msgid ""
"Return the directory for either the general or platform-dependent C include "
"files.  If *plat_specific* is true, the platform-dependent include directory "
"is returned; if false or omitted, the platform-independent directory is "
"returned. If *prefix* is given, it is used as either the prefix instead of :"
"const:`PREFIX`, or as the exec-prefix instead of :const:`EXEC_PREFIX` if "
"*plat_specific* is true."
msgstr ""
"Повертає каталог для загальних або залежних від платформи C-файлів "
"включення. Якщо *plat_specific* має значення true, повертається залежний від "
"платформи каталог включення; якщо false або опущено, повертається незалежний "
"від платформи каталог. Якщо вказано *префікс*, він використовується або як "
"префікс замість :const:`PREFIX`, або як префікс exec замість :const:"
"`EXEC_PREFIX`, якщо *plat_specific* має значення true."

msgid ""
"Return the directory for either the general or platform-dependent library "
"installation.  If *plat_specific* is true, the platform-dependent include "
"directory is returned; if false or omitted, the platform-independent "
"directory is returned.  If *prefix* is given, it is used as either the "
"prefix instead of :const:`PREFIX`, or as the exec-prefix instead of :const:"
"`EXEC_PREFIX` if *plat_specific* is true.  If *standard_lib* is true, the "
"directory for the standard library is returned rather than the directory for "
"the installation of third-party extensions."
msgstr ""
"Поверніть каталог для встановлення загальної або залежної від платформи "
"бібліотеки. Якщо *plat_specific* має значення true, повертається залежний "
"від платформи каталог включення; якщо false або опущено, повертається "
"незалежний від платформи каталог. Якщо вказано *префікс*, він "
"використовується або як префікс замість :const:`PREFIX`, або як префікс exec "
"замість :const:`EXEC_PREFIX`, якщо *plat_specific* має значення true. Якщо "
"*standard_lib* має значення true, повертається каталог для стандартної "
"бібліотеки, а не каталог для встановлення розширень сторонніх розробників."

msgid ""
"The following function is only intended for use within the :mod:`distutils` "
"package."
msgstr ""
"Наступна функція призначена лише для використання в пакеті :mod:`distutils`."

msgid ""
"Do any platform-specific customization of a :class:`distutils.ccompiler."
"CCompiler` instance."
msgstr ""
"Виконайте будь-яке налаштування екземпляра :class:`distutils.ccompiler."
"CCompiler` для певної платформи."

msgid ""
"This function is only needed on Unix at this time, but should be called "
"consistently to support forward-compatibility.  It inserts the information "
"that varies across Unix flavors and is stored in Python's :file:`Makefile`.  "
"This information includes the selected compiler, compiler and linker "
"options, and the extension used by the linker for shared objects."
msgstr ""
"На даний момент ця функція потрібна тільки в Unix, але її слід викликати "
"постійно, щоб підтримувати сумісність. Він вставляє інформацію, яка "
"різниться в різних варіантах Unix і зберігається в файлі :file:`Makefile` "
"Python. Ця інформація включає вибраний компілятор, параметри компілятора та "
"компонувальника, а також розширення, яке використовує компонувальник для "
"спільних об’єктів."

msgid ""
"This function is even more special-purpose, and should only be used from "
"Python's own build procedures."
msgstr ""
"Ця функція ще більш спеціального призначення, і її слід використовувати лише "
"з власних процедур збірки Python."

msgid ""
"Inform the :mod:`distutils.sysconfig` module that it is being used as part "
"of the build process for Python.  This changes a lot of relative locations "
"for files, allowing them to be located in the build area rather than in an "
"installed Python."
msgstr ""
"Повідомте модуль :mod:`distutils.sysconfig`, що він використовується як "
"частина процесу збирання для Python. Це змінює багато відносних розташувань "
"файлів, дозволяючи їм розташовуватися в області збірки, а не у встановленому "
"Python."

msgid ":mod:`distutils.text_file` --- The TextFile class"
msgstr ":mod:`distutils.text_file` --- Клас TextFile"

msgid ""
"This module provides the :class:`TextFile` class, which gives an interface  "
"to text files that (optionally) takes care of stripping comments, ignoring  "
"blank lines, and joining lines with backslashes."
msgstr ""
"Цей модуль надає клас :class:`TextFile`, який надає інтерфейс для текстових "
"файлів, який (необов’язково) піклується про видалення коментарів, "
"ігнорування порожніх рядків і об’єднання рядків зворотними похилими рисками."

msgid ""
"This class provides a file-like object that takes care of all  the things "
"you commonly want to do when processing a text file  that has some line-by-"
"line syntax: strip comments (as long as ``#``  is your comment character), "
"skip blank lines, join adjacent lines by escaping the newline (ie. backslash "
"at end of line), strip leading and/or trailing whitespace.  All of these are "
"optional and independently controllable."
msgstr ""
"Цей клас надає файлоподібний об’єкт, який піклується про всі речі, які ви "
"зазвичай хочете робити під час обробки текстового файлу, який має деякий "
"рядковий синтаксис: видалення коментарів (за умови, що ``#`` є вашим "
"символом коментаря ), пропускати порожні рядки, об’єднувати суміжні рядки "
"шляхом екранування символу нового рядка (тобто зворотної косої риски в кінці "
"рядка), видаляти пробіли на початку та/або в кінці. Усі вони необов’язкові "
"та управляються незалежно."

msgid ""
"The class provides a :meth:`warn` method so you can generate  warning "
"messages that report physical line number, even if the  logical line in "
"question spans multiple physical lines.  Also  provides :meth:`unreadline` "
"for implementing line-at-a-time lookahead."
msgstr ""
"Клас надає метод :meth:`warn`, щоб ви могли генерувати попередження, які "
"повідомляють номер фізичного рядка, навіть якщо відповідний логічний рядок "
"охоплює кілька фізичних рядків. Також надає :meth:`unreadline` для "
"реалізації построкового перегляду."

msgid ""
":class:`TextFile` instances are create with either *filename*, *file*, or "
"both. :exc:`RuntimeError` is raised if both are ``None``. *filename* should "
"be a string, and *file* a file object (or something that provides :meth:"
"`readline` and :meth:`close`  methods).  It is recommended that you supply "
"at least *filename*,  so that :class:`TextFile` can include it in warning "
"messages.  If *file* is not supplied, :class:`TextFile` creates its own "
"using the :func:`open` built-in function."
msgstr ""
":class:`TextFile` екземпляри створюються з *filename*, *file* або обома. :"
"exc:`RuntimeError` виникає, якщо обидва мають значення ``None``. *filename* "
"має бути рядком, а *file* — файловим об’єктом (або чимось, що надає методи :"
"meth:`readline` і :meth:`close`). Рекомендовано вказати принаймні *ім’я "
"файлу*, щоб :class:`TextFile` міг включити його в попередження. Якщо *file* "
"не вказано, :class:`TextFile` створює власний за допомогою вбудованої "
"функції :func:`open`."

msgid ""
"The options are all boolean, and affect the values returned by :meth:"
"`readline`"
msgstr ""
"Усі параметри є логічними і впливають на значення, які повертає :meth:"
"`readline`"

msgid "option name"
msgstr "назва опції"

msgid "default"
msgstr "за замовчуванням"

msgid "*strip_comments*"
msgstr "*strip_comments*"

msgid ""
"strip from ``'#'`` to end-of-line, as well as any whitespace leading up to "
"the ``'#'``\\ ---unless it is escaped by a backslash"
msgstr ""
"смуга від ``'#'`` до кінця рядка, а також будь-які пробіли, що ведуть до "
"``'#'``\\ --- якщо це не екрановано зворотною скісною рискою"

msgid "true"
msgstr "правда"

msgid "*lstrip_ws*"
msgstr "*lstrip_ws*"

msgid "strip leading whitespace from each line before returning it"
msgstr "видаляти початкові пробіли з кожного рядка перед поверненням"

msgid "false"
msgstr "помилковий"

msgid "*rstrip_ws*"
msgstr "*rstrip_ws*"

msgid ""
"strip trailing whitespace (including line terminator!) from each line before "
"returning it."
msgstr ""
"видаляти кінцеві пробіли (включно з символом закінчення рядка!) з кожного "
"рядка перед поверненням."

msgid "*skip_blanks*"
msgstr "*skip_blanks*"

msgid ""
"skip lines that are empty \\*after\\* stripping comments and whitespace.  "
"(If both lstrip_ws and rstrip_ws are false, then some lines may consist of "
"solely whitespace: these will \\*not\\* be skipped, even if *skip_blanks* is "
"true.)"
msgstr ""
"пропускати порожні рядки \\*після\\* видалення коментарів і пробілів. (Якщо "
"і lstrip_ws, і rstrip_ws false, то деякі рядки можуть складатися лише з "
"пробілів: вони \\*не\\* будуть пропущені, навіть якщо *skip_blanks* має "
"значення true.)"

msgid "*join_lines*"
msgstr "*join_lines*"

msgid ""
"if a backslash is the last non-newline character on a line after stripping "
"comments and whitespace, join the following line to it to form one logical "
"line; if N consecutive lines end with a backslash, then N+1 physical lines "
"will be joined to form one logical line."
msgstr ""
"якщо зворотна скісна риска є останнім символом у рядку після видалення "
"коментарів і пробілів, приєднайте наступний рядок до нього, щоб утворити "
"один логічний рядок; якщо N послідовних рядків закінчуються зворотною "
"скісною рискою, тоді N+1 фізичний рядок буде об’єднано в один логічний рядок."

msgid "*collapse_join*"
msgstr "*collapse_join*"

msgid ""
"strip leading whitespace from lines that are joined to their predecessor; "
"only matters if ``(join_lines and not lstrip_ws)``"
msgstr ""
"видаляти початкові пробіли з рядків, які приєднані до їх попереднього; має "
"значення лише якщо ``(join_lines, а не lstrip_ws)``"

msgid ""
"Note that since *rstrip_ws* can strip the trailing newline, the semantics "
"of :meth:`readline` must differ from those of the built-in file object's :"
"meth:`readline` method!  In particular, :meth:`readline`  returns ``None`` "
"for end-of-file: an empty string might just be a  blank line (or an all-"
"whitespace line), if *rstrip_ws* is true  but *skip_blanks* is not."
msgstr ""
"Зауважте, що оскільки *rstrip_ws* може видаляти кінцевий новий рядок, "
"семантика :meth:`readline` має відрізнятися від методу :meth:`readline` "
"вбудованого файлового об’єкта! Зокрема, :meth:`readline` повертає ``None`` "
"для кінця файлу: порожній рядок може бути просто порожнім рядком (або рядком "
"із пробілами), якщо *rstrip_ws* має значення true, але *skip_blanks* не."

msgid ""
"Open a new file *filename*.  This overrides any *file* or *filename* "
"constructor arguments."
msgstr ""
"Відкрийте новий файл *назва файлу*. Це перевизначає будь-які аргументи "
"конструктора *file* або *filename*."

msgid ""
"Close the current file and forget everything we know about it (including the "
"filename and the current line number)."
msgstr ""
"Закрийте поточний файл і забудьте все, що ми знаємо про нього (включно з "
"назвою файлу та номером поточного рядка)."

msgid ""
"Print (to stderr) a warning message tied to the current logical line in the "
"current file.  If the current logical line in the file spans multiple "
"physical lines, the warning refers to the whole range, such as ``\"lines "
"3-5\"``.  If *line* is supplied,  it overrides the current line number; it "
"may be a list or tuple  to indicate a range of physical lines, or an integer "
"for a  single physical line."
msgstr ""
"Вивести (у stderr) попереджувальне повідомлення, прив’язане до поточного "
"логічного рядка в поточному файлі. Якщо поточний логічний рядок у файлі "
"охоплює кілька фізичних рядків, попередження стосується всього діапазону, "
"наприклад \"рядків 3-5\". Якщо вказано *рядок*, він замінює поточний номер "
"рядка; це може бути список або кортеж для позначення діапазону фізичних "
"рядків або ціле число для окремого фізичного рядка."

msgid ""
"Read and return a single logical line from the current file (or from an "
"internal buffer if lines have previously been \"unread\" with :meth:"
"`unreadline`).  If the *join_lines* option  is true, this may involve "
"reading multiple physical lines concatenated into a single string.  Updates "
"the current line number,  so calling :meth:`warn` after :meth:`readline` "
"emits a warning  about the physical line(s) just read.  Returns ``None`` on "
"end-of-file,  since the empty string can occur if *rstrip_ws* is true but  "
"*strip_blanks* is not."
msgstr ""
"Читання та повернення одного логічного рядка з поточного файлу (або з "
"внутрішнього буфера, якщо рядки раніше були \"непрочитаними\" за допомогою :"
"meth:`unreadline`). Якщо параметр *join_lines* має значення true, це може "
"передбачати читання кількох фізичних рядків, об’єднаних в один рядок. "
"Оновлює номер поточного рядка, тому виклик :meth:`warn` після :meth:"
"`readline` видає попередження про щойно прочитаний фізичний рядок(и). "
"Повертає ``None`` у кінці файлу, оскільки порожній рядок може виникнути, "
"якщо *rstrip_ws* має значення true, а *strip_blanks* — ні."

msgid ""
"Read and return the list of all logical lines remaining in the current file. "
"This updates the current line number to the last line of the file."
msgstr ""
"Прочитати та повернути список усіх логічних рядків, що залишилися в "
"поточному файлі. Це оновить номер поточного рядка до останнього рядка файлу."

msgid ""
"Push *line* (a string) onto an internal buffer that will be checked by "
"future :meth:`readline` calls.  Handy for implementing a parser with line-at-"
"a-time lookahead. Note that lines that are \"unread\" with :meth:"
"`unreadline` are not subsequently re-cleansed (whitespace  stripped, or "
"whatever) when read with :meth:`readline`. If multiple calls are made to :"
"meth:`unreadline` before a call to :meth:`readline`, the lines will be "
"returned most in most recent first order."
msgstr ""
"Надішліть *рядок* (рядок) у внутрішній буфер, який перевірятиметься "
"майбутніми викликами :meth:`readline`. Зручно для реалізації синтаксичного "
"аналізатора з построковим переглядом. Зауважте, що рядки, які є "
"\"непрочитаними\" за допомогою :meth:`unreadline`, згодом не очищаються "
"повторно (видаляються пробіли чи щось інше), коли читаються за допомогою :"
"meth:`readline`. Якщо перед викликом :meth:`readline` зроблено декілька "
"викликів :meth:`unreadline`, рядки буде повернуто в найновішому першому "
"порядку."

msgid ":mod:`distutils.version` --- Version number classes"
msgstr ":mod:`distutils.version` --- Класи номерів версій"

msgid ":mod:`distutils.cmd` --- Abstract base class for Distutils commands"
msgstr ":mod:`distutils.cmd` --- Абстрактний базовий клас для команд Distutils"

msgid "This module supplies the abstract base class :class:`Command`."
msgstr "Цей модуль надає абстрактний базовий клас :class:`Command`."

msgid ""
"Abstract base class for defining command classes, the \"worker bees\" of the "
"Distutils.  A useful analogy for command classes is to think of them as "
"subroutines with local variables called *options*.  The options are declared "
"in :meth:`initialize_options` and defined (given their final values) in :"
"meth:`finalize_options`, both of which must be defined by every command "
"class.  The distinction between the two is necessary because option values "
"might come from the outside world (command line, config file, ...), and any "
"options dependent on other options must be computed after these outside "
"influences have been processed --- hence :meth:`finalize_options`.  The body "
"of the subroutine, where it does all its work based on the values of its "
"options, is the :meth:`run` method, which must also be implemented by every "
"command class."
msgstr ""
"Абстрактний базовий клас для визначення класів команд, \"робочих бджіл\" "
"Distutils. Корисною аналогією для класів команд є розглядати їх як "
"підпрограми з локальними змінними, які називаються *options*. Параметри "
"оголошені в :meth:`initialize_options` і визначені (враховуючи їх кінцеві "
"значення) в :meth:`finalize_options`, обидва з яких повинні бути визначені "
"кожним класом команд. Розрізнення між цими двома параметрами є необхідним, "
"оскільки значення параметрів можуть надходити із зовнішнього світу "
"(командний рядок, конфігураційний файл, ...), а будь-які параметри, залежні "
"від інших параметрів, мають бути обчислені після обробки цих зовнішніх "
"впливів --- отже :meth:`finalize_options`. Тіло підпрограми, де вона виконує "
"всю свою роботу на основі значень своїх параметрів, є методом :meth:`run`, "
"який також має бути реалізований кожним класом команд."

msgid ""
"The class constructor takes a single argument *dist*, a :class:`~distutils."
"core.Distribution` instance."
msgstr ""
"Конструктор класу приймає один аргумент *dist*, екземпляр :class:`~distutils."
"core.Distribution`."

msgid "Creating a new Distutils command"
msgstr "Створення нової команди Distutils"

msgid "This section outlines the steps to create a new Distutils command."
msgstr "У цьому розділі описано кроки для створення нової команди Distutils."

msgid ""
"A new command lives in a module in the :mod:`distutils.command` package. "
"There is a sample template in that directory called :file:"
"`command_template`.  Copy this file to a new module with the same name as "
"the new command you're implementing.  This module should implement a class "
"with the same name as the module (and the command).  So, for instance, to "
"create the command ``peel_banana`` (so that users can run ``setup.py "
"peel_banana``), you'd copy :file:`command_template` to :file:`distutils/"
"command/peel_banana.py`, then edit it so that it's implementing the class :"
"class:`peel_banana`, a subclass of :class:`distutils.cmd.Command`."
msgstr ""
"Нова команда міститься в модулі в пакеті :mod:`distutils.command`. У цьому "
"каталозі є зразок шаблону під назвою :file:`command_template`. Скопіюйте цей "
"файл до нового модуля з такою ж назвою, як і нова команда, яку ви "
"реалізуєте. Цей модуль має реалізовувати клас із такою самою назвою, як і "
"модуль (і команда). Отже, наприклад, щоб створити команду ``peel_banana`` "
"(щоб користувачі могли запускати ``setup.py peel_banana``), ви повинні "
"скопіювати :file:`command_template` до :file:`distutils/command/peel_banana ."
"py`, потім відредагуйте його так, щоб він реалізував клас :class:"
"`peel_banana`, підклас :class:`distutils.cmd.Command`."

msgid "Subclasses of :class:`Command` must define the following methods."
msgstr "Підкласи :class:`Command` повинні визначати такі методи."

msgid ""
"Set default values for all the options that this command supports.  Note "
"that these defaults may be overridden by other commands, by the setup "
"script, by config files, or by the command-line.  Thus, this is not the "
"place to code dependencies between options; generally, :meth:"
"`initialize_options` implementations are just a bunch of ``self.foo = None`` "
"assignments."
msgstr ""
"Установіть значення за замовчуванням для всіх параметрів, які підтримує ця "
"команда. Зауважте, що ці параметри за замовчуванням можуть бути замінені "
"іншими командами, сценарієм налаштування, файлами конфігурації або командним "
"рядком. Таким чином, це не місце для кодування залежностей між параметрами; "
"загалом, реалізації :meth:`initialize_options` — це просто купа призначень "
"``self.foo = None``."

msgid ""
"Set final values for all the options that this command supports. This is "
"always called as late as possible, ie.  after any option assignments from "
"the command-line or from other commands have been done.  Thus, this is the "
"place to code option dependencies: if *foo* depends on *bar*, then it is "
"safe to set *foo* from *bar* as long as *foo* still has the same value it "
"was assigned in :meth:`initialize_options`."
msgstr ""
"Установіть остаточні значення для всіх параметрів, які підтримує ця команда. "
"Це завжди викликається якомога пізніше, тобто. після виконання будь-яких "
"призначень параметрів із командного рядка чи інших команд. Таким чином, це "
"місце для кодування залежностей параметрів: якщо *foo* залежить від *bar*, "
"тоді безпечно встановити *foo* з *bar*, якщо *foo* все ще має те саме "
"значення, яке було призначено в :meth:`ініціалізувати_параметри`."

msgid ""
"A command's raison d'etre: carry out the action it exists to perform, "
"controlled by the options initialized in :meth:`initialize_options`, "
"customized by other commands, the setup script, the command-line, and config "
"files, and finalized in :meth:`finalize_options`.  All terminal output and "
"filesystem interaction should be done by :meth:`run`."
msgstr ""
"Сенс існування команди: виконати дію, для виконання якої вона існує, що "
"контролюється параметрами, ініціалізованими в :meth:`initialize_options`, "
"налаштованими іншими командами, сценарієм налаштування, командним рядком і "
"файлами конфігурації, а також завершеними в :meth:`finalize_options`. Весь "
"вихід терміналу та взаємодія з файловою системою має здійснюватися за "
"допомогою :meth:`run`."

msgid ""
"*sub_commands* formalizes the notion of a \"family\" of commands, e.g. "
"``install`` as the parent with sub-commands ``install_lib``, "
"``install_headers``, etc.  The parent of a family of commands defines "
"*sub_commands* as a class attribute; it's a list of 2-tuples "
"``(command_name, predicate)``, with *command_name* a string and *predicate* "
"a function, a string or ``None``.  *predicate* is a method of the parent "
"command that determines whether the corresponding command is applicable in "
"the current situation.  (E.g. ``install_headers`` is only applicable if we "
"have any C header files to install.)  If *predicate* is ``None``, that "
"command is always applicable."
msgstr ""
"*sub_commands* формалізує поняття \"сімейства\" команд, напр. ``install`` як "
"батьківський з підкомандами ``install_lib``, ``install_headers`` тощо. "
"Батьківський елемент сімейства команд визначає *sub_commands* як атрибут "
"класу; це список із двох кортежів ``(назва_команди, предикат)``, де "
"*назва_команди* є рядком, а *предикат* — функцією, рядком або ``None``. "
"*предикат* — це метод батьківської команди, який визначає, чи застосовна "
"відповідна команда в поточній ситуації. (Наприклад, ``install_headers`` "
"застосовний, лише якщо у нас є файли заголовків C для встановлення.) Якщо "
"*predicate* має значення ``None``, ця команда завжди застосовна."

msgid ""
"*sub_commands* is usually defined at the *end* of a class, because "
"predicates can be methods of the class, so they must already have been "
"defined.  The canonical example is the :command:`install` command."
msgstr ""
"*sub_commands* зазвичай визначається в *кінці* класу, оскільки предикати "
"можуть бути методами класу, тому вони повинні бути вже визначені. Канонічним "
"прикладом є команда :command:`install`."

msgid ":mod:`distutils.command` --- Individual Distutils commands"
msgstr ":mod:`distutils.command` --- Окремі команди Distutils"

msgid ":mod:`distutils.command.bdist` --- Build a binary installer"
msgstr ":mod:`distutils.command.bdist` --- Створення бінарного інсталятора"

msgid ""
":mod:`distutils.command.bdist_packager` --- Abstract base class for packagers"
msgstr ""
":mod:`distutils.command.bdist_packager` --- Абстрактний базовий клас для "
"пакувальників"

msgid ":mod:`distutils.command.bdist_dumb` --- Build a \"dumb\" installer"
msgstr ""
":mod:`distutils.command.bdist_dumb` --- Створення \"тупого\" інсталятора"

msgid ""
":mod:`distutils.command.bdist_rpm` --- Build a binary distribution as a "
"Redhat RPM and SRPM"
msgstr ""
":mod:`distutils.command.bdist_rpm` --- Створення бінарного дистрибутива як "
"Redhat RPM і SRPM"

msgid ":mod:`distutils.command.sdist` --- Build a source distribution"
msgstr ":mod:`distutils.command.sdist` --- Створення вихідного дистрибутива"

msgid ":mod:`distutils.command.build` --- Build all files of a package"
msgstr ":mod:`distutils.command.build` --- Збірка всіх файлів пакета"

msgid ""
":mod:`distutils.command.build_clib` --- Build any C libraries in a package"
msgstr ""
":mod:`distutils.command.build_clib` --- Збірка будь-яких бібліотек C у "
"пакунок"

msgid ""
":mod:`distutils.command.build_ext` --- Build any extensions in a package"
msgstr ""
":mod:`distutils.command.build_ext` --- Створення будь-яких розширень у пакеті"

msgid ""
":mod:`distutils.command.build_py` --- Build the .py/.pyc files of a package"
msgstr ":mod:`distutils.command.build_py` --- Створення файлів .py/.pyc пакета"

msgid ""
"Alternative implementation of build_py which also runs the 2to3 conversion "
"library on each .py file that is going to be installed. To use this in a "
"setup.py file for a distribution that is designed to run with both Python 2."
"x and 3.x, add::"
msgstr ""
"Альтернативна реалізація build_py, яка також запускає бібліотеку "
"перетворення 2to3 для кожного файлу .py, який буде встановлено. Щоб "
"використовувати це у файлі setup.py для дистрибутива, призначеного для "
"роботи з Python 2.x і 3.x, додайте::"

msgid "to your setup.py, and later::"
msgstr "до вашого setup.py, а пізніше::"

msgid "to the invocation of setup()."
msgstr "до виклику setup()."

msgid ""
":mod:`distutils.command.build_scripts` --- Build the scripts of a package"
msgstr ":mod:`distutils.command.build_scripts` --- Збірка сценаріїв пакета"

msgid ":mod:`distutils.command.clean` --- Clean a package build area"
msgstr ":mod:`distutils.command.clean` --- Очистити область збірки пакета"

msgid ""
"This command removes the temporary files created by :command:`build` and its "
"subcommands, like intermediary compiled object files.  With the ``--all`` "
"option, the complete build directory will be removed."
msgstr ""
"Ця команда видаляє тимчасові файли, створені :command:`build` та його "
"підкомандами, як-от проміжні скомпільовані об’єктні файли. З опцією ``--"
"all`` буде видалено повний каталог збірки."

msgid ""
"Extension modules built :ref:`in place <distutils-build-ext-inplace>` will "
"not be cleaned, as they are not in the build directory."
msgstr ""
"Модулі розширення, створені :ref:`in place <distutils-build-ext-inplace>`, "
"не будуть очищені, оскільки їх немає в каталозі збірки."

msgid ":mod:`distutils.command.config` --- Perform package configuration"
msgstr ":mod:`distutils.command.config` --- Виконати налаштування пакета"

msgid ":mod:`distutils.command.install` --- Install a package"
msgstr ":mod:`distutils.command.install` --- Встановити пакет"

msgid ""
":mod:`distutils.command.install_data` --- Install data files from a package"
msgstr ""
":mod:`distutils.command.install_data` --- Встановити файли даних із пакета"

msgid ""
":mod:`distutils.command.install_headers` --- Install C/C++ header files from "
"a package"
msgstr ""
":mod:`distutils.command.install_headers` --- Встановити файли заголовків C/C+"
"+ із пакета"

msgid ""
":mod:`distutils.command.install_lib` --- Install library files from a package"
msgstr ""
":mod:`distutils.command.install_lib` --- Встановити файли бібліотеки з пакета"

msgid ""
":mod:`distutils.command.install_scripts` --- Install script files from a "
"package"
msgstr ""
":mod:`distutils.command.install_scripts` --- Встановити файли сценарію з "
"пакета"

msgid ""
":mod:`distutils.command.register` --- Register a module with the Python "
"Package Index"
msgstr ""
":mod:`distutils.command.register` --- Реєстрація модуля в індексі пакетів "
"Python"

msgid ""
"The ``register`` command registers the package with the Python Package  "
"Index. This is described in more detail in :pep:`301`."
msgstr ""
"Команда ``register`` реєструє пакет в індексі пакетів Python. Це описано "
"більш детально в :pep:`301`."

msgid ":mod:`distutils.command.check` --- Check the meta-data of a package"
msgstr ":mod:`distutils.command.check` --- Перевірити метадані пакета"

msgid ""
"The ``check`` command performs some tests on the meta-data of a package. For "
"example, it verifies that all required meta-data are provided as the "
"arguments passed to the :func:`setup` function."
msgstr ""
"Команда ``check`` виконує деякі перевірки метаданих пакета. Наприклад, він "
"перевіряє, що всі необхідні метадані надано як аргументи, передані до "
"функції :func:`setup`."
