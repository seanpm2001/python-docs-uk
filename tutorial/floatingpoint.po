# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:50+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Floating Point Arithmetic:  Issues and Limitations"
msgstr "Арифметика з плаваючою комою: проблеми та обмеження"

msgid ""
"Floating-point numbers are represented in computer hardware as base 2 "
"(binary) fractions.  For example, the **decimal** fraction ``0.125`` has "
"value 1/10 + 2/100 + 5/1000, and in the same way the **binary** fraction "
"``0.001`` has value 0/2 + 0/4 + 1/8. These two fractions have identical "
"values, the only real difference being that the first is written in base 10 "
"fractional notation, and the second in base 2."
msgstr ""

msgid ""
"Unfortunately, most decimal fractions cannot be represented exactly as "
"binary fractions.  A consequence is that, in general, the decimal floating-"
"point numbers you enter are only approximated by the binary floating-point "
"numbers actually stored in the machine."
msgstr ""
"На жаль, більшість десяткових дробів не можна представити точно як двійкові "
"дроби. Наслідком цього є те, що загалом десяткові числа з плаваючою комою, "
"які ви вводите, є лише наближеними до двійкових чисел з плаваючою комою, які "
"фактично зберігаються в машині."

msgid ""
"The problem is easier to understand at first in base 10.  Consider the "
"fraction 1/3.  You can approximate that as a base 10 fraction::"
msgstr ""
"Задачу легше зрозуміти спочатку з основою 10. Розглянемо дріб 1/3. Ви можете "
"наблизити це як дріб з основою 10:"

msgid "or, better, ::"
msgstr "або, краще, ::"

msgid ""
"and so on.  No matter how many digits you're willing to write down, the "
"result will never be exactly 1/3, but will be an increasingly better "
"approximation of 1/3."
msgstr ""
"і так далі. Незалежно від того, скільки цифр ви готові записати, результат "
"ніколи не буде рівно 1/3, а буде дедалі кращим наближенням 1/3."

msgid ""
"In the same way, no matter how many base 2 digits you're willing to use, the "
"decimal value 0.1 cannot be represented exactly as a base 2 fraction.  In "
"base 2, 1/10 is the infinitely repeating fraction ::"
msgstr ""
"Таким же чином, незалежно від того, скільки цифр з основою 2 ви бажаєте "
"використовувати, десяткове значення 0,1 не може бути представлено точно як "
"дріб з основою 2. За основою 2 1/10 — нескінченно повторюваний дріб ::"

msgid ""
"Stop at any finite number of bits, and you get an approximation.  On most "
"machines today, floats are approximated using a binary fraction with the "
"numerator using the first 53 bits starting with the most significant bit and "
"with the denominator as a power of two.  In the case of 1/10, the binary "
"fraction is ``3602879701896397 / 2 ** 55`` which is close to but not exactly "
"equal to the true value of 1/10."
msgstr ""
"Зупиніться на будь-якій кінцевій кількості бітів, і ви отримаєте наближення. "
"На більшості сучасних машин числа з плаваючою точкою наближаються за "
"допомогою двійкового дробу з чисельником, використовуючи перші 53 біти, "
"починаючи зі старшого біта, а знаменник – ступінь двійки. У випадку 1/10 "
"двійковий дріб дорівнює ``3602879701896397 / 2 ** 55``, що близько до "
"справжнього значення 1/10, але не зовсім дорівнює йому."

msgid ""
"Many users are not aware of the approximation because of the way values are "
"displayed.  Python only prints a decimal approximation to the true decimal "
"value of the binary approximation stored by the machine.  On most machines, "
"if Python were to print the true decimal value of the binary approximation "
"stored for 0.1, it would have to display ::"
msgstr ""
"Багато користувачів не знають про наближення через спосіб відображення "
"значень. Python друкує лише десяткове наближення справжнього десяткового "
"значення двійкового наближення, збереженого машиною. На більшості машин, "
"якби Python друкував справжнє десяткове значення двійкової апроксимації, "
"збережене для 0,1, він мав би відображати:"

msgid ""
"That is more digits than most people find useful, so Python keeps the number "
"of digits manageable by displaying a rounded value instead ::"
msgstr ""
"Це більше цифр, ніж більшість людей вважають за потрібне, тому Python "
"зберігає кількість цифр керованою, відображаючи натомість округлене значення:"

msgid ""
"Just remember, even though the printed result looks like the exact value of "
"1/10, the actual stored value is the nearest representable binary fraction."
msgstr ""
"Просто пам’ятайте, навіть якщо надрукований результат виглядає як точне "
"значення 1/10, фактичне збережене значення є найближчим двійковим дрібом, "
"який можна представити."

msgid ""
"Interestingly, there are many different decimal numbers that share the same "
"nearest approximate binary fraction.  For example, the numbers ``0.1`` and "
"``0.10000000000000001`` and "
"``0.1000000000000000055511151231257827021181583404541015625`` are all "
"approximated by ``3602879701896397 / 2 ** 55``.  Since all of these decimal "
"values share the same approximation, any one of them could be displayed "
"while still preserving the invariant ``eval(repr(x)) == x``."
msgstr ""
"Цікаво, що існує багато різних десяткових чисел, які мають однаковий "
"найближчий наближений двійковий дріб. Наприклад, числа ``0,1`` і "
"``0,100000000000000001`` і "
"``0,100000000000000005511151231257827021181583404541015625`` наближено до "
"``360287970751596`` Оскільки всі ці десяткові значення мають однакове "
"наближення, будь-яке з них може бути відображено, зберігаючи інваріант "
"``eval(repr(x)) == x``."

msgid ""
"Historically, the Python prompt and built-in :func:`repr` function would "
"choose the one with 17 significant digits, ``0.10000000000000001``.   "
"Starting with Python 3.1, Python (on most systems) is now able to choose the "
"shortest of these and simply display ``0.1``."
msgstr ""
"Історично склалося так, що підказка Python і вбудована функція :func:`repr` "
"вибирали одну з 17 значущих цифр, ``0.10000000000000001``. Починаючи з "
"Python 3.1, Python (у більшості систем) тепер може вибирати найкоротший із "
"них і просто відображати ``0.1``."

msgid ""
"Note that this is in the very nature of binary floating-point: this is not a "
"bug in Python, and it is not a bug in your code either.  You'll see the same "
"kind of thing in all languages that support your hardware's floating-point "
"arithmetic (although some languages may not *display* the difference by "
"default, or in all output modes)."
msgstr ""
"Зауважте, що це в самій природі двійкового числа з плаваючою комою: це не "
"помилка в Python і не є помилкою у вашому коді. Ви побачите те саме на всіх "
"мовах, які підтримують арифметику з плаваючою комою вашого апаратного "
"забезпечення (хоча деякі мови можуть не *відображати* різницю за "
"замовчуванням або в усіх режимах виводу)."

msgid ""
"For more pleasant output, you may wish to use string formatting to produce a "
"limited number of significant digits::"
msgstr ""
"Для більш приємного виводу ви можете використати форматування рядка для "
"отримання обмеженої кількості значущих цифр::"

msgid ""
"It's important to realize that this is, in a real sense, an illusion: you're "
"simply rounding the *display* of the true machine value."
msgstr ""
"Важливо усвідомлювати, що насправді це ілюзія: ви просто округлюєте "
"*відображення* справжнього значення машини."

msgid ""
"One illusion may beget another.  For example, since 0.1 is not exactly 1/10, "
"summing three values of 0.1 may not yield exactly 0.3, either::"
msgstr ""
"Одна ілюзія може породити іншу. Наприклад, оскільки 0,1 не є точно 1/10, "
"підсумовування трьох значень 0,1 може не дати точно 0,3:"

msgid ""
"Also, since the 0.1 cannot get any closer to the exact value of 1/10 and 0.3 "
"cannot get any closer to the exact value of 3/10, then pre-rounding with :"
"func:`round` function cannot help::"
msgstr ""
"Крім того, оскільки 0,1 не може бути ближче до точного значення 1/10, а 0,3 "
"не може бути ближче до точного значення 3/10, то попереднє округлення за "
"допомогою функції :func:`round` не допоможе::"

msgid ""
"Though the numbers cannot be made closer to their intended exact values, "
"the :func:`round` function can be useful for post-rounding so that results "
"with inexact values become comparable to one another::"
msgstr ""
"Хоча числа неможливо наблизити до запланованих точних значень, функція :func:"
"`round` може бути корисною для подальшого округлення, щоб результати з "
"неточними значеннями стали порівнюваними один з одним:"

msgid ""
"Binary floating-point arithmetic holds many surprises like this.  The "
"problem with \"0.1\" is explained in precise detail below, in the "
"\"Representation Error\" section.  See `The Perils of Floating Point "
"<https://www.lahey.com/float.htm>`_ for a more complete account of other "
"common surprises."
msgstr ""
"Двійкова арифметика з плаваючою комою містить багато таких сюрпризів. "
"Проблема з \"0.1\" детально описана нижче, у розділі \"Помилка "
"представлення\". Перегляньте `Небезпеки з плаваючою точкою <https://www."
"lahey.com/float.htm>`_ для більш повного опису інших поширених несподіванок."

msgid ""
"As that says near the end, \"there are no easy answers.\"  Still, don't be "
"unduly wary of floating-point!  The errors in Python float operations are "
"inherited from the floating-point hardware, and on most machines are on the "
"order of no more than 1 part in 2\\*\\*53 per operation.  That's more than "
"adequate for most tasks, but you do need to keep in mind that it's not "
"decimal arithmetic and that every float operation can suffer a new rounding "
"error."
msgstr ""
"Як сказано ближче до кінця, \"простих відповідей немає\". Тим не менш, не "
"будьте надмірно обережні з плаваючою комою! Помилки в операціях з плаваючою "
"комою в Python успадковуються від апаратного забезпечення з плаваючою комою, "
"і на більшості машин вони становлять не більше 1 частини з 2\\*\\*53 на "
"операцію. Цього більш ніж достатньо для більшості завдань, але ви повинні "
"мати на увазі, що це не десяткова арифметика і що кожна операція з плаваючою "
"точкою може зазнати нової помилки округлення."

msgid ""
"While pathological cases do exist, for most casual use of floating-point "
"arithmetic you'll see the result you expect in the end if you simply round "
"the display of your final results to the number of decimal digits you "
"expect. :func:`str` usually suffices, and for finer control see the :meth:"
"`str.format` method's format specifiers in :ref:`formatstrings`."
msgstr ""
"Хоча патологічні випадки дійсно існують, для більшості випадкового "
"використання арифметики з плаваючою комою ви побачите очікуваний результат, "
"якщо просто округлите відображення кінцевих результатів до очікуваної "
"кількості десяткових цифр. :func:`str` зазвичай достатньо, і для більш "
"точного контролю дивіться специфікатори формату методу :meth:`str.format` у :"
"ref:`formatstrings`."

msgid ""
"For use cases which require exact decimal representation, try using the :mod:"
"`decimal` module which implements decimal arithmetic suitable for accounting "
"applications and high-precision applications."
msgstr ""
"Для випадків використання, які вимагають точного десяткового представлення, "
"спробуйте використовувати модуль :mod:`decimal`, який реалізує десяткову "
"арифметику, придатну для програм бухгалтерського обліку та програм високої "
"точності."

msgid ""
"Another form of exact arithmetic is supported by the :mod:`fractions` module "
"which implements arithmetic based on rational numbers (so the numbers like "
"1/3 can be represented exactly)."
msgstr ""
"Інша форма точної арифметики підтримується модулем :mod:`fractions`, який "
"реалізує арифметику на основі раціональних чисел (таким чином числа, такі як "
"1/3, можуть бути представлені точно)."

msgid ""
"If you are a heavy user of floating point operations you should take a look "
"at the NumPy package and many other packages for mathematical and "
"statistical operations supplied by the SciPy project. See <https://scipy."
"org>."
msgstr ""
"Якщо ви активно використовуєте операції з плаваючою комою, вам слід "
"поглянути на пакет NumPy та багато інших пакетів для математичних і "
"статистичних операцій, які надає проект SciPy. Див. <https://scipy.org>."

msgid ""
"Python provides tools that may help on those rare occasions when you really "
"*do* want to know the exact value of a float.  The :meth:`float."
"as_integer_ratio` method expresses the value of a float as a fraction::"
msgstr ""
"Python надає інструменти, які можуть допомогти в тих рідкісних випадках, "
"коли ви дійсно хочете знати точне значення числа з плаваючою точкою. Метод :"
"meth:`float.as_integer_ratio` виражає значення числа з плаваючою точкою у "
"вигляді дробу::"

msgid ""
"Since the ratio is exact, it can be used to losslessly recreate the original "
"value::"
msgstr ""
"Оскільки співвідношення є точним, його можна використовувати для відтворення "
"вихідного значення без втрат::"

msgid ""
"The :meth:`float.hex` method expresses a float in hexadecimal (base 16), "
"again giving the exact value stored by your computer::"
msgstr ""
"Метод :meth:`float.hex` виражає число з плаваючою точкою в шістнадцятковій "
"формі (за основою 16), знову надаючи точне значення, яке зберігає ваш "
"комп’ютер:"

msgid ""
"This precise hexadecimal representation can be used to reconstruct the float "
"value exactly::"
msgstr ""
"Це точне шістнадцяткове представлення можна використовувати для точної "
"реконструкції значення з плаваючою точкою:"

msgid ""
"Since the representation is exact, it is useful for reliably porting values "
"across different versions of Python (platform independence) and exchanging "
"data with other languages that support the same format (such as Java and "
"C99)."
msgstr ""
"Оскільки представлення є точним, воно корисне для надійного перенесення "
"значень між різними версіями Python (незалежність від платформи) та обміну "
"даними з іншими мовами, які підтримують той самий формат (такими як Java і "
"C99)."

msgid ""
"Another helpful tool is the :func:`math.fsum` function which helps mitigate "
"loss-of-precision during summation.  It tracks \"lost digits\" as values are "
"added onto a running total.  That can make a difference in overall accuracy "
"so that the errors do not accumulate to the point where they affect the "
"final total:"
msgstr ""
"Іншим корисним інструментом є функція :func:`math.fsum`, яка допомагає "
"зменшити втрату точності під час підсумовування. Він відстежує \"втрачені "
"цифри\", коли значення додаються до поточної суми. Це може вплинути на "
"загальну точність, щоб помилки не накопичувалися до точки, коли вони "
"впливали на кінцеву суму:"

msgid "Representation Error"
msgstr "Помилка представлення"

msgid ""
"This section explains the \"0.1\" example in detail, and shows how you can "
"perform an exact analysis of cases like this yourself.  Basic familiarity "
"with binary floating-point representation is assumed."
msgstr ""
"У цьому розділі детально пояснюється приклад \"0.1\" і показано, як ви "
"можете самостійно виконати точний аналіз подібних випадків. Передбачається "
"базове знайомство з двійковим представленням із плаваючою комою."

msgid ""
":dfn:`Representation error` refers to the fact that some (most, actually) "
"decimal fractions cannot be represented exactly as binary (base 2) "
"fractions. This is the chief reason why Python (or Perl, C, C++, Java, "
"Fortran, and many others) often won't display the exact decimal number you "
"expect."
msgstr ""
":dfn:`Representation error` стосується того факту, що деякі (насправді "
"більшість) десяткових дробів не можуть бути представлені точно як двійкові "
"(за основою 2) дроби. Це головна причина, чому Python (або Perl, C, C++, "
"Java, Fortran та багато інших) часто не відображає точне десяткове число, "
"яке ви очікуєте."

msgid ""
"Why is that?  1/10 is not exactly representable as a binary fraction. Almost "
"all machines today (November 2000) use IEEE-754 floating point arithmetic, "
"and almost all platforms map Python floats to IEEE-754 \"double "
"precision\".  754 doubles contain 53 bits of precision, so on input the "
"computer strives to convert 0.1 to the closest fraction it can of the form "
"*J*/2**\\ *N* where *J* is an integer containing exactly 53 bits.  "
"Rewriting ::"
msgstr ""
"Чому так? 1/10 не зовсім точно можна представити у вигляді двійкового дробу. "
"Майже всі машини сьогодні (листопад 2000) використовують арифметику з "
"плаваючою комою IEEE-754, і майже всі платформи відображають плаваючі числа "
"Python у IEEE-754 \"подвійної точності\". 754 подвійних числа містять 53 "
"біти точності, тому на вхідних даних комп’ютер намагається перетворити 0,1 у "
"найближчий дріб у формі *J*/2**\\ *N*, де *J* — ціле число, що містить рівно "
"53 біти. Переписування ::"

msgid "as ::"
msgstr "як ::"

msgid ""
"and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< "
"2**53``), the best value for *N* is 56::"
msgstr ""
"і нагадуючи, що *J* має рівно 53 біти (це ``>= 2**52``, але ``< 2**53``), "
"найкращим значенням для *N* є 56::"

msgid ""
"That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits.  "
"The best possible value for *J* is then that quotient rounded::"
msgstr ""
"Тобто 56 — це єдине значення для *N*, яке залишає *J* рівно 53 біти. "
"Найкраще можливе значення для *J* — це округлена частка::"

msgid ""
"Since the remainder is more than half of 10, the best approximation is "
"obtained by rounding up::"
msgstr ""
"Оскільки залишок становить більше половини від 10, найкраще наближення можна "
"отримати шляхом округлення:"

msgid ""
"Therefore the best possible approximation to 1/10 in 754 double precision "
"is::"
msgstr "Тому найкраще можливе наближення до 1/10 у 754 подвійної точності:"

msgid ""
"Dividing both the numerator and denominator by two reduces the fraction to::"
msgstr "Ділення чисельника та знаменника на два скорочує дріб до:"

msgid ""
"Note that since we rounded up, this is actually a little bit larger than "
"1/10; if we had not rounded up, the quotient would have been a little bit "
"smaller than 1/10.  But in no case can it be *exactly* 1/10!"
msgstr ""
"Зауважте, що оскільки ми округлили в більшу сторону, це насправді трохи "
"більше, ніж 1/10; якби ми не округляли в більшу сторону, частка була б трохи "
"меншою за 1/10. Але ні в якому разі не може бути *рівно* 1/10!"

msgid ""
"So the computer never \"sees\" 1/10:  what it sees is the exact fraction "
"given above, the best 754 double approximation it can get::"
msgstr ""
"Тому комп’ютер ніколи не \"бачить\" 1/10: він бачить точну частку, наведену "
"вище, найкраще подвійне наближення 754, яке він може отримати:"

msgid ""
"If we multiply that fraction by 10\\*\\*55, we can see the value out to 55 "
"decimal digits::"
msgstr ""
"Якщо ми помножимо цей дріб на 10\\*\\*55, ми побачимо значення до 55 "
"десяткових цифр:"

msgid ""
"meaning that the exact number stored in the computer is equal to the decimal "
"value 0.1000000000000000055511151231257827021181583404541015625. Instead of "
"displaying the full decimal value, many languages (including older versions "
"of Python), round the result to 17 significant digits::"
msgstr ""
"це означає, що точне число, яке зберігається в комп’ютері, дорівнює "
"десятковому значенню "
"0,1000000000000000055511151231257827021181583404541015625. Замість "
"відображення повного десяткового значення багато мов (включаючи старі версії "
"Python) округлюють результат до 17 значущих цифр:"

msgid ""
"The :mod:`fractions` and :mod:`decimal` modules make these calculations "
"easy::"
msgstr "Модулі :mod:`fractions` і :mod:`decimal` полегшують ці обчислення:"
