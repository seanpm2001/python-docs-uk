# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
# Vadim Kashirny, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Vadim Kashirny, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Design and History FAQ"
msgstr "Поширені запитання про оформлення та історію"

msgid "Contents"
msgstr "Зміст"

msgid "Why does Python use indentation for grouping of statements?"
msgstr "Чому Python використовує відступи для групування операторів?"

msgid ""
"Guido van Rossum believes that using indentation for grouping is extremely "
"elegant and contributes a lot to the clarity of the average Python program. "
"Most people learn to love this feature after a while."
msgstr ""
"Гвідо ван Россум вважає, що використання відступів для групування є "
"надзвичайно елегантним і значною мірою сприяє ясності звичайної програми на "
"Python. Більшість людей через деякий час полюблять цю функцію."

msgid ""
"Since there are no begin/end brackets there cannot be a disagreement between "
"grouping perceived by the parser and the human reader.  Occasionally C "
"programmers will encounter a fragment of code like this::"
msgstr ""
"Оскільки немає початкових/кінцевих дужок, не може бути розбіжностей між "
"групуванням, сприйнятим синтаксичним аналізатором і людиною, що читає код. "
"Час від часу програмісти на C стикаються з таким фрагментом коду:"

msgid ""
"Only the ``x++`` statement is executed if the condition is true, but the "
"indentation leads many to believe otherwise.  Even experienced C programmers "
"will sometimes stare at it a long time wondering as to why ``y`` is being "
"decremented even for ``x > y``."
msgstr ""
"Тільки оператор ``x++`` виконується, якщо умова виконується, але відступ "
"змушує багатьох вважати протилежне. Навіть досвідчені С-програмісти іноді "
"довго дивляться на нього, дивуючись, чому ``y`` зменшується навіть для ``x > "
"y``."

msgid ""
"Because there are no begin/end brackets, Python is much less prone to coding-"
"style conflicts.  In C there are many different ways to place the braces. "
"After becoming used to reading and writing code using a particular style, it "
"is normal to feel somewhat uneasy when reading (or being required to write) "
"in a different one."
msgstr ""
"Оскільки немає початкових/кінцевих фігурних дужок, Python значно менше "
"схильний до конфліктів стилю кодування. У C є багато різних способів "
"розміщення фігурних дужок. Після того, як ви звикли читати та писати код, "
"використовуючи певний стиль, це нормально відчувати незручності, коли "
"читаєте (або коли вам потрібно писати) в іншому стилі."

msgid ""
"Many coding styles place begin/end brackets on a line by themselves.  This "
"makes programs considerably longer and wastes valuable screen space, making "
"it harder to get a good overview of a program.  Ideally, a function should "
"fit on one screen (say, 20--30 lines).  20 lines of Python can do a lot more "
"work than 20 lines of C.  This is not solely due to the lack of begin/end "
"brackets -- the lack of declarations and the high-level data types are also "
"responsible -- but the indentation-based syntax certainly helps."
msgstr ""
"Багато стилів кодування розміщують початкові/кінцеві дужки на рядку "
"самостійно. Це робить програми значно довшими та витрачає дорогоцінний "
"простір на екрані, що ускладнює гарний огляд програми. В ідеалі функція "
"повинна міститися на одному екрані (скажімо, 20--30 рядків). 20 рядків "
"Python можуть виконувати набагато більше роботи, ніж 20 рядків C. Це "
"пов’язано не лише з відсутністю початкових/кінцевих дужок – відсутність "
"декларацій і високорівневих типів даних також відповідає – але  оснований на "
"відступах синтаксис, звичайно, допомагає."

msgid "Why am I getting strange results with simple arithmetic operations?"
msgstr "Чому я отримую дивні результати під час простих арифметичних операцій?"

msgid "See the next question."
msgstr "Дивіться наступне запитання."

msgid "Why are floating-point calculations so inaccurate?"
msgstr "Чому обчислення з плаваючою комою настільки неточні?"

msgid "Users are often surprised by results like this::"
msgstr "Користувачів часто дивують такі результати:"

msgid ""
"and think it is a bug in Python.  It's not.  This has little to do with "
"Python, and much more to do with how the underlying platform handles "
"floating-point numbers."
msgstr ""
"і вони думають, що це помилка в Python. Це не так. Це має мало спільного з "
"Python, і набагато більше пов’язане з тим, як базова платформа обробляє "
"числа з плаваючою комою."

msgid ""
"The :class:`float` type in CPython uses a C ``double`` for storage.  A :"
"class:`float` object's value is stored in binary floating-point with a fixed "
"precision (typically 53 bits) and Python uses C operations, which in turn "
"rely on the hardware implementation in the processor, to perform floating-"
"point operations. This means that as far as floating-point operations are "
"concerned, Python behaves like many popular languages including C and Java."
msgstr ""
"Тип :class:`float` у CPython використовує C ``double`` для зберігання. "
"Значення об’єкта :class:`float` зберігається у двійковій формі з плаваючою "
"комою з фіксованою точністю (зазвичай 53 біти), і Python використовує "
"операції C, які, у свою чергу, покладаються на апаратну реалізацію в "
"процесорі, щоб виконувати операції з плаваючою комою. Це означає, що в "
"операціях з плаваючою комою Python поводиться як багато популярних мов, "
"включаючи C і Java."

msgid ""
"Many numbers that can be written easily in decimal notation cannot be "
"expressed exactly in binary floating-point.  For example, after::"
msgstr ""
"Багато чисел, які можна легко записати в десятковій системі числення, "
"неможливо точно виразити у двійковій формі з плаваючою комою. Наприклад, "
"після::"

msgid ""
"the value stored for ``x`` is a (very good) approximation to the decimal "
"value ``1.2``, but is not exactly equal to it.  On a typical machine, the "
"actual stored value is::"
msgstr ""
"значення, яке зберігається для ``x``, є (дуже точним) наближенням до "
"десяткового значення ``1.2``, але не зовсім дорівнює йому. На типовій машині "
"фактичне збережене значення:"

msgid "which is exactly::"
msgstr "а саме::"

msgid ""
"The typical precision of 53 bits provides Python floats with 15--16 decimal "
"digits of accuracy."
msgstr ""
"Типова точність в 53 біти забезпечує числа з плаваючою точкою Python з "
"точністю 15--16 десяткових цифр."

msgid ""
"For a fuller explanation, please see the :ref:`floating point arithmetic "
"<tut-fp-issues>` chapter in the Python tutorial."
msgstr ""
"Для більш детального пояснення дивіться розділ :ref:`арифметика з плаваючою "
"комою <tut-fp-issues>` у підручнику з Python."

msgid "Why are Python strings immutable?"
msgstr "Чому рядки Python немутабельні?"

msgid "There are several advantages."
msgstr "Є кілька переваг."

msgid ""
"One is performance: knowing that a string is immutable means we can allocate "
"space for it at creation time, and the storage requirements are fixed and "
"unchanging.  This is also one of the reasons for the distinction between "
"tuples and lists."
msgstr ""
"Одна з них — це продуктивність: знання того, що рядок є незмінним, означає, "
"що ми можемо виділити для нього місце під час створення, а вимоги до пам’яті "
"є фіксованими та незмінними. Це також одна з причин відмінності між "
"кортежами та списками."

msgid ""
"Another advantage is that strings in Python are considered as \"elemental\" "
"as numbers.  No amount of activity will change the value 8 to anything else, "
"and in Python, no amount of activity will change the string \"eight\" to "
"anything else."
msgstr ""
"Ще одна перевага полягає в тому, що рядки в Python вважаються такими ж "
"\"елементарними\", як і числа. Жодна активність не змінить значення 8 на "
"щось інше, а в Python жодна активність не змінить рядок \"вісім\" на щось "
"інше."

msgid "Why must 'self' be used explicitly in method definitions and calls?"
msgstr ""
"Чому \"self\" має використовуватися явно у визначеннях і викликах методів?"

msgid ""
"The idea was borrowed from Modula-3.  It turns out to be very useful, for a "
"variety of reasons."
msgstr ""
"Ідея була запозичена з Modula-3. Це виявляється дуже корисним з різних "
"причин."

msgid ""
"First, it's more obvious that you are using a method or instance attribute "
"instead of a local variable.  Reading ``self.x`` or ``self.meth()`` makes it "
"absolutely clear that an instance variable or method is used even if you "
"don't know the class definition by heart.  In C++, you can sort of tell by "
"the lack of a local variable declaration (assuming globals are rare or "
"easily recognizable) -- but in Python, there are no local variable "
"declarations, so you'd have to look up the class definition to be sure.  "
"Some C++ and Java coding standards call for instance attributes to have an "
"``m_`` prefix, so this explicitness is still useful in those languages, too."
msgstr ""
"По-перше, більш очевидно, що ви використовуєте метод або атрибут екземпляра "
"замість локальної змінної. Читання ``self.x`` або ``self.meth()`` робить "
"абсолютно зрозумілим, що використовується змінна екземпляра або метод, "
"навіть якщо ви не знаєте визначення класу напам'ять. У C++ це можна "
"визначити за відсутністю оголошення локальної змінної (якщо глобальні "
"значення рідкісні або легко впізнавані), але в Python немає оголошення "
"локальної змінної, тому вам доведеться шукати визначення класу, щоб бути "
"впевненим. Деякі стандарти кодування C++ і Java вимагають, щоб атрибути "
"екземплярів мали префікс ``m_``, тому ця чіткість все ще корисна в цих мовах."

msgid ""
"Second, it means that no special syntax is necessary if you want to "
"explicitly reference or call the method from a particular class.  In C++, if "
"you want to use a method from a base class which is overridden in a derived "
"class, you have to use the ``::`` operator -- in Python you can write "
"``baseclass.methodname(self, <argument list>)``.  This is particularly "
"useful for :meth:`__init__` methods, and in general in cases where a derived "
"class method wants to extend the base class method of the same name and thus "
"has to call the base class method somehow."
msgstr ""
"По-друге, це означає, що не потрібен спеціальний синтаксис, якщо ви хочете "
"явно посилатися на метод або викликати його з певного класу. У C++, якщо ви "
"хочете використовувати метод із базового класу, який перевизначено в "
"похідному класі, вам потрібно використовувати оператор ``::`` -- у Python ви "
"можете написати ``baseclass.methodname(self, <argument list>)``. Це особливо "
"корисно для методів :meth:`__init__` і загалом у випадках, коли метод "
"похідного класу хоче розширити однойменний метод базового класу і, отже, має "
"якось викликати метод базового класу."

msgid ""
"Finally, for instance variables it solves a syntactic problem with "
"assignment: since local variables in Python are (by definition!) those "
"variables to which a value is assigned in a function body (and that aren't "
"explicitly declared global), there has to be some way to tell the "
"interpreter that an assignment was meant to assign to an instance variable "
"instead of to a local variable, and it should preferably be syntactic (for "
"efficiency reasons).  C++ does this through declarations, but Python doesn't "
"have declarations and it would be a pity having to introduce them just for "
"this purpose.  Using the explicit ``self.var`` solves this nicely.  "
"Similarly, for using instance variables, having to write ``self.var`` means "
"that references to unqualified names inside a method don't have to search "
"the instance's directories.  To put it another way, local variables and "
"instance variables live in two different namespaces, and you need to tell "
"Python which namespace to use."
msgstr ""
"Нарешті, для  змінних екземпляра, такий підхід вирішує синтаксичну проблему "
"з призначенням: оскільки локальні змінні в Python — це (за визначенням!) ті "
"змінні, яким присвоєно значення в тілі функції (і які явно не оголошені "
"глобальними), необхідно бути якимось способом повідомити інтерпретатору, що "
"це призначено для встановленния значення змінній екземпляра, а не локальній "
"змінній, і бажано, щоб воно було синтаксичним (з причин ефективності). C++ "
"робить це за допомогою декларацій, але Python не має декларацій, і було б "
"шкода вводити їх лише для цієї мети. Використання явного ``self.var`` добре "
"вирішує цю проблему. Подібним чином, для використання змінних екземпляра "
"необхідність запису ``self.var`` означає, що посилання на некваліфіковані "
"імена всередині методу не потребують пошуку в каталогах екземпляра. Іншими "
"словами, локальні змінні та змінні екземплярів живуть у двох різних "
"просторах імен, і вам потрібно сказати інтерпритатору Python, який простір "
"імен використовувати."

msgid "Why can't I use an assignment in an expression?"
msgstr "Чому я не можу використовувати присвоєння у виразі?"

msgid "Starting in Python 3.8, you can!"
msgstr "Починаючи з Python 3.8, ви можете!"

msgid ""
"Assignment expressions using the walrus operator ``:=`` assign a variable in "
"an expression::"
msgstr ""

msgid "See :pep:`572` for more information."
msgstr "Перегляньте :pep:`572` для отримання додаткової інформації."

msgid ""
"Why does Python use methods for some functionality (e.g. list.index()) but "
"functions for other (e.g. len(list))?"
msgstr ""
"Чому Python використовує методи для одних функцій (наприклад, list.index()), "
"а функції для інших (наприклад, len(list))?"

msgid "As Guido said:"
msgstr "Як сказав Гвідо:"

msgid ""
"(a) For some operations, prefix notation just reads better than postfix -- "
"prefix (and infix!) operations have a long tradition in mathematics which "
"likes notations where the visuals help the mathematician thinking about a "
"problem. Compare the easy with which we rewrite a formula like x*(a+b) into "
"x*a + x*b to the clumsiness of doing the same thing using a raw OO notation."
msgstr ""
"(a) Для деяких операцій префіксна нотація просто читається краще, ніж "
"постфіксна — префіксні (та інфіксні!) операції мають давню традицію в "
"математиці, яка любить нотації, де візуальні елементи допомагають математику "
"думати про проблему. Порівняйте легкість, за допомогою якої ми переписуємо "
"формулу на кшталт x*(a+b) на x*a + x*b, із незграбністю виконання того ж "
"самого, використовуючи чисту нотацію OO."

msgid ""
"(b) When I read code that says len(x) I *know* that it is asking for the "
"length of something. This tells me two things: the result is an integer, and "
"the argument is some kind of container. To the contrary, when I read x."
"len(), I have to already know that x is some kind of container implementing "
"an interface or inheriting from a class that has a standard len(). Witness "
"the confusion we occasionally have when a class that is not implementing a "
"mapping has a get() or keys() method, or something that isn't a file has a "
"write() method."
msgstr ""
"(b) Коли я читаю код, який каже len(x), я *знаю*, що він запитує довжину "
"чогось. Це говорить мені про дві речі: результат є цілим числом, а аргумент "
"є певним контейнером. Навпаки, коли я читаю x.len(), я вже маю знати, що x — "
"це якийсь контейнер, який реалізує інтерфейс або успадковує від класу, який "
"має стандартний len(). Подивіться, яка плутанина у нас іноді виникає, коли "
"клас, який не реалізує відображення, має метод get() або keys(), або щось, "
"що не є файлом, має метод write()."

msgid "https://mail.python.org/pipermail/python-3000/2006-November/004643.html"
msgstr ""
"https://mail.python.org/pipermail/python-3000/2006-November/004643.html"

msgid "Why is join() a string method instead of a list or tuple method?"
msgstr "Чому метод join() є методом рядків, а не методом списку чи кортежу?"

msgid ""
"Strings became much more like other standard types starting in Python 1.6, "
"when methods were added which give the same functionality that has always "
"been available using the functions of the string module.  Most of these new "
"methods have been widely accepted, but the one which appears to make some "
"programmers feel uncomfortable is::"
msgstr ""
"Рядки стали набагато більше схожими на інші стандартні типи, починаючи з "
"Python 1.6, коли були додані методи, які надають ту саму функціональність, "
"яка завжди була доступна за допомогою функцій модуля string. Більшість цих "
"нових методів були широко прийняті, але один, який, здається, змушує деяких "
"програмістів почуватися некомфортно:"

msgid "which gives the result::"
msgstr "що дає результат::"

msgid "There are two common arguments against this usage."
msgstr "Існує два загальні аргументи проти такого використання."

msgid ""
"The first runs along the lines of: \"It looks really ugly using a method of "
"a string literal (string constant)\", to which the answer is that it might, "
"but a string literal is just a fixed value. If the methods are to be allowed "
"on names bound to strings there is no logical reason to make them "
"unavailable on literals."
msgstr ""
"Перше звучить так: \"Це виглядає дуже потворно, використовуючи метод "
"рядкового літералу (рядкова константа)\", на що є відповідь, що це може "
"бути, навіть якщо рядковий літерал це лише фіксоване значення. Якщо методи "
"мають бути дозволені для імен, прив’язаних до рядків, немає логічної причини "
"робити їх недоступними для літералів."

msgid ""
"The second objection is typically cast as: \"I am really telling a sequence "
"to join its members together with a string constant\".  Sadly, you aren't.  "
"For some reason there seems to be much less difficulty with having :meth:"
"`~str.split` as a string method, since in that case it is easy to see that ::"
msgstr ""
"Друге заперечення, як правило, формулюється так: \"Я справді кажу "
"послідовності об’єднати її члени за допомогою рядкової константи\". На жаль, "
"ні. З певних причин здається, що з використанням :meth:`~str.split` як "
"рядкового методу набагато менше труднощів, оскільки в цьому випадку легко "
"побачити, що:"

msgid ""
"is an instruction to a string literal to return the substrings delimited by "
"the given separator (or, by default, arbitrary runs of white space)."
msgstr ""
"це вказівка для рядкового літералу повертати підрядки, розділені заданим "
"роздільником (або, за замовчуванням, пробілом)."

msgid ""
":meth:`~str.join` is a string method because in using it you are telling the "
"separator string to iterate over a sequence of strings and insert itself "
"between adjacent elements.  This method can be used with any argument which "
"obeys the rules for sequence objects, including any new classes you might "
"define yourself. Similar methods exist for bytes and bytearray objects."
msgstr ""
":meth:`~str.join` — це рядковий метод, оскільки, використовуючи його, ви "
"вказуєте рядку-роздільнику перебирати послідовність рядків і вставляти себе "
"між суміжними елементами. Цей метод можна використовувати з будь-яким "
"аргументом, який підкоряється правилам для об’єктів послідовності, включаючи "
"будь-які нові класи, які ви можете визначити самостійно. Подібні методи "
"існують для об’єктів bytes і bytearray."

msgid "How fast are exceptions?"
msgstr "Як швидко працюють винятки?"

msgid ""
"A try/except block is extremely efficient if no exceptions are raised.  "
"Actually catching an exception is expensive.  In versions of Python prior to "
"2.0 it was common to use this idiom::"
msgstr ""
"Блок try/except надзвичайно ефективний, якщо винятки не викликаються. "
"Насправді перехоплення винятків коштує дорого. У версіях Python до 2.0 було "
"поширеним використання цієї ідіоми:"

msgid ""
"This only made sense when you expected the dict to have the key almost all "
"the time.  If that wasn't the case, you coded it like this::"
msgstr ""
"Це мало сенс лише тоді, коли ви очікували, що dict матиме ключ майже весь "
"час. Якщо це не так, ви закодували це так::"

msgid ""
"For this specific case, you could also use ``value = dict.setdefault(key, "
"getvalue(key))``, but only if the ``getvalue()`` call is cheap enough "
"because it is evaluated in all cases."
msgstr ""
"Для цього конкретного випадку ви також можете використати ``value = dict."
"setdefault(key, getvalue(key))``, але лише якщо виклик ``getvalue()`` досить "
"дешевий, оскільки він оцінюється в усіх випадках."

msgid "Why isn't there a switch or case statement in Python?"
msgstr "Чому в Python немає оператора switch або case?"

msgid ""
"You can do this easily enough with a sequence of ``if... elif... elif... "
"else``. For literal values, or constants within a namespace, you can also "
"use a ``match ... case`` statement."
msgstr ""
"Ви можете зробити це досить легко за допомогою послідовності ``if... elif... "
"elif... else``. Для літеральних значень або констант у просторі імен ви "
"також можете використовувати оператор ``match ... case``."

msgid ""
"For cases where you need to choose from a very large number of "
"possibilities, you can create a dictionary mapping case values to functions "
"to call.  For example::"
msgstr ""
"У випадках, коли вам потрібно вибрати з дуже великої кількості можливостей, "
"ви можете створити словник, який зіставлятиме значення регістру з функціями "
"для виклику. Наприклад::"

msgid ""
"For calling methods on objects, you can simplify yet further by using the :"
"func:`getattr` built-in to retrieve methods with a particular name::"
msgstr ""
"Для виклику методів об’єктів ви можете ще більше спростити, використовуючи "
"вбудований :func:`getattr` для отримання методів із певним іменем::"

msgid ""
"It's suggested that you use a prefix for the method names, such as "
"``visit_`` in this example.  Without such a prefix, if values are coming "
"from an untrusted source, an attacker would be able to call any method on "
"your object."
msgstr ""
"Рекомендується використовувати префікс для імен методів, наприклад "
"``visit_`` у цьому прикладі. Без такого префікса, якщо значення надходять із "
"ненадійного джерела, зловмисник зможе викликати будь-який метод вашого "
"об’єкта."

msgid ""
"Can't you emulate threads in the interpreter instead of relying on an OS-"
"specific thread implementation?"
msgstr ""
"Чи не можна емулювати потоки в інтерпретаторі замість того, щоб покладатися "
"на реалізацію потоку, специфічного для ОС?"

msgid ""
"Answer 1: Unfortunately, the interpreter pushes at least one C stack frame "
"for each Python stack frame.  Also, extensions can call back into Python at "
"almost random moments.  Therefore, a complete threads implementation "
"requires thread support for C."
msgstr ""
"Відповідь 1: На жаль, інтерпретатор надсилає принаймні один кадр стека C для "
"кожного кадру стека Python. Крім того, розширення можуть повертатися до "
"Python у майже випадкові моменти. Таким чином, повна реалізація потоків "
"вимагає підтримки потоків для C."

msgid ""
"Answer 2: Fortunately, there is `Stackless Python <https://github.com/"
"stackless-dev/stackless/wiki>`_, which has a completely redesigned "
"interpreter loop that avoids the C stack."
msgstr ""
"Відповідь 2: На щастя, є `Stackless Python <https://github.com/stackless-dev/"
"stackless/wiki>`_, який має повністю перероблений цикл інтерпретатора, який "
"уникає стека C."

msgid "Why can't lambda expressions contain statements?"
msgstr "Чому лямбда-вирази не можуть містити оператори?"

msgid ""
"Python lambda expressions cannot contain statements because Python's "
"syntactic framework can't handle statements nested inside expressions.  "
"However, in Python, this is not a serious problem.  Unlike lambda forms in "
"other languages, where they add functionality, Python lambdas are only a "
"shorthand notation if you're too lazy to define a function."
msgstr ""
"Лямбда-вирази Python не можуть містити оператори, оскільки синтаксична "
"структура Python не може обробляти оператори, вкладені у вирази. Однак у "
"Python це не є серйозною проблемою. На відміну від лямбда-форм в інших "
"мовах, де вони додають функціональність, лямбда-вирази Python є лише "
"скороченою нотацією, якщо вам ліньки визначати функцію."

msgid ""
"Functions are already first class objects in Python, and can be declared in "
"a local scope.  Therefore the only advantage of using a lambda instead of a "
"locally defined function is that you don't need to invent a name for the "
"function -- but that's just a local variable to which the function object "
"(which is exactly the same type of object that a lambda expression yields) "
"is assigned!"
msgstr ""

msgid "Can Python be compiled to machine code, C or some other language?"
msgstr "Чи можна Python скомпілювати до машинного коду, мови C чи іншої?"

msgid ""
"`Cython <https://cython.org/>`_ compiles a modified version of Python with "
"optional annotations into C extensions.  `Nuitka <https://www.nuitka.net/>`_ "
"is an up-and-coming compiler of Python into C++ code, aiming to support the "
"full Python language."
msgstr ""

msgid "How does Python manage memory?"
msgstr "Як Python керує пам'яттю?"

msgid ""
"The details of Python memory management depend on the implementation.  The "
"standard implementation of Python, :term:`CPython`, uses reference counting "
"to detect inaccessible objects, and another mechanism to collect reference "
"cycles, periodically executing a cycle detection algorithm which looks for "
"inaccessible cycles and deletes the objects involved. The :mod:`gc` module "
"provides functions to perform a garbage collection, obtain debugging "
"statistics, and tune the collector's parameters."
msgstr ""
"Деталі керування пам’яттю Python залежать від реалізації. Стандартна "
"реалізація Python, :term:`CPython`, використовує підрахунок посилань для "
"виявлення недоступних об’єктів та інший механізм для збору посилальних "
"циклів, періодично виконуючи алгоритм виявлення циклів, який шукає "
"недоступні цикли та видаляє залучені об’єкти. Модуль :mod:`gc` надає функції "
"для збирання сміття, отримання статистики налагодження та налаштування "
"параметрів збирача."

msgid ""
"Other implementations (such as `Jython <https://www.jython.org>`_ or `PyPy "
"<https://www.pypy.org>`_), however, can rely on a different mechanism such "
"as a full-blown garbage collector.  This difference can cause some subtle "
"porting problems if your Python code depends on the behavior of the "
"reference counting implementation."
msgstr ""

msgid ""
"In some Python implementations, the following code (which is fine in "
"CPython) will probably run out of file descriptors::"
msgstr ""
"У деяких реалізаціях Python наступний код (який добре процює у CPython), "
"ймовірно, не матиме файлових дескрипторів::"

msgid ""
"Indeed, using CPython's reference counting and destructor scheme, each new "
"assignment to *f* closes the previous file.  With a traditional GC, however, "
"those file objects will only get collected (and closed) at varying and "
"possibly long intervals."
msgstr ""
"Дійсно, використовуючи схему підрахунку посилань і деструктора CPython, "
"кожне нове призначення *f* закриває попередній файл. Однак за допомогою "
"традиційного збирача сміття ці файлові об’єкти збиратимуться (і "
"закриватимуться) лише через різні та, можливо, великі проміжки часу."

msgid ""
"If you want to write code that will work with any Python implementation, you "
"should explicitly close the file or use the :keyword:`with` statement; this "
"will work regardless of memory management scheme::"
msgstr ""
"Якщо ви хочете написати код, який працюватиме з будь-якою реалізацією "
"Python, вам слід явно закрити файл або використати оператор :keyword:`with`; "
"це працюватиме незалежно від схеми керування пам'яттю:"

msgid "Why doesn't CPython use a more traditional garbage collection scheme?"
msgstr "Чому CPython не використовує більш традиційну схему збирання сміття?"

msgid ""
"For one thing, this is not a C standard feature and hence it's not portable. "
"(Yes, we know about the Boehm GC library.  It has bits of assembler code for "
"*most* common platforms, not for all of them, and although it is mostly "
"transparent, it isn't completely transparent; patches are required to get "
"Python to work with it.)"
msgstr ""
"По-перше, це не є стандартною функцією C, а отже, вона не переносна. (Так, "
"ми знаємо про бібліотеку Boehm GC. Вона містить фрагменти коду асемблера для "
"*найбільш* поширених платформ, не для всіх, і хоча вона здебільшого прозора, "
"але  всеж таки не зовсім прозора; для Python потрібні патчи щоб  працювати з "
"нею.)"

msgid ""
"Traditional GC also becomes a problem when Python is embedded into other "
"applications.  While in a standalone Python it's fine to replace the "
"standard malloc() and free() with versions provided by the GC library, an "
"application embedding Python may want to have its *own* substitute for "
"malloc() and free(), and may not want Python's.  Right now, CPython works "
"with anything that implements malloc() and free() properly."
msgstr ""
"Звичайний GC також стає проблемою, коли Python вбудовано в інші програми. "
"Хоча в автономному Python можна замінити стандартні malloc() і free() "
"версіями, наданими бібліотекою GC, програма, яка вбудовує Python, може "
"захотіти мати свій *власний* замінник malloc() і free(), і може не хотіти "
"використовувати те що є у Python. Наразі CPython працює з усім, що правильно "
"реалізує malloc() і free()."

msgid "Why isn't all memory freed when CPython exits?"
msgstr "Чому не вся пам'ять звільняється, коли CPython завершує роботу?"

msgid ""
"Objects referenced from the global namespaces of Python modules are not "
"always deallocated when Python exits.  This may happen if there are circular "
"references.  There are also certain bits of memory that are allocated by the "
"C library that are impossible to free (e.g. a tool like Purify will complain "
"about these).  Python is, however, aggressive about cleaning up memory on "
"exit and does try to destroy every single object."
msgstr ""
"Об’єкти, на які посилаються глобальні простори імен модулів Python, не "
"завжди звільняються, коли Python завершує роботу. Це може статися, якщо є "
"циклічні посилання. Є також певні частини пам’яті, виділені бібліотекою C, "
"які неможливо звільнити (наприклад, такий інструмент, як Purify, буде "
"скаржитися на це). Однак Python агресивно очищає пам’ять під час виходу та "
"намагається знищити кожен окремий об’єкт."

msgid ""
"If you want to force Python to delete certain things on deallocation use "
"the :mod:`atexit` module to run a function that will force those deletions."
msgstr ""
"Якщо ви хочете змусити Python видалити певні речі під час звільнення, "
"скористайтеся модулем :mod:`atexit`, щоб запустити функцію, яка примусово "
"прискорить ці видалення."

msgid "Why are there separate tuple and list data types?"
msgstr "Чому існують окремі типи даних кортежу та списку?"

msgid ""
"Lists and tuples, while similar in many respects, are generally used in "
"fundamentally different ways.  Tuples can be thought of as being similar to "
"Pascal records or C structs; they're small collections of related data which "
"may be of different types which are operated on as a group.  For example, a "
"Cartesian coordinate is appropriately represented as a tuple of two or three "
"numbers."
msgstr ""
"Списки та кортежі, хоч і схожі в багатьох відношеннях, зазвичай "
"використовуються принципово різними способами. Кортежі можна розглядати як "
"подібні до записів Pascal або структур C; це невеликі колекції пов’язаних "
"даних, які можуть бути різних типів, які обробляються як група. Наприклад, "
"декартова координата відповідним чином представлена у вигляді кортежу з двох "
"або трьох чисел."

msgid ""
"Lists, on the other hand, are more like arrays in other languages.  They "
"tend to hold a varying number of objects all of which have the same type and "
"which are operated on one-by-one.  For example, ``os.listdir('.')`` returns "
"a list of strings representing the files in the current directory.  "
"Functions which operate on this output would generally not break if you "
"added another file or two to the directory."
msgstr ""
"Списки, з іншого боку, більше схожі на масиви в інших мовах. Вони, як "
"правило, містять різну кількість об’єктів, усі з яких мають однаковий тип і "
"з якими працюють один за одним. Наприклад, ``os.listdir('.')`` повертає "
"список рядків, що представляють файли в поточному каталозі. Функції, які "
"працюють з цим виводом, як правило, не зламаються, якщо ви додасте ще один "
"або два файли до каталогу."

msgid ""
"Tuples are immutable, meaning that once a tuple has been created, you can't "
"replace any of its elements with a new value.  Lists are mutable, meaning "
"that you can always change a list's elements.  Only immutable elements can "
"be used as dictionary keys, and hence only tuples and not lists can be used "
"as keys."
msgstr ""
"Кортежі є незмінними, тобто після створення кортежу ви не можете замінити "
"жоден із його елементів новим значенням. Списки є змінними, тобто ви завжди "
"можете змінити елементи списку. Тільки незмінні елементи можна "
"використовувати як ключі словника, а отже, лише кортежі можна "
"використовувати як ключі, а списки не можна."

msgid "How are lists implemented in CPython?"
msgstr "Як списки реалізовані в CPython?"

msgid ""
"CPython's lists are really variable-length arrays, not Lisp-style linked "
"lists. The implementation uses a contiguous array of references to other "
"objects, and keeps a pointer to this array and the array's length in a list "
"head structure."
msgstr ""
"Списки CPython насправді є масивами змінної довжини, а не пов’язаними "
"списками як у стилі Lisp. Реалізація використовує безперервний масив "
"посилань на інші об’єкти та зберігає вказівник на цей масив і довжину масиву "
"в структурі заголовка списку."

msgid ""
"This makes indexing a list ``a[i]`` an operation whose cost is independent "
"of the size of the list or the value of the index."
msgstr ""
"Це робить індексацію списку ``a[i]`` операцією, вартість якої не залежить "
"від розміру списку або значення індексу."

msgid ""
"When items are appended or inserted, the array of references is resized.  "
"Some cleverness is applied to improve the performance of appending items "
"repeatedly; when the array must be grown, some extra space is allocated so "
"the next few times don't require an actual resize."
msgstr ""
"Коли елементи додаються або вставляються, розмір масиву посилань змінюється. "
"Деяка кмітливість застосована для покращення продуктивності багаторазового "
"додавання елементів; коли масив потрібно збільшити, виділяється додатковий "
"простір, тому наступні кілька разів не вимагають фактичної зміни розміру."

msgid "How are dictionaries implemented in CPython?"
msgstr "Як реалізовані словники в CPython?"

msgid ""
"CPython's dictionaries are implemented as resizable hash tables.  Compared "
"to B-trees, this gives better performance for lookup (the most common "
"operation by far) under most circumstances, and the implementation is "
"simpler."
msgstr ""
"Словники CPython реалізовані як хеш-таблиці зі змінним розміром. Порівняно з "
"B-деревами, це дає кращу продуктивність для пошуку (найпоширеніша операція "
"на сьогоднішній день) у більшості випадків, а реалізація є простішою."

msgid ""
"Dictionaries work by computing a hash code for each key stored in the "
"dictionary using the :func:`hash` built-in function.  The hash code varies "
"widely depending on the key and a per-process seed; for example, \"Python\" "
"could hash to -539294296 while \"python\", a string that differs by a single "
"bit, could hash to 1142331976.  The hash code is then used to calculate a "
"location in an internal array where the value will be stored.  Assuming that "
"you're storing keys that all have different hash values, this means that "
"dictionaries take constant time -- O(1), in Big-O notation -- to retrieve a "
"key."
msgstr ""
"Словники працюють шляхом обчислення хеш-коду для кожного ключа, що "
"зберігається в словнику, за допомогою вбудованої функції :func:`hash`. Хеш-"
"код значно змінюється залежно від ключа та початкового числа процесу; "
"наприклад, рядок \"Python\" може отримати хеш -539294296, тоді як "
"\"python\", рядок, який відрізняється одним бітом, може отримати хеш  "
"1142331976. Хеш-код потім використовується для обчислення розташування у "
"внутрішньому масиві, де буде зберігатися значення . Якщо припустити, що ви "
"зберігаєте ключі, усі з яких мають різні хеш-значення, це означає, що "
"словникам потрібен постійний час – O(1) у нотації Big-O – щоб отримати ключ."

msgid "Why must dictionary keys be immutable?"
msgstr "Чому ключі словника повинні бути незмінними?"

msgid ""
"The hash table implementation of dictionaries uses a hash value calculated "
"from the key value to find the key.  If the key were a mutable object, its "
"value could change, and thus its hash could also change.  But since whoever "
"changes the key object can't tell that it was being used as a dictionary "
"key, it can't move the entry around in the dictionary.  Then, when you try "
"to look up the same object in the dictionary it won't be found because its "
"hash value is different. If you tried to look up the old value it wouldn't "
"be found either, because the value of the object found in that hash bin "
"would be different."
msgstr ""
"Реалізація хеш-таблиці словників використовує хеш-значення, обчислене зі "
"значення ключа, щоб знайти ключ. Якби ключ був змінним об’єктом, його "
"значення могло б змінитися, а отже, і його хеш також міг би змінитися. Але "
"оскільки той, хто змінює об’єкт ключа, не може сказати, що він "
"використовувався як ключ словника, він не може переміщувати запис у "
"словнику. Тоді, коли ви спробуєте знайти той самий об’єкт у словнику, він не "
"буде знайдений, оскільки його хеш-значення інше. Якщо ви спробуєте знайти "
"старе значення, його також не буде знайдено, оскільки значення об’єкта, "
"знайденого в цьому хеш-біні, буде іншим."

msgid ""
"If you want a dictionary indexed with a list, simply convert the list to a "
"tuple first; the function ``tuple(L)`` creates a tuple with the same entries "
"as the list ``L``.  Tuples are immutable and can therefore be used as "
"dictionary keys."
msgstr ""
"Якщо ви хочете, щоб словник був індексований списком, просто спочатку "
"перетворіть список на кортеж; функція ``tuple(L)`` створює кортеж з тими "
"самими записами, що і список ``L``. Кортежі є незмінними, тому їх можна "
"використовувати як ключі словника."

msgid "Some unacceptable solutions that have been proposed:"
msgstr "Деякі неприйнятні рішення, які були запропоновані:"

msgid ""
"Hash lists by their address (object ID).  This doesn't work because if you "
"construct a new list with the same value it won't be found; e.g.::"
msgstr ""
"Хешувати списки за їхньою адресою (ID об'єкта). Це не працює, тому що якщо "
"ви створите новий список із тим самим значенням, його не буде знайдено; "
"наприклад::"

msgid ""
"would raise a :exc:`KeyError` exception because the id of the ``[1, 2]`` "
"used in the second line differs from that in the first line.  In other "
"words, dictionary keys should be compared using ``==``, not using :keyword:"
"`is`."
msgstr ""
"викличе виняток :exc:`KeyError`, оскільки ідентифікатор ``[1, 2]``, який "
"використовується у другому рядку, відрізняється від ідентифікатора в першому "
"рядку. Іншими словами, ключі словника слід порівнювати за допомогою ``==``, "
"а не за допомогою :keyword:`is`."

msgid ""
"Make a copy when using a list as a key.  This doesn't work because the list, "
"being a mutable object, could contain a reference to itself, and then the "
"copying code would run into an infinite loop."
msgstr ""
"Зробити копію, якщо використовуєте список як ключ. Це не працює, тому що "
"список, будучи змінним об’єктом, може містити посилання на себе, і тоді код "
"копіювання запускатиметься в нескінченний цикл."

msgid ""
"Allow lists as keys but tell the user not to modify them.  This would allow "
"a class of hard-to-track bugs in programs when you forgot or modified a list "
"by accident. It also invalidates an important invariant of dictionaries: "
"every value in ``d.keys()`` is usable as a key of the dictionary."
msgstr ""
"Дозволити списки як ключі, але сказати користувачеві не змінювати їх. Це "
"дозволило б створити клас помилок, які важко відстежити в програмах, коли ви "
"випадково забули або змінили список. Це також робить недійсним важливий "
"інваріант словників: кожне значення в ``d.keys()`` можна використовувати як "
"ключ словника."

msgid ""
"Mark lists as read-only once they are used as a dictionary key.  The problem "
"is that it's not just the top-level object that could change its value; you "
"could use a tuple containing a list as a key.  Entering anything as a key "
"into a dictionary would require marking all objects reachable from there as "
"read-only -- and again, self-referential objects could cause an infinite "
"loop."
msgstr ""
"Позначайте списки як доступні лише для читання, коли вони використовуються "
"як ключ словника. Проблема полягає в тому, що не лише об’єкт верхнього рівня "
"може змінити своє значення; ви можете використовувати кортеж, що містить "
"список, як ключ. Введення будь-чого як ключа до словника вимагало б "
"позначити всі доступні звідти об’єкти як доступні лише для читання – і знову "
"ж таки самопосилання на об’єкти могло б спричинити нескінченний цикл."

msgid ""
"There is a trick to get around this if you need to, but use it at your own "
"risk: You can wrap a mutable structure inside a class instance which has "
"both a :meth:`__eq__` and a :meth:`__hash__` method.  You must then make "
"sure that the hash value for all such wrapper objects that reside in a "
"dictionary (or other hash based structure), remain fixed while the object is "
"in the dictionary (or other structure). ::"
msgstr ""
"Існує трюк, щоб обійти це, якщо вам потрібно, але використовуйте його на "
"свій страх і ризик: ви можете загорнути змінну структуру в екземпляр класу, "
"який має методи як :meth:`__eq__`, так і :meth:`__hash__`. . Потім ви "
"повинні переконатися, що хеш-значення для всіх таких об’єктів-огорток, які "
"знаходяться в словнику (або іншій структурі на основі хешів), залишаються "
"фіксованими, поки об’єкт знаходиться в словнику (або іншій структурі). ::"

msgid ""
"Note that the hash computation is complicated by the possibility that some "
"members of the list may be unhashable and also by the possibility of "
"arithmetic overflow."
msgstr ""
"Зверніть увагу, що обчислення хешу ускладнюється можливістю того, що деякі "
"члени списку можуть бути нехешованими, а також можливістю арифметичного "
"переповнення."

msgid ""
"Furthermore it must always be the case that if ``o1 == o2`` (ie ``o1."
"__eq__(o2) is True``) then ``hash(o1) == hash(o2)`` (ie, ``o1.__hash__() == "
"o2.__hash__()``), regardless of whether the object is in a dictionary or "
"not.  If you fail to meet these restrictions dictionaries and other hash "
"based structures will misbehave."
msgstr ""
"Крім того, завжди має бути так, що якщо ``o1 == o2`` (тобто ``o1.__eq__(o2) "
"має значення True``), тоді ``hash(o1) == hash(o2)`` (тобто, ``o1.__hash__() "
"== o2.__hash__()``), незалежно від того, чи є об’єкт у словнику чи ні. Якщо "
"ви не впораєтеся з цими обмеженнями, словники та інші хеш-структури "
"працюватимуть неправильно."

msgid ""
"In the case of ListWrapper, whenever the wrapper object is in a dictionary "
"the wrapped list must not change to avoid anomalies.  Don't do this unless "
"you are prepared to think hard about the requirements and the consequences "
"of not meeting them correctly.  Consider yourself warned."
msgstr ""
"У випадку ListWrapper, щоразу, коли об’єкт-огортка знаходиться в словнику, "
"обгорнутий список не повинен змінюватися, щоб уникнути аномалій. Не робіть "
"цього, якщо ви не готові добре подумати про вимоги та наслідки їх "
"невиконання належним чином. Вважайте, що вас попередили."

msgid "Why doesn't list.sort() return the sorted list?"
msgstr "Чому list.sort() не повертає відсортований список?"

msgid ""
"In situations where performance matters, making a copy of the list just to "
"sort it would be wasteful. Therefore, :meth:`list.sort` sorts the list in "
"place. In order to remind you of that fact, it does not return the sorted "
"list.  This way, you won't be fooled into accidentally overwriting a list "
"when you need a sorted copy but also need to keep the unsorted version "
"around."
msgstr ""
"У ситуаціях, коли продуктивність має значення, створення копії списку лише "
"для його сортування було б марним. Тому :meth:`list.sort` сортує список за "
"місцем. Щоб нагадати вам про цей факт, він не повертає відсортований список. "
"Таким чином, вас не введуть в оману випадковим перезаписом списку, коли вам "
"потрібна відсортована копія, але також потрібно зберегти невідсортовану "
"версію."

msgid ""
"If you want to return a new list, use the built-in :func:`sorted` function "
"instead.  This function creates a new list from a provided iterable, sorts "
"it and returns it.  For example, here's how to iterate over the keys of a "
"dictionary in sorted order::"
msgstr ""
"Якщо ви хочете повернути новий список, скористайтеся вбудованою функцією :"
"func:`sorted`. Ця функція створює новий список із наданого ітератора, сортує "
"його та повертає. Наприклад, ось як виконати ітерацію по ключах словника у "
"відсортованому порядку:"

msgid "How do you specify and enforce an interface spec in Python?"
msgstr "Як визначити та застосувати специфікацію інтерфейсу в Python?"

msgid ""
"An interface specification for a module as provided by languages such as C++ "
"and Java describes the prototypes for the methods and functions of the "
"module.  Many feel that compile-time enforcement of interface specifications "
"helps in the construction of large programs."
msgstr ""
"Специфікація інтерфейсу для модуля, яка надається такими мовами, як C++ і "
"Java, описує прототипи методів і функцій модуля. Багато хто вважає, що "
"примусове виконання специфікацій інтерфейсу під час компіляції допомагає "
"створювати великі програми."

msgid ""
"Python 2.6 adds an :mod:`abc` module that lets you define Abstract Base "
"Classes (ABCs).  You can then use :func:`isinstance` and :func:`issubclass` "
"to check whether an instance or a class implements a particular ABC.  The :"
"mod:`collections.abc` module defines a set of useful ABCs such as :class:"
"`~collections.abc.Iterable`, :class:`~collections.abc.Container`, and :class:"
"`~collections.abc.MutableMapping`."
msgstr ""
"Python 2.6 додає модуль :mod:`abc`, який дозволяє визначати абстрактні "
"базові класи (ABC - Abstract Base Classes ). Потім ви можете "
"використовувати :func:`isinstance` і :func:`issubclass`, щоб перевірити, чи "
"екземпляр або клас певного ABC їх реалізує. Модуль :mod:`collections.abc` "
"визначає набір корисних ABC, таких як :class:`~collections.abc.Iterable`, :"
"class:`~collections.abc.Container` і :class:`~collections. abc."
"MutableMapping`."

msgid ""
"For Python, many of the advantages of interface specifications can be "
"obtained by an appropriate test discipline for components."
msgstr ""
"Для Python багато переваг специфікацій інтерфейсу можна отримати за "
"допомогою відповідного порядку тестування компонентів."

msgid ""
"A good test suite for a module can both provide a regression test and serve "
"as a module interface specification and a set of examples.  Many Python "
"modules can be run as a script to provide a simple \"self test.\"  Even "
"modules which use complex external interfaces can often be tested in "
"isolation using trivial \"stub\" emulations of the external interface.  The :"
"mod:`doctest` and :mod:`unittest` modules or third-party test frameworks can "
"be used to construct exhaustive test suites that exercise every line of code "
"in a module."
msgstr ""
"Хороший набір тестів для модуля може як забезпечити регресійний тест, так і "
"служити специфікацією інтерфейсу модуля та набором прикладів. Багато модулів "
"Python можна запускати як сценарій для забезпечення простого "
"\"самотестування\". Навіть модулі, які використовують складні зовнішні "
"інтерфейси, часто можуть бути протестовані ізольовано за допомогою "
"тривіальних \"заглушок\" емуляції зовнішнього інтерфейсу. Модулі :mod:"
"`doctest` і :mod:`unittest` або сторонні фреймворки тестування можна "
"використовувати для створення вичерпних наборів тестів, які перевіряють "
"кожен рядок коду в модулі."

msgid ""
"An appropriate testing discipline can help build large complex applications "
"in Python as well as having interface specifications would.  In fact, it can "
"be better because an interface specification cannot test certain properties "
"of a program.  For example, the :meth:`append` method is expected to add new "
"elements to the end of some internal list; an interface specification cannot "
"test that your :meth:`append` implementation will actually do this "
"correctly, but it's trivial to check this property in a test suite."
msgstr ""
"Відповідний порядок тестування може допомогти створювати великі складні "
"програми на Python так само, як і специфікації інтерфейсу. Насправді це може "
"бути краще, оскільки специфікація інтерфейсу не може перевірити певні "
"властивості програми. Наприклад, очікується, що метод :meth:`append` додасть "
"нові елементи в кінець деякого внутрішнього списку; специфікація інтерфейсу "
"не може перевірити, чи ваша реалізація :meth:`append` справді зробить це "
"правильно, але перевірити цю властивість у наборі тестів досить просто."

msgid ""
"Writing test suites is very helpful, and you might want to design your code "
"to make it easily tested. One increasingly popular technique, test-driven "
"development, calls for writing parts of the test suite first, before you "
"write any of the actual code.  Of course Python allows you to be sloppy and "
"not write test cases at all."
msgstr ""
"Написання наборів тестів дуже корисно, і ви можете розробити свій код, щоб "
"його було легко перевірити. Одна з технік, що стає все більш популярною, — "
"розробка на основі тестування (TDD - test-driven development)— вимагає "
"спочатку написати частини набору тестів, перш ніж писати будь-який фактичний "
"код. Звичайно, Python дозволяє вам бути неохайними і взагалі не писати тести."

msgid "Why is there no goto?"
msgstr "Чому немає goto?"

msgid ""
"In the 1970s people realized that unrestricted goto could lead to messy "
"\"spaghetti\" code that was hard to understand and revise. In a high-level "
"language, it is also unneeded as long as there are ways to branch (in "
"Python, with ``if`` statements and ``or``, ``and``, and ``if-else`` "
"expressions) and loop (with ``while`` and ``for`` statements, possibly "
"containing ``continue`` and ``break``)."
msgstr ""
"У 1970-х роках люди зрозуміли, що необмежений goto може призвести до "
"безладного \"спагетті\" коду, який важко зрозуміти та переглянути. У мові "
"високого рівня він також непотрібний, якщо є способи розгалуження (у Python "
"з операторами ``if``, ``or``, ``and`` та ``if-else`` вирази) і цикл (з "
"операторами ``while`` і ``for``, можливо, що містять ``continue`` і "
"``break``)."

msgid ""
"One can also use exceptions to provide a \"structured goto\" that works even "
"across function calls.  Many feel that exceptions can conveniently emulate "
"all reasonable uses of the \"go\" or \"goto\" constructs of C, Fortran, and "
"other languages.  For example::"
msgstr ""
"Можна також використовувати винятки, щоб забезпечити \"структурований "
"переход\", який працює навіть при викликах функцій. Багато хто вважає, що "
"винятки можуть зручно імітувати всі розумні використання конструкцій \"go\" "
"або \"goto\" C, Fortran та інших мов. Наприклад::"

msgid ""
"This doesn't allow you to jump into the middle of a loop, but that's usually "
"considered an abuse of goto anyway.  Use sparingly."
msgstr ""
"Це не дозволяє вам переходити в середину циклу, але зазвичай це вважається "
"зловживанням goto. Використовуйте раціонально."

msgid "Why can't raw strings (r-strings) end with a backslash?"
msgstr ""
"Чому необроблені рядки (r-рядки) не можуть закінчуватися зворотною косою "
"рискою?"

msgid ""
"More precisely, they can't end with an odd number of backslashes: the "
"unpaired backslash at the end escapes the closing quote character, leaving "
"an unterminated string."
msgstr ""
"Точніше, вони не можуть закінчуватися непарною кількістю зворотних скісних "
"рисок: непарна зворотна коса риска в кінці виходить із символу закриваючої "
"лапки, залишаючи незакінчений рядок."

msgid ""
"Raw strings were designed to ease creating input for processors (chiefly "
"regular expression engines) that want to do their own backslash escape "
"processing. Such processors consider an unmatched trailing backslash to be "
"an error anyway, so raw strings disallow that.  In return, they allow you to "
"pass on the string quote character by escaping it with a backslash.  These "
"rules work well when r-strings are used for their intended purpose."
msgstr ""
"Необроблені рядки були розроблені, щоб полегшити створення вхідних даних для "
"процесорів (головним чином механізмів регулярних виразів), які хочуть "
"виконувати власну обробку зворотного слеша. Такі процесори в будь-якому "
"випадку вважають невідповідну зворотну косу риску в кінці помилкою, тому "
"необроблені рядки це забороняють. Натомість вони дозволяють вам передати "
"символ лапки рядка, екрануючи його зворотною косою рискою. Ці правила добре "
"працюють, коли r-рядки використовуються за призначенням."

msgid ""
"If you're trying to build Windows pathnames, note that all Windows system "
"calls accept forward slashes too::"
msgstr ""
"Якщо ви намагаєтеся створити імена шляхів Windows, зверніть увагу, що всі "
"системні виклики Windows також приймають косу риску::"

msgid ""
"If you're trying to build a pathname for a DOS command, try e.g. one of ::"
msgstr ""
"Якщо ви намагаєтеся створити шлях для команди DOS, спробуйте, наприклад. "
"один з ::"

msgid "Why doesn't Python have a \"with\" statement for attribute assignments?"
msgstr "Чому в Python немає оператора \"with\" для призначення атрибутів?"

msgid ""
"Python has a 'with' statement that wraps the execution of a block, calling "
"code on the entrance and exit from the block.  Some languages have a "
"construct that looks like this::"
msgstr ""
"У Python є оператор with, який завершує виконання блоку, викликаючи код на "
"вході та виході з блоку. У деяких мовах є конструкція, яка виглядає так:"

msgid "In Python, such a construct would be ambiguous."
msgstr "У Python така конструкція була б неоднозначною."

msgid ""
"Other languages, such as Object Pascal, Delphi, and C++, use static types, "
"so it's possible to know, in an unambiguous way, what member is being "
"assigned to. This is the main point of static typing -- the compiler "
"*always* knows the scope of every variable at compile time."
msgstr ""
"Інші мови, такі як Object Pascal, Delphi та C++, використовують статичні "
"типи, тому можна однозначно знати, якому члену призначено. Це головний "
"момент статичної типізації -- компілятор *завжди* знає область кожної "
"змінної під час компіляції."

msgid ""
"Python uses dynamic types. It is impossible to know in advance which "
"attribute will be referenced at runtime. Member attributes may be added or "
"removed from objects on the fly. This makes it impossible to know, from a "
"simple reading, what attribute is being referenced: a local one, a global "
"one, or a member attribute?"
msgstr ""
"Python використовує динамічні типи. Неможливо знати заздалегідь, на який "
"атрибут буде посилатися під час виконання. Атрибути учасників можна додавати "
"або видаляти з об’єктів на льоту. Це робить неможливим з простого читання "
"дізнатися, на який атрибут посилається: локальний, глобальний чи атрибут-"
"член?"

msgid "For instance, take the following incomplete snippet::"
msgstr "Наприклад, візьмемо наступний неповний фрагмент:"

msgid ""
"The snippet assumes that \"a\" must have a member attribute called \"x\".  "
"However, there is nothing in Python that tells the interpreter this. What "
"should happen if \"a\" is, let us say, an integer?  If there is a global "
"variable named \"x\", will it be used inside the with block?  As you see, "
"the dynamic nature of Python makes such choices much harder."
msgstr ""
"Фрагмент припускає, що \"a\" повинен мати атрибут члена під назвою \"x\". "
"Однак у Python немає нічого, що повідомляє про це інтерпретатору. Що має "
"статися, якщо \"а\" є, скажімо, цілим числом? Якщо існує глобальна змінна з "
"назвою \"x\", чи буде вона використана в блоці with? Як бачите, динамічна "
"природа Python робить такий вибір набагато складнішим."

msgid ""
"The primary benefit of \"with\" and similar language features (reduction of "
"code volume) can, however, easily be achieved in Python by assignment.  "
"Instead of::"
msgstr ""
"Основна перевага \"with\" і подібних функцій мови (зменшення обсягу коду) "
"може бути легко досягнута в Python за допомогою призначення. Замість::"

msgid "write this::"
msgstr "напиши це::"

msgid ""
"This also has the side-effect of increasing execution speed because name "
"bindings are resolved at run-time in Python, and the second version only "
"needs to perform the resolution once."
msgstr ""
"Це також має побічний ефект збільшення швидкості виконання, оскільки "
"прив’язки імен вирішуються під час виконання в Python, а другій версії "
"потрібно виконати розв’язання лише один раз."

msgid "Why don't generators support the with statement?"
msgstr "Чому генератори не підтримують оператор with?"

msgid ""
"For technical reasons, a generator used directly as a context manager would "
"not work correctly.  When, as is most common, a generator is used as an "
"iterator run to completion, no closing is needed.  When it is, wrap it as "
"\"contextlib.closing(generator)\" in the 'with' statement."
msgstr ""
"З технічних причин генератор, який використовується безпосередньо як "
"менеджер контексту, не працюватиме належним чином. Коли, як це найчастіше "
"буває, генератор використовується як ітератор, що виконується до кінця, "
"закриття не потрібне. Коли це так, оберніть його як \"contextlib."
"closing(generator)\" у операторі \"with\"."

msgid "Why are colons required for the if/while/def/class statements?"
msgstr "Чому в операторах if/while/def/class потрібні двокрапки?"

msgid ""
"The colon is required primarily to enhance readability (one of the results "
"of the experimental ABC language).  Consider this::"
msgstr ""
"Двокрапка потрібна насамперед для покращення читабельності (один із "
"результатів експериментальної мови ABC). Розглянемо це::"

msgid "versus ::"
msgstr "проти ::"

msgid ""
"Notice how the second one is slightly easier to read.  Notice further how a "
"colon sets off the example in this FAQ answer; it's a standard usage in "
"English."
msgstr ""
"Зверніть увагу, що другий читається трохи легше. Зверніть увагу на те, як "
"двокрапка виділяє приклад у цій відповіді на поширені запитання; це "
"стандартне використання в англійській мові."

msgid ""
"Another minor reason is that the colon makes it easier for editors with "
"syntax highlighting; they can look for colons to decide when indentation "
"needs to be increased instead of having to do a more elaborate parsing of "
"the program text."
msgstr ""
"Інша незначна причина полягає в тому, що двокрапка полегшує роботу "
"редакторів із підсвічуванням синтаксису; вони можуть шукати двокрапки, щоб "
"вирішити, коли потрібно збільшити відступ, замість того, щоб виконувати "
"більш детальний розбір тексту програми."

msgid "Why does Python allow commas at the end of lists and tuples?"
msgstr "Чому Python допускає коми в кінці списків і кортежів?"

msgid ""
"Python lets you add a trailing comma at the end of lists, tuples, and "
"dictionaries::"
msgstr ""
"Python дозволяє додавати кінцеву кому в кінці списків, кортежів і словників:"

msgid "There are several reasons to allow this."
msgstr "Є кілька причин дозволити це."

msgid ""
"When you have a literal value for a list, tuple, or dictionary spread across "
"multiple lines, it's easier to add more elements because you don't have to "
"remember to add a comma to the previous line.  The lines can also be "
"reordered without creating a syntax error."
msgstr ""
"Коли у вас є літеральне значення для списку, кортежу чи словника, "
"розкиданого на кілька рядків, легше додати більше елементів, оскільки вам не "
"потрібно пам’ятати про додавання коми в попередній рядок. Рядки також можна "
"змінити, не створюючи синтаксичних помилок."

msgid ""
"Accidentally omitting the comma can lead to errors that are hard to "
"diagnose. For example::"
msgstr ""
"Випадковий пропуск коми може призвести до помилок, які важко діагностувати. "
"Наприклад::"

msgid ""
"This list looks like it has four elements, but it actually contains three: "
"\"fee\", \"fiefoo\" and \"fum\".  Always adding the comma avoids this source "
"of error."
msgstr ""
"Цей список виглядає так, ніби він складається з чотирьох елементів, але "
"насправді він містить три: \"fee\", \"fiefoo\" і \"fum\". Постійне додавання "
"коми дозволяє уникнути цього джерела помилки."

msgid ""
"Allowing the trailing comma may also make programmatic code generation "
"easier."
msgstr "Дозвіл кінцевої коми також може полегшити генерацію програмного коду."
