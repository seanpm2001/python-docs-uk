# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Library and Extension FAQ"
msgstr "Поширені запитання про бібліотеку та розширення"

msgid "Contents"
msgstr "Зміст"

msgid "General Library Questions"
msgstr "Загальні бібліотечні питання"

msgid "How do I find a module or application to perform task X?"
msgstr "Як знайти модуль або програму для виконання завдання X?"

msgid ""
"Check :ref:`the Library Reference <library-index>` to see if there's a "
"relevant standard library module.  (Eventually you'll learn what's in the "
"standard library and will be able to skip this step.)"
msgstr ""
"Перевірте :ref:`довідник бібліотеки <library-index>`, щоб побачити, чи є "
"відповідний модуль стандартної бібліотеки. (Згодом ви дізнаєтеся, що "
"міститься в стандартній бібліотеці, і зможете пропустити цей крок.)"

msgid ""
"For third-party packages, search the `Python Package Index <https://pypi."
"org>`_ or try `Google <https://www.google.com>`_ or another web search "
"engine.  Searching for \"Python\" plus a keyword or two for your topic of "
"interest will usually find something helpful."
msgstr ""
"Пакунки сторонніх розробників шукайте в `Python Package Index <https://pypi."
"org>`_ або спробуйте `Google <https://www.google.com>`_ або іншу веб-"
"пошукову систему. Якщо шукати \"Python\" і кілька ключових слів для теми, "
"яка вас цікавить, зазвичай знайдете щось корисне."

msgid "Where is the math.py (socket.py, regex.py, etc.) source file?"
msgstr "Де знаходиться вихідний файл math.py (socket.py, regex.py тощо)?"

msgid ""
"If you can't find a source file for a module it may be a built-in or "
"dynamically loaded module implemented in C, C++ or other compiled language. "
"In this case you may not have the source file or it may be something like :"
"file:`mathmodule.c`, somewhere in a C source directory (not on the Python "
"Path)."
msgstr ""
"Якщо ви не можете знайти вихідний файл для модуля, це може бути вбудований "
"або динамічно завантажуваний модуль, реалізований на C, C++ або іншій "
"скомпільованій мові. У цьому випадку ви можете не мати вихідного файлу або "
"це може бути щось на кшталт :file:`mathmodule.c`, десь у каталозі вихідного "
"коду C (не на шляху Python)."

msgid "There are (at least) three kinds of modules in Python:"
msgstr "У Python є (принаймні) три типи модулів:"

msgid "modules written in Python (.py);"
msgstr "модулі, написані мовою Python (.py);"

msgid ""
"modules written in C and dynamically loaded (.dll, .pyd, .so, .sl, etc);"
msgstr ""
"модулі, написані на C і динамічно завантажуються (.dll, .pyd, .so, .sl тощо);"

msgid ""
"modules written in C and linked with the interpreter; to get a list of "
"these, type::"
msgstr ""
"модулі, написані на C і пов'язані з інтерпретатором; щоб отримати їх список, "
"введіть::"

msgid "How do I make a Python script executable on Unix?"
msgstr "Як зробити сценарій Python виконуваним у Unix?"

msgid ""
"You need to do two things: the script file's mode must be executable and the "
"first line must begin with ``#!`` followed by the path of the Python "
"interpreter."
msgstr ""
"Вам потрібно зробити дві речі: режим файлу сценарію має бути виконуваним, а "
"перший рядок має починатися з ``#!``, за яким слідує шлях інтерпретатора "
"Python."

msgid ""
"The first is done by executing ``chmod +x scriptfile`` or perhaps ``chmod "
"755 scriptfile``."
msgstr ""
"Перший виконується шляхом виконання ``chmod +x scriptfile`` або, можливо, "
"``chmod 755 scriptfile``."

msgid ""
"The second can be done in a number of ways.  The most straightforward way is "
"to write ::"
msgstr ""
"Друге можна зробити кількома способами. Найпростіший спосіб - написати ::"

msgid ""
"as the very first line of your file, using the pathname for where the Python "
"interpreter is installed on your platform."
msgstr ""
"як перший рядок вашого файлу, використовуючи ім’я шляху для того, де на "
"вашій платформі встановлено інтерпретатор Python."

msgid ""
"If you would like the script to be independent of where the Python "
"interpreter lives, you can use the :program:`env` program.  Almost all Unix "
"variants support the following, assuming the Python interpreter is in a "
"directory on the user's :envvar:`PATH`::"
msgstr ""
"Якщо ви бажаєте, щоб сценарій не залежав від місця розташування "
"інтерпретатора Python, ви можете скористатися програмою :program:`env`. "
"Майже всі варіанти Unix підтримують наступне, припускаючи, що інтерпретатор "
"Python знаходиться в каталозі користувача :envvar:`PATH`::"

msgid ""
"*Don't* do this for CGI scripts.  The :envvar:`PATH` variable for CGI "
"scripts is often very minimal, so you need to use the actual absolute "
"pathname of the interpreter."
msgstr ""
"*Не* робіть цього для сценаріїв CGI. Змінна :envvar:`PATH` для сценаріїв CGI "
"часто дуже мінімальна, тому вам потрібно використовувати фактичний "
"абсолютний шлях інтерпретатора."

msgid ""
"Occasionally, a user's environment is so full that the :program:`/usr/bin/"
"env` program fails; or there's no env program at all.  In that case, you can "
"try the following hack (due to Alex Rezinsky):"
msgstr ""
"Іноді середовище користувача настільки переповнене, що програма :program:`/"
"usr/bin/env` дає збій; або взагалі немає програми env. У такому випадку ви "
"можете спробувати наступний хак (завдяки Alex Rezinsky):"

msgid ""
"The minor disadvantage is that this defines the script's __doc__ string. "
"However, you can fix that by adding ::"
msgstr ""
"Незначним недоліком є те, що це визначає рядок __doc__ сценарію. Однак ви "
"можете виправити це, додавши ::"

msgid "Is there a curses/termcap package for Python?"
msgstr "Чи є пакет curses/termcap для Python?"

msgid ""
"For Unix variants: The standard Python source distribution comes with a "
"curses module in the :source:`Modules` subdirectory, though it's not "
"compiled by default. (Note that this is not available in the Windows "
"distribution -- there is no curses module for Windows.)"
msgstr ""
"Для варіантів Unix: Стандартний дистрибутив вихідного коду Python "
"постачається з модулем curses у підкаталозі :source:`Modules`, хоча він не "
"скомпільований за замовчуванням. (Зауважте, що це недоступно в дистрибутиві "
"Windows — для Windows немає модуля curses.)"

msgid ""
"The :mod:`curses` module supports basic curses features as well as many "
"additional functions from ncurses and SYSV curses such as colour, "
"alternative character set support, pads, and mouse support. This means the "
"module isn't compatible with operating systems that only have BSD curses, "
"but there don't seem to be any currently maintained OSes that fall into this "
"category."
msgstr ""
"Модуль :mod:`curses` підтримує базові функції curses, а також багато "
"додаткових функцій від ncurses і curses SYSV, таких як підтримка кольору, "
"альтернативного набору символів, панелей і підтримки миші. Це означає, що "
"модуль не сумісний з операційними системами, які мають лише прокляття BSD, "
"але, здається, на даний момент не існує операційних систем, які підпадають "
"під цю категорію."

msgid "Is there an equivalent to C's onexit() in Python?"
msgstr "Чи є еквівалент onexit() C у Python?"

msgid ""
"The :mod:`atexit` module provides a register function that is similar to "
"C's :c:func:`onexit`."
msgstr ""
"Модуль :mod:`atexit` надає функцію реєстру, подібну до :c:func:`onexit` C."

msgid "Why don't my signal handlers work?"
msgstr "Чому мої обробники сигналів не працюють?"

msgid ""
"The most common problem is that the signal handler is declared with the "
"wrong argument list.  It is called as ::"
msgstr ""
"Найбільш поширеною проблемою є те, що обробник сигналу оголошено з "
"неправильним списком аргументів. Називається як ::"

msgid "so it should be declared with two parameters::"
msgstr "тому його слід оголосити з двома параметрами::"

msgid "Common tasks"
msgstr "Загальні завдання"

msgid "How do I test a Python program or component?"
msgstr "Як перевірити програму або компонент Python?"

msgid ""
"Python comes with two testing frameworks.  The :mod:`doctest` module finds "
"examples in the docstrings for a module and runs them, comparing the output "
"with the expected output given in the docstring."
msgstr ""
"Python постачається з двома платформами тестування. Модуль :mod:`doctest` "
"знаходить приклади в рядках документів для модуля та запускає їх, порівнюючи "
"вихідні дані з очікуваними результатами, указаними в рядках документів."

msgid ""
"The :mod:`unittest` module is a fancier testing framework modelled on Java "
"and Smalltalk testing frameworks."
msgstr ""
"Модуль :mod:`unittest` — це модніша платформа для тестування, змодельована "
"на платформах тестування Java і Smalltalk."

msgid ""
"To make testing easier, you should use good modular design in your program. "
"Your program should have almost all functionality encapsulated in either "
"functions or class methods -- and this sometimes has the surprising and "
"delightful effect of making the program run faster (because local variable "
"accesses are faster than global accesses).  Furthermore the program should "
"avoid depending on mutating global variables, since this makes testing much "
"more difficult to do."
msgstr ""
"Щоб спростити тестування, вам слід використовувати хороший модульний дизайн "
"у вашій програмі. Ваша програма повинна мати майже всю функціональність, "
"інкапсульовану або у функції, або в методи класу - і це іноді має дивовижний "
"і чудовий ефект, прискорюючи роботу програми (оскільки доступ до локальних "
"змінних є швидшим, ніж доступ до глобальних). Крім того, програмі слід "
"уникати залежності від мутації глобальних змінних, оскільки це значно "
"ускладнює виконання тестування."

msgid "The \"global main logic\" of your program may be as simple as ::"
msgstr ""
"\"Глобальна основна логіка\" вашої програми може бути такою ж простою, як:"

msgid "at the bottom of the main module of your program."
msgstr "у нижній частині головного модуля вашої програми."

msgid ""
"Once your program is organized as a tractable collection of function and "
"class behaviours, you should write test functions that exercise the "
"behaviours.  A test suite that automates a sequence of tests can be "
"associated with each module. This sounds like a lot of work, but since "
"Python is so terse and flexible it's surprisingly easy.  You can make coding "
"much more pleasant and fun by writing your test functions in parallel with "
"the \"production code\", since this makes it easy to find bugs and even "
"design flaws earlier."
msgstr ""
"Після того, як ваша програма організована як придатна для читання колекція "
"поведінки функцій і класів, ви повинні написати тестові функції, які "
"реалізують поведінку. З кожним модулем можна пов’язати набір тестів, який "
"автоматизує послідовність тестів. Це звучить як велика робота, але оскільки "
"Python такий стислий і гнучкий, це напрочуд легко. Ви можете зробити "
"кодування набагато приємнішим і веселішим, написавши тестові функції "
"паралельно з \"виробничим кодом\", оскільки це полегшить пошук помилок і "
"навіть недоліків дизайну раніше."

msgid ""
"\"Support modules\" that are not intended to be the main module of a program "
"may include a self-test of the module. ::"
msgstr ""
"\"Модулі підтримки\", які не призначені бути основними модулями програми, "
"можуть включати самотестування модуля. ::"

msgid ""
"Even programs that interact with complex external interfaces may be tested "
"when the external interfaces are unavailable by using \"fake\" interfaces "
"implemented in Python."
msgstr ""
"Навіть програми, які взаємодіють зі складними зовнішніми інтерфейсами, можна "
"перевіряти, коли зовнішні інтерфейси недоступні, використовуючи \"фальшиві\" "
"інтерфейси, реалізовані на Python."

msgid "How do I create documentation from doc strings?"
msgstr "Як створити документацію з рядків документа?"

msgid ""
"The :mod:`pydoc` module can create HTML from the doc strings in your Python "
"source code.  An alternative for creating API documentation purely from "
"docstrings is `epydoc <https://epydoc.sourceforge.net/>`_.  `Sphinx <https://"
"www.sphinx-doc.org>`_ can also include docstring content."
msgstr ""

msgid "How do I get a single keypress at a time?"
msgstr "Як отримати одне натискання клавіші за раз?"

msgid ""
"For Unix variants there are several solutions.  It's straightforward to do "
"this using curses, but curses is a fairly large module to learn."
msgstr ""
"Для варіантів Unix є кілька рішень. Це легко зробити за допомогою curses, "
"але curses — це досить великий модуль для вивчення."

msgid "Threads"
msgstr "Нитки"

msgid "How do I program using threads?"
msgstr "Як програмувати за допомогою потоків?"

msgid ""
"Be sure to use the :mod:`threading` module and not the :mod:`_thread` "
"module. The :mod:`threading` module builds convenient abstractions on top of "
"the low-level primitives provided by the :mod:`_thread` module."
msgstr ""
"Обов’язково використовуйте модуль :mod:`threading`, а не модуль :mod:"
"`_thread`. Модуль :mod:`threading` створює зручні абстракції на основі "
"низькорівневих примітивів, які надає модуль :mod:`_thread`."

msgid "None of my threads seem to run: why?"
msgstr "Здається, жодна з моїх тем не працює: чому?"

msgid ""
"As soon as the main thread exits, all threads are killed.  Your main thread "
"is running too quickly, giving the threads no time to do any work."
msgstr ""
"Як тільки головний потік виходить, усі потоки припиняються. Ваш основний "
"потік працює надто швидко, не даючи потокам часу виконувати будь-яку роботу."

msgid ""
"A simple fix is to add a sleep to the end of the program that's long enough "
"for all the threads to finish::"
msgstr ""
"Простим виправленням є додавання сну до кінця програми, який буде достатнім "
"для завершення всіх потоків:"

msgid ""
"But now (on many platforms) the threads don't run in parallel, but appear to "
"run sequentially, one at a time!  The reason is that the OS thread scheduler "
"doesn't start a new thread until the previous thread is blocked."
msgstr ""
"Але тепер (на багатьох платформах) потоки не працюють паралельно, а, "
"здається, виконуються послідовно, один за одним! Причина полягає в тому, що "
"планувальник потоків ОС не запускає новий потік, доки попередній потік не "
"буде заблоковано."

msgid "A simple fix is to add a tiny sleep to the start of the run function::"
msgstr ""
"Просте виправлення полягає в тому, щоб додати крихітний сон до початку "
"функції запуску:"

msgid ""
"Instead of trying to guess a good delay value for :func:`time.sleep`, it's "
"better to use some kind of semaphore mechanism.  One idea is to use the :mod:"
"`queue` module to create a queue object, let each thread append a token to "
"the queue when it finishes, and let the main thread read as many tokens from "
"the queue as there are threads."
msgstr ""
"Замість того, щоб намагатися вгадати хороше значення затримки для :func:"
"`time.sleep`, краще використати якийсь семафорний механізм. Одна з ідей "
"полягає в тому, щоб використовувати модуль :mod:`queue` для створення "
"об’єкта черги, дозволити кожному потоку додавати маркер до черги, коли він "
"закінчиться, і дозволити основному потоку читати стільки маркерів із черги, "
"скільки є потоків."

msgid "How do I parcel out work among a bunch of worker threads?"
msgstr "Як розділити роботу серед групи робочих потоків?"

msgid ""
"The easiest way is to use the :mod:`concurrent.futures` module, especially "
"the :mod:`~concurrent.futures.ThreadPoolExecutor` class."
msgstr ""
"Найпростішим способом є використання модуля :mod:`concurrent.futures`, "
"особливо класу :mod:`~concurrent.futures.ThreadPoolExecutor`."

msgid ""
"Or, if you want fine control over the dispatching algorithm, you can write "
"your own logic manually.  Use the :mod:`queue` module to create a queue "
"containing a list of jobs.  The :class:`~queue.Queue` class maintains a list "
"of objects and has a ``.put(obj)`` method that adds items to the queue and a "
"``.get()`` method to return them.  The class will take care of the locking "
"necessary to ensure that each job is handed out exactly once."
msgstr ""
"Або, якщо вам потрібен точний контроль над алгоритмом диспетчеризації, ви "
"можете написати власну логіку вручну. Використовуйте модуль :mod:`queue`, "
"щоб створити чергу зі списком завдань. Клас :class:`~queue.Queue` підтримує "
"список об’єктів і має метод ``.put(obj)``, який додає елементи до черги, і "
"метод ``.get()`` для їх повернення. Клас подбає про блокування, необхідне "
"для того, щоб кожне завдання було роздано рівно один раз."

msgid "Here's a trivial example::"
msgstr "Ось тривіальний приклад::"

msgid "When run, this will produce the following output:"
msgstr "Під час запуску це створить такий результат:"

msgid ""
"Consult the module's documentation for more details; the :class:`~queue."
"Queue` class provides a featureful interface."
msgstr ""
"Щоб дізнатися більше, зверніться до документації модуля; клас :class:`~queue."
"Queue` забезпечує зручний інтерфейс."

msgid "What kinds of global value mutation are thread-safe?"
msgstr "Які види глобальної мутації значення є потокобезпечними?"

msgid ""
"A :term:`global interpreter lock` (GIL) is used internally to ensure that "
"only one thread runs in the Python VM at a time.  In general, Python offers "
"to switch among threads only between bytecode instructions; how frequently "
"it switches can be set via :func:`sys.setswitchinterval`.  Each bytecode "
"instruction and therefore all the C implementation code reached from each "
"instruction is therefore atomic from the point of view of a Python program."
msgstr ""
":term:`global interpreter lock` (GIL) використовується внутрішньо, щоб "
"забезпечити виконання лише одного потоку у віртуальній машині Python "
"одночасно. Загалом, Python пропонує перемикатися між потоками лише між "
"інструкціями байт-коду; як часто він перемикається, можна встановити через :"
"func:`sys.setswitchinterval`. Кожна інструкція байт-коду і, отже, весь код "
"реалізації C, отриманий від кожної інструкції, є атомарними з точки зору "
"програми Python."

msgid ""
"In theory, this means an exact accounting requires an exact understanding of "
"the PVM bytecode implementation.  In practice, it means that operations on "
"shared variables of built-in data types (ints, lists, dicts, etc) that "
"\"look atomic\" really are."
msgstr ""
"Теоретично це означає, що точний облік вимагає точного розуміння реалізації "
"байт-коду PVM. На практиці це означає, що операції зі спільними змінними "
"вбудованих типів даних (int, списки, dicts тощо), які \"виглядають "
"атомарними\", дійсно є такими."

msgid ""
"For example, the following operations are all atomic (L, L1, L2 are lists, "
"D, D1, D2 are dicts, x, y are objects, i, j are ints)::"
msgstr ""
"Наприклад, усі наступні операції є атомарними (L, L1, L2 — списки, D, D1, D2 "
"— dicts, x, y — об’єкти, i, j — цілі):"

msgid "These aren't::"
msgstr "Це не::"

msgid ""
"Operations that replace other objects may invoke those other objects' :meth:"
"`__del__` method when their reference count reaches zero, and that can "
"affect things.  This is especially true for the mass updates to dictionaries "
"and lists.  When in doubt, use a mutex!"
msgstr ""
"Операції, які замінюють інші об’єкти, можуть викликати метод :meth:`__del__` "
"цих інших об’єктів, коли кількість посилань досягає нуля, і це може вплинути "
"на речі. Особливо це стосується масових оновлень словників і списків. Якщо "
"сумніваєтеся, використовуйте м'ютекс!"

msgid "Can't we get rid of the Global Interpreter Lock?"
msgstr "Чи не можемо ми позбутися глобального блокування інтерпретатора?"

msgid ""
"The :term:`global interpreter lock` (GIL) is often seen as a hindrance to "
"Python's deployment on high-end multiprocessor server machines, because a "
"multi-threaded Python program effectively only uses one CPU, due to the "
"insistence that (almost) all Python code can only run while the GIL is held."
msgstr ""
":term:`global interpreter lock` (GIL) часто розглядається як перешкода для "
"розгортання Python на високоякісних багатопроцесорних серверах, оскільки "
"багатопотокова програма Python фактично використовує лише один ЦП, через те, "
"що (майже) весь код Python може виконуватися лише під час утримання GIL."

msgid ""
"Back in the days of Python 1.5, Greg Stein actually implemented a "
"comprehensive patch set (the \"free threading\" patches) that removed the "
"GIL and replaced it with fine-grained locking.  Adam Olsen recently did a "
"similar experiment in his `python-safethread <https://code.google.com/"
"archive/p/python-safethread>`_ project.  Unfortunately, both experiments "
"exhibited a sharp drop in single-thread performance (at least 30% slower), "
"due to the amount of fine-grained locking necessary to compensate for the "
"removal of the GIL."
msgstr ""
"Ще за часів Python 1.5 Грег Стайн фактично реалізував повний набір патчів "
"(патчів \"безкоштовних потоків\"), які видалили GIL і замінили його дрібним "
"блокуванням. Адам Олсен нещодавно провів подібний експеримент у своєму "
"проекті `python-safethread <https://code.google.com/archive/p/python-"
"safethread>`_. На жаль, обидва експерименти продемонстрували різке зниження "
"продуктивності одного потоку (принаймні на 30% повільніше) через кількість "
"дрібнозернистого блокування, необхідного для компенсації видалення GIL."

msgid ""
"This doesn't mean that you can't make good use of Python on multi-CPU "
"machines! You just have to be creative with dividing the work up between "
"multiple *processes* rather than multiple *threads*.  The :class:"
"`~concurrent.futures.ProcessPoolExecutor` class in the new :mod:`concurrent."
"futures` module provides an easy way of doing so; the :mod:`multiprocessing` "
"module provides a lower-level API in case you want more control over "
"dispatching of tasks."
msgstr ""
"Це не означає, що ви не можете ефективно використовувати Python на "
"багатопроцесорних машинах! Вам просто потрібно бути творчим, розподіляючи "
"роботу між кількома *процесами*, а не кількома *потоками*. Клас :class:"
"`~concurrent.futures.ProcessPoolExecutor` у новому модулі :mod:`concurrent."
"futures` забезпечує простий спосіб зробити це; Модуль :mod:`multiprocessing` "
"надає API нижчого рівня, якщо вам потрібен більший контроль над "
"диспетчеризацією завдань."

msgid ""
"Judicious use of C extensions will also help; if you use a C extension to "
"perform a time-consuming task, the extension can release the GIL while the "
"thread of execution is in the C code and allow other threads to get some "
"work done.  Some standard library modules such as :mod:`zlib` and :mod:"
"`hashlib` already do this."
msgstr ""
"Розумне використання розширень C також допоможе; якщо ви використовуєте "
"розширення C для виконання трудомісткого завдання, розширення може звільнити "
"GIL, поки потік виконання знаходиться в коді C, і дозволить іншим потокам "
"виконати певну роботу. Деякі стандартні бібліотечні модулі, такі як :mod:"
"`zlib` і :mod:`hashlib`, вже це роблять."

msgid ""
"It has been suggested that the GIL should be a per-interpreter-state lock "
"rather than truly global; interpreters then wouldn't be able to share "
"objects. Unfortunately, this isn't likely to happen either.  It would be a "
"tremendous amount of work, because many object implementations currently "
"have global state. For example, small integers and short strings are cached; "
"these caches would have to be moved to the interpreter state.  Other object "
"types have their own free list; these free lists would have to be moved to "
"the interpreter state. And so on."
msgstr ""
"Було запропоновано, щоб GIL був блокуванням стану для кожного "
"інтерпретатора, а не справді глобальним; інтерпретатори тоді не зможуть "
"ділитися об’єктами. На жаль, це теж навряд чи станеться. Це було б "
"величезним обсягом роботи, оскільки багато реалізацій об’єктів зараз мають "
"глобальний стан. Наприклад, малі цілі числа та короткі рядки кешуються; ці "
"кеші потрібно було б перемістити в стан інтерпретатора. Інші типи об'єктів "
"мають власний вільний список; ці вільні списки потрібно було б перемістити в "
"стан інтерпретатора. І так далі."

msgid ""
"And I doubt that it can even be done in finite time, because the same "
"problem exists for 3rd party extensions.  It is likely that 3rd party "
"extensions are being written at a faster rate than you can convert them to "
"store all their global state in the interpreter state."
msgstr ""
"І я сумніваюся, що це навіть можна зробити за скінченний час, тому що та "
"сама проблема існує для сторонніх розширень. Цілком ймовірно, що розширення "
"сторонніх розробників пишуться швидше, ніж ви можете перетворити їх, щоб "
"зберігати весь їхній глобальний стан у стані інтерпретатора."

msgid ""
"And finally, once you have multiple interpreters not sharing any state, what "
"have you gained over running each interpreter in a separate process?"
msgstr ""
"І, нарешті, коли у вас є кілька інтерпретаторів, які не мають спільного "
"стану, що ви отримуєте від запуску кожного інтерпретатора в окремому процесі?"

msgid "Input and Output"
msgstr "Вхід і вихід"

msgid "How do I delete a file? (And other file questions...)"
msgstr "Як видалити файл? (І інші запитання щодо файлів...)"

msgid ""
"Use ``os.remove(filename)`` or ``os.unlink(filename)``; for documentation, "
"see the :mod:`os` module.  The two functions are identical; :func:`~os."
"unlink` is simply the name of the Unix system call for this function."
msgstr ""
"Використовуйте ``os.remove(ім’я файлу)`` або ``os.unlink(ім’я файлу)``; для "
"документації дивіться модуль :mod:`os`. Дві функції ідентичні; :func:`~os."
"unlink` — це просто назва системного виклику Unix для цієї функції."

msgid ""
"To remove a directory, use :func:`os.rmdir`; use :func:`os.mkdir` to create "
"one. ``os.makedirs(path)`` will create any intermediate directories in "
"``path`` that don't exist. ``os.removedirs(path)`` will remove intermediate "
"directories as long as they're empty; if you want to delete an entire "
"directory tree and its contents, use :func:`shutil.rmtree`."
msgstr ""
"Щоб видалити каталог, використовуйте :func:`os.rmdir`; використовуйте :func:"
"`os.mkdir`, щоб створити його. ``os.makedirs(path)`` створить будь-які "
"проміжні каталоги в ``path``, яких не існує. ``os.removedirs(path)`` "
"видалить проміжні каталоги, якщо вони порожні; якщо ви хочете видалити ціле "
"дерево каталогів і його вміст, використовуйте :func:`shutil.rmtree`."

msgid "To rename a file, use ``os.rename(old_path, new_path)``."
msgstr ""
"Щоб перейменувати файл, використовуйте ``os.rename(old_path, new_path)``."

msgid ""
"To truncate a file, open it using ``f = open(filename, \"rb+\")``, and use "
"``f.truncate(offset)``; offset defaults to the current seek position.  "
"There's also ``os.ftruncate(fd, offset)`` for files opened with :func:`os."
"open`, where *fd* is the file descriptor (a small integer)."
msgstr ""
"Щоб скоротити файл, відкрийте його за допомогою ``f = open(filename, \"rb+"
"\")`` і використовуйте ``f.truncate(offset)``; offset за замовчуванням до "
"поточної позиції пошуку. Існує також ``os.ftruncate(fd, offset)`` для "
"файлів, відкритих за допомогою :func:`os.open`, де *fd* є дескриптором файлу "
"(мале ціле число)."

msgid ""
"The :mod:`shutil` module also contains a number of functions to work on "
"files including :func:`~shutil.copyfile`, :func:`~shutil.copytree`, and :"
"func:`~shutil.rmtree`."
msgstr ""
"Модуль :mod:`shutil` також містить ряд функцій для роботи з файлами, "
"включаючи :func:`~shutil.copyfile`, :func:`~shutil.copytree` і :func:"
"`~shutil.rmtree`."

msgid "How do I copy a file?"
msgstr "Як скопіювати файл?"

msgid ""
"The :mod:`shutil` module contains a :func:`~shutil.copyfile` function. Note "
"that on Windows NTFS volumes, it does not copy `alternate data streams "
"<https://en.wikipedia.org/wiki/NTFS#Alternate_data_stream_(ADS)>`_ nor "
"`resource forks <https://en.wikipedia.org/wiki/Resource_fork>`__ on macOS "
"HFS+ volumes, though both are now rarely used. It also doesn't copy file "
"permissions and metadata, though using :func:`shutil.copy2` instead will "
"preserve most (though not all) of it."
msgstr ""
"Модуль :mod:`shutil` містить функцію :func:`~shutil.copyfile`. Зауважте, що "
"на томах Windows NTFS він не копіює `альтернативні потоки даних <https://en."
"wikipedia.org/wiki/NTFS#Alternate_data_stream_(ADS)>`_ і `розгалуження "
"ресурсів <https://en.wikipedia.org/wiki/Resource_fork>`__ на томах macOS "
"HFS+, хоча обидва зараз використовуються рідко. Він також не копіює дозволи "
"на файли та метадані, хоча використання натомість :func:`shutil.copy2` "
"збереже більшість (хоча не всі) з них."

msgid "How do I read (or write) binary data?"
msgstr "Як читати (або записувати) двійкові дані?"

msgid ""
"To read or write complex binary data formats, it's best to use the :mod:"
"`struct` module.  It allows you to take a string containing binary data "
"(usually numbers) and convert it to Python objects; and vice versa."
msgstr ""
"Для читання або запису складних двійкових форматів даних найкраще "
"використовувати модуль :mod:`struct`. Це дозволяє вам взяти рядок, що "
"містить двійкові дані (зазвичай числа), і перетворити його на об’єкти "
"Python; і навпаки."

msgid ""
"For example, the following code reads two 2-byte integers and one 4-byte "
"integer in big-endian format from a file::"
msgstr ""
"Наприклад, наступний код читає два 2-байтових цілих числа та одне 4-байтове "
"ціле число у форматі big-endian з файлу::"

msgid ""
"The '>' in the format string forces big-endian data; the letter 'h' reads "
"one \"short integer\" (2 bytes), and 'l' reads one \"long integer\" (4 "
"bytes) from the string."
msgstr ""
"Знак \">\" у рядку формату примусово вводить дані в бік старшого; літера 'h' "
"читає одне \"коротке ціле число\" (2 байти), а 'l' читає одне \"довге ціле "
"число\" (4 байти) з рядка."

msgid ""
"For data that is more regular (e.g. a homogeneous list of ints or floats), "
"you can also use the :mod:`array` module."
msgstr ""
"Для даних, які є більш регулярними (наприклад, однорідний список int або "
"float), ви також можете використовувати модуль :mod:`array`."

msgid ""
"To read and write binary data, it is mandatory to open the file in binary "
"mode (here, passing ``\"rb\"`` to :func:`open`).  If you use ``\"r\"`` "
"instead (the default), the file will be open in text mode and ``f.read()`` "
"will return :class:`str` objects rather than :class:`bytes` objects."
msgstr ""
"Щоб читати та записувати двійкові дані, необхідно відкрити файл у двійковому "
"режимі (тут передаючи ``\"rb\"`` до :func:`open`). Якщо замість цього "
"використовувати ``\"r\"`` (за замовчуванням), файл буде відкритий у "
"текстовому режимі, а ``f.read()`` повертатиме об’єкти :class:`str`, а не :"
"class:`bytes` об'єктів."

msgid "I can't seem to use os.read() on a pipe created with os.popen(); why?"
msgstr ""
"Здається, я не можу використовувати os.read() у каналі, створеному за "
"допомогою os.popen(); чому?"

msgid ""
":func:`os.read` is a low-level function which takes a file descriptor, a "
"small integer representing the opened file.  :func:`os.popen` creates a high-"
"level file object, the same type returned by the built-in :func:`open` "
"function. Thus, to read *n* bytes from a pipe *p* created with :func:`os."
"popen`, you need to use ``p.read(n)``."
msgstr ""
":func:`os.read` — це функція низького рівня, яка приймає дескриптор файлу, "
"маленьке ціле число, що представляє відкритий файл. :func:`os.popen` створює "
"об’єкт файлу високого рівня, того самого типу, який повертає вбудована "
"функція :func:`open`. Таким чином, щоб прочитати *n* байт з каналу *p*, "
"створеного за допомогою :func:`os.popen`, вам потрібно використовувати ``p."
"read(n)``."

msgid "How do I access the serial (RS232) port?"
msgstr "Як отримати доступ до послідовного (RS232) порту?"

msgid "For Win32, OSX, Linux, BSD, Jython, IronPython:"
msgstr "Для Win32, OSX, Linux, BSD, Jython, IronPython:"

msgid "https://pypi.org/project/pyserial/"
msgstr "https://pypi.org/project/pyserial/"

msgid "For Unix, see a Usenet post by Mitch Chapman:"
msgstr "Щодо Unix, перегляньте публікацію Usenet від Мітча Чепмена:"

msgid "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"
msgstr "https://groups.google.com/groups?selm=34A04430.CF9@ohioee.com"

msgid "Why doesn't closing sys.stdout (stdin, stderr) really close it?"
msgstr "Чому закриття sys.stdout (stdin, stderr) насправді не закриває його?"

msgid ""
"Python :term:`file objects <file object>` are a high-level layer of "
"abstraction on low-level C file descriptors."
msgstr ""
"Python :term:`файлові об’єкти <file object>` є високорівневим рівнем "
"абстракції на низькорівневих файлових дескрипторах C."

msgid ""
"For most file objects you create in Python via the built-in :func:`open` "
"function, ``f.close()`` marks the Python file object as being closed from "
"Python's point of view, and also arranges to close the underlying C file "
"descriptor.  This also happens automatically in ``f``'s destructor, when "
"``f`` becomes garbage."
msgstr ""
"Для більшості файлових об’єктів, які ви створюєте в Python за допомогою "
"вбудованої функції :func:`open`, ``f.close()`` позначає файловий об’єкт "
"Python як закритий з точки зору Python, а також організовує закриття базовий "
"дескриптор файлу C. Це також відбувається автоматично в деструкторі ``f``, "
"коли ``f`` стає сміттям."

msgid ""
"But stdin, stdout and stderr are treated specially by Python, because of the "
"special status also given to them by C.  Running ``sys.stdout.close()`` "
"marks the Python-level file object as being closed, but does *not* close the "
"associated C file descriptor."
msgstr ""
"Але stdin, stdout і stderr спеціально обробляються Python через особливий "
"статус, наданий їм також C. Запуск ``sys.stdout.close()`` позначає файловий "
"об’єкт на рівні Python як закритий, але *не* закривати пов’язаний дескриптор "
"файлу C."

msgid ""
"To close the underlying C file descriptor for one of these three, you should "
"first be sure that's what you really want to do (e.g., you may confuse "
"extension modules trying to do I/O).  If it is, use :func:`os.close`::"
msgstr ""
"Щоб закрити базовий дескриптор файлу C для одного з цих трьох, ви повинні "
"спочатку переконатися, що це те, що ви дійсно хочете зробити (наприклад, ви "
"можете сплутати модулі розширення, які намагаються виконати введення-"
"виведення). Якщо так, використовуйте :func:`os.close`::"

msgid "Or you can use the numeric constants 0, 1 and 2, respectively."
msgstr "Або ви можете використовувати числові константи 0, 1 і 2 відповідно."

msgid "Network/Internet Programming"
msgstr "Програмування мережі/Інтернету"

msgid "What WWW tools are there for Python?"
msgstr "Які інструменти WWW існують для Python?"

msgid ""
"See the chapters titled :ref:`internet` and :ref:`netdata` in the Library "
"Reference Manual.  Python has many modules that will help you build server-"
"side and client-side web systems."
msgstr ""
"Див. розділи під назвою :ref:`internet` і :ref:`netdata` у Довідковому "
"посібнику з бібліотеки. Python має багато модулів, які допоможуть вам "
"створювати серверні та клієнтські веб-системи."

msgid ""
"A summary of available frameworks is maintained by Paul Boddie at https://"
"wiki.python.org/moin/WebProgramming\\ ."
msgstr ""
"Резюме доступних фреймворків підтримує Пол Бодді на https://wiki.python.org/"
"moin/WebProgramming\\ ."

msgid ""
"Cameron Laird maintains a useful set of pages about Python web technologies "
"at https://web.archive.org/web/20210224183619/http://phaseit.net/claird/comp."
"lang.python/web_python."
msgstr ""

msgid "How can I mimic CGI form submission (METHOD=POST)?"
msgstr "Як я можу імітувати надсилання форми CGI (METHOD=POST)?"

msgid ""
"I would like to retrieve web pages that are the result of POSTing a form. Is "
"there existing code that would let me do this easily?"
msgstr ""
"Я хотів би отримати веб-сторінки, які є результатом розміщення форми POST. "
"Чи є існуючий код, який дозволив би мені легко це зробити?"

msgid "Yes. Here's a simple example that uses :mod:`urllib.request`::"
msgstr "Так. Ось простий приклад використання :mod:`urllib.request`::"

msgid ""
"Note that in general for percent-encoded POST operations, query strings must "
"be quoted using :func:`urllib.parse.urlencode`.  For example, to send "
"``name=Guy Steele, Jr.``::"
msgstr ""
"Зверніть увагу, що загалом для операцій POST із відсотковим кодуванням рядки "
"запиту мають бути взяті в лапки за допомогою :func:`urllib.parse.urlencode`. "
"Наприклад, щоб надіслати ``name=Guy Steele, Jr.``::"

msgid ":ref:`urllib-howto` for extensive examples."
msgstr ":ref:`urllib-howto` для докладних прикладів."

msgid "What module should I use to help with generating HTML?"
msgstr "Який модуль мені слід використовувати для створення HTML?"

msgid ""
"You can find a collection of useful links on the `Web Programming wiki page "
"<https://wiki.python.org/moin/WebProgramming>`_."
msgstr ""
"Ви можете знайти колекцію корисних посилань на `Вікі-сторінці веб-"
"програмування <https://wiki.python.org/moin/WebProgramming>`_."

msgid "How do I send mail from a Python script?"
msgstr "Як надіслати пошту за допомогою сценарію Python?"

msgid "Use the standard library module :mod:`smtplib`."
msgstr "Використовуйте стандартний бібліотечний модуль :mod:`smtplib`."

msgid ""
"Here's a very simple interactive mail sender that uses it.  This method will "
"work on any host that supports an SMTP listener. ::"
msgstr ""
"Ось дуже простий інтерактивний відправник пошти, який його використовує. Цей "
"метод працюватиме на будь-якому хості, який підтримує прослуховувач SMTP. ::"

msgid ""
"A Unix-only alternative uses sendmail.  The location of the sendmail program "
"varies between systems; sometimes it is ``/usr/lib/sendmail``, sometimes ``/"
"usr/sbin/sendmail``.  The sendmail manual page will help you out.  Here's "
"some sample code::"
msgstr ""
"Альтернатива лише для Unix використовує sendmail. Розташування програми "
"sendmail залежить від системи; іноді це ``/usr/lib/sendmail``, іноді ``/usr/"
"sbin/sendmail``. Довідкова сторінка sendmail допоможе вам. Ось приклад коду::"

msgid "How do I avoid blocking in the connect() method of a socket?"
msgstr "Як уникнути блокування в методі connect() сокета?"

msgid ""
"The :mod:`select` module is commonly used to help with asynchronous I/O on "
"sockets."
msgstr ""
"Модуль :mod:`select` зазвичай використовується для допомоги з асинхронним "
"введенням/виведенням на сокетах."

msgid ""
"To prevent the TCP connect from blocking, you can set the socket to non-"
"blocking mode.  Then when you do the :meth:`socket.connect`, you will either "
"connect immediately (unlikely) or get an exception that contains the error "
"number as ``.errno``. ``errno.EINPROGRESS`` indicates that the connection is "
"in progress, but hasn't finished yet.  Different OSes will return different "
"values, so you're going to have to check what's returned on your system."
msgstr ""
"Щоб запобігти блокуванню підключення TCP, ви можете встановити для сокета "
"неблокуючий режим. Тоді, коли ви виконуєте :meth:`socket.connect`, ви або "
"підключитеся негайно (навряд чи), або отримаєте виняток, який містить номер "
"помилки як ``.errno``. ``errno.EINPROGRESS`` вказує на те, що підключення "
"триває, але ще не завершено. Різні ОС повертатимуть різні значення, тому вам "
"доведеться перевірити, що повертає ваша система."

msgid ""
"You can use the :meth:`socket.connect_ex` method to avoid creating an "
"exception.  It will just return the errno value.  To poll, you can call :"
"meth:`socket.connect_ex` again later -- ``0`` or ``errno.EISCONN`` indicate "
"that you're connected -- or you can pass this socket to :meth:`select."
"select` to check if it's writable."
msgstr ""
"Ви можете використовувати метод :meth:`socket.connect_ex`, щоб уникнути "
"створення винятку. Він просто поверне значення errno. Щоб провести "
"опитування, ви можете пізніше знову викликати :meth:`socket.connect_ex` -- "
"``0`` або ``errno.EISCONN`` вказують на те, що ви підключені -- або ви "
"можете передати цей сокет :meth:`select.select`, щоб перевірити, чи "
"доступний він для запису."

msgid ""
"The :mod:`asyncio` module provides a general purpose single-threaded and "
"concurrent asynchronous library, which can be used for writing non-blocking "
"network code. The third-party `Twisted <https://twistedmatrix.com/trac/>`_ "
"library is a popular and feature-rich alternative."
msgstr ""
"Модуль :mod:`asyncio` надає однопотокову та однопотокову асинхронну "
"бібліотеку загального призначення, яку можна використовувати для написання "
"неблокуючого мережевого коду. Стороння бібліотека `Twisted <https://"
"twistedmatrix.com/trac/>`_ є популярною та багатофункціональною "
"альтернативою."

msgid "Databases"
msgstr "Бази даних"

msgid "Are there any interfaces to database packages in Python?"
msgstr "Чи існують інтерфейси для пакетів баз даних у Python?"

msgid "Yes."
msgstr "Так."

msgid ""
"Interfaces to disk-based hashes such as :mod:`DBM <dbm.ndbm>` and :mod:`GDBM "
"<dbm.gnu>` are also included with standard Python.  There is also the :mod:"
"`sqlite3` module, which provides a lightweight disk-based relational "
"database."
msgstr ""
"Інтерфейси для дискових хешів, таких як :mod:`DBM <dbm.ndbm>` і :mod:`GDBM "
"<dbm.gnu>`, також включені в стандартний Python. Існує також модуль :mod:"
"`sqlite3`, який забезпечує полегшену дискову реляційну базу даних."

msgid ""
"Support for most relational databases is available.  See the "
"`DatabaseProgramming wiki page <https://wiki.python.org/moin/"
"DatabaseProgramming>`_ for details."
msgstr ""
"Доступна підтримка більшості реляційних баз даних. Перегляньте "
"`DatabaseProgramming вікі-сторінку <https://wiki.python.org/moin/"
"DatabaseProgramming>`_ для отримання додаткової інформації."

msgid "How do you implement persistent objects in Python?"
msgstr "Як реалізувати постійні об’єкти в Python?"

msgid ""
"The :mod:`pickle` library module solves this in a very general way (though "
"you still can't store things like open files, sockets or windows), and the :"
"mod:`shelve` library module uses pickle and (g)dbm to create persistent "
"mappings containing arbitrary Python objects."
msgstr ""
"Модуль бібліотеки :mod:`pickle` вирішує це у дуже загальний спосіб (хоча ви "
"все одно не можете зберігати такі речі, як відкриті файли, сокети чи вікна), "
"а модуль бібліотеки :mod:`shelve` використовує pickle і (g) dbm для "
"створення постійних відображень, що містять довільні об’єкти Python."

msgid "Mathematics and Numerics"
msgstr "Математика та цифри"

msgid "How do I generate random numbers in Python?"
msgstr "Як генерувати випадкові числа в Python?"

msgid ""
"The standard module :mod:`random` implements a random number generator.  "
"Usage is simple::"
msgstr ""
"Стандартний модуль :mod:`random` реалізує генератор випадкових чисел. "
"Використання просте::"

msgid "This returns a random floating point number in the range [0, 1)."
msgstr "Це повертає випадкове число з плаваючою комою в діапазоні [0, 1)."

msgid ""
"There are also many other specialized generators in this module, such as:"
msgstr ""
"У цьому модулі також є багато інших спеціалізованих генераторів, таких як:"

msgid "``randrange(a, b)`` chooses an integer in the range [a, b)."
msgstr "``randrange(a, b)`` вибирає ціле число в діапазоні [a, b)."

msgid "``uniform(a, b)`` chooses a floating point number in the range [a, b)."
msgstr "``uniform(a, b)`` вибирає число з плаваючою комою в діапазоні [a, b)."

msgid ""
"``normalvariate(mean, sdev)`` samples the normal (Gaussian) distribution."
msgstr ""
"``normalvariate(mean, sdev)`` вибірка нормального (гауссового) розподілу."

msgid "Some higher-level functions operate on sequences directly, such as:"
msgstr ""
"Деякі функції вищого рівня працюють безпосередньо з послідовностями, "
"наприклад:"

msgid "``choice(S)`` chooses a random element from a given sequence."
msgstr "``choice(S)`` вибирає випадковий елемент із заданої послідовності."

msgid "``shuffle(L)`` shuffles a list in-place, i.e. permutes it randomly."
msgstr ""
"``shuffle(L)`` перемішує список на місці, тобто переставляє його випадковим "
"чином."

msgid ""
"There's also a ``Random`` class you can instantiate to create independent "
"multiple random number generators."
msgstr ""
"Існує також клас ``Random``, який можна створити для створення незалежних "
"кількох генераторів випадкових чисел."
