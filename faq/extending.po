# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
# Vadim Kashirny, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:52+0000\n"
"Last-Translator: Vadim Kashirny, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Extending/Embedding FAQ"
msgstr "Поширені запитання про розширення/вбудовування"

msgid "Contents"
msgstr "Зміст"

msgid "Can I create my own functions in C?"
msgstr "Чи можу я створювати власні функції на C?"

msgid ""
"Yes, you can create built-in modules containing functions, variables, "
"exceptions and even new types in C.  This is explained in the document :ref:"
"`extending-index`."
msgstr ""
"Так, у C можна створювати вбудовані модулі, що містять функції, змінні, "
"винятки та навіть нові типи. Це пояснюється в документі :ref:`extending-"
"index`."

msgid "Most intermediate or advanced Python books will also cover this topic."
msgstr ""
"Більшість книжок про Python середнього та просунутого рівня також охоплюють "
"цю тему."

msgid "Can I create my own functions in C++?"
msgstr "Чи можу я створювати власні функції на C++?"

msgid ""
"Yes, using the C compatibility features found in C++.  Place ``extern "
"\"C\" { ... }`` around the Python include files and put ``extern \"C\"`` "
"before each function that is going to be called by the Python interpreter.  "
"Global or static C++ objects with constructors are probably not a good idea."
msgstr ""
"Так, використовуючи функції сумісності з C, наявні в C++. Розмістіть "
"``extern \"C\" { ... }`` навколо файлів включення Python і поставте ``extern "
"\"C\"`` перед кожною функцією, яку буде викликати інтерпретатор Python. "
"Глобальні чи статичні об’єкти C++ із конструкторами, мабуть, не є гарною "
"ідеєю."

msgid "Writing C is hard; are there any alternatives?"
msgstr "Писати С важко; є якісь альтернативи?"

msgid ""
"There are a number of alternatives to writing your own C extensions, "
"depending on what you're trying to do."
msgstr ""
"Існує кілька альтернатив написанню власних розширень C, залежно від того, що "
"ви намагаєтеся зробити."

msgid ""
"`Cython <https://cython.org>`_ and its relative `Pyrex <https://www.cosc."
"canterbury.ac.nz/greg.ewing/python/Pyrex/>`_ are compilers that accept a "
"slightly modified form of Python and generate the corresponding C code.  "
"Cython and Pyrex make it possible to write an extension without having to "
"learn Python's C API."
msgstr ""

msgid ""
"If you need to interface to some C or C++ library for which no Python "
"extension currently exists, you can try wrapping the library's data types "
"and functions with a tool such as `SWIG <https://www.swig.org>`_.  `SIP "
"<https://riverbankcomputing.com/software/sip/intro>`__, `CXX <https://cxx."
"sourceforge.net/>`_ `Boost <https://www.boost.org/libs/python/doc/index."
"html>`_, or `Weave <https://github.com/scipy/weave>`_ are also alternatives "
"for wrapping C++ libraries."
msgstr ""

msgid "How can I execute arbitrary Python statements from C?"
msgstr "Як я можу виконати довільні оператори Python із C?"

msgid ""
"The highest-level function to do this is :c:func:`PyRun_SimpleString` which "
"takes a single string argument to be executed in the context of the module "
"``__main__`` and returns ``0`` for success and ``-1`` when an exception "
"occurred (including :exc:`SyntaxError`).  If you want more control, use :c:"
"func:`PyRun_String`; see the source for :c:func:`PyRun_SimpleString` in "
"``Python/pythonrun.c``."
msgstr ""
"Функція найвищого рівня для цього — :c:func:`PyRun_SimpleString`, яка "
"приймає один рядковий аргумент для виконання в контексті модуля ``__main__`` "
"і повертає ``0`` для успіху та ``- 1``, коли стався виняток (включаючи :exc:"
"`SyntaxError`). Якщо вам потрібен більше контролю, використовуйте :c:func:"
"`PyRun_String`; див. джерело для :c:func:`PyRun_SimpleString` у ``Python/"
"pythonrun.c``."

msgid "How can I evaluate an arbitrary Python expression from C?"
msgstr "Як я можу обчислити довільний вираз Python із C?"

msgid ""
"Call the function :c:func:`PyRun_String` from the previous question with the "
"start symbol :c:data:`Py_eval_input`; it parses an expression, evaluates it "
"and returns its value."
msgstr ""
"Викличте функцію :c:func:`PyRun_String` з попереднього запитання з символом "
"початку :c:data:`Py_eval_input`; він аналізує вираз, обчислює його та "
"повертає його значення."

msgid "How do I extract C values from a Python object?"
msgstr "Як отримати значення C з об’єкта Python?"

msgid ""
"That depends on the object's type.  If it's a tuple, :c:func:`PyTuple_Size` "
"returns its length and :c:func:`PyTuple_GetItem` returns the item at a "
"specified index.  Lists have similar functions, :c:func:`PyListSize` and :c:"
"func:`PyList_GetItem`."
msgstr ""
"Це залежить від типу об'єкта. Якщо це кортеж, :c:func:`PyTuple_Size` "
"повертає його довжину, а :c:func:`PyTuple_GetItem` повертає елемент за "
"вказаним індексом. Списки мають подібні функції, :c:func:`PyListSize` і :c:"
"func:`PyList_GetItem`."

msgid ""
"For bytes, :c:func:`PyBytes_Size` returns its length and :c:func:"
"`PyBytes_AsStringAndSize` provides a pointer to its value and its length.  "
"Note that Python bytes objects may contain null bytes so C's :c:func:"
"`strlen` should not be used."
msgstr ""
"Для байтів :c:func:`PyBytes_Size` повертає його довжину, а :c:func:"
"`PyBytes_AsStringAndSize` надає покажчик на його значення та довжину. "
"Зауважте, що об’єкти Python bytes можуть містити нульові байти, тому C :c:"
"func:`strlen` не слід використовувати."

msgid ""
"To test the type of an object, first make sure it isn't ``NULL``, and then "
"use :c:func:`PyBytes_Check`, :c:func:`PyTuple_Check`, :c:func:"
"`PyList_Check`, etc."
msgstr ""
"Щоб перевірити тип об’єкта, спочатку переконайтеся, що він не ``NULL``, а "
"потім скористайтеся :c:func:`PyBytes_Check`, :c:func:`PyTuple_Check`, :c:"
"func:`PyList_Check` і т.д."

msgid ""
"There is also a high-level API to Python objects which is provided by the so-"
"called 'abstract' interface -- read ``Include/abstract.h`` for further "
"details.  It allows interfacing with any kind of Python sequence using calls "
"like :c:func:`PySequence_Length`, :c:func:`PySequence_GetItem`, etc. as well "
"as many other useful protocols such as numbers (:c:func:`PyNumber_Index` et "
"al.) and mappings in the PyMapping APIs."
msgstr ""
"Існує також високорівневий API для об’єктів Python, який надається так "
"званим \"абстрактним\" інтерфейсом — читайте ``Include/abstract.h`` для "
"отримання додаткової інформації. Він дозволяє взаємодіяти з будь-якою "
"послідовністю Python за допомогою таких викликів, як :c:func:"
"`PySequence_Length`, :c:func:`PySequence_GetItem` тощо, а також багатьох "
"інших корисних протоколів, таких як числа (:c:func:`PyNumber_Index` та ін.) "
"і відображення в API PyMapping."

msgid "How do I use Py_BuildValue() to create a tuple of arbitrary length?"
msgstr ""
"Як я можу використовувати Py_BuildValue() для створення кортежу довільної "
"довжини?"

msgid "You can't.  Use :c:func:`PyTuple_Pack` instead."
msgstr ""
"Ви не можете це робити. Натомість використовуйте :c:func:`PyTuple_Pack`."

msgid "How do I call an object's method from C?"
msgstr "Як викликати метод об’єкта з C?"

msgid ""
"The :c:func:`PyObject_CallMethod` function can be used to call an arbitrary "
"method of an object.  The parameters are the object, the name of the method "
"to call, a format string like that used with :c:func:`Py_BuildValue`, and "
"the argument values::"
msgstr ""
"Функцію :c:func:`PyObject_CallMethod` можна використовувати для виклику "
"довільного методу об’єкта. Параметрами є об’єкт, ім’я методу для виклику, "
"рядок формату, який використовується з :c:func:`Py_BuildValue`, і значення "
"аргументів::"

msgid ""
"This works for any object that has methods -- whether built-in or user-"
"defined. You are responsible for eventually :c:func:`Py_DECREF`\\ 'ing the "
"return value."
msgstr ""
"Це працює для будь-якого об’єкта, який має методи – вбудовані чи визначені "
"користувачем. Ви несете відповідальність за остаточне :c:func:`Py_DECREF`\\ "
"'виведення значення, що повертається."

msgid ""
"To call, e.g., a file object's \"seek\" method with arguments 10, 0 "
"(assuming the file object pointer is \"f\")::"
msgstr ""
"Щоб викликати, наприклад, метод \"seek\" файлового об'єкта з аргументами 10, "
"0 (припускаючи, що вказівник на файловий об'єкт є \"f\")::"

msgid ""
"Note that since :c:func:`PyObject_CallObject` *always* wants a tuple for the "
"argument list, to call a function without arguments, pass \"()\" for the "
"format, and to call a function with one argument, surround the argument in "
"parentheses, e.g. \"(i)\"."
msgstr ""
"Зауважте, що оскільки :c:func:`PyObject_CallObject` *завжди* вимагає кортеж "
"для списку аргументів, щоб викликати функцію без аргументів, передайте "
"\"()\" для формату, а щоб викликати функцію з одним аргументом, оточіть "
"аргумент в дужках, напр. \"(i)\"."

msgid ""
"How do I catch the output from PyErr_Print() (or anything that prints to "
"stdout/stderr)?"
msgstr ""
"Як мені перехопити вихідні дані PyErr_Print() (або будь-чого, що друкує в "
"stdout/stderr)?"

msgid ""
"In Python code, define an object that supports the ``write()`` method.  "
"Assign this object to :data:`sys.stdout` and :data:`sys.stderr`.  Call "
"print_error, or just allow the standard traceback mechanism to work. Then, "
"the output will go wherever your ``write()`` method sends it."
msgstr ""
"У коді Python визначте об’єкт, який підтримує метод ``write()``. Призначте "
"цей об’єкт :data:`sys.stdout` і :data:`sys.stderr`. Викличте print_error або "
"просто дозвольте стандартному механізму відстеження працювати. Тоді вивід "
"буде відправлятися туди, куди його надсилає метод ``write()``."

msgid "The easiest way to do this is to use the :class:`io.StringIO` class:"
msgstr ""
"Найпростіший спосіб зробити це — використати клас :class:`io.StringIO`:"

msgid "A custom object to do the same would look like this:"
msgstr "Настроюваний об’єкт, який буде робити те саме, виглядатиме так:"

msgid "How do I access a module written in Python from C?"
msgstr "Як отримати доступ до модуля, написаного мовою Python, із C?"

msgid "You can get a pointer to the module object as follows::"
msgstr "Ви можете отримати вказівник на об’єкт модуля наступним чином:"

msgid ""
"If the module hasn't been imported yet (i.e. it is not yet present in :data:"
"`sys.modules`), this initializes the module; otherwise it simply returns the "
"value of ``sys.modules[\"<modulename>\"]``.  Note that it doesn't enter the "
"module into any namespace -- it only ensures it has been initialized and is "
"stored in :data:`sys.modules`."
msgstr ""
"Якщо модуль ще не було імпортовано (тобто його ще немає в :data:`sys."
"modules`), це ініціалізує модуль; інакше він просто повертає значення ``sys."
"modules[\" <modulename> \"]``. Зверніть увагу, що він не вводить модуль у "
"простір імен — він лише гарантує, що його було ініціалізовано та збережено "
"в :data:`sys.modules`."

msgid ""
"You can then access the module's attributes (i.e. any name defined in the "
"module) as follows::"
msgstr ""
"Потім ви можете отримати доступ до атрибутів модуля (тобто до будь-якого "
"імені, визначеного в модулі) наступним чином:"

msgid ""
"Calling :c:func:`PyObject_SetAttrString` to assign to variables in the "
"module also works."
msgstr ""
"Виклик :c:func:`PyObject_SetAttrString` для призначення змінним у модулі "
"також працює."

msgid "How do I interface to C++ objects from Python?"
msgstr "Як підключитися до об’єктів C++ із Python?"

msgid ""
"Depending on your requirements, there are many approaches.  To do this "
"manually, begin by reading :ref:`the \"Extending and Embedding\" document "
"<extending-index>`.  Realize that for the Python run-time system, there "
"isn't a whole lot of difference between C and C++ -- so the strategy of "
"building a new Python type around a C structure (pointer) type will also "
"work for C++ objects."
msgstr ""
"Залежно від ваших вимог існує багато підходів. Щоб зробити це вручну, "
"почніть із прочитання документу :ref:`\"Розширення та вбудовування\\ "
"<extending-index>`. Зрозумійте, що для системи виконання Python немає "
"великої різниці між C і C++, тому стратегія побудови нового типу Python "
"навколо типу структури (вказівника) C також працюватиме для об’єктів C++."

msgid "For C++ libraries, see :ref:`c-wrapper-software`."
msgstr "Для бібліотек C++ див. :ref:`c-wrapper-software`."

msgid "I added a module using the Setup file and the make fails; why?"
msgstr "Я додав модуль за допомогою файлу Setup, і отримав помилку, чому?"

msgid ""
"Setup must end in a newline, if there is no newline there, the build process "
"fails.  (Fixing this requires some ugly shell script hackery, and this bug "
"is so minor that it doesn't seem worth the effort.)"
msgstr ""
"Налаштування має закінчуватися символом нового рядка, якщо там немає нового "
"рядка, процес збирання завершується помилкою. (Щоб виправити це, потрібне "
"негарне хакерство сценарію оболонки, і ця помилка настільки незначна, що "
"здається не вартою зусиль.)"

msgid "How do I debug an extension?"
msgstr "Як відлагодити розширення?"

msgid ""
"When using GDB with dynamically loaded extensions, you can't set a "
"breakpoint in your extension until your extension is loaded."
msgstr ""
"Під час використання GDB із динамічно завантажуваними розширеннями ви не "
"можете встановити точку зупинки у своєму розширенні, доки воно не "
"завантажиться."

msgid "In your ``.gdbinit`` file (or interactively), add the command:"
msgstr "У свій файл ``.gdbinit`` (або інтерактивно) додайте команду:"

msgid "Then, when you run GDB:"
msgstr "Тоді, коли ви запускаєте GDB:"

msgid ""
"I want to compile a Python module on my Linux system, but some files are "
"missing. Why?"
msgstr ""
"Я хочу скомпілювати модуль Python у своїй системі Linux, але деякі файли "
"відсутні. чому"

msgid ""
"Most packaged versions of Python don't include the :file:`/usr/lib/python2."
"{x}/config/` directory, which contains various files required for compiling "
"Python extensions."
msgstr ""
"Більшість упакованих версій Python не включають каталог :file:`/usr/lib/"
"python2.{x}/config/`, який містить різні файли, необхідні для компіляції "
"розширень Python."

msgid "For Red Hat, install the python-devel RPM to get the necessary files."
msgstr "Для Red Hat встановіть RPM python-devel, щоб отримати необхідні файли."

msgid "For Debian, run ``apt-get install python-dev``."
msgstr "Для Debian запустіть ``apt-get install python-dev``."

msgid "How do I tell \"incomplete input\" from \"invalid input\"?"
msgstr "Як відрізнити \"неповне введення\" від \"некоректного введення\"?"

msgid ""
"Sometimes you want to emulate the Python interactive interpreter's behavior, "
"where it gives you a continuation prompt when the input is incomplete (e.g. "
"you typed the start of an \"if\" statement or you didn't close your "
"parentheses or triple string quotes), but it gives you a syntax error "
"message immediately when the input is invalid."
msgstr ""
"Іноді потрібно імітувати поведінку інтерактивного інтерпретатора Python, "
"коли він дає вам запит на продовження, коли введення неповне (наприклад, ви "
"ввели початок оператора \"if\" або не закрили дужки чи потрійні рядкові "
"лапки), але він дає вам повідомлення про синтаксичну помилку негайно, коли "
"введення некректне."

msgid ""
"In Python you can use the :mod:`codeop` module, which approximates the "
"parser's behavior sufficiently.  IDLE uses this, for example."
msgstr ""
"У Python ви можете використовувати модуль :mod:`codeop`, який достатньо "
"наближає поведінку аналізатора. IDLE використовує це, наприклад."

msgid ""
"The easiest way to do it in C is to call :c:func:`PyRun_InteractiveLoop` "
"(perhaps in a separate thread) and let the Python interpreter handle the "
"input for you. You can also set the :c:func:`PyOS_ReadlineFunctionPointer` "
"to point at your custom input function. See ``Modules/readline.c`` and "
"``Parser/myreadline.c`` for more hints."
msgstr ""
"Найпростіший спосіб зробити це в C — викликати :c:func:"
"`PyRun_InteractiveLoop` (можливо, в окремому потоці) і дозволити "
"інтерпретатору Python обробити вхідні дані за вас. Ви також можете "
"встановити :c:func:`PyOS_ReadlineFunctionPointer` так, щоб він вказував на "
"вашу власну функцію введення. Перегляньте ``Modules/readline.c`` і ``Parser/"
"myreadline.c`` для отримання додаткових підказок."

msgid "How do I find undefined g++ symbols __builtin_new or __pure_virtual?"
msgstr "Як знайти невизначені символи g++ __builtin_new або __pure_virtual?"

msgid ""
"To dynamically load g++ extension modules, you must recompile Python, relink "
"it using g++ (change LINKCC in the Python Modules Makefile), and link your "
"extension module using g++ (e.g., ``g++ -shared -o mymodule.so mymodule.o``)."
msgstr ""
"Щоб динамічно завантажувати модулі розширення g++, ви повинні "
"перекомпілювати Python, перекомпілювати його за допомогою g++ (змінити "
"LINKCC у Makefile модулів Python) і пов'язати свій модуль розширення за "
"допомогою g++ (наприклад, ``g++ -shared -o mymodule.so mymodule.o``)."

msgid ""
"Can I create an object class with some methods implemented in C and others "
"in Python (e.g. through inheritance)?"
msgstr ""
"Чи можу я створити клас об’єктів за допомогою деяких методів, реалізованих у "
"C, а інших – у Python (наприклад, через успадкування)?"

msgid ""
"Yes, you can inherit from built-in classes such as :class:`int`, :class:"
"`list`, :class:`dict`, etc."
msgstr ""
"Так, ви можете успадкувати такі вбудовані класи, як :class:`int`, :class:"
"`list`, :class:`dict` тощо."

msgid ""
"The Boost Python Library (BPL, https://www.boost.org/libs/python/doc/index."
"html) provides a way of doing this from C++ (i.e. you can inherit from an "
"extension class written in C++ using the BPL)."
msgstr ""
