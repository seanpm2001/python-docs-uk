# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:49+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Expressions"
msgstr "Вирази"

msgid ""
"This chapter explains the meaning of the elements of expressions in Python."
msgstr "У цьому розділі пояснюється значення елементів виразів у Python."

msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF notation "
"will be used to describe syntax, not lexical analysis.  When (one "
"alternative of) a syntax rule has the form"
msgstr ""
"**Примітки до синтаксису:** У цьому та наступних розділах для опису "
"синтаксису буде використано розширену нотацію BNF, а не лексичний аналіз. "
"Коли (одна альтернатива) синтаксичне правило має форму"

msgid ""
"and no semantics are given, the semantics of this form of ``name`` are the "
"same as for ``othername``."
msgstr ""
"і семантика не вказана, семантика цієї форми ``name`` така сама, як і "
"``othername``."

msgid "Arithmetic conversions"
msgstr "Арифметичні перетворення"

msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type\", this means that the "
"operator implementation for built-in types works as follows:"
msgstr ""
"Коли в описі арифметичного оператора нижче використовується фраза \"числові "
"аргументи перетворюються на загальний тип\", це означає, що реалізація "
"оператора для вбудованих типів працює наступним чином:"

msgid ""
"If either argument is a complex number, the other is converted to complex;"
msgstr ""
"Якщо будь-який аргумент є комплексним числом, інший перетворюється на "
"комплексне;"

msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr ""
"інакше, якщо будь-який аргумент є числом з плаваючою комою, інший "
"перетворюється на число з плаваючою комою;"

msgid "otherwise, both must be integers and no conversion is necessary."
msgstr "інакше обидва мають бути цілими числами, і перетворення не потрібне."

msgid ""
"Some additional rules apply for certain operators (e.g., a string as a left "
"argument to the '%' operator).  Extensions must define their own conversion "
"behavior."
msgstr ""
"Деякі додаткові правила застосовуються до певних операторів (наприклад, "
"рядок як лівий аргумент для оператора \"%\"). Розширення мають визначати "
"власну поведінку перетворення."

msgid "Atoms"
msgstr "Атоми"

msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are "
"identifiers or literals.  Forms enclosed in parentheses, brackets or braces "
"are also categorized syntactically as atoms.  The syntax for atoms is:"
msgstr ""
"Атоми є основними елементами виразів. Найпростішими атомами є ідентифікатори "
"або літерали. Форми, укладені в дужки, дужки або дужки, також класифікуються "
"синтаксично як атоми. Синтаксис для атомів:"

msgid "Identifiers (Names)"
msgstr "Ідентифікатори (імена)"

msgid ""
"An identifier occurring as an atom is a name.  See section :ref:"
"`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""
"Ідентифікатор, що зустрічається як атом, є ім'ям. Перегляньте розділ :ref:"
"`identifiers` для лексичного визначення та розділ :ref:`naming` для "
"документації іменування та прив’язки."

msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a :exc:"
"`NameError` exception."
msgstr ""
"Коли ім’я пов’язане з об’єктом, оцінка атома дає цей об’єкт. Коли ім’я не "
"прив’язане, спроба його оцінити викликає виняток :exc:`NameError`."

msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does not "
"end in two or more underscores, it is considered a :dfn:`private name` of "
"that class. Private names are transformed to a longer form before code is "
"generated for them.  The transformation inserts the class name, with leading "
"underscores removed and a single underscore inserted, in front of the name.  "
"For example, the identifier ``__spam`` occurring in a class named ``Ham`` "
"will be transformed to ``_Ham__spam``.  This transformation is independent "
"of the syntactical context in which the identifier is used.  If the "
"transformed name is extremely long (longer than 255 characters), "
"implementation defined truncation may happen. If the class name consists "
"only of underscores, no transformation is done."
msgstr ""
"**Приватне спотворення імені:** Якщо ідентифікатор, який текстово "
"зустрічається у визначенні класу, починається з двох або більше символів "
"підкреслення і не закінчується двома або більше підкресленнями, він "
"вважається :dfn:`приватним ім’ям` цього класу. Приватні імена перетворюються "
"на довшу форму перед тим, як для них буде згенеровано код. Трансформація "
"вставляє ім’я класу з видаленням початкового підкреслення та вставленням "
"одного підкреслення перед ім’ям. Наприклад, ідентифікатор ``__spam``, що "
"зустрічається в класі з назвою ``Ham``, буде перетворено на ``_Ham__spam``. "
"Це перетворення не залежить від синтаксичного контексту, у якому "
"використовується ідентифікатор. Якщо перетворене ім’я надзвичайно довге "
"(більше 255 символів), може статися скорочення, визначене реалізацією. Якщо "
"ім'я класу складається лише з підкреслення, перетворення не виконується."

msgid "Literals"
msgstr "Літерали"

msgid "Python supports string and bytes literals and various numeric literals:"
msgstr ""
"Python підтримує рядкові та байтові літерали та різні числові літерали:"

msgid ""
"Evaluation of a literal yields an object of the given type (string, bytes, "
"integer, floating point number, complex number) with the given value.  The "
"value may be approximated in the case of floating point and imaginary "
"(complex) literals.  See section :ref:`literals` for details."
msgstr ""
"Обчислення літералу дає об’єкт заданого типу (рядок, байти, ціле число, "
"число з плаваючою комою, комплексне число) із заданим значенням. Значення "
"може бути наближено у випадку плаваючої коми та уявних (комплексних) "
"літералів. Перегляньте розділ :ref:`literals` для деталей."

msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of literals "
"with the same value (either the same occurrence in the program text or a "
"different occurrence) may obtain the same object or a different object with "
"the same value."
msgstr ""
"Усі літерали відповідають незмінним типам даних, і, отже, ідентичність "
"об’єкта менш важлива, ніж його значення. Кілька обчислень літералів з "
"однаковим значенням (або те саме входження в текст програми, або інше "
"входження) можуть отримати той самий об’єкт або інший об’єкт з тим самим "
"значенням."

msgid "Parenthesized forms"
msgstr "Форми в дужках"

msgid ""
"A parenthesized form is an optional expression list enclosed in parentheses:"
msgstr "Форма в дужках – це необов’язковий список виразів, укладений у дужки:"

msgid ""
"A parenthesized expression list yields whatever that expression list yields: "
"if the list contains at least one comma, it yields a tuple; otherwise, it "
"yields the single expression that makes up the expression list."
msgstr ""
"Список виразів у дужках дає все, що дає цей список виразів: якщо список "
"містить принаймні одну кому, він дає кортеж; інакше він дає єдиний вираз, "
"який складає список виразів."

msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples are "
"immutable, the same rules as for literals apply (i.e., two occurrences of "
"the empty tuple may or may not yield the same object)."
msgstr ""
"Порожня пара круглих дужок дає порожній об’єкт кортежу. Оскільки кортежі є "
"незмінними, застосовуються ті ж правила, що й для літералів (тобто два "
"входження порожнього кортежу можуть або не можуть давати той самий об’єкт)."

msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of the "
"comma.  The exception is the empty tuple, for which parentheses *are* "
"required --- allowing unparenthesized \"nothing\" in expressions would cause "
"ambiguities and allow common typos to pass uncaught."
msgstr ""

msgid "Displays for lists, sets and dictionaries"
msgstr "Відображення списків, наборів і словників"

msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr ""
"Для побудови списку, набору або словника Python надає спеціальний синтаксис, "
"званий \"дисплеями\", кожен з яких у двох варіантах:"

msgid "either the container contents are listed explicitly, or"
msgstr "або вміст контейнера перераховано явно, або"

msgid ""
"they are computed via a set of looping and filtering instructions, called a :"
"dfn:`comprehension`."
msgstr ""
"вони обчислюються за допомогою набору інструкцій циклу та фільтрації, які "
"називаються :dfn:`comprehension`."

msgid "Common syntax elements for comprehensions are:"
msgstr "Загальні синтаксичні елементи для розуміння:"

msgid ""
"The comprehension consists of a single expression followed by at least one :"
"keyword:`!for` clause and zero or more :keyword:`!for` or :keyword:`!if` "
"clauses. In this case, the elements of the new container are those that "
"would be produced by considering each of the :keyword:`!for` or :keyword:`!"
"if` clauses a block, nesting from left to right, and evaluating the "
"expression to produce an element each time the innermost block is reached."
msgstr ""
"Розуміння складається з одного виразу, за яким слідує принаймні одна "
"пропозиція :keyword:`!for` і нуль або більше пропозицій :keyword:`!for` або :"
"keyword:`!if`. У цьому випадку елементи нового контейнера — це ті, які були "
"б створені шляхом розгляду кожного з пропозицій :keyword:`!for` або :keyword:"
"`!if` блоку, вкладення зліва направо та оцінювання виразу створювати елемент "
"кожного разу, коли досягнуто внутрішнього блоку."

msgid ""
"However, aside from the iterable expression in the leftmost :keyword:`!for` "
"clause, the comprehension is executed in a separate implicitly nested scope. "
"This ensures that names assigned to in the target list don't \"leak\" into "
"the enclosing scope."
msgstr ""
"Однак, окрім ітераційного виразу в крайньому лівому реченні :keyword:`!for`, "
"розуміння виконується в окремій неявно вкладеній області. Це гарантує, що "
"імена, призначені в цільовому списку, не \"просочуються\" в охоплюючу "
"область."

msgid ""
"The iterable expression in the leftmost :keyword:`!for` clause is evaluated "
"directly in the enclosing scope and then passed as an argument to the "
"implicitly nested scope. Subsequent :keyword:`!for` clauses and any filter "
"condition in the leftmost :keyword:`!for` clause cannot be evaluated in the "
"enclosing scope as they may depend on the values obtained from the leftmost "
"iterable. For example: ``[x*y for x in range(10) for y in range(x, x+10)]``."
msgstr ""
"Ітераційний вираз у крайньому лівому реченні :keyword:`!for` обчислюється "
"безпосередньо в охоплюючій області, а потім передається як аргумент до "
"неявно вкладеної області. Наступні пропозиції :keyword:`!for` і будь-яка "
"умова фільтра в крайньому лівому пункті :keyword:`!for` не можуть бути "
"оцінені в охоплюючій області, оскільки вони можуть залежати від значень, "
"отриманих від крайнього лівого ітератора. Наприклад: ``[x*y для x в "
"діапазоні (10) для y в діапазоні (x, x+10)]``."

msgid ""
"To ensure the comprehension always results in a container of the appropriate "
"type, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly nested scope."
msgstr ""
"Щоб гарантувати, що розуміння завжди призводить до контейнера відповідного "
"типу, вирази ``yield`` і ``yield from`` заборонені в неявно вкладеній "
"області."

msgid ""
"Since Python 3.6, in an :keyword:`async def` function, an :keyword:`!async "
"for` clause may be used to iterate over a :term:`asynchronous iterator`. A "
"comprehension in an :keyword:`!async def` function may consist of either a :"
"keyword:`!for` or :keyword:`!async for` clause following the leading "
"expression, may contain additional :keyword:`!for` or :keyword:`!async for` "
"clauses, and may also use :keyword:`await` expressions. If a comprehension "
"contains either :keyword:`!async for` clauses or :keyword:`!await` "
"expressions or other asynchronous comprehensions it is called an :dfn:"
"`asynchronous comprehension`.  An asynchronous comprehension may suspend the "
"execution of the coroutine function in which it appears. See also :pep:`530`."
msgstr ""

msgid "Asynchronous comprehensions were introduced."
msgstr "Були введені асинхронні розуміння."

msgid "``yield`` and ``yield from`` prohibited in the implicitly nested scope."
msgstr "``yield`` і ``yield from`` заборонені в неявно вкладеній області."

msgid ""
"Asynchronous comprehensions are now allowed inside comprehensions in "
"asynchronous functions. Outer comprehensions implicitly become asynchronous."
msgstr ""

msgid "List displays"
msgstr "Відображається список"

msgid ""
"A list display is a possibly empty series of expressions enclosed in square "
"brackets:"
msgstr ""
"Відображення списку – це, можливо, порожня серія виразів, укладених у "
"квадратні дужки:"

msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a comprehension "
"is supplied, the list is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"Відображення списку дає новий об’єкт списку, вміст якого визначається або "
"списком виразів, або розумінням. Коли надається список виразів, розділених "
"комами, його елементи обчислюються зліва направо та розміщуються в об’єкті "
"списку в такому порядку. Коли надається розуміння, список складається з "
"елементів, отриманих у результаті розуміння."

msgid "Set displays"
msgstr "Встановити дисплеї"

msgid ""
"A set display is denoted by curly braces and distinguishable from dictionary "
"displays by the lack of colons separating keys and values:"
msgstr ""
"Відображення набору позначається фігурними дужками та відрізняється від "
"відображення словника відсутністю двокрапки, що розділяє ключі та значення:"

msgid ""
"A set display yields a new mutable set object, the contents being specified "
"by either a sequence of expressions or a comprehension.  When a comma-"
"separated list of expressions is supplied, its elements are evaluated from "
"left to right and added to the set object.  When a comprehension is "
"supplied, the set is constructed from the elements resulting from the "
"comprehension."
msgstr ""
"Відображення набору дає новий змінний об’єкт набору, вміст якого "
"визначається або послідовністю виразів, або розумінням. Коли надається "
"список виразів, розділених комами, його елементи обчислюються зліва направо "
"та додаються до набору об’єктів. Коли надається розуміння, набір будується з "
"елементів, отриманих у результаті розуміння."

msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs an "
"empty dictionary."
msgstr ""
"Порожній набір не можна створити за допомогою ``{}``; цей літерал створює "
"порожній словник."

msgid "Dictionary displays"
msgstr "Відображення словника"

msgid ""
"A dictionary display is a possibly empty series of key/datum pairs enclosed "
"in curly braces:"
msgstr ""
"Відображення словника – це, можливо, порожня серія пар ключ/дата, укладена у "
"фігурні дужки:"

msgid "A dictionary display yields a new dictionary object."
msgstr "Відображення словника дає новий об’єкт словника."

msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: each "
"key object is used as a key into the dictionary to store the corresponding "
"datum.  This means that you can specify the same key multiple times in the "
"key/datum list, and the final dictionary's value for that key will be the "
"last one given."
msgstr ""
"Якщо подано розділену комами послідовність пар ключ/дані, вони оцінюються "
"зліва направо, щоб визначити записи словника: кожен ключовий об’єкт "
"використовується як ключ у словнику для збереження відповідних даних. Це "
"означає, що ви можете вказати той самий ключ кілька разів у списку ключів/"
"даних, і остаточне значення словника для цього ключа буде останнім наданим."

msgid ""
"A double asterisk ``**`` denotes :dfn:`dictionary unpacking`. Its operand "
"must be a :term:`mapping`.  Each mapping item is added to the new "
"dictionary.  Later values replace values already set by earlier key/datum "
"pairs and earlier dictionary unpackings."
msgstr ""
"Подвійна зірочка ``**`` позначає :dfn:`dictionary unpacking`. Його операнд "
"має бути :term:`mapping`. Кожен елемент зіставлення додається до нового "
"словника. Пізніші значення замінюють значення, уже встановлені попередніми "
"парами ключ/дані та попередніми розпакуваннями словника."

msgid "Unpacking into dictionary displays, originally proposed by :pep:`448`."
msgstr ""
"Розпакування у словникові відображення, спочатку запропоноване :pep:`448`."

msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs two "
"expressions separated with a colon followed by the usual \"for\" and \"if\" "
"clauses. When the comprehension is run, the resulting key and value elements "
"are inserted in the new dictionary in the order they are produced."
msgstr ""
"Розуміння dict, на відміну від списків і набору, потребує двох виразів, "
"розділених двокрапкою, за якими слідують звичайні пропозиції \"for\" і "
"\"if\". Коли виконується розуміння, отримані елементи ключа та значення "
"вставляються в новий словник у тому порядку, в якому вони створені."

msgid ""
"Restrictions on the types of the key values are listed earlier in section :"
"ref:`types`.  (To summarize, the key type should be :term:`hashable`, which "
"excludes all mutable objects.)  Clashes between duplicate keys are not "
"detected; the last datum (textually rightmost in the display) stored for a "
"given key value prevails."
msgstr ""
"Обмеження щодо типів значень ключів перелічені раніше в розділі :ref:"
"`types`. (Підсумовуючи, тип ключа має бути :term:`hashable`, що виключає всі "
"змінні об’єкти.) Конфлікти між повторюваними ключами не виявляються; "
"переважає остання дата (текстово крайня права на дисплеї), збережена для "
"заданого значення ключа."

msgid ""
"Prior to Python 3.8, in dict comprehensions, the evaluation order of key and "
"value was not well-defined.  In CPython, the value was evaluated before the "
"key.  Starting with 3.8, the key is evaluated before the value, as proposed "
"by :pep:`572`."
msgstr ""
"До Python 3.8 у розуміннях dict порядок оцінки ключа та значення не був "
"чітко визначений. У CPython значення було обчислено перед ключем. Починаючи "
"з 3.8, ключ оцінюється перед значенням, як запропоновано :pep:`572`."

msgid "Generator expressions"
msgstr "Генератор виразів"

msgid "A generator expression is a compact generator notation in parentheses:"
msgstr "Генеруючий вираз — це компактний генераторний запис у круглих дужках:"

msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr ""
"Генеруючий вираз дає новий генераторний об’єкт. Його синтаксис такий самий, "
"як і для розуміння, за винятком того, що він узятий у дужки замість дужок "
"або фігурних дужок."

msgid ""
"Variables used in the generator expression are evaluated lazily when the :"
"meth:`~generator.__next__` method is called for the generator object (in the "
"same fashion as normal generators).  However, the iterable expression in the "
"leftmost :keyword:`!for` clause is immediately evaluated, so that an error "
"produced by it will be emitted at the point where the generator expression "
"is defined, rather than at the point where the first value is retrieved. "
"Subsequent :keyword:`!for` clauses and any filter condition in the leftmost :"
"keyword:`!for` clause cannot be evaluated in the enclosing scope as they may "
"depend on the values obtained from the leftmost iterable. For example: "
"``(x*y for x in range(10) for y in range(x, x+10))``."
msgstr ""
"Змінні, які використовуються у виразі генератора, обчислюються ліниво, коли "
"метод :meth:`~generator.__next__` викликається для об’єкта генератора (так "
"само, як і звичайні генератори). Однак ітераційний вираз у крайньому лівому "
"реченні :keyword:`!for` негайно обчислюється, тому помилка, створена ним, "
"буде видана в точці, де визначено вираз генератора, а не в точці, де перше "
"значення відновлено. Наступні пропозиції :keyword:`!for` і будь-яка умова "
"фільтра в крайньому лівому пункті :keyword:`!for` не можуть бути оцінені в "
"охоплюючій області, оскільки вони можуть залежати від значень, отриманих від "
"крайнього лівого ітератора. Наприклад: ``(x*y для x в діапазоні (10) для y в "
"діапазоні (x, x+10))``."

msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for details."
msgstr ""
"У викликах лише з одним аргументом дужки можна опускати. Подробиці див. у "
"розділі :ref:`calls`."

msgid ""
"To avoid interfering with the expected operation of the generator expression "
"itself, ``yield`` and ``yield from`` expressions are prohibited in the "
"implicitly defined generator."
msgstr ""
"Щоб уникнути перешкоджання очікуваній роботі самого виразу генератора, "
"вирази ``yield`` і ``yield from`` заборонені в неявно визначеному генераторі."

msgid ""
"If a generator expression contains either :keyword:`!async for` clauses or :"
"keyword:`await` expressions it is called an :dfn:`asynchronous generator "
"expression`.  An asynchronous generator expression returns a new "
"asynchronous generator object, which is an asynchronous iterator (see :ref:"
"`async-iterators`)."
msgstr ""
"Якщо вираз генератора містить пропозиції :keyword:`!async for` або вирази :"
"keyword:`await`, це називається :dfn:`asynchronous generator expression`. "
"Вираз асинхронного генератора повертає новий об’єкт асинхронного генератора, "
"який є асинхронним ітератором (див. :ref:`async-iterators`)."

msgid "Asynchronous generator expressions were introduced."
msgstr "Було введено асинхронні генераторні вирази."

msgid ""
"Prior to Python 3.7, asynchronous generator expressions could only appear "
"in :keyword:`async def` coroutines.  Starting with 3.7, any function can use "
"asynchronous generator expressions."
msgstr ""
"До Python 3.7 вирази асинхронного генератора могли з’являтися лише в "
"співпрограмах :keyword:`async def`. Починаючи з 3.7, будь-яка функція може "
"використовувати вирази асинхронного генератора."

msgid "Yield expressions"
msgstr "Вирази дохідності"

msgid ""
"The yield expression is used when defining a :term:`generator` function or "
"an :term:`asynchronous generator` function and thus can only be used in the "
"body of a function definition.  Using a yield expression in a function's "
"body causes that function to be a generator function, and using it in an :"
"keyword:`async def` function's body causes that coroutine function to be an "
"asynchronous generator function. For example::"
msgstr ""
"Вираз yield використовується під час визначення функції :term:`generator` "
"або функції :term:`asynchronous generator` і тому може використовуватися "
"лише в тілі визначення функції. Використання виразу yield у тілі функції "
"робить цю функцію функцією-генератором, а використання його в тілі функції :"
"keyword:`async def` призводить до того, що функція співпрограми стає "
"асинхронною функцією-генератором. Наприклад::"

msgid ""
"Due to their side effects on the containing scope, ``yield`` expressions are "
"not permitted as part of the implicitly defined scopes used to implement "
"comprehensions and generator expressions."
msgstr ""
"Через їхній побічний вплив на область, що містить, вирази ``yield`` не "
"дозволені як частина неявно визначених областей, які використовуються для "
"реалізації розуміння та виразів генератора."

msgid ""
"Yield expressions prohibited in the implicitly nested scopes used to "
"implement comprehensions and generator expressions."
msgstr ""
"Вирази yield, заборонені в неявно вкладених областях, що використовуються "
"для реалізації виразів розуміння та генератора."

msgid ""
"Generator functions are described below, while asynchronous generator "
"functions are described separately in section :ref:`asynchronous-generator-"
"functions`."
msgstr ""
"Функції генератора описані нижче, тоді як функції асинхронного генератора "
"описані окремо в розділі :ref:`asynchronous-generator-functions`."

msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of the generator "
"function.  The execution starts when one of the generator's methods is "
"called. At that time, the execution proceeds to the first yield expression, "
"where it is suspended again, returning the value of :token:`~python-grammar:"
"expression_list` to the generator's caller.  By suspended, we mean that all "
"local state is retained, including the current bindings of local variables, "
"the instruction pointer, the internal evaluation stack, and the state of any "
"exception handling. When the execution is resumed by calling one of the "
"generator's methods, the function can proceed exactly as if the yield "
"expression were just another external call.  The value of the yield "
"expression after resuming depends on the method which resumed the "
"execution.  If :meth:`~generator.__next__` is used (typically via either a :"
"keyword:`for` or the :func:`next` builtin) then the result is :const:"
"`None`.  Otherwise, if :meth:`~generator.send` is used, then the result will "
"be the value passed in to that method."
msgstr ""
"Коли функція генератора викликається, вона повертає ітератор, відомий як "
"генератор. Потім цей генератор керує виконанням функції генератора. "
"Виконання починається при виклику одного з методів генератора. У цей час "
"виконання переходить до першого виразу yield, де воно знову призупиняється, "
"повертаючи значення :token:`~python-grammar:expression_list` до викликаючого "
"генератора. Під призупиненням ми маємо на увазі, що весь локальний стан "
"зберігається, включаючи поточні прив’язки локальних змінних, вказівник "
"інструкцій, внутрішній стек оцінки та стан будь-якої обробки винятків. Коли "
"виконання відновлюється викликом одного з методів генератора, функція може "
"продовжувати роботу точно так, якби вираз yield був ще одним зовнішнім "
"викликом. Значення виразу yield після відновлення залежить від методу, який "
"відновив виконання. Якщо :meth:`~generator.__next__` використовується "
"(зазвичай через :keyword:`for` або вбудований :func:`next`), тоді "
"результатом буде :const:`None`. В іншому випадку, якщо :meth:`~generator."
"send` використовується, результатом буде значення, передане цьому методу."

msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where the execution should continue after it yields; "
"the control is always transferred to the generator's caller."
msgstr ""
"Усе це робить функції генератора досить схожими на співпрограми; вони "
"поступаються кілька разів, вони мають більше однієї точки входу, і їхнє "
"виконання може бути призупинено. Єдина відмінність полягає в тому, що "
"функція-генератор не може контролювати, де має продовжуватися виконання "
"після того, як вона виходить; керування завжди передається абоненту "
"генератора."

msgid ""
"Yield expressions are allowed anywhere in a :keyword:`try` construct.  If "
"the generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), the generator-iterator's :"
"meth:`~generator.close` method will be called, allowing any pending :keyword:"
"`finally` clauses to execute."
msgstr ""
"Вирази yield дозволені будь-де в конструкції :keyword:`try`. Якщо генератор "
"не відновлено до його завершення (досягнувши нульової кількості посилань або "
"збираючи сміття), буде викликано метод :meth:`~generator.close` генератора-"
"ітератора, дозволяючи будь-які очікуючі :keyword:`finally` пропозиції для "
"виконання."

msgid ""
"When ``yield from <expr>`` is used, the supplied expression must be an "
"iterable. The values produced by iterating that iterable are passed directly "
"to the caller of the current generator's methods. Any values passed in with :"
"meth:`~generator.send` and any exceptions passed in with :meth:`~generator."
"throw` are passed to the underlying iterator if it has the appropriate "
"methods.  If this is not the case, then :meth:`~generator.send` will raise :"
"exc:`AttributeError` or :exc:`TypeError`, while :meth:`~generator.throw` "
"will just raise the passed in exception immediately."
msgstr ""
"Коли використовується ``yield from <expr>``, наданий вираз має бути "
"повторюваним. Значення, отримані шляхом ітерації цього ітерованого, "
"передаються безпосередньо до виклику методів поточного генератора. Будь-які "
"значення, передані за допомогою :meth:`~generator.send`, і будь-які винятки, "
"передані за допомогою :meth:`~generator.throw`, передаються базовому "
"ітератору, якщо він має відповідні методи. Якщо це не так, то :meth:"
"`~generator.send` викличе :exc:`AttributeError` або :exc:`TypeError`, а :"
"meth:`~generator.throw` просто викличе переданий виняток негайно."

msgid ""
"When the underlying iterator is complete, the :attr:`~StopIteration.value` "
"attribute of the raised :exc:`StopIteration` instance becomes the value of "
"the yield expression. It can be either set explicitly when raising :exc:"
"`StopIteration`, or automatically when the subiterator is a generator (by "
"returning a value from the subgenerator)."
msgstr ""
"Коли основний ітератор завершено, атрибут :attr:`~StopIteration.value` "
"піднятого екземпляра :exc:`StopIteration` стає значенням виразу yield. Його "
"можна встановити явно під час виклику :exc:`StopIteration` або автоматично, "
"коли субітератор є генератором (шляхом повернення значення з субгенератора)."

msgid "Added ``yield from <expr>`` to delegate control flow to a subiterator."
msgstr ""
"Додано ``yield from <expr>`` для делегування потоку керування субітератору."

msgid ""
"The parentheses may be omitted when the yield expression is the sole "
"expression on the right hand side of an assignment statement."
msgstr ""
"Дужки можуть бути опущені, якщо вираз yield є єдиним виразом у правій "
"частині оператора призначення."

msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - Прості генератори"

msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr ""
"Пропозиція щодо додавання генераторів і оператора :keyword:`yield` до Python."

msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`342` - Співпрограми через розширені генератори"

msgid ""
"The proposal to enhance the API and syntax of generators, making them usable "
"as simple coroutines."
msgstr ""
"Пропозиція покращити API та синтаксис генераторів, зробивши їх придатними "
"для використання як простих співпрограм."

msgid ":pep:`380` - Syntax for Delegating to a Subgenerator"
msgstr ":pep:`380` - Синтаксис для делегування підгенератору"

msgid ""
"The proposal to introduce the :token:`~python-grammar:yield_from` syntax, "
"making delegation to subgenerators easy."
msgstr ""
"Пропозиція запровадити синтаксис :token:`~python-grammar:yield_from`, що "
"спрощує делегування субгенераторам."

msgid ":pep:`525` - Asynchronous Generators"
msgstr ":pep:`525` - Асинхронні генератори"

msgid ""
"The proposal that expanded on :pep:`492` by adding generator capabilities to "
"coroutine functions."
msgstr ""
"Пропозиція, яка розширила :pep:`492` шляхом додавання можливостей генератора "
"до функцій співпрограми."

msgid "Generator-iterator methods"
msgstr "Методи генератор-ітератор"

msgid ""
"This subsection describes the methods of a generator iterator.  They can be "
"used to control the execution of a generator function."
msgstr ""
"У цьому підрозділі описано методи ітератора генератора. Вони можуть "
"використовуватися для керування виконанням функції генератора."

msgid ""
"Note that calling any of the generator methods below when the generator is "
"already executing raises a :exc:`ValueError` exception."
msgstr ""
"Зауважте, що виклик будь-якого з наведених нижче методів генератора, коли "
"генератор уже виконується, викликає виняткову ситуацію :exc:`ValueError`."

msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed yield expression.  When a generator function is resumed with a :"
"meth:`~generator.__next__` method, the current yield expression always "
"evaluates to :const:`None`.  The execution then continues to the next yield "
"expression, where the generator is suspended again, and the value of the :"
"token:`~python-grammar:expression_list` is returned to :meth:`__next__`'s "
"caller.  If the generator exits without yielding another value, a :exc:"
"`StopIteration` exception is raised."
msgstr ""
"Починає виконання функції генератора або відновлює його після останнього "
"виконаного виразу yield. Коли функцію генератора відновлено за допомогою "
"методу :meth:`~generator.__next__`, поточний вираз yield завжди оцінюється "
"як :const:`None`. Потім виконання продовжується до наступного виразу yield, "
"де генератор знову призупиняється, а значення :token:`~python-grammar:"
"expression_list` повертається до викликаючого :meth:`__next__`. Якщо "
"генератор завершує роботу, не видаючи іншого значення, виникає виняток :exc:"
"`StopIteration`."

msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop, or "
"by the built-in :func:`next` function."
msgstr ""
"Цей метод зазвичай викликається неявно, напр. за допомогою циклу :keyword:"
"`for` або за допомогою вбудованої функції :func:`next`."

msgid ""
"Resumes the execution and \"sends\" a value into the generator function.  "
"The *value* argument becomes the result of the current yield expression.  "
"The :meth:`send` method returns the next value yielded by the generator, or "
"raises :exc:`StopIteration` if the generator exits without yielding another "
"value.  When :meth:`send` is called to start the generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""
"Відновлює виконання та \"надсилає\" значення у функцію генератора. Аргумент "
"*value* стає результатом поточного виразу yield. Метод :meth:`send` повертає "
"наступне значення, отримане генератором, або викликає :exc:`StopIteration`, "
"якщо генератор завершує роботу, не видаючи іншого значення. Коли :meth:"
"`send` викликається для запуску генератора, його потрібно викликати з :const:"
"`None` як аргументом, оскільки немає виразу yield, який міг би отримати "
"значення."

msgid ""
"Raises an exception at the point where the generator was paused, and returns "
"the next value yielded by the generator function.  If the generator exits "
"without yielding another value, a :exc:`StopIteration` exception is raised.  "
"If the generator function does not catch the passed-in exception, or raises "
"a different exception, then that exception propagates to the caller."
msgstr ""
"Викликає виняток у точці, де генератор було призупинено, і повертає наступне "
"значення, отримане функцією генератора. Якщо генератор завершує роботу, не "
"видаючи іншого значення, виникає виняток :exc:`StopIteration`. Якщо функція "
"генератора не перехоплює переданий виняток або викликає інший виняток, тоді "
"цей виняток поширюється на виклик."

msgid ""
"In typical use, this is called with a single exception instance similar to "
"the way the :keyword:`raise` keyword is used."
msgstr ""
"У типовому використанні це викликається з одним винятком, подібним до того, "
"як використовується ключове слово :keyword:`raise`."

msgid ""
"For backwards compatibility, however, the second signature is supported, "
"following a convention from older versions of Python. The *type* argument "
"should be an exception class, and *value* should be an exception instance. "
"If the *value* is not provided, the *type* constructor is called to get an "
"instance. If *traceback* is provided, it is set on the exception, otherwise "
"any existing :attr:`~BaseException.__traceback__` attribute stored in "
"*value* may be cleared."
msgstr ""

msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function was "
"paused.  If the generator function then exits gracefully, is already closed, "
"or raises :exc:`GeneratorExit` (by not catching the exception), close "
"returns to its caller.  If the generator yields a value, a :exc:"
"`RuntimeError` is raised.  If the generator raises any other exception, it "
"is propagated to the caller.  :meth:`close` does nothing if the generator "
"has already exited due to an exception or normal exit."
msgstr ""
"Викликає :exc:`GeneratorExit` у точці, де функцію генератора було "
"призупинено. Якщо функція-генератор завершує роботу належним чином, уже "
"закрита або викликає :exc:`GeneratorExit` (не перехоплюючи виняток), close "
"повертається до свого виклику. Якщо генератор видає значення, виникає :exc:"
"`RuntimeError`. Якщо генератор викликає будь-який інший виняток, він "
"передається до абонента. :meth:`close` нічого не робить, якщо генератор уже "
"завершив роботу через виняток або нормальний вихід."

msgid "Examples"
msgstr "Приклади"

msgid ""
"Here is a simple example that demonstrates the behavior of generators and "
"generator functions::"
msgstr ""
"Ось простий приклад, який демонструє поведінку генераторів і функцій "
"генератора:"

msgid ""
"For examples using ``yield from``, see :ref:`pep-380` in \"What's New in "
"Python.\""
msgstr ""
"Приклади використання ``yield from`` див. :ref:`pep-380` у розділі \"Що "
"нового в Python\"."

msgid "Asynchronous generator functions"
msgstr "Функції асинхронного генератора"

msgid ""
"The presence of a yield expression in a function or method defined using :"
"keyword:`async def` further defines the function as an :term:`asynchronous "
"generator` function."
msgstr ""
"Наявність виразу yield у функції чи методі, визначеному за допомогою :"
"keyword:`async def`, далі визначає функцію як функцію :term:`asynchronous "
"generator`."

msgid ""
"When an asynchronous generator function is called, it returns an "
"asynchronous iterator known as an asynchronous generator object. That object "
"then controls the execution of the generator function. An asynchronous "
"generator object is typically used in an :keyword:`async for` statement in a "
"coroutine function analogously to how a generator object would be used in a :"
"keyword:`for` statement."
msgstr ""
"Коли викликається функція асинхронного генератора, вона повертає асинхронний "
"ітератор, відомий як об’єкт асинхронного генератора. Потім цей об’єкт керує "
"виконанням функції генератора. Асинхронний об’єкт генератора зазвичай "
"використовується в операторі :keyword:`async for` у функції співпрограми "
"аналогічно тому, як об’єкт генератора використовувався б у операторі :"
"keyword:`for`."

msgid ""
"Calling one of the asynchronous generator's methods returns an :term:"
"`awaitable` object, and the execution starts when this object is awaited on. "
"At that time, the execution proceeds to the first yield expression, where it "
"is suspended again, returning the value of :token:`~python-grammar:"
"expression_list` to the awaiting coroutine. As with a generator, suspension "
"means that all local state is retained, including the current bindings of "
"local variables, the instruction pointer, the internal evaluation stack, and "
"the state of any exception handling. When the execution is resumed by "
"awaiting on the next object returned by the asynchronous generator's "
"methods, the function can proceed exactly as if the yield expression were "
"just another external call. The value of the yield expression after resuming "
"depends on the method which resumed the execution.  If :meth:`~agen."
"__anext__` is used then the result is :const:`None`. Otherwise, if :meth:"
"`~agen.asend` is used, then the result will be the value passed in to that "
"method."
msgstr ""
"Виклик одного з методів асинхронного генератора повертає об’єкт :term:"
"`awaitable`, і виконання починається, коли цей об’єкт очікується. У цей час "
"виконання переходить до першого виразу yield, де воно знову призупиняється, "
"повертаючи значення :token:`~python-grammar:expression_list` до співпрограми "
"очікування. Як і у випадку з генератором, призупинення означає, що весь "
"локальний стан зберігається, включаючи поточні прив’язки локальних змінних, "
"покажчик інструкцій, внутрішній стек оцінки та стан будь-якої обробки "
"винятків. Коли виконання відновлюється шляхом очікування наступного об’єкта, "
"повернутого методами асинхронного генератора, функція може продовжувати "
"роботу точно так, якби вираз yield був просто ще одним зовнішнім викликом. "
"Значення виразу yield після відновлення залежить від методу, який відновив "
"виконання. Якщо використано :meth:`~agen.__anext__`, результатом буде :const:"
"`None`. В іншому випадку, якщо :meth:`~agen.asend` використовується, "
"результатом буде значення, передане цьому методу."

msgid ""
"If an asynchronous generator happens to exit early by :keyword:`break`, the "
"caller task being cancelled, or other exceptions, the generator's async "
"cleanup code will run and possibly raise exceptions or access context "
"variables in an unexpected context--perhaps after the lifetime of tasks it "
"depends, or during the event loop shutdown when the async-generator garbage "
"collection hook is called. To prevent this, the caller must explicitly close "
"the async generator by calling :meth:`~agen.aclose` method to finalize the "
"generator and ultimately detach it from the event loop."
msgstr ""
"Якщо асинхронний генератор завершує роботу раніше через :keyword:`break`, "
"скасування завдання виклику або інші винятки, запуститься асинхронний код "
"очищення генератора та, можливо, викличе винятки або отримає доступ до "
"змінних контексту в неочікуваному контексті — можливо, після час життя "
"завдань залежить від цього, або під час завершення циклу подій, коли "
"викликається хук збирання сміття асинхронного генератора. Щоб запобігти "
"цьому, абонент повинен явно закрити асинхронний генератор, викликавши метод :"
"meth:`~agen.aclose`, щоб завершити генератор і остаточно від’єднати його від "
"циклу подій."

msgid ""
"In an asynchronous generator function, yield expressions are allowed "
"anywhere in a :keyword:`try` construct. However, if an asynchronous "
"generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), then a yield expression "
"within a :keyword:`!try` construct could result in a failure to execute "
"pending :keyword:`finally` clauses.  In this case, it is the responsibility "
"of the event loop or scheduler running the asynchronous generator to call "
"the asynchronous generator-iterator's :meth:`~agen.aclose` method and run "
"the resulting coroutine object, thus allowing any pending :keyword:`!"
"finally` clauses to execute."
msgstr ""
"У функції асинхронного генератора вирази yield дозволені будь-де в "
"конструкції :keyword:`try`. Однак, якщо асинхронний генератор не відновлено "
"до його завершення (досягнувши нульового підрахунку посилань або збираючи "
"сміття), тоді вираз yield у конструкції :keyword:`!try` може призвести до "
"збою виконання очікуваного :keyword:`finally`. У цьому випадку цикл подій "
"або планувальник, який запускає асинхронний генератор, відповідає за виклик "
"методу :meth:`~agen.aclose` асинхронного генератора-ітератора та запуск "
"отриманого об’єкта співпрограми, таким чином дозволяючи будь-які очікуючі :"
"keyword:`!finally` для виконання."

msgid ""
"To take care of finalization upon event loop termination, an event loop "
"should define a *finalizer* function which takes an asynchronous generator-"
"iterator and presumably calls :meth:`~agen.aclose` and executes the "
"coroutine. This  *finalizer* may be registered by calling :func:`sys."
"set_asyncgen_hooks`. When first iterated over, an asynchronous generator-"
"iterator will store the registered *finalizer* to be called upon "
"finalization. For a reference example of a *finalizer* method see the "
"implementation of ``asyncio.Loop.shutdown_asyncgens`` in :source:`Lib/"
"asyncio/base_events.py`."
msgstr ""
"Щоб подбати про фіналізацію після завершення циклу подій, цикл подій має "
"визначати функцію *finalizer*, яка приймає асинхронний генератор-ітератор і, "
"ймовірно, викликає :meth:`~agen.aclose` і виконує співпрограму. Цей "
"*фіналізатор* можна зареєструвати, викликавши :func:`sys."
"set_asyncgen_hooks`. Під час першого повторення асинхронний генератор-"
"ітератор зберігатиме зареєстрований *фіналізатор*, який буде викликаний під "
"час фіналізації. Для довідкового прикладу методу *finalizer* перегляньте "
"реалізацію ``asyncio.Loop.shutdown_asyncgens`` у :source:`Lib/asyncio/"
"base_events.py`."

msgid ""
"The expression ``yield from <expr>`` is a syntax error when used in an "
"asynchronous generator function."
msgstr ""
"Вираз ``yield from <expr>`` є синтаксичною помилкою під час використання у "
"функції асинхронного генератора."

msgid "Asynchronous generator-iterator methods"
msgstr "Методи асинхронного генератора-ітератора"

msgid ""
"This subsection describes the methods of an asynchronous generator iterator, "
"which are used to control the execution of a generator function."
msgstr ""
"У цьому підрозділі описано методи ітератора асинхронного генератора, які "
"використовуються для керування виконанням функції генератора."

msgid ""
"Returns an awaitable which when run starts to execute the asynchronous "
"generator or resumes it at the last executed yield expression.  When an "
"asynchronous generator function is resumed with an :meth:`~agen.__anext__` "
"method, the current yield expression always evaluates to :const:`None` in "
"the returned awaitable, which when run will continue to the next yield "
"expression. The value of the :token:`~python-grammar:expression_list` of the "
"yield expression is the value of the :exc:`StopIteration` exception raised "
"by the completing coroutine.  If the asynchronous generator exits without "
"yielding another value, the awaitable instead raises a :exc:"
"`StopAsyncIteration` exception, signalling that the asynchronous iteration "
"has completed."
msgstr ""
"Повертає awaitable, який під час запуску починає виконувати асинхронний "
"генератор або відновлює його після останнього виконаного виразу yield. Коли "
"функцію асинхронного генератора відновлено за допомогою методу :meth:`~agen."
"__anext__`, поточний вираз yield завжди обчислюється як :const:`None` у "
"поверненому очікуваному, який під час виконання продовжиться до наступного "
"виразу yield. Значення :token:`~python-grammar:expression_list` виразу yield "
"є значенням винятку :exc:`StopIteration`, викликаного завершальною "
"співпрограмою. Якщо асинхронний генератор завершує роботу, не видаючи іншого "
"значення, awaitable натомість викликає виняток :exc:`StopAsyncIteration`, "
"сигналізуючи, що асинхронну ітерацію завершено."

msgid ""
"This method is normally called implicitly by a :keyword:`async for` loop."
msgstr "Цей метод зазвичай викликається неявно циклом :keyword:`async for`."

msgid ""
"Returns an awaitable which when run resumes the execution of the "
"asynchronous generator. As with the :meth:`~generator.send()` method for a "
"generator, this \"sends\" a value into the asynchronous generator function, "
"and the *value* argument becomes the result of the current yield expression. "
"The awaitable returned by the :meth:`asend` method will return the next "
"value yielded by the generator as the value of the raised :exc:"
"`StopIteration`, or raises :exc:`StopAsyncIteration` if the asynchronous "
"generator exits without yielding another value.  When :meth:`asend` is "
"called to start the asynchronous generator, it must be called with :const:"
"`None` as the argument, because there is no yield expression that could "
"receive the value."
msgstr ""
"Повертає awaitable, який після запуску відновлює виконання асинхронного "
"генератора. Як і у випадку з методом :meth:`~generator.send()` для "
"генератора, це \"надсилає\" значення у функцію асинхронного генератора, а "
"аргумент *value* стає результатом поточного виразу yield. Awaitable, "
"повернений методом :meth:`asend`, поверне наступне значення, отримане "
"генератором, як значення підвищеної :exc:`StopIteration`, або підвищить :exc:"
"`StopAsyncIteration`, якщо асинхронний генератор завершує роботу, не даючи "
"іншого. значення. Коли :meth:`asend` викликається для запуску асинхронного "
"генератора, його потрібно викликати з :const:`None` як аргументом, оскільки "
"немає виразу yield, який міг би отримати значення."

msgid ""
"Returns an awaitable that raises an exception of type ``type`` at the point "
"where the asynchronous generator was paused, and returns the next value "
"yielded by the generator function as the value of the raised :exc:"
"`StopIteration` exception.  If the asynchronous generator exits without "
"yielding another value, a :exc:`StopAsyncIteration` exception is raised by "
"the awaitable. If the generator function does not catch the passed-in "
"exception, or raises a different exception, then when the awaitable is run "
"that exception propagates to the caller of the awaitable."
msgstr ""
"Повертає awaitable, який викликає виняток типу ``type`` у точці, де "
"асинхронний генератор було призупинено, і повертає наступне значення, "
"отримане функцією генератора як значення викликаного винятку :exc:"
"`StopIteration`. Якщо асинхронний генератор завершує роботу, не видаючи "
"іншого значення, очікуваний виклик викликає виняток :exc:"
"`StopAsyncIteration`. Якщо функція генератора не перехоплює переданий "
"виняток або викликає інший виняток, тоді, коли виконується очікуваний, цей "
"виняток поширюється на виклик очікуваного."

msgid ""
"Returns an awaitable that when run will throw a :exc:`GeneratorExit` into "
"the asynchronous generator function at the point where it was paused. If the "
"asynchronous generator function then exits gracefully, is already closed, or "
"raises :exc:`GeneratorExit` (by not catching the exception), then the "
"returned awaitable will raise a :exc:`StopIteration` exception. Any further "
"awaitables returned by subsequent calls to the asynchronous generator will "
"raise a :exc:`StopAsyncIteration` exception.  If the asynchronous generator "
"yields a value, a :exc:`RuntimeError` is raised by the awaitable.  If the "
"asynchronous generator raises any other exception, it is propagated to the "
"caller of the awaitable.  If the asynchronous generator has already exited "
"due to an exception or normal exit, then further calls to :meth:`aclose` "
"will return an awaitable that does nothing."
msgstr ""
"Повертає awaitable, який під час виконання видає :exc:`GeneratorExit` у "
"функцію асинхронного генератора в точці, де її було призупинено. Якщо "
"функція асинхронного генератора завершує роботу належним чином, уже закрита "
"або викликає :exc:`GeneratorExit` (не перехоплюючи виняток), тоді повернутий "
"awaitable викличе виняток :exc:`StopIteration`. Будь-які подальші "
"очікування, повернуті наступними викликами асинхронного генератора, "
"викличуть виняток :exc:`StopAsyncIteration`. Якщо асинхронний генератор "
"видає значення, awaitable викликає :exc:`RuntimeError`. Якщо асинхронний "
"генератор викликає будь-який інший виняток, він поширюється на виклик "
"очікуваного. Якщо асинхронний генератор уже завершив роботу через виняток "
"або звичайний вихід, тоді подальші виклики :meth:`aclose` повернуть "
"очікуваний, який нічого не робить."

msgid "Primaries"
msgstr "Праймеріз"

msgid ""
"Primaries represent the most tightly bound operations of the language. Their "
"syntax is:"
msgstr ""
"Основні представляють найбільш тісно зв'язані операції мови. Їх синтаксис:"

msgid "Attribute references"
msgstr "Посилання на атрибути"

msgid "An attribute reference is a primary followed by a period and a name:"
msgstr "Посилання на атрибут є основним, за яким йдуть крапка та ім’я:"

msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce the "
"attribute whose name is the identifier.  This production can be customized "
"by overriding the :meth:`__getattr__` method.  If this attribute is not "
"available, the exception :exc:`AttributeError` is raised.  Otherwise, the "
"type and value of the object produced is determined by the object.  Multiple "
"evaluations of the same attribute reference may yield different objects."
msgstr ""
"Первинний має обчислювати об’єкт типу, який підтримує посилання на атрибути, "
"що більшість об’єктів підтримує. Потім цього об’єкта просять створити "
"атрибут, ім’я якого є ідентифікатором. Цю продукцію можна налаштувати, "
"замінивши метод :meth:`__getattr__`. Якщо цей атрибут недоступний, виникає "
"виняток :exc:`AttributeError`. В іншому випадку тип і вартість виробленого "
"об'єкта визначаються об'єктом. Кілька оцінок одного посилання на атрибути "
"можуть давати різні об’єкти."

msgid "Subscriptions"
msgstr "Підписки"

msgid ""
"The subscription of an instance of a :ref:`container class <sequence-types>` "
"will generally select an element from the container. The subscription of a :"
"term:`generic class <generic type>` will generally return a :ref:"
"`GenericAlias <types-genericalias>` object."
msgstr ""
"Підписка екземпляра :ref:`класу контейнера <sequence-types>` зазвичай "
"вибирає елемент із контейнера. Підписка :term:`загального класу <generic "
"type>` зазвичай повертатиме об’єкт :ref:`GenericAlias <types-genericalias>`."

msgid ""
"When an object is subscripted, the interpreter will evaluate the primary and "
"the expression list."
msgstr ""
"Коли об’єкт має індекс, інтерпретатор обчислить основний і список виразів."

msgid ""
"The primary must evaluate to an object that supports subscription. An object "
"may support subscription through defining one or both of :meth:`~object."
"__getitem__` and :meth:`~object.__class_getitem__`. When the primary is "
"subscripted, the evaluated result of the expression list will be passed to "
"one of these methods. For more details on when ``__class_getitem__`` is "
"called instead of ``__getitem__``, see :ref:`classgetitem-versus-getitem`."
msgstr ""
"Основний має обчислювати об’єкт, який підтримує підписку. Об’єкт може "
"підтримувати підписку через визначення одного або обох :meth:`~object."
"__getitem__` і :meth:`~object.__class_getitem__`. Коли основний має індекс, "
"обчислений результат списку виразів буде передано одному з цих методів. Щоб "
"дізнатися більше про те, коли ``__class_getitem__`` викликається замість "
"``__getitem__``, перегляньте :ref:`classgetitem-versus-getitem`."

msgid ""
"If the expression list contains at least one comma, it will evaluate to a :"
"class:`tuple` containing the items of the expression list. Otherwise, the "
"expression list will evaluate to the value of the list's sole member."
msgstr ""
"Якщо список виразів містить принаймні одну кому, він обчислиться як :class:"
"`tuple`, що містить елементи списку виразів. В іншому випадку список виразів "
"обчислюватиметься значенням єдиного члена списку."

msgid ""
"For built-in objects, there are two types of objects that support "
"subscription via :meth:`~object.__getitem__`:"
msgstr ""
"Для вбудованих об’єктів є два типи об’єктів, які підтримують підписку через :"
"meth:`~object.__getitem__`:"

msgid ""
"Mappings. If the primary is a :term:`mapping`, the expression list must "
"evaluate to an object whose value is one of the keys of the mapping, and the "
"subscription selects the value in the mapping that corresponds to that key. "
"An example of a builtin mapping class is the :class:`dict` class."
msgstr ""
"Відображення. Якщо основним є :term:`mapping`, список виразів має "
"обчислювати об’єкт, значення якого є одним із ключів відображення, а "
"підписка вибирає значення у відображенні, яке відповідає цьому ключу. "
"Прикладом вбудованого класу відображення є клас :class:`dict`."

msgid ""
"Sequences. If the primary is a :term:`sequence`, the expression list must "
"evaluate to an :class:`int` or a :class:`slice` (as discussed in the "
"following section). Examples of builtin sequence classes include the :class:"
"`str`, :class:`list` and :class:`tuple` classes."
msgstr ""
"Послідовності. Якщо основним є :term:`sequence`, список виразів має "
"обчислюватися як :class:`int` або :class:`slice` (як описано в наступному "
"розділі). Приклади вбудованих класів послідовності включають класи :class:"
"`str`, :class:`list` і :class:`tuple`."

msgid ""
"The formal syntax makes no special provision for negative indices in :term:"
"`sequences <sequence>`. However, built-in sequences all provide a :meth:"
"`~object.__getitem__` method that interprets negative indices by adding the "
"length of the sequence to the index so that, for example, ``x[-1]`` selects "
"the last item of ``x``. The resulting value must be a nonnegative integer "
"less than the number of items in the sequence, and the subscription selects "
"the item whose index is that value (counting from zero). Since the support "
"for negative indices and slicing occurs in the object's :meth:`__getitem__` "
"method, subclasses overriding this method will need to explicitly add that "
"support."
msgstr ""
"Формальний синтаксис не містить спеціальних положень щодо від’ємних індексів "
"у :term:`послідовностях <sequence>`. Однак усі вбудовані послідовності "
"забезпечують метод :meth:`~object.__getitem__`, який інтерпретує негативні "
"індекси, додаючи довжину послідовності до індексу, щоб, наприклад, ``x[-1]`` "
"вибирати останній елемент ``x``. Отримане значення має бути невід’ємним "
"цілим числом, меншим за кількість елементів у послідовності, і підписка "
"вибирає елемент, індекс якого є цим значенням (відлік від нуля). Оскільки "
"підтримка негативних індексів і нарізки відбувається в методі :meth:"
"`__getitem__` об’єкта, підкласи, які замінюють цей метод, повинні будуть "
"явно додати цю підтримку."

msgid ""
"A :class:`string <str>` is a special kind of sequence whose items are "
"*characters*. A character is not a separate data type but a string of "
"exactly one character."
msgstr ""
":class:`string <str>` — це особливий вид послідовності, елементами якої є "
"*символи*. Символ — це не окремий тип даних, а рядок із рівно одного символу."

msgid "Slicings"
msgstr "Нарізки"

msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""
"Нарізка вибирає діапазон елементів в об’єкті послідовності (наприклад, "
"рядок, кортеж або список). Зрізи можуть використовуватися як вирази або як "
"цілі в операторах призначення або :keyword:`del`. Синтаксис нарізки:"

msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an "
"expression list also looks like a slice list, so any subscription can be "
"interpreted as a slicing.  Rather than further complicating the syntax, this "
"is disambiguated by defining that in this case the interpretation as a "
"subscription takes priority over the interpretation as a slicing (this is "
"the case if the slice list contains no proper slice)."
msgstr ""
"Тут існує неоднозначність у формальному синтаксисі: все, що виглядає як "
"список виразів, також виглядає як список фрагментів, тому будь-яку підписку "
"можна інтерпретувати як фрагмент. Замість подальшого ускладнення синтаксису, "
"це усувається визначенням того, що в цьому випадку інтерпретація як підписка "
"має пріоритет над інтерпретацією як нарізка (це випадок, якщо список зрізів "
"не містить належного зрізу)."

msgid ""
"The semantics for a slicing are as follows.  The primary is indexed (using "
"the same :meth:`__getitem__` method as normal subscription) with a key that "
"is constructed from the slice list, as follows.  If the slice list contains "
"at least one comma, the key is a tuple containing the conversion of the "
"slice items; otherwise, the conversion of the lone slice item is the key.  "
"The conversion of a slice item that is an expression is that expression.  "
"The conversion of a proper slice is a slice object (see section :ref:"
"`types`) whose :attr:`~slice.start`, :attr:`~slice.stop` and :attr:`~slice."
"step` attributes are the values of the expressions given as lower bound, "
"upper bound and stride, respectively, substituting ``None`` for missing "
"expressions."
msgstr ""
"Семантика нарізки така. Основний індексується (використовуючи той самий "
"метод :meth:`__getitem__`, що й звичайна підписка) за допомогою ключа, "
"створеного зі списку фрагментів, як показано нижче. Якщо список фрагментів "
"містить принаймні одну кому, ключ є кортежем, що містить перетворення "
"елементів фрагмента; в іншому випадку ключовим є перетворення елемента "
"окремого фрагмента. Перетворення елемента фрагмента, який є виразом, є цим "
"виразом. Перетворення правильного фрагмента є об’єктом фрагмента (див. "
"розділ :ref:`types`), у якого :attr:`~slice.start`, :attr:`~slice.stop` і :"
"attr:`~slice.step` Атрибути — це значення виразів, поданих як нижня межа, "
"верхня межа та крок, відповідно, замінюючи відсутні вирази на ``None``."

msgid "Calls"
msgstr "Дзвінки"

msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly "
"empty series of :term:`arguments <argument>`:"
msgstr ""
"Виклик викликає об’єкт, який можна викликати (наприклад, :term:`function`) з "
"можливо порожньою серією :term:`аргументів <argument>`:"

msgid ""
"An optional trailing comma may be present after the positional and keyword "
"arguments but does not affect the semantics."
msgstr ""
"Необов’язкова кінцева кома може бути присутнім після позиційних і ключових "
"аргументів, але не впливає на семантику."

msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods of "
"class instances, and all objects having a :meth:`__call__` method are "
"callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of "
"formal :term:`parameter` lists."
msgstr ""
"Основний має обчислювати об’єкт, який можна викликати (визначені "
"користувачем функції, вбудовані функції, методи вбудованих об’єктів, об’єкти "
"класу, методи екземплярів класу та всі об’єкти, що мають метод :meth:"
"`__call__`, є викликаними). Усі вирази аргументів оцінюються перед спробою "
"виклику. Зверніться до розділу :ref:`function` щодо синтаксису формальних "
"списків :term:`parameter`."

msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for the "
"formal parameters.  If there are N positional arguments, they are placed in "
"the first N slots.  Next, for each keyword argument, the identifier is used "
"to determine the corresponding slot (if the identifier is the same as the "
"first formal parameter name, the first slot is used, and so on).  If the "
"slot is already filled, a :exc:`TypeError` exception is raised. Otherwise, "
"the argument is placed in the slot, filling it (even if the expression is "
"``None``, it fills the slot).  When all arguments have been processed, the "
"slots that are still unfilled are filled with the corresponding default "
"value from the function definition.  (Default values are calculated, once, "
"when the function is defined; thus, a mutable object such as a list or "
"dictionary used as default value will be shared by all calls that don't "
"specify an argument value for the corresponding slot; this should usually be "
"avoided.)  If there are any unfilled slots for which no default value is "
"specified, a :exc:`TypeError` exception is raised.  Otherwise, the list of "
"filled slots is used as the argument list for the call."
msgstr ""

msgid ""
"An implementation may provide built-in functions whose positional parameters "
"do not have names, even if they are 'named' for the purpose of "
"documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use :c:func:"
"`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"Реалізація може надавати вбудовані функції, чиї позиційні параметри не мають "
"імен, навіть якщо вони \"іменовані\" з метою документації, і які, отже, не "
"можуть бути надані за ключовими словами. У CPython це стосується функцій, "
"реалізованих у C, які використовують :c:func:`PyArg_ParseTuple` для аналізу "
"своїх аргументів."

msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or an "
"empty tuple if there were no excess positional arguments)."
msgstr ""
"Якщо позиційних аргументів більше, ніж слотів формальних параметрів, виникає "
"виняток :exc:`TypeError`, якщо не існує формального параметра, що "
"використовує синтаксис ``*identifier``; у цьому випадку формальний параметр "
"отримує кортеж, що містить зайві позиційні аргументи (або порожній кортеж, "
"якщо надлишкових позиційних аргументів не було)."

msgid ""
"If any keyword argument does not correspond to a formal parameter name, a :"
"exc:`TypeError` exception is raised, unless a formal parameter using the "
"syntax ``**identifier`` is present; in this case, that formal parameter "
"receives a dictionary containing the excess keyword arguments (using the "
"keywords as keys and the argument values as corresponding values), or a "
"(new) empty dictionary if there were no excess keyword arguments."
msgstr ""
"Якщо будь-який аргумент ключового слова не відповідає офіційній назві "
"параметра, виникає виняток :exc:`TypeError`, якщо не існує формального "
"параметра, що використовує синтаксис ``**ідентифікатор``; у цьому випадку "
"формальний параметр отримує словник, що містить надлишкові аргументи "
"ключового слова (з використанням ключових слів як ключів і значень "
"аргументів як відповідних значень), або (новий) порожній словник, якщо не "
"було надлишкових аргументів ключового слова."

msgid ""
"If the syntax ``*expression`` appears in the function call, ``expression`` "
"must evaluate to an :term:`iterable`.  Elements from these iterables are "
"treated as if they were additional positional arguments.  For the call "
"``f(x1, x2, *y, x3, x4)``, if *y* evaluates to a sequence *y1*, ..., *yM*, "
"this is equivalent to a call with M+4 positional arguments *x1*, *x2*, "
"*y1*, ..., *yM*, *x3*, *x4*."
msgstr ""
"Якщо у виклику функції з’являється синтаксис ``*expression``, ``expression`` "
"має обчислюватися як :term:`iterable`. Елементи з цих ітерованих елементів "
"розглядаються як додаткові позиційні аргументи. Для виклику ``f(x1, x2, *y, "
"x3, x4)``, якщо *y* обчислюється як послідовність *y1*, ..., *yM*, це "
"еквівалентно виклику з M+ 4 позиційні аргументи *x1*, *x2*, *y1*, ..., *yM*, "
"*x3*, *x4*."

msgid ""
"A consequence of this is that although the ``*expression`` syntax may appear "
"*after* explicit keyword arguments, it is processed *before* the keyword "
"arguments (and any ``**expression`` arguments -- see below).  So::"
msgstr ""
"Наслідком цього є те, що хоча синтаксис ``*виразу`` може з’явитися *після* "
"явних аргументів ключового слова, він обробляється *перед* аргументами "
"ключового слова (та будь-якими аргументами ``**виразу`` – див. нижче). Тому::"

msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax to "
"be used in the same call, so in practice this confusion does not often arise."
msgstr ""

msgid ""
"If the syntax ``**expression`` appears in the function call, ``expression`` "
"must evaluate to a :term:`mapping`, the contents of which are treated as "
"additional keyword arguments. If a parameter matching a key has already been "
"given a value (by an explicit keyword argument, or from another unpacking), "
"a :exc:`TypeError` exception is raised."
msgstr ""

msgid ""
"When ``**expression`` is used, each key in this mapping must be a string. "
"Each value from the mapping is assigned to the first formal parameter "
"eligible for keyword assignment whose name is equal to the key. A key need "
"not be a Python identifier (e.g. ``\"max-temp °F\"`` is acceptable, although "
"it will not match any formal parameter that could be declared). If there is "
"no match to a formal parameter the key-value pair is collected by the ``**`` "
"parameter, if there is one, or if there is not, a :exc:`TypeError` exception "
"is raised."
msgstr ""

msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr ""
"Формальні параметри, що використовують синтаксис ``*ідентифікатор`` або "
"``**ідентифікатор``, не можуть використовуватися як слоти позиційних "
"аргументів або як імена аргументів ключових слів."

msgid ""
"Function calls accept any number of ``*`` and ``**`` unpackings, positional "
"arguments may follow iterable unpackings (``*``), and keyword arguments may "
"follow dictionary unpackings (``**``). Originally proposed by :pep:`448`."
msgstr ""
"Виклики функцій приймають будь-яку кількість розпакувань ``*`` і ``**``, "
"позиційні аргументи можуть слідувати за ітерованими розпакуваннями (``*``), "
"а аргументи ключових слів можуть слідувати за розпакуваннями словника "
"(``**``). Спочатку запропоновано :pep:`448`."

msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the callable "
"object."
msgstr ""
"Виклик завжди повертає певне значення, можливо, ``None``, якщо тільки це не "
"викликає виняткову ситуацію. Спосіб обчислення цього значення залежить від "
"типу викликаного об’єкта."

msgid "If it is---"
msgstr "Якщо це---"

msgid "a user-defined function:"
msgstr "функція, визначена користувачем:"

msgid ""
"The code block for the function is executed, passing it the argument list.  "
"The first thing the code block will do is bind the formal parameters to the "
"arguments; this is described in section :ref:`function`.  When the code "
"block executes a :keyword:`return` statement, this specifies the return "
"value of the function call."
msgstr ""
"Блок коду для функції виконується, передаючи їй список аргументів. Перше, що "
"зробить блок коду, це прив’яже формальні параметри до аргументів; це описано "
"в розділі :ref:`function`. Коли блок коду виконує оператор :keyword:"
"`return`, це визначає значення, що повертається викликом функції."

msgid "a built-in function or method:"
msgstr "вбудована функція або метод:"

msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr ""
"Результат залежить від перекладача; див. :ref:`built-in-funcs` для опису "
"вбудованих функцій і методів."

msgid "a class object:"
msgstr "об'єкт класу:"

msgid "A new instance of that class is returned."
msgstr "Повертається новий екземпляр цього класу."

msgid "a class instance method:"
msgstr "метод екземпляра класу:"

msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance becomes "
"the first argument."
msgstr ""
"Викликається відповідна функція, визначена користувачем, зі списком "
"аргументів, який на один довший за список аргументів виклику: екземпляр стає "
"першим аргументом."

msgid "a class instance:"
msgstr "екземпляр класу:"

msgid ""
"The class must define a :meth:`__call__` method; the effect is then the same "
"as if that method was called."
msgstr ""
"Клас повинен визначати метод :meth:`__call__`; тоді ефект буде таким самим, "
"якби цей метод був викликаний."

msgid "Await expression"
msgstr "Очікуйте вираження"

msgid ""
"Suspend the execution of :term:`coroutine` on an :term:`awaitable` object. "
"Can only be used inside a :term:`coroutine function`."
msgstr ""
"Призупинити виконання :term:`coroutine` на об’єкті :term:`awaitable`. Можна "
"використовувати лише всередині функції співпрограми (:term:`coroutine "
"function`)."

msgid "The power operator"
msgstr "Оператор енергетики"

msgid ""
"The power operator binds more tightly than unary operators on its left; it "
"binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""
"Потужний оператор прив’язується сильніше, ніж унарні оператори зліва; він "
"зв'язується менш тісно, ніж унарні оператори справа. Синтаксис:"

msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""
"Таким чином, у послідовності степеневих і унарних операторів без дужок "
"оператори обчислюються справа наліво (це не обмежує порядок обчислення для "
"операндів): ``-1**2`` призводить до ``-1`` ."

msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument raised "
"to the power of its right argument.  The numeric arguments are first "
"converted to a common type, and the result is of that type."
msgstr ""
"Оператор ступеня має таку саму семантику, як і вбудована функція :func:"
"`pow`, коли викликається з двома аргументами: він повертає свій лівий "
"аргумент, зведений до степеня правого аргументу. Числові аргументи спочатку "
"перетворюються на загальний тип, і результат має відповідний тип."

msgid ""
"For int operands, the result has the same type as the operands unless the "
"second argument is negative; in that case, all arguments are converted to "
"float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""
"Для операндів int результат має той самий тип, що й операнди, якщо другий "
"аргумент не є від’ємним; у цьому випадку всі аргументи перетворюються на "
"значення float і видає результат float. Наприклад, ``10**2`` повертає "
"``100``, а ``10**-2`` повертає ``0,01``."

msgid ""
"Raising ``0.0`` to a negative power results in a :exc:`ZeroDivisionError`. "
"Raising a negative number to a fractional power results in a :class:"
"`complex` number. (In earlier versions it raised a :exc:`ValueError`.)"
msgstr ""
"Піднесення ``0.0`` до негативного степеня призводить до :exc:"
"`ZeroDivisionError`. Зведення від’ємного числа до дробового степеня "
"призводить до :class:`complex` числа. (У попередніх версіях це викликало :"
"exc:`ValueError`.)"

msgid ""
"This operation can be customized using the special :meth:`__pow__` method."
msgstr ""
"Цю операцію можна налаштувати за допомогою спеціального методу :meth:"
"`__pow__`."

msgid "Unary arithmetic and bitwise operations"
msgstr "Унарні арифметичні та порозрядні операції"

msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr ""
"Усі унарні арифметичні та порозрядні операції мають однаковий пріоритет:"

msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric "
"argument; the operation can be overridden with the :meth:`__neg__` special "
"method."
msgstr ""
"Унарний оператор ``-`` (мінус) дає заперечення свого числового аргументу; "
"операцію можна перевизначити спеціальним методом :meth:`__neg__`."

msgid ""
"The unary ``+`` (plus) operator yields its numeric argument unchanged; the "
"operation can be overridden with the :meth:`__pos__` special method."
msgstr ""
"Унарний оператор ``+`` (плюс) повертає свій числовий аргумент без змін; "
"операцію можна перевизначити спеціальним методом :meth:`__pos__`."

msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as ``-(x+1)``.  "
"It only applies to integral numbers or to custom objects that override the :"
"meth:`__invert__` special method."
msgstr ""
"Унарний оператор ``~`` (інвертування) дає порозрядну інверсію свого "
"цілочисельного аргументу. Побітова інверсія ``x`` визначається як ``-"
"(x+1)``. Це стосується лише цілих чисел або користувацьких об’єктів, які "
"замінюють спеціальний метод :meth:`__invert__`."

msgid ""
"In all three cases, if the argument does not have the proper type, a :exc:"
"`TypeError` exception is raised."
msgstr ""
"В усіх трьох випадках, якщо аргумент не має належного типу, виникає виняток :"
"exc:`TypeError`."

msgid "Binary arithmetic operations"
msgstr "Двійкові арифметичні операції"

msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric types.  "
"Apart from the power operator, there are only two levels, one for "
"multiplicative operators and one for additive operators:"
msgstr ""
"Двійкові арифметичні операції мають загальноприйняті рівні пріоритету. "
"Зверніть увагу, що деякі з цих операцій також застосовуються до певних "
"нечислових типів. Окрім оператора степеня, існує лише два рівні: один для "
"мультиплікативних операторів і один для адитивних операторів:"

msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments.  "
"The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers "
"are converted to a common type and then multiplied together.  In the latter "
"case, sequence repetition is performed; a negative repetition factor yields "
"an empty sequence."
msgstr ""
"Оператор ``*`` (множення) повертає добуток своїх аргументів. Обидва "
"аргументи мають бути числами, або один аргумент має бути цілим числом, а "
"інший — послідовністю. У першому випадку числа перетворюються на загальний "
"тип, а потім перемножуються. В останньому випадку виконується повторення "
"послідовності; негативний коефіцієнт повторення дає порожню послідовність."

msgid ""
"This operation can be customized using the special :meth:`__mul__` and :meth:"
"`__rmul__` methods."
msgstr ""
"Цю операцію можна налаштувати за допомогою спеціальних методів :meth:"
"`__mul__` і :meth:`__rmul__`."

msgid ""
"The ``@`` (at) operator is intended to be used for matrix multiplication.  "
"No builtin Python types implement this operator."
msgstr ""
"Оператор ``@`` (at) призначений для використання для множення матриці. Жодні "
"вбудовані типи Python не реалізують цей оператор."

msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted to a "
"common type. Division of integers yields a float, while floor division of "
"integers results in an integer; the result is that of mathematical division "
"with the 'floor' function applied to the result.  Division by zero raises "
"the :exc:`ZeroDivisionError` exception."
msgstr ""
"Оператори ``/`` (поділ) і ``//`` (поділ на поверх) видають приватне своїх "
"аргументів. Числові аргументи спочатку перетворюються на загальний тип. "
"Ділення цілих чисел дає значення з плаваючою точкою, а поділення цілих чисел "
"дає ціле число; результатом є математичне ділення із застосованою до "
"результату функцією \"підлога\". Ділення на нуль викликає виключення :exc:"
"`ZeroDivisionError`."

msgid ""
"This operation can be customized using the special :meth:`__truediv__` and :"
"meth:`__floordiv__` methods."
msgstr ""
"Цю операцію можна налаштувати за допомогою спеціальних методів :meth:"
"`__truediv__` і :meth:`__floordiv__`."

msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the "
"first argument by the second.  The numeric arguments are first converted to "
"a common type.  A zero right argument raises the :exc:`ZeroDivisionError` "
"exception.  The arguments may be floating point numbers, e.g., ``3.14%0.7`` "
"equals ``0.34`` (since ``3.14`` equals ``4*0.7 + 0.34``.)  The modulo "
"operator always yields a result with the same sign as its second operand (or "
"zero); the absolute value of the result is strictly smaller than the "
"absolute value of the second operand [#]_."
msgstr ""
"Оператор ``%`` (по модулю) дає залишок від ділення першого аргументу на "
"другий. Числові аргументи спочатку перетворюються на загальний тип. Нульовий "
"правий аргумент викликає виняток :exc:`ZeroDivisionError`. Аргументи можуть "
"бути числами з плаваючою комою, наприклад, \"3,14%0,7\" дорівнює "
"\"0,34\" (оскільки \"3,14\" дорівнює \"4*0,7 + 0,34\"). Оператор модуля "
"завжди дає результат із той же знак, що і його другий операнд (або нуль); "
"абсолютне значення результату строго менше, ніж абсолютне значення другого "
"операнда [#]_."

msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == (x//"
"y, x%y)``. [#]_."
msgstr ""
"Оператори поділу поверху та модульні оператори з’єднані такою тотожністю: "
"``x == (x//y)*y + (x%y)``. Поділ на поверх і модуль також пов’язані з "
"вбудованою функцією :func:`divmod`: ``divmod(x, y) == (x//y, x%y)``. [#]_."

msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string "
"formatting (also known as interpolation).  The syntax for string formatting "
"is described in the Python Library Reference, section :ref:`old-string-"
"formatting`."
msgstr ""
"На додаток до виконання операції за модулем над числами, оператор ``%`` "
"також перевантажується рядковими об’єктами для виконання старого "
"форматування рядків (також відомого як інтерполяція). Синтаксис для "
"форматування рядків описано в Довіднику з бібліотеки Python, розділ :ref:"
"`old-string-formatting`."

msgid ""
"The *modulo* operation can be customized using the special :meth:`__mod__` "
"method."
msgstr ""
"Операцію *modulo* можна налаштувати за допомогою спеціального методу :meth:"
"`__mod__`."

msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""
"Оператор поверхового ділення, оператор модуля та функція :func:`divmod` не "
"визначені для комплексних чисел. Замість цього перетворіть на число з "
"плаваючою комою за допомогою функції :func:`abs`, якщо потрібно."

msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both be sequences of the same "
"type.  In the former case, the numbers are converted to a common type and "
"then added together. In the latter case, the sequences are concatenated."
msgstr ""
"Оператор ``+`` (додавання) повертає суму своїх аргументів. Обидва аргументи "
"мають бути числами або обома послідовностями одного типу. У першому випадку "
"числа перетворюються на загальний тип, а потім сумуються. В останньому "
"випадку послідовності об’єднані."

msgid ""
"This operation can be customized using the special :meth:`__add__` and :meth:"
"`__radd__` methods."
msgstr ""
"Цю операцію можна налаштувати за допомогою спеціальних методів :meth:"
"`__add__` і :meth:`__radd__`."

msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments.  "
"The numeric arguments are first converted to a common type."
msgstr ""
"Оператор ``-`` (віднімання) повертає різницю своїх аргументів. Числові "
"аргументи спочатку перетворюються на загальний тип."

msgid ""
"This operation can be customized using the special :meth:`__sub__` method."
msgstr ""
"Цю операцію можна налаштувати за допомогою спеціального методу :meth:"
"`__sub__`."

msgid "Shifting operations"
msgstr "Змінні операції"

msgid ""
"The shifting operations have lower priority than the arithmetic operations:"
msgstr "Операції зсуву мають нижчий пріоритет, ніж арифметичні операції:"

msgid ""
"These operators accept integers as arguments.  They shift the first argument "
"to the left or right by the number of bits given by the second argument."
msgstr ""
"Ці оператори приймають цілі числа як аргументи. Вони зсувають перший "
"аргумент вліво або вправо на кількість бітів, задану другим аргументом."

msgid ""
"This operation can be customized using the special :meth:`__lshift__` and :"
"meth:`__rshift__` methods."
msgstr ""
"Цю операцію можна налаштувати за допомогою спеціальних методів :meth:"
"`__lshift__` і :meth:`__rshift__`."

msgid ""
"A right shift by *n* bits is defined as floor division by ``pow(2,n)``.  A "
"left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""
"Зсув праворуч на *n* бітів визначається як нижнє ділення на ``pow(2,n)``. "
"Зсув ліворуч на *n* бітів визначається як множення на ``pow(2,n)``."

msgid "Binary bitwise operations"
msgstr "Бінарні побітові операції"

msgid "Each of the three bitwise operations has a different priority level:"
msgstr "Кожна з трьох побітових операцій має різний рівень пріоритету:"

msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be "
"integers or one of them must be a custom object overriding :meth:`__and__` "
"or :meth:`__rand__` special methods."
msgstr ""
"Оператор ``&`` повертає порозрядне І своїх аргументів, які мають бути цілими "
"числами або один із них має бути спеціальним об’єктом, що перекриває "
"спеціальні методи :meth:`__and__` або :meth:`__rand__`."

msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its arguments, "
"which must be integers or one of them must be a custom object overriding :"
"meth:`__xor__` or :meth:`__rxor__` special methods."
msgstr ""
"Оператор ``^`` повертає порозрядне XOR (виключаюче АБО) своїх аргументів, "
"які мають бути цілими числами або один із них має бути спеціальним об’єктом, "
"що перекриває спеціальні методи :meth:`__xor__` або :meth:`__rxor__`."

msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, which "
"must be integers or one of them must be a custom object overriding :meth:"
"`__or__` or :meth:`__ror__` special methods."
msgstr ""
"Оператор ``|`` повертає порозрядне (включне) АБО своїх аргументів, які мають "
"бути цілими числами або один із них має бути спеціальним об’єктом, що "
"перекриває спеціальні методи :meth:`__or__` або :meth:`__ror__`."

msgid "Comparisons"
msgstr "Порівняння"

msgid ""
"Unlike C, all comparison operations in Python have the same priority, which "
"is lower than that of any arithmetic, shifting or bitwise operation.  Also "
"unlike C, expressions like ``a < b < c`` have the interpretation that is "
"conventional in mathematics:"
msgstr ""
"На відміну від C, усі операції порівняння в Python мають однаковий "
"пріоритет, який нижчий, ніж у будь-якої арифметичної операції, операції "
"зсуву чи побітової операції. Крім того, на відміну від C, такі вирази, як "
"``a < b < c``, мають тлумачення, яке є звичайним у математиці:"

msgid ""
"Comparisons yield boolean values: ``True`` or ``False``. Custom :dfn:`rich "
"comparison methods` may return non-boolean values. In this case Python will "
"call :func:`bool` on such value in boolean contexts."
msgstr ""
"Порівняння дають логічні значення: ``True`` або ``False``. Спеціальні :dfn:"
"`rich comparison methods` можуть повертати не логічні значення. У цьому "
"випадку Python викличе :func:`bool` для такого значення в логічних "
"контекстах."

msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is equivalent "
"to ``x < y and y <= z``, except that ``y`` is evaluated only once (but in "
"both cases ``z`` is not evaluated at all when ``x < y`` is found to be "
"false)."
msgstr ""
"Порівняння можна довільно об’єднати в ланцюжок, наприклад, ``x < y <= z`` "
"еквівалентно ``x < y і y <= z``, за винятком того, що ``y`` обчислюється "
"лише один раз (але в обох випадках ``z`` взагалі не обчислюється, якщо ``x < "
"y`` виявляється хибним)."

msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y opN "
"z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except that "
"each expression is evaluated at most once."
msgstr ""
"Формально, якщо *a*, *b*, *c*, ..., *y*, *z* є виразами, а *op1*, "
"*op2*, ..., *opN* є операторами порівняння, тоді ``a op1 b op2 c ... y opN "
"z`` еквівалентний ``a op1 b і b op2 c і ... y opN z``, за винятком того, що "
"кожен вираз обчислюється щонайбільше один раз."

msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between *a* "
"and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though perhaps not "
"pretty)."
msgstr ""
"Зауважте, що ``a op1 b op2 c`` не передбачає жодного порівняння між *a* і "
"*c*, тому, наприклад, ``x < y > z`` є абсолютно законним (хоча, можливо, не "
"дуже)."

msgid "Value comparisons"
msgstr "Порівняння цінностей"

msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare the "
"values of two objects.  The objects do not need to have the same type."
msgstr ""
"Оператори ``<``, ``>``, ``==``, ``>=``, ``<=`` і ``!=`` порівнюють значення "
"двох об’єктів. Об’єкти не обов’язково мають однаковий тип."

msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to type "
"and identity).  The value of an object is a rather abstract notion in "
"Python: For example, there is no canonical access method for an object's "
"value.  Also, there is no requirement that the value of an object should be "
"constructed in a particular way, e.g. comprised of all its data attributes. "
"Comparison operators implement a particular notion of what the value of an "
"object is.  One can think of them as defining the value of an object "
"indirectly, by means of their comparison implementation."
msgstr ""
"У розділі :ref:`objects` зазначено, що об’єкти мають значення (крім типу та "
"ідентичності). Значення об’єкта є досить абстрактним поняттям у Python: "
"наприклад, не існує канонічного методу доступу до значення об’єкта. Крім "
"того, немає вимоги, щоб значення об’єкта було сконструйовано певним чином, "
"напр. складається з усіх своїх атрибутів даних. Оператори порівняння "
"реалізують певне уявлення про цінність об’єкта. Можна думати про них як про "
"визначення значення об’єкта опосередковано, за допомогою реалізації "
"порівняння."

msgid ""
"Because all types are (direct or indirect) subtypes of :class:`object`, they "
"inherit the default comparison behavior from :class:`object`.  Types can "
"customize their comparison behavior by implementing :dfn:`rich comparison "
"methods` like :meth:`__lt__`, described in :ref:`customization`."
msgstr ""
"Оскільки всі типи є (прямими чи непрямими) підтипами :class:`object`, вони "
"успадковують типову поведінку порівняння від :class:`object`. Типи можуть "
"налаштувати свою поведінку порівняння, реалізувавши :dfn:`багаті методи "
"порівняння`, такі як :meth:`__lt__`, описані в :ref:`customization`."

msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based on "
"the identity of the objects.  Hence, equality comparison of instances with "
"the same identity results in equality, and equality comparison of instances "
"with different identities results in inequality.  A motivation for this "
"default behavior is the desire that all objects should be reflexive (i.e. "
"``x is y`` implies ``x == y``)."
msgstr ""
"Поведінка за умовчанням для порівняння рівності (``==`` і ``!=``) базується "
"на ідентичності об’єктів. Отже, порівняння рівності екземплярів з однаковою "
"тотожністю призводить до рівності, а порівняння рівності екземплярів з "
"різними ідентичністями призводить до нерівності. Мотивацією такої поведінки "
"за замовчуванням є бажання, щоб усі об’єкти були рефлексивними (тобто ``x є "
"y`` означає ``x == y``)."

msgid ""
"A default order comparison (``<``, ``>``, ``<=``, and ``>=``) is not "
"provided; an attempt raises :exc:`TypeError`.  A motivation for this default "
"behavior is the lack of a similar invariant as for equality."
msgstr ""
"Порівняння порядку за замовчуванням (``<``, ``>``, ``<=``, and ``> =``) не "
"надається; спроба викликає :exc:`TypeError`. Мотивацією такої поведінки за "
"замовчуванням є відсутність аналогічного інваріанта, як для рівності."

msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types "
"will need that have a sensible definition of object value and value-based "
"equality.  Such types will need to customize their comparison behavior, and "
"in fact, a number of built-in types have done that."
msgstr ""
"Поведінка порівняння рівності за замовчуванням, тобто екземпляри з різними "
"ідентифікаторами завжди нерівні, може відрізнятися від того, які типи "
"потребуватимуть розумного визначення значення об’єкта та рівності на основі "
"значення. Таким типам потрібно буде налаштувати свою поведінку порівняння, і "
"насправді це зробили кілька вбудованих типів."

msgid ""
"The following list describes the comparison behavior of the most important "
"built-in types."
msgstr ""
"У наведеному нижче списку описано поведінку порівняння найважливіших "
"вбудованих типів."

msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the standard "
"library types :class:`fractions.Fraction` and :class:`decimal.Decimal` can "
"be compared within and across their types, with the restriction that complex "
"numbers do not support order comparison.  Within the limits of the types "
"involved, they compare mathematically (algorithmically) correct without loss "
"of precision."
msgstr ""
"Числа вбудованих числових типів (:ref:`typesnumeric`) і стандартних "
"бібліотечних типів :class:`fractions.Fraction` і :class:`decimal.Decimal` "
"можна порівнювати всередині та між типами, з обмеженням що комплексні числа "
"не підтримують порівняння порядку. У межах залучених типів вони порівнюють "
"математично (алгоритмічно) правильно без втрати точності."

msgid ""
"The not-a-number values ``float('NaN')`` and ``decimal.Decimal('NaN')`` are "
"special.  Any ordered comparison of a number to a not-a-number value is "
"false. A counter-intuitive implication is that not-a-number values are not "
"equal to themselves.  For example, if ``x = float('NaN')``, ``3 < x``, ``x < "
"3`` and ``x == x`` are all false, while ``x != x`` is true.  This behavior "
"is compliant with IEEE 754."
msgstr ""
"Нечислові значення ``float('NaN')`` і ``decimal.Decimal('NaN')`` є "
"спеціальними. Будь-яке впорядковане порівняння числа з нечисловим значенням "
"є хибним. Протиінтуїтивний висновок полягає в тому, що нечислові значення не "
"дорівнюють самі собі. Наприклад, якщо ``x = float('NaN')``, ``3 < x``, ``x < "
"3`` і ``x == x`` є помилковими, тоді як ``x ! = x`` вірно. Така поведінка "
"відповідає стандарту IEEE 754."

msgid ""
"``None`` and ``NotImplemented`` are singletons.  :PEP:`8` advises that "
"comparisons for singletons should always be done with ``is`` or ``is not``, "
"never the equality operators."
msgstr ""
"``None`` і ``NotImplemented`` є одиночними елементами. :PEP:`8` радить, що "
"порівняння одиночних елементів завжди слід виконувати за допомогою ``is`` "
"або ``is not``, а не операторів рівності."

msgid ""
"Binary sequences (instances of :class:`bytes` or :class:`bytearray`) can be "
"compared within and across their types.  They compare lexicographically "
"using the numeric values of their elements."
msgstr ""
"Двійкові послідовності (екземпляри :class:`bytes` або :class:`bytearray`) "
"можна порівнювати всередині та між типами. Вони порівнюють лексикографічно, "
"використовуючи числові значення своїх елементів."

msgid ""
"Strings (instances of :class:`str`) compare lexicographically using the "
"numerical Unicode code points (the result of the built-in function :func:"
"`ord`) of their characters. [#]_"
msgstr ""
"Рядки (примірники :class:`str`) порівнюються лексикографічно за допомогою "
"числових кодових точок Unicode (результат вбудованої функції :func:`ord`) "
"їхніх символів. [#]_"

msgid "Strings and binary sequences cannot be directly compared."
msgstr "Рядки та двійкові послідовності не можна безпосередньо порівнювати."

msgid ""
"Sequences (instances of :class:`tuple`, :class:`list`, or :class:`range`) "
"can be compared only within each of their types, with the restriction that "
"ranges do not support order comparison.  Equality comparison across these "
"types results in inequality, and ordering comparison across these types "
"raises :exc:`TypeError`."
msgstr ""
"Послідовності (екземпляри :class:`tuple`, :class:`list` або :class:`range`) "
"можна порівнювати лише в межах кожного зі своїх типів, з обмеженням, що "
"діапазони не підтримують порівняння порядку. Порівняння рівності між цими "
"типами призводить до нерівності, а впорядковане порівняння між цими типами "
"викликає :exc:`TypeError`."

msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements.  The built-in containers typically assume identical objects are "
"equal to themselves.  That lets them bypass equality tests for identical "
"objects to improve performance and to maintain their internal invariants."
msgstr ""
"Послідовності порівнюють лексикографічно за допомогою порівняння відповідних "
"елементів. Вбудовані контейнери зазвичай припускають, що ідентичні об’єкти "
"рівні самі собі. Це дозволяє їм обійти тести на рівність для ідентичних "
"об’єктів, щоб підвищити продуктивність і зберегти свої внутрішні інваріанти."

msgid ""
"Lexicographical comparison between built-in collections works as follows:"
msgstr ""
"Лексикографічне порівняння між вбудованими колекціями працює таким чином:"

msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal "
"(for example, ``[1,2] == (1,2)`` is false because the type is not the same)."
msgstr ""
"Щоб дві колекції порівнювалися однаково, вони повинні бути одного типу, мати "
"однакову довжину, і кожна пара відповідних елементів має порівнюватися "
"однаковими (наприклад, ``[1,2] == (1,2)`` false, оскільки тип не той самий)."

msgid ""
"Collections that support order comparison are ordered the same as their "
"first unequal elements (for example, ``[1,2,x] <= [1,2,y]`` has the same "
"value as ``x <= y``).  If a corresponding element does not exist, the "
"shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is "
"true)."
msgstr ""
"Колекції, які підтримують порівняння порядку, упорядковуються так само, як і "
"їхні перші нерівні елементи (наприклад, ``[1,2,x] <= [1,2,y]`` має те саме "
"значення, що ``x <= y``). Якщо відповідний елемент не існує, коротша "
"колекція впорядковується першою (наприклад, ``[1,2] < [1,2,3]`` є істинним)."

msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they have "
"equal ``(key, value)`` pairs. Equality comparison of the keys and values "
"enforces reflexivity."
msgstr ""

msgid ""
"Order comparisons (``<``, ``>``, ``<=``, and ``>=``) raise :exc:`TypeError`."
msgstr ""
"Порівняння порядку (``<``, ``>``, ``<=``, and ``> =``) викликає :exc:"
"`TypeError`."

msgid ""
"Sets (instances of :class:`set` or :class:`frozenset`) can be compared "
"within and across their types."
msgstr ""
"Набори (екземпляри :class:`set` або :class:`frozenset`) можна порівнювати "
"всередині та між типами."

msgid ""
"They define order comparison operators to mean subset and superset tests.  "
"Those relations do not define total orderings (for example, the two sets "
"``{1,2}`` and ``{2,3}`` are not equal, nor subsets of one another, nor "
"supersets of one another).  Accordingly, sets are not appropriate arguments "
"for functions which depend on total ordering (for example, :func:`min`, :"
"func:`max`, and :func:`sorted` produce undefined results given a list of "
"sets as inputs)."
msgstr ""
"Вони визначають оператори порівняння порядку, щоб означати тести підмножини "
"та надмножини. Ці відносини не визначають загальних порядків (наприклад, дві "
"множини ``{1,2}`` і ``{2,3}`` не є рівними, ані підмножини одна одної, ані "
"надмножини одна одної). Відповідно, набори не є відповідними аргументами для "
"функцій, які залежать від загального порядку (наприклад, :func:`min`, :func:"
"`max` і :func:`sorted` дають невизначені результати, якщо ввести список "
"наборів як вхідні дані) ."

msgid "Comparison of sets enforces reflexivity of its elements."
msgstr "Порівняння множин посилює рефлексивність її елементів."

msgid ""
"Most other built-in types have no comparison methods implemented, so they "
"inherit the default comparison behavior."
msgstr ""
"Більшість інших вбудованих типів не мають реалізованих методів порівняння, "
"тому вони успадковують типову поведінку порівняння."

msgid ""
"User-defined classes that customize their comparison behavior should follow "
"some consistency rules, if possible:"
msgstr ""
"Визначені користувачем класи, які налаштовують свою поведінку порівняння, "
"повинні дотримуватися деяких правил узгодженості, якщо це можливо:"

msgid ""
"Equality comparison should be reflexive. In other words, identical objects "
"should compare equal:"
msgstr ""
"Порівняння рівності має бути рефлексивним. Іншими словами, ідентичні об'єкти "
"повинні порівнюватися рівними:"

msgid "``x is y`` implies ``x == y``"
msgstr "``x є y`` означає ``x == y``"

msgid ""
"Comparison should be symmetric. In other words, the following expressions "
"should have the same result:"
msgstr ""
"Порівняння має бути симетричним. Іншими словами, наступні вирази повинні "
"мати однаковий результат:"

msgid "``x == y`` and ``y == x``"
msgstr "``x == y`` і ``y == x``"

msgid "``x != y`` and ``y != x``"
msgstr "``x != y`` і ``y != x``"

msgid "``x < y`` and ``y > x``"
msgstr "``x < y`` and ``y > x``"

msgid "``x <= y`` and ``y >= x``"
msgstr "``x <= y`` and ``y > = x``"

msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr ""
"Порівняння має бути транзитивним. Наступні (невичерпні) приклади ілюструють "
"це:"

msgid "``x > y and y > z`` implies ``x > z``"
msgstr "``x > y і y > z`` передбачає ``x > z``"

msgid "``x < y and y <= z`` implies ``x < z``"
msgstr "``x < y і y <= z`` передбачає ``x < z``"

msgid ""
"Inverse comparison should result in the boolean negation. In other words, "
"the following expressions should have the same result:"
msgstr ""
"Зворотне порівняння має призвести до логічного заперечення. Іншими словами, "
"наступні вирази повинні мати однаковий результат:"

msgid "``x == y`` and ``not x != y``"
msgstr "``x == y`` і ``не x != y``"

msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr "``x < y`` and ``not x > = y`` (для загального впорядкування)"

msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr "``x > y`` і ``not x <= y`` (для загального порядку)"

msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the :func:`~functools."
"total_ordering` decorator."
msgstr ""
"Останні два вирази застосовуються до повністю впорядкованих колекцій "
"(наприклад, до послідовностей, але не до наборів чи відображень). Дивіться "
"також декоратор :func:`~functools.total_ordering`."

msgid ""
"The :func:`hash` result should be consistent with equality. Objects that are "
"equal should either have the same hash value, or be marked as unhashable."
msgstr ""
"Результат :func:`hash` має відповідати рівності. Рівні об’єкти повинні або "
"мати однакове хеш-значення, або бути позначеними як нехешовані."

msgid ""
"Python does not enforce these consistency rules. In fact, the not-a-number "
"values are an example for not following these rules."
msgstr ""
"Python не забезпечує виконання цих правил узгодженості. Фактично, нечислові "
"значення є прикладом недотримання цих правил."

msgid "Membership test operations"
msgstr "Тестові операції членства"

msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  ``x "
"in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False`` "
"otherwise. ``x not in s`` returns the negation of ``x in s``.  All built-in "
"sequences and set types support this as well as dictionary, for which :"
"keyword:`!in` tests whether the dictionary has a given key. For container "
"types such as list, tuple, set, frozenset, dict, or collections.deque, the "
"expression ``x in y`` is equivalent to ``any(x is e or x == e for e in y)``."
msgstr ""
"Оператори :keyword:`in` і :keyword:`not in` перевіряють членство. ``x in s`` "
"обчислюється як ``True``, якщо *x* є членом *s*, і ``False`` в іншому "
"випадку. ``x not in s`` повертає заперечення ``x in s``. Усі вбудовані "
"послідовності та типи наборів підтримують це, а також словник, для якого :"
"keyword:`!in` перевіряє, чи має словник заданий ключ. Для типів контейнерів, "
"таких як список, кортеж, набір, frozenset, dict або collections.deque, вираз "
"``x in y`` еквівалентний ``any(x is e or x == e for e in y)``."

msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x* is "
"a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  Empty "
"strings are always considered to be a substring of any other string, so "
"``\"\" in \"abc\"`` will return ``True``."
msgstr ""
"Для типів рядків і байтів ``x в y`` є ``True`` тоді і тільки тоді, коли *x* "
"є підрядком *y*. Еквівалентним тестом є ``y.find(x) != -1``. Порожні рядки "
"завжди вважаються підрядками будь-яких інших рядків, тому ``\"\" у \"abc`` "
"поверне ``True``."

msgid ""
"For user-defined classes which define the :meth:`__contains__` method, ``x "
"in y`` returns ``True`` if ``y.__contains__(x)`` returns a true value, and "
"``False`` otherwise."
msgstr ""
"Для визначених користувачем класів, які визначають метод :meth:"
"`__contains__`, ``x in y`` повертає ``True``, якщо ``y.__contains__(x)`` "
"повертає істинне значення, і ``False`` інакше."

msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is ``True`` if some value ``z``, for "
"which the expression ``x is z or x == z`` is true, is produced while "
"iterating over ``y``. If an exception is raised during the iteration, it is "
"as if :keyword:`in` raised that exception."
msgstr ""
"Для визначених користувачем класів, які не визначають :meth:`__contains__`, "
"але визначають :meth:`__iter__`, ``x в y`` є ``True``, якщо деяке значення "
"``z``, для якого вираз ``x є z або x == z`` є істинним, створюється під час "
"повторення ``y``. Якщо під час ітерації виникає виняток, це ніби :keyword:"
"`in` викликав цей виняток."

msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines :meth:"
"`__getitem__`, ``x in y`` is ``True`` if and only if there is a non-negative "
"integer index *i* such that ``x is y[i] or x == y[i]``, and no lower integer "
"index raises the :exc:`IndexError` exception.  (If any other exception is "
"raised, it is as if :keyword:`in` raised that exception)."
msgstr ""
"Нарешті, випробувано старий протокол ітерації: якщо клас визначає :meth:"
"`__getitem__`, ``x in y`` є ``True`` тоді і тільки тоді, коли існує "
"невід’ємне ціле число *i* таким чином, що ``x є y[i] або x == y[i]``, і "
"жоден нижній цілий індекс не викликає виключення :exc:`IndexError`. (Якщо "
"виникає будь-який інший виняток, це ніби :keyword:`in` викликав цей виняток)."

msgid ""
"The operator :keyword:`not in` is defined to have the inverse truth value "
"of :keyword:`in`."
msgstr ""
"Оператор :keyword:`not in` визначено таким, що має зворотне значення "
"істинності :keyword:`in`."

msgid "Identity comparisons"
msgstr "Порівняння тотожності"

msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for an object's "
"identity: ``x is y`` is true if and only if *x* and *y* are the same "
"object.  An Object's identity is determined using the :meth:`id` function.  "
"``x is not y`` yields the inverse truth value. [#]_"
msgstr ""
"Оператори :keyword:`is` і :keyword:`is not` перевіряють ідентичність "
"об’єкта: ``x is y`` є істинним тоді і тільки тоді, коли *x* і *y* є одним і "
"тим же об’єктом. Ідентичність об’єкта визначається за допомогою функції :"
"meth:`id`. \"x не є y\" дає зворотне значення істинності. [#]_"

msgid "Boolean operations"
msgstr "Логічні операції"

msgid ""
"In the context of Boolean operations, and also when expressions are used by "
"control flow statements, the following values are interpreted as false: "
"``False``, ``None``, numeric zero of all types, and empty strings and "
"containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`__bool__` "
"method."
msgstr ""
"У контексті логічних операцій, а також коли вирази використовуються "
"операторами потоку керування, такі значення інтерпретуються як false: "
"``False``, ``None``, числові нулі всіх типів, а також порожні рядки та "
"контейнери ( включаючи рядки, кортежі, списки, словники, набори та "
"заморожені набори). Усі інші значення інтерпретуються як істинні. Визначені "
"користувачем об’єкти можуть налаштувати своє значення істинності, надаючи "
"метод :meth:`__bool__`."

msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr ""
"Оператор :keyword:`not` видає ``True``, якщо його аргумент false, ``False`` "
"в іншому випадку."

msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"Вираз ``x і y`` спочатку обчислює *x*; якщо *x* false, повертається його "
"значення; інакше обчислюється *y* і повертається отримане значення."

msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value is "
"returned; otherwise, *y* is evaluated and the resulting value is returned."
msgstr ""
"Вираз ``x або y`` спочатку обчислює *x*; якщо *x* істинне, повертається його "
"значення; інакше обчислюється *y* і повертається отримане значення."

msgid ""
"Note that neither :keyword:`and` nor :keyword:`or` restrict the value and "
"type they return to ``False`` and ``True``, but rather return the last "
"evaluated argument.  This is sometimes useful, e.g., if ``s`` is a string "
"that should be replaced by a default value if it is empty, the expression "
"``s or 'foo'`` yields the desired value.  Because :keyword:`not` has to "
"create a new value, it returns a boolean value regardless of the type of its "
"argument (for example, ``not 'foo'`` produces ``False`` rather than ``''``.)"
msgstr ""
"Зауважте, що ані :keyword:`and`, ані :keyword:`or` не обмежують значення та "
"тип, які вони повертають, значеннями ``False`` і ``True``, а радше "
"повертають останній оцінений аргумент. Це іноді корисно, наприклад, якщо "
"``s`` є рядком, який слід замінити значенням за замовчуванням, якщо він "
"порожній, вираз ``s або 'foo'`` дає потрібне значення. Оскільки :keyword:"
"`not` має створити нове значення, воно повертає логічне значення незалежно "
"від типу свого аргументу (наприклад, ``not 'foo'`` створює ``False``, а не "
"``''`` .)"

msgid "Assignment expressions"
msgstr "Вирази присвоєння"

msgid ""
"An assignment expression (sometimes also called a \"named expression\" or "
"\"walrus\") assigns an :token:`~python-grammar:expression` to an :token:"
"`~python-grammar:identifier`, while also returning the value of the :token:"
"`~python-grammar:expression`."
msgstr ""
"Вираз присвоєння (іноді його також називають \"іменованим виразом\" або "
"\"моржем\") призначає :token:`~python-grammar:expression` :token:`~python-"
"grammar:identifier`, а також повертає значення :token:`~python-grammar:"
"expression`."

msgid "One common use case is when handling matched regular expressions:"
msgstr ""
"Одним із поширених випадків використання є обробка зіставлених регулярних "
"виразів:"

msgid "Or, when processing a file stream in chunks:"
msgstr "Або при обробці потоку файлів у частинах:"

msgid ""
"Assignment expressions must be surrounded by parentheses when used as sub-"
"expressions in slicing, conditional, lambda, keyword-argument, and "
"comprehension-if expressions and in ``assert`` and ``with`` statements. In "
"all other places where they can be used, parentheses are not required, "
"including in ``if`` and ``while`` statements."
msgstr ""

msgid "See :pep:`572` for more details about assignment expressions."
msgstr ""
"Перегляньте :pep:`572` для отримання додаткової інформації про вирази "
"присвоєння."

msgid "Conditional expressions"
msgstr "Умовні вирази"

msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have the "
"lowest priority of all Python operations."
msgstr ""
"Умовні вирази (іноді їх називають \"потрійним оператором\") мають найнижчий "
"пріоритет з усіх операцій Python."

msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* rather "
"than *x*. If *C* is true, *x* is evaluated and its value is returned; "
"otherwise, *y* is evaluated and its value is returned."
msgstr ""
"Вираз x if C else y спочатку обчислює умову *C*, а не *x*. Якщо *C* істинне, "
"*x* обчислюється і повертається його значення; інакше обчислюється *y* і "
"повертається його значення."

msgid "See :pep:`308` for more details about conditional expressions."
msgstr ""
"Перегляньте :pep:`308` для отримання додаткової інформації про умовні вирази."

msgid "Lambdas"
msgstr "Лямбда"

msgid ""
"Lambda expressions (sometimes called lambda forms) are used to create "
"anonymous functions. The expression ``lambda parameters: expression`` yields "
"a function object.  The unnamed object behaves like a function object "
"defined with:"
msgstr ""
"Лямбда-вирази (іноді їх називають лямбда-формами) використовуються для "
"створення анонімних функцій. Вираз ``параметри лямбда: вираз`` дає об’єкт "
"функції. Безіменний об’єкт поводиться як об’єкт-функція, визначений за "
"допомогою:"

msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that "
"functions created with lambda expressions cannot contain statements or "
"annotations."
msgstr ""
"Перегляньте розділ :ref:`function` для синтаксису списків параметрів. "
"Зауважте, що функції, створені за допомогою лямбда-виразів, не можуть "
"містити оператори чи анотації."

msgid "Expression lists"
msgstr "Списки виразів"

msgid ""
"Except when part of a list or set display, an expression list containing at "
"least one comma yields a tuple.  The length of the tuple is the number of "
"expressions in the list.  The expressions are evaluated from left to right."
msgstr ""
"За винятком випадків, коли є частиною списку або відображення набору, список "
"виразів, що містить принаймні одну кому, дає кортеж. Довжина кортежу — це "
"кількість виразів у списку. Вирази обчислюються зліва направо."

msgid ""
"An asterisk ``*`` denotes :dfn:`iterable unpacking`.  Its operand must be "
"an :term:`iterable`.  The iterable is expanded into a sequence of items, "
"which are included in the new tuple, list, or set, at the site of the "
"unpacking."
msgstr ""
"Зірочка ``*`` позначає :dfn:`iterable unpacking`. Його операнд має бути :"
"term:`iterable`. Ітерація розгортається в послідовність елементів, які "
"включені в новий кортеж, список або набір на місці розпакування."

msgid ""
"Iterable unpacking in expression lists, originally proposed by :pep:`448`."
msgstr ""
"Ітераційне розпакування в списках виразів, спочатку запропоноване :pep:`448`."

msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the value "
"of that expression. (To create an empty tuple, use an empty pair of "
"parentheses: ``()``.)"
msgstr ""
"Кінцева кома потрібна лише для створення одного кортежу (він же "
"*singleton*); у всіх інших випадках це необов'язково. Один вираз без "
"кінцевої коми не створює кортеж, а скоріше видає значення цього виразу. (Щоб "
"створити порожній кортеж, використовуйте порожню пару круглих дужок: ``()``.)"

msgid "Evaluation order"
msgstr "Порядок оцінювання"

msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the left-"
"hand side."
msgstr ""
"Python обчислює вирази зліва направо. Зауважте, що під час оцінювання "
"завдання права частина оцінюється перед лівою."

msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr ""
"У наступних рядках вирази обчислюватимуться в арифметичному порядку їх "
"суфіксів:"

msgid "Operator precedence"
msgstr "Пріоритет оператора"

msgid ""
"The following table summarizes the operator precedence in Python, from "
"highest precedence (most binding) to lowest precedence (least binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is "
"explicitly given, operators are binary.  Operators in the same box group "
"left to right (except for exponentiation and conditional expressions, which "
"group from right to left)."
msgstr ""

msgid ""
"Note that comparisons, membership tests, and identity tests, all have the "
"same precedence and have a left-to-right chaining feature as described in "
"the :ref:`comparisons` section."
msgstr ""
"Зауважте, що порівняння, тести на приналежність і тести ідентичності мають "
"однаковий пріоритет і функцію ланцюжка зліва направо, як описано в розділі :"
"ref:`comparisons`."

msgid "Operator"
msgstr "Оператор"

msgid "Description"
msgstr "опис"

msgid "``(expressions...)``,"
msgstr "``(вирази...)``,"

msgid "``[expressions...]``, ``{key: value...}``, ``{expressions...}``"
msgstr "``[вирази...]``, ``{ключ: значення...}``, ``{вирази...}``"

msgid ""
"Binding or parenthesized expression, list display, dictionary display, set "
"display"
msgstr ""
"Прив’язка або вираз у дужках, відображення списку, відображення словника, "
"відображення набору"

msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"

msgid "Subscription, slicing, call, attribute reference"
msgstr "Підписка, нарізка, виклик, посилання на атрибути"

msgid ":keyword:`await x <await>`"
msgstr ":keyword:`await x <await>`"

msgid "``**``"
msgstr "``**``"

msgid "Exponentiation [#]_"
msgstr "Піднесення до степеня [#]_"

msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

msgid "Positive, negative, bitwise NOT"
msgstr "Позитивне, негативне, побітове НІ"

msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr "``*``, ``@``, ``/``, ``//``, ``%``"

msgid ""
"Multiplication, matrix multiplication, division, floor division, remainder "
"[#]_"
msgstr "Множення, матричне множення, ділення, поверхове ділення, залишок [#]_"

msgid "``+``, ``-``"
msgstr "``+``, ``-``"

msgid "Addition and subtraction"
msgstr "Додавання і віднімання"

msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

msgid "Shifts"
msgstr "Зміни"

msgid "``&``"
msgstr "``&``"

msgid "Bitwise AND"
msgstr "Побітове І"

msgid "``^``"
msgstr "``^``"

msgid "Bitwise XOR"
msgstr "Побітове XOR"

msgid "``|``"
msgstr "``|``"

msgid "Bitwise OR"
msgstr "Порозрядне АБО"

msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, ``<``, "
"``<=``, ``>``, ``>=``, ``!=``, ``==``"

msgid "Comparisons, including membership tests and identity tests"
msgstr "Порівняння, включаючи тести на приналежність і тести на ідентифікацію"

msgid ":keyword:`not x <not>`"
msgstr ":keyword:`not x <not>`"

msgid "Boolean NOT"
msgstr "Логічне НІ"

msgid ":keyword:`and`"
msgstr ":keyword:`and`"

msgid "Boolean AND"
msgstr "Логічне І"

msgid ":keyword:`or`"
msgstr ":keyword:`or`"

msgid "Boolean OR"
msgstr "Логічне АБО"

msgid ":keyword:`if <if_expr>` -- :keyword:`!else`"
msgstr ":keyword:`if <if_expr>` -- :keyword:`!else`"

msgid "Conditional expression"
msgstr "Умовний вираз"

msgid ":keyword:`lambda`"
msgstr ":keyword:`lambda`"

msgid "Lambda expression"
msgstr "Лямбда-вираз"

msgid "``:=``"
msgstr "``:=``"

msgid "Assignment expression"
msgstr "Вираз присвоєння"

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not be "
"true numerically due to roundoff.  For example, and assuming a platform on "
"which a Python float is an IEEE 754 double-precision number, in order that "
"``-1e-100 % 1e100`` have the same sign as ``1e100``, the computed result is "
"``-1e-100 + 1e100``, which is numerically exactly equal to ``1e100``.  The "
"function :func:`math.fmod` returns a result whose sign matches the sign of "
"the first argument instead, and so returns ``-1e-100`` in this case. Which "
"approach is more appropriate depends on the application."
msgstr ""
"У той час як ``abs(x%y) < abs(y)`` є істинним математично, для чисельних "
"чисел це може не бути істинним через округлення. Наприклад, якщо припустити, "
"що платформа Python з плаваючою точкою є числом подвійної точності IEEE 754, "
"для того, щоб ``-1e-100 % 1e100`` мали той самий знак, що ``1e100``, "
"обчислений результат буде ``-1e-100 + 1e100``, що чисельно точно дорівнює "
"``1e100``. Функція :func:`math.fmod` повертає результат, знак якого "
"збігається зі знаком першого аргументу, і тому в цьому випадку повертає "
"``-1e-100``. Який підхід є більш доцільним, залежить від програми."

msgid ""
"If x is very close to an exact integer multiple of y, it's possible for ``x//"
"y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such cases, "
"Python returns the latter result, in order to preserve that ``divmod(x,y)[0] "
"* y + x % y`` be very close to ``x``."
msgstr ""
"Якщо x дуже близький до точного цілого числа, кратного y, через округлення "
"``x//y`` може бути на одиницю більшим за ``(x-x%y)//y``. У таких випадках "
"Python повертає останній результат, щоб зберегти те, що ``divmod(x,y)[0] * y "
"+ x % y`` буде дуже близьким до ``x``."

msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. U+0041) "
"and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\"). While most "
"abstract characters in Unicode are only represented using one code point, "
"there is a number of abstract characters that can in addition be represented "
"using a sequence of more than one code point.  For example, the abstract "
"character \"LATIN CAPITAL LETTER C WITH CEDILLA\" can be represented as a "
"single :dfn:`precomposed character` at code position U+00C7, or as a "
"sequence of a :dfn:`base character` at code position U+0043 (LATIN CAPITAL "
"LETTER C), followed by a :dfn:`combining character` at code position U+0327 "
"(COMBINING CEDILLA)."
msgstr ""
"Стандарт Unicode розрізняє :dfn:`code points` (наприклад, U+0041) і :dfn:"
"`abstract characters` (наприклад, \"ЛАТИНСЬКА ВЕЛИКА ЛІТЕРА A\"). У той час "
"як більшість абстрактних символів у Unicode представлено лише за допомогою "
"однієї кодової точки, існує ряд абстрактних символів, які, крім того, можуть "
"бути представлені за допомогою послідовності з кількох кодових точок. "
"Наприклад, абстрактний символ \"ВЕЛИКА ЛАТИНСЬКА ЛІТЕРА C З ЦЕДІЛЬЄЮ\" може "
"бути представлений як один :dfn:`precomposed character` у позиції коду "
"U+00C7 або як послідовність :dfn:`base character` у позиції коду U+0043 "
"(ВЕЛИКА ЛАТИНСЬКА ЛІТЕРА C), за якою йде :dfn:`combining character` у "
"позиції коду U+0327 (КОМБІНУЮЧА CEDILLA)."

msgid ""
"The comparison operators on strings compare at the level of Unicode code "
"points. This may be counter-intuitive to humans.  For example, ``\"\\u00C7\" "
"== \"\\u0043\\u0327\"`` is ``False``, even though both strings represent the "
"same abstract character \"LATIN CAPITAL LETTER C WITH CEDILLA\"."
msgstr ""
"Оператори порівняння рядків порівнюються на рівні кодових точок Unicode. "
"Людям це може бути не зрозуміло. Наприклад, ``\"\\u00C7\" == "
"\"\\u0043\\u0327\"`` є ``False``, навіть якщо обидва рядки представляють той "
"самий абстрактний символ \"ЛАТИНСЬКА ВЕЛИКА ЛІТЕРА C З ЦЕДІЛЬЄЮ\"."

msgid ""
"To compare strings at the level of abstract characters (that is, in a way "
"intuitive to humans), use :func:`unicodedata.normalize`."
msgstr ""
"Щоб порівняти рядки на рівні абстрактних символів (тобто інтуїтивно "
"зрозумілим людям), використовуйте :func:`unicodedata.normalize`."

msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature of "
"descriptors, you may notice seemingly unusual behaviour in certain uses of "
"the :keyword:`is` operator, like those involving comparisons between "
"instance methods, or constants.  Check their documentation for more info."
msgstr ""
"Завдяки автоматичному збиранню сміття, вільним спискам і динамічній природі "
"дескрипторів ви можете помітити, здавалося б, незвичайну поведінку в певних "
"випадках використання оператора :keyword:`is`, як-от порівняння між методами "
"екземплярів або константами. Щоб дізнатися більше, перегляньте їхню "
"документацію."

msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or bitwise "
"unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""
"Оператор степені ``**`` прив’язує менш тісно, ніж арифметичний або "
"порозрядний унарний оператор справа, тобто ``2**-1`` дорівнює ``0,5``."

msgid ""
"The ``%`` operator is also used for string formatting; the same precedence "
"applies."
msgstr ""
"Оператор ``%`` також використовується для форматування рядків; "
"застосовується той самий пріоритет."
