# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 01:19+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Execution model"
msgstr "Модель виконання"

msgid "Structure of a program"
msgstr "Структура програми"

msgid ""
"A Python program is constructed from code blocks. A :dfn:`block` is a piece "
"of Python program text that is executed as a unit. The following are blocks: "
"a module, a function body, and a class definition. Each command typed "
"interactively is a block.  A script file (a file given as standard input to "
"the interpreter or specified as a command line argument to the interpreter) "
"is a code block.  A script command (a command specified on the interpreter "
"command line with the :option:`-c` option) is a code block. A module run as "
"a top level script (as module ``__main__``) from the command line using a :"
"option:`-m` argument is also a code block. The string argument passed to the "
"built-in functions :func:`eval` and :func:`exec` is a code block."
msgstr ""
"Програма Python складається з блоків коду. :dfn:`block` — це частина тексту "
"програми Python, яка виконується як одиниця. Це блоки: модуль, тіло функції "
"та визначення класу. Кожна команда, введена в інтерактивному режимі, є "
"блоком. Файл сценарію (файл, наданий інтерпретатору як стандартний ввід або "
"вказаний як аргумент командного рядка для інтерпретатора) є блоком коду. "
"Команда сценарію (команда, указана в командному рядку інтерпретатора з "
"опцією :option:`-c`) — це блок коду. Модуль, запущений як сценарій верхнього "
"рівня (як модуль ``__main__``) з командного рядка за допомогою аргументу :"
"option:`-m`, також є блоком коду. Рядковий аргумент, який передається до "
"вбудованих функцій :func:`eval` і :func:`exec`, є блоком коду."

msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where "
"and how execution continues after the code block's execution has completed."
msgstr ""
"Блок коду виконується у :dfn:`execution frame`. Кадр містить деяку "
"адміністративну інформацію (використовується для налагодження) і визначає, "
"де і як виконання продовжується після завершення виконання блоку коду."

msgid "Naming and binding"
msgstr "Називання та зв'язування"

msgid "Binding of names"
msgstr "Прив'язка імен"

msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations."
msgstr ""
":dfn:`Names` стосуються об'єктів. Імена вводяться за допомогою операцій "
"зв’язування імен."

msgid "The following constructs bind names:"
msgstr "Наступні конструкції зв'язують імена:"

msgid "formal parameters to functions,"
msgstr "формальні параметри функцій,"

msgid "class definitions,"
msgstr "визначення класів,"

msgid "function definitions,"
msgstr "визначення функцій,"

msgid "assignment expressions,"
msgstr "вирази присвоєння,"

msgid ""
":ref:`targets <assignment>` that are identifiers if occurring in an "
"assignment:"
msgstr ""
":ref:`targets <assignment>`, які є ідентифікаторами, якщо зустрічаються у "
"призначенні:"

msgid ":keyword:`for` loop header,"
msgstr ":keyword:`for` заголовок циклу,"

msgid ""
"after :keyword:`!as` in a :keyword:`with` statement, :keyword:`except` "
"clause, :keyword:`except* <except_star>` clause, or in the as-pattern in "
"structural pattern matching,"
msgstr ""

msgid "in a capture pattern in structural pattern matching"
msgstr "у шаблоні захоплення в зіставленні структурного шаблону"

msgid ":keyword:`import` statements."
msgstr ":keyword:`import` оператори."

msgid ""
"The :keyword:`!import` statement of the form ``from ... import *`` binds all "
"names defined in the imported module, except those beginning with an "
"underscore. This form may only be used at the module level."
msgstr ""
"Оператор :keyword:`!import` у формі ``from ... import *`` прив’язує всі "
"імена, визначені в імпортованому модулі, за винятком тих, що починаються з "
"підкреслення. Цю форму можна використовувати лише на рівні модуля."

msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound "
"for this purpose (though the actual semantics are to unbind the name)."
msgstr ""
"Ціль, що зустрічається в операторі :keyword:`del`, також вважається "
"зв’язаною для цієї мети (хоча фактична семантика полягає в тому, щоб "
"роз’єднати ім’я)."

msgid ""
"Each assignment or import statement occurs within a block defined by a class "
"or function definition or at the module level (the top-level code block)."
msgstr ""
"Кожен оператор призначення або імпорту відбувається в блоці, визначеному "
"визначенням класу чи функції, або на рівні модуля (блок коду верхнього "
"рівня)."

msgid ""
"If a name is bound in a block, it is a local variable of that block, unless "
"declared as :keyword:`nonlocal` or :keyword:`global`.  If a name is bound at "
"the module level, it is a global variable.  (The variables of the module "
"code block are local and global.)  If a variable is used in a code block but "
"not defined there, it is a :dfn:`free variable`."
msgstr ""
"Якщо ім’я прив’язане до блоку, воно є локальною змінною цього блоку, якщо не "
"оголошено як :keyword:`nonlocal` або :keyword:`global`. Якщо ім’я прив’язане "
"на рівні модуля, воно є глобальною змінною. (Змінні блоку коду модуля є "
"локальними та глобальними.) Якщо змінна використовується в блоці коду, але "
"не визначена там, це :dfn:`free variable`."

msgid ""
"Each occurrence of a name in the program text refers to the :dfn:`binding` "
"of that name established by the following name resolution rules."
msgstr ""
"Кожне входження імені в текст програми посилається на :dfn:`binding` цього "
"імені, встановлене наступними правилами розпізнавання імен."

msgid "Resolution of names"
msgstr "Розділення імен"

msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a local "
"variable is defined in a block, its scope includes that block.  If the "
"definition occurs in a function block, the scope extends to any blocks "
"contained within the defining one, unless a contained block introduces a "
"different binding for the name."
msgstr ""
":dfn:`scope` визначає видимість імені в блоці. Якщо локальна змінна "
"визначена в блоці, її область включає цей блок. Якщо визначення міститься у "
"функціональному блоці, область поширюється на будь-які блоки, що містяться в "
"визначальному, якщо тільки блок не вводить іншу прив’язку для імені."

msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr ""
"Коли ім’я використовується в блоці коду, воно розпізнається за допомогою "
"найближчої охоплюючої області. Набір усіх таких областей, видимих для блоку "
"коду, називається :dfn:`environment` блоку."

msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised. If "
"the current scope is a function scope, and the name refers to a local "
"variable that has not yet been bound to a value at the point where the name "
"is used, an :exc:`UnboundLocalError` exception is raised. :exc:"
"`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""
"Якщо ім’я взагалі не знайдено, виникає виняток :exc:`NameError`. Якщо "
"поточна область є областю функції, а ім’я посилається на локальну змінну, "
"яка ще не прив’язана до значення в точці, де використовується ім’я, виникає "
"виняток :exc:`UnboundLocalError`. :exc:`UnboundLocalError` є підкласом :exc:"
"`NameError`."

msgid ""
"If a name binding operation occurs anywhere within a code block, all uses of "
"the name within the block are treated as references to the current block.  "
"This can lead to errors when a name is used within a block before it is "
"bound.  This rule is subtle.  Python lacks declarations and allows name "
"binding operations to occur anywhere within a code block.  The local "
"variables of a code block can be determined by scanning the entire text of "
"the block for name binding operations."
msgstr ""
"Якщо операція зв’язування імені відбувається будь-де в блоці коду, усі "
"використання імені в блоці розглядаються як посилання на поточний блок. Це "
"може призвести до помилок, коли ім’я використовується в блоці до його "
"зв’язування. Це правило є тонким. Python не має декларацій і дозволяє "
"виконувати операції зв’язування імен у будь-якому місці блоку коду. Локальні "
"змінні блоку коду можна визначити шляхом сканування всього тексту блоку для "
"операцій зв’язування імен."

msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the "
"names specified in the statement refer to the bindings of those names in the "
"top-level namespace.  Names are resolved in the top-level namespace by "
"searching the global namespace, i.e. the namespace of the module containing "
"the code block, and the builtins namespace, the namespace of the module :mod:"
"`builtins`.  The global namespace is searched first.  If the names are not "
"found there, the builtins namespace is searched.  The :keyword:`!global` "
"statement must precede all uses of the listed names."
msgstr ""
"Якщо оператор :keyword:`global` зустрічається в блоці, усі використання "
"імен, указаних у цьому операторі, посилаються на прив’язки цих імен у "
"просторі імен верхнього рівня. Імена розпізнаються в просторі імен верхнього "
"рівня шляхом пошуку в глобальному просторі імен, тобто в просторі імен "
"модуля, що містить блок коду, і вбудованому просторі імен, просторі імен "
"модуля :mod:`builtins`. Спочатку виконується пошук у глобальному просторі "
"імен. Якщо імена там не знайдено, пошук здійснюється у вбудованому просторі "
"імен. Оператор :keyword:`!global` має передувати всім використанням "
"наведених імен."

msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""
"Оператор :keyword:`global` має ту саму область дії, що й операція прив’язки "
"імені в тому самому блоці. Якщо найближча охоплююча область для вільної "
"змінної містить глобальний оператор, вільна змінна розглядається як "
"глобальна."

msgid ""
"The :keyword:`nonlocal` statement causes corresponding names to refer to "
"previously bound variables in the nearest enclosing function scope. :exc:"
"`SyntaxError` is raised at compile time if the given name does not exist in "
"any enclosing function scope."
msgstr ""
"Оператор :keyword:`nonlocal` змушує відповідні імена посилатися на раніше "
"зв’язані змінні в найближчій охоплюючій області функції. :exc:`SyntaxError` "
"викликається під час компіляції, якщо задане ім’я не існує в жодній "
"охоплюючій області функції."

msgid ""
"The namespace for a module is automatically created the first time a module "
"is imported.  The main module for a script is always called :mod:`__main__`."
msgstr ""
"Простір імен для модуля створюється автоматично під час першого імпорту "
"модуля. Основний модуль для сценарію завжди називається :mod:`__main__`."

msgid ""
"Class definition blocks and arguments to :func:`exec` and :func:`eval` are "
"special in the context of name resolution. A class definition is an "
"executable statement that may use and define names. These references follow "
"the normal rules for name resolution with an exception that unbound local "
"variables are looked up in the global namespace. The namespace of the class "
"definition becomes the attribute dictionary of the class. The scope of names "
"defined in a class block is limited to the class block; it does not extend "
"to the code blocks of methods -- this includes comprehensions and generator "
"expressions since they are implemented using a function scope.  This means "
"that the following will fail::"
msgstr ""
"Блоки визначення класу та аргументи для :func:`exec` і :func:`eval` є "
"спеціальними в контексті розпізнавання імен. Визначення класу - це "
"виконуваний оператор, який може використовувати та визначати імена. Ці "
"посилання відповідають звичайним правилам розпізнавання імен, за винятком "
"того, що незв’язані локальні змінні шукаються в глобальному просторі імен. "
"Простір імен визначення класу стає словником атрибутів класу. Область імен, "
"визначених у блоці класу, обмежена блоком класу; він не поширюється на блоки "
"коду методів -- це включає в себе розуміння та вирази генератора, оскільки "
"вони реалізовані за допомогою області видимості функції. Це означає, що не "
"вийде:"

msgid "Builtins and restricted execution"
msgstr "Вбудоване та обмежене виконання"

msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation "
"detail.  Users wanting to override values in the builtins namespace should :"
"keyword:`import` the :mod:`builtins` module and modify its attributes "
"appropriately."
msgstr ""
"Користувачі не повинні торкатися ``__builtins__``; це суто деталь "
"реалізації. Користувачі, які хочуть змінити значення у просторі імен "
"вбудованих модулів, повинні :keyword:`import` модуль :mod:`builtins` і "
"відповідним чином змінити його атрибути."

msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case the "
"module's dictionary is used).  By default, when in the :mod:`__main__` "
"module, ``__builtins__`` is the built-in module :mod:`builtins`; when in any "
"other module, ``__builtins__`` is an alias for the dictionary of the :mod:"
"`builtins` module itself."
msgstr ""
"Простір вбудованих імен, пов’язаний із виконанням блоку коду, фактично можна "
"знайти шляхом пошуку назви ``__builtins__`` у його глобальному просторі "
"імен; це має бути словник або модуль (в останньому випадку використовується "
"словник модуля). За замовчуванням у модулі :mod:`__main__` ``__builtins__`` "
"є вбудованим модулем :mod:`builtins`; у будь-якому іншому модулі "
"``__builtins__`` є псевдонімом для словника самого модуля :mod:`builtins`."

msgid "Interaction with dynamic features"
msgstr "Взаємодія з динамічними функціями"

msgid ""
"Name resolution of free variables occurs at runtime, not at compile time. "
"This means that the following code will print 42::"
msgstr ""
"Розділення імен вільних змінних відбувається під час виконання, а не під час "
"компіляції. Це означає, що наступний код виведе 42::"

msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the full "
"environment for resolving names.  Names may be resolved in the local and "
"global namespaces of the caller.  Free variables are not resolved in the "
"nearest enclosing namespace, but in the global namespace.  [#]_ The :func:"
"`exec` and :func:`eval` functions have optional arguments to override the "
"global and local namespace.  If only one namespace is specified, it is used "
"for both."
msgstr ""
"Функції :func:`eval` і :func:`exec` не мають доступу до повного середовища "
"для розпізнавання імен. Імена можуть бути дозволені в локальному та "
"глобальному просторах імен абонента. Вільні змінні вирішуються не в "
"найближчому охоплюючому просторі імен, а в глобальному просторі імен. [#]_ "
"Функції :func:`exec` і :func:`eval` мають додаткові аргументи для заміни "
"глобального та локального простору імен. Якщо вказано лише один простір "
"імен, він використовується для обох."

msgid "Exceptions"
msgstr "Винятки"

msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a "
"code block in order to handle errors or other exceptional conditions.  An "
"exception is *raised* at the point where the error is detected; it may be "
"*handled* by the surrounding code block or by any code block that directly "
"or indirectly invoked the code block where the error occurred."
msgstr ""
"Винятки — це засіб виходу зі звичайного потоку керування блоком коду для "
"обробки помилок або інших виняткових умов. Виняток *викликається* в точці, "
"де виявлено помилку; вона може *оброблятися* навколишнім блоком коду або "
"будь-яким блоком коду, який прямо чи опосередковано викликав блок коду, де "
"сталася помилка."

msgid ""
"The Python interpreter raises an exception when it detects a run-time error "
"(such as division by zero).  A Python program can also explicitly raise an "
"exception with the :keyword:`raise` statement. Exception handlers are "
"specified with the :keyword:`try` ... :keyword:`except` statement.  The :"
"keyword:`finally` clause of such a statement can be used to specify cleanup "
"code which does not handle the exception, but is executed whether an "
"exception occurred or not in the preceding code."
msgstr ""
"Інтерпретатор Python викликає виняток, коли виявляє помилку під час "
"виконання (наприклад, ділення на нуль). Програма на Python також може явно "
"викликати виняток за допомогою оператора :keyword:`raise`. Обробники "
"винятків визначаються оператором :keyword:`try` ... :keyword:`except`. "
"Речення :keyword:`finally` такого оператора можна використовувати для "
"визначення коду очищення, який не обробляє виняток, але виконується "
"незалежно від того, чи виникла виняток у попередньому коді."

msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer level, "
"but it cannot repair the cause of the error and retry the failing operation "
"(except by re-entering the offending piece of code from the top)."
msgstr ""
"Python використовує модель \"припинення\" обробки помилок: обробник винятків "
"може дізнатися, що сталося, і продовжити виконання на зовнішньому рівні, але "
"він не може виправити причину помилки та повторити невдалу операцію (за "
"винятком повторного введення несправної частини коду зверху)."

msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack traceback, except when the exception is :exc:"
"`SystemExit`."
msgstr ""
"Якщо виняток взагалі не обробляється, інтерпретатор припиняє виконання "
"програми або повертається до основного інтерактивного циклу. У будь-якому "
"випадку він друкує зворотне трасування стека, за винятком випадків, коли "
"винятком є :exc:`SystemExit`."

msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` clause "
"is selected depending on the class of the instance: it must reference the "
"class of the instance or a :term:`non-virtual base class <abstract base "
"class>` thereof. The instance can be received by the handler and can carry "
"additional information about the exceptional condition."
msgstr ""
"Винятки визначаються екземплярами класу. Речення :keyword:`except` "
"вибирається залежно від класу примірника: воно має посилатися на клас "
"примірника або його :term:`невіртуальний базовий клас <abstract base "
"class>`. Примірник може бути отриманий обробником і може містити додаткову "
"інформацію про винятковий стан."

msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should not "
"be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""
"Повідомлення про винятки не є частиною API Python. Їх вміст може змінюватися "
"від однієї версії Python до іншої без попередження, і на нього не слід "
"покладатися кодом, який працюватиме під кількома версіями інтерпретатора."

msgid ""
"See also the description of the :keyword:`try` statement in section :ref:"
"`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""
"Дивіться також опис оператора :keyword:`try` у розділі :ref:`try` та "
"оператора :keyword:`raise` у розділі :ref:`raise`."

msgid "Footnotes"
msgstr "Виноски"

msgid ""
"This limitation occurs because the code that is executed by these operations "
"is not available at the time the module is compiled."
msgstr ""
"Це обмеження виникає через те, що код, який виконується цими операціями, "
"недоступний під час компіляції модуля."
