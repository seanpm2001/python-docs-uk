# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Logging Cookbook"
msgstr "\"Книга рецептів\" з логування"

msgid "Author"
msgstr "Автор"

msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

msgid ""
"This page contains a number of recipes related to logging, which have been "
"found useful in the past. For links to tutorial and reference information, "
"please see :ref:`cookbook-ref-links`."
msgstr ""

msgid "Using logging in multiple modules"
msgstr "Використання журналювання в кількох модулях"

msgid ""
"Multiple calls to ``logging.getLogger('someLogger')`` return a reference to "
"the same logger object.  This is true not only within the same module, but "
"also across modules as long as it is in the same Python interpreter "
"process.  It is true for references to the same object; additionally, "
"application code can define and configure a parent logger in one module and "
"create (but not configure) a child logger in a separate module, and all "
"logger calls to the child will pass up to the parent.  Here is a main "
"module::"
msgstr ""
"Кілька викликів ``logging.getLogger('someLogger')`` повертають посилання на "
"той самий об’єкт журналу. Це вірно не лише в межах одного модуля, але й у "
"всіх модулях, якщо вони знаходяться в одному процесі інтерпретатора Python. "
"Це вірно для посилань на той самий об’єкт; крім того, код програми може "
"визначати та налаштовувати батьківський реєстратор в одному модулі та "
"створювати (але не налаштовувати) дочірній реєстратор в окремому модулі, і "
"всі виклики реєстратора до дочірнього модуля передадуться батьківському. Ось "
"головний модуль::"

msgid "Here is the auxiliary module::"
msgstr "Ось допоміжний модуль::"

msgid "The output looks like this:"
msgstr "Результат виглядає так:"

msgid "Logging from multiple threads"
msgstr "Ведення журналу з кількох потоків"

msgid ""
"Logging from multiple threads requires no special effort. The following "
"example shows logging from the main (initial) thread and another thread::"
msgstr ""
"Логування з кількох потоків не потребує особливих зусиль. У наступному "
"прикладі показано журналювання з основного (початкового) потоку та іншого "
"потоку::"

msgid "When run, the script should print something like the following:"
msgstr "Під час запуску сценарій має надрукувати щось на зразок такого:"

msgid ""
"This shows the logging output interspersed as one might expect. This "
"approach works for more threads than shown here, of course."
msgstr ""
"Це показує результати журналювання, як і можна було очікувати. Звичайно, цей "
"підхід працює для більшої кількості потоків, ніж показано тут."

msgid "Multiple handlers and formatters"
msgstr "Кілька обробників і форматувальників"

msgid ""
"Loggers are plain Python objects.  The :meth:`~Logger.addHandler` method has "
"no minimum or maximum quota for the number of handlers you may add.  "
"Sometimes it will be beneficial for an application to log all messages of "
"all severities to a text file while simultaneously logging errors or above "
"to the console.  To set this up, simply configure the appropriate handlers.  "
"The logging calls in the application code will remain unchanged.  Here is a "
"slight modification to the previous simple module-based configuration "
"example::"
msgstr ""
"Логери — це звичайні об’єкти Python. Метод :meth:`~Logger.addHandler` не має "
"мінімальної або максимальної квоти на кількість обробників, які ви можете "
"додати. Іноді для програми буде корисно реєструвати всі повідомлення будь-"
"якого рівня серйозності в текстовий файл, одночасно реєструючи помилки або "
"вище на консолі. Щоб налаштувати це, просто налаштуйте відповідні обробники. "
"Виклики журналювання в коді програми залишаться незмінними. Ось невелика "
"модифікація попереднього простого прикладу конфігурації на основі модуля:"

msgid ""
"Notice that the 'application' code does not care about multiple handlers.  "
"All that changed was the addition and configuration of a new handler named "
"*fh*."
msgstr ""
"Зауважте, що код програми не піклується про декілька обробників. Все, що "
"змінилося, це додавання та налаштування нового обробника під назвою *fh*."

msgid ""
"The ability to create new handlers with higher- or lower-severity filters "
"can be very helpful when writing and testing an application.  Instead of "
"using many ``print`` statements for debugging, use ``logger.debug``: Unlike "
"the print statements, which you will have to delete or comment out later, "
"the logger.debug statements can remain intact in the source code and remain "
"dormant until you need them again.  At that time, the only change that needs "
"to happen is to modify the severity level of the logger and/or handler to "
"debug."
msgstr ""
"Можливість створювати нові обробники з фільтрами вищого або нижчого рівня "
"серйозності може бути дуже корисною під час написання та тестування "
"програми. Замість використання багатьох інструкцій ``print`` для "
"налагодження використовуйте ``logger.debug``: на відміну від інструкцій "
"print, які вам доведеться видалити або закоментувати пізніше, інструкції "
"logger.debug можуть залишатися недоторканими у вихідному коді. і залишаються "
"в стані спокою, доки вони вам знову не знадобляться. У той час єдина зміна, "
"яка має відбутися, це змінити рівень серйозності реєстратора та/або "
"обробника для налагодження."

msgid "Logging to multiple destinations"
msgstr "Реєстрація в кількох пунктах призначення"

msgid ""
"Let's say you want to log to console and file with different message formats "
"and in differing circumstances. Say you want to log messages with levels of "
"DEBUG and higher to file, and those messages at level INFO and higher to the "
"console. Let's also assume that the file should contain timestamps, but the "
"console messages should not. Here's how you can achieve this::"
msgstr ""
"Припустімо, ви хочете увійти в консоль і файл із різними форматами "
"повідомлень і за різних обставин. Скажімо, ви хочете реєструвати "
"повідомлення з рівнями DEBUG і вище у файл, а ці повідомлення рівня INFO і "
"вище — на консоль. Давайте також припустимо, що файл повинен містити мітки "
"часу, але повідомлення консолі не повинні. Ось як ви можете цього досягти:"

msgid "When you run this, on the console you will see"
msgstr "Коли ви запустите це, на консолі ви побачите"

msgid "and in the file you will see something like"
msgstr "і у файлі ви побачите щось на зразок"

msgid ""
"As you can see, the DEBUG message only shows up in the file. The other "
"messages are sent to both destinations."
msgstr ""
"Як бачите, повідомлення DEBUG відображається лише у файлі. Інші повідомлення "
"надсилаються в обидва адресати."

msgid ""
"This example uses console and file handlers, but you can use any number and "
"combination of handlers you choose."
msgstr ""
"У цьому прикладі використовуються обробники консолі та файлів, але ви можете "
"використовувати будь-яку кількість і комбінацію обробників на свій вибір."

msgid ""
"Note that the above choice of log filename ``/tmp/myapp.log`` implies use of "
"a standard location for temporary files on POSIX systems. On Windows, you "
"may need to choose a different directory name for the log - just ensure that "
"the directory exists and that you have the permissions to create and update "
"files in it."
msgstr ""

msgid "Custom handling of levels"
msgstr ""

msgid ""
"Sometimes, you might want to do something slightly different from the "
"standard handling of levels in handlers, where all levels above a threshold "
"get processed by a handler. To do this, you need to use filters. Let's look "
"at a scenario where you want to arrange things as follows:"
msgstr ""

msgid "Send messages of severity ``INFO`` and ``WARNING`` to ``sys.stdout``"
msgstr ""

msgid "Send messages of severity ``ERROR`` and above to ``sys.stderr``"
msgstr ""

msgid "Send messages of severity ``DEBUG`` and above to file ``app.log``"
msgstr ""

msgid "Suppose you configure logging with the following JSON:"
msgstr ""

msgid ""
"This configuration does *almost* what we want, except that ``sys.stdout`` "
"would show messages of severity ``ERROR`` and above as well as ``INFO`` and "
"``WARNING`` messages. To prevent this, we can set up a filter which excludes "
"those messages and add it to the relevant handler. This can be configured by "
"adding a ``filters`` section parallel to ``formatters`` and ``handlers``:"
msgstr ""

msgid "and changing the section on the ``stdout`` handler to add it:"
msgstr ""

msgid ""
"A filter is just a function, so we can define the ``filter_maker`` (a "
"factory function) as follows:"
msgstr ""

msgid ""
"This converts the string argument passed in to a numeric level, and returns "
"a function which only returns ``True`` if the level of the passed in record "
"is at or below the specified level. Note that in this example I have defined "
"the ``filter_maker`` in a test script ``main.py`` that I run from the "
"command line, so its module will be ``__main__`` - hence the ``__main__."
"filter_maker`` in the filter configuration. You will need to change that if "
"you define it in a different module."
msgstr ""

msgid "With the filter added, we can run ``main.py``, which in full is:"
msgstr ""

msgid "And after running it like this:"
msgstr ""

msgid "We can see the results are as expected:"
msgstr ""

msgid "Configuration server example"
msgstr "Приклад конфігурації сервера"

msgid "Here is an example of a module using the logging configuration server::"
msgstr "Ось приклад модуля, який використовує сервер конфігурації журналу:"

msgid ""
"And here is a script that takes a filename and sends that file to the "
"server, properly preceded with the binary-encoded length, as the new logging "
"configuration::"
msgstr ""
"А ось сценарій, який приймає ім’я файлу та надсилає цей файл на сервер, "
"належним чином передуючи довжиною у двійковому кодуванні, як нову "
"конфігурацію журналювання::"

msgid "Dealing with handlers that block"
msgstr "Робота з обробниками, які блокують"

msgid ""
"Sometimes you have to get your logging handlers to do their work without "
"blocking the thread you're logging from. This is common in web applications, "
"though of course it also occurs in other scenarios."
msgstr ""
"Іноді вам потрібно змусити обробників журналу виконувати свою роботу, не "
"блокуючи потік, з якого ви входите. Це поширене явище у веб-додатках, хоча, "
"звичайно, трапляється й в інших сценаріях."

msgid ""
"A common culprit which demonstrates sluggish behaviour is the :class:"
"`SMTPHandler`: sending emails can take a long time, for a number of reasons "
"outside the developer's control (for example, a poorly performing mail or "
"network infrastructure). But almost any network-based handler can block: "
"Even a :class:`SocketHandler` operation may do a DNS query under the hood "
"which is too slow (and this query can be deep in the socket library code, "
"below the Python layer, and outside your control)."
msgstr ""
"Поширеним винуватцем млявої поведінки є :class:`SMTPHandler`: надсилання "
"електронних листів може тривати багато часу через ряд причин, які не "
"залежать від розробника (наприклад, погана робота пошти чи мережевої "
"інфраструктури). Але майже будь-який мережевий обробник може заблокувати: "
"навіть операція :class:`SocketHandler` може виконати DNS-запит під капотом, "
"який надто повільний (і цей запит може бути глибоко в коді бібліотеки "
"сокетів, нижче рівня Python, і поза вашим контролем)."

msgid ""
"One solution is to use a two-part approach. For the first part, attach only "
"a :class:`QueueHandler` to those loggers which are accessed from performance-"
"critical threads. They simply write to their queue, which can be sized to a "
"large enough capacity or initialized with no upper bound to their size. The "
"write to the queue will typically be accepted quickly, though you will "
"probably need to catch the :exc:`queue.Full` exception as a precaution in "
"your code. If you are a library developer who has performance-critical "
"threads in their code, be sure to document this (together with a suggestion "
"to attach only ``QueueHandlers`` to your loggers) for the benefit of other "
"developers who will use your code."
msgstr ""
"Одним із рішень є використання підходу з двох частин. Для першої частини "
"додайте лише :class:`QueueHandler` до тих реєстраторів, доступ до яких "
"здійснюється з критичних для продуктивності потоків. Вони просто записують у "
"свою чергу, розмір якої може бути достатньо великим або ініціалізований без "
"верхньої межі їхнього розміру. Запис до черги, як правило, швидко "
"приймається, хоча вам, ймовірно, потрібно буде перехопити виняток :exc:"
"`queue.Full` як запобіжний захід у вашому коді. Якщо ви розробник "
"бібліотеки, у коді якого є критично важливі для продуктивності потоки, "
"обов’язково задокументуйте це (разом із пропозицією приєднати лише "
"``QueueHandlers`` до ваших реєстраторів) на користь інших розробників, які "
"використовуватимуть ваш код."

msgid ""
"The second part of the solution is :class:`QueueListener`, which has been "
"designed as the counterpart to :class:`QueueHandler`.  A :class:"
"`QueueListener` is very simple: it's passed a queue and some handlers, and "
"it fires up an internal thread which listens to its queue for LogRecords "
"sent from ``QueueHandlers`` (or any other source of ``LogRecords``, for that "
"matter). The ``LogRecords`` are removed from the queue and passed to the "
"handlers for processing."
msgstr ""
"Другою частиною рішення є :class:`QueueListener`, який був розроблений як "
"відповідник :class:`QueueHandler`. :class:`QueueListener` дуже простий: він "
"передає чергу та деякі обробники, і запускає внутрішній потік, який "
"прослуховує свою чергу для LogRecords, надісланих з ``QueueHandlers`` (або "
"будь-якого іншого джерела ``LogRecords``, як на те пішло). ``LogRecords`` "
"видаляються з черги та передаються обробникам для обробки."

msgid ""
"The advantage of having a separate :class:`QueueListener` class is that you "
"can use the same instance to service multiple ``QueueHandlers``. This is "
"more resource-friendly than, say, having threaded versions of the existing "
"handler classes, which would eat up one thread per handler for no particular "
"benefit."
msgstr ""
"Перевага наявності окремого класу :class:`QueueListener` полягає в тому, що "
"ви можете використовувати один екземпляр для обслуговування кількох "
"``QueueHandler``. Це більш дружньо до ресурсів, ніж, скажімо, мати "
"багатопотокові версії існуючих класів обробників, які з’їдають один потік на "
"обробник без особливої користі."

msgid "An example of using these two classes follows (imports omitted)::"
msgstr "Нижче наведено приклад використання цих двох класів (імпорт опущено):"

msgid "which, when run, will produce:"
msgstr "який під час запуску вироблятиме:"

msgid ""
"Although the earlier discussion wasn't specifically talking about async "
"code, but rather about slow logging handlers, it should be noted that when "
"logging from async code, network and even file handlers could lead to "
"problems (blocking the event loop) because some logging is done from :mod:"
"`asyncio` internals. It might be best, if any async code is used in an "
"application, to use the above approach for logging, so that any blocking "
"code runs only in the ``QueueListener`` thread."
msgstr ""

msgid ""
"Prior to Python 3.5, the :class:`QueueListener` always passed every message "
"received from the queue to every handler it was initialized with. (This was "
"because it was assumed that level filtering was all done on the other side, "
"where the queue is filled.) From 3.5 onwards, this behaviour can be changed "
"by passing a keyword argument ``respect_handler_level=True`` to the "
"listener's constructor. When this is done, the listener compares the level "
"of each message with the handler's level, and only passes a message to a "
"handler if it's appropriate to do so."
msgstr ""
"До Python 3.5 :class:`QueueListener` завжди передавав кожне повідомлення, "
"отримане з черги, кожному обробнику, яким він був ініціалізований. (Це "
"сталося тому, що передбачалося, що фільтрація рівня виконується з іншого "
"боку, де заповнюється черга.) Починаючи з версії 3.5 і далі цю поведінку "
"можна змінити, передавши аргумент ключового слова "
"``respect_handler_level=True`` конструктору слухача . Коли це зроблено, "
"слухач порівнює рівень кожного повідомлення з рівнем обробника та передає "
"повідомлення обробнику, лише якщо це доречно."

msgid "Sending and receiving logging events across a network"
msgstr "Надсилання та отримання журнальних подій через мережу"

msgid ""
"Let's say you want to send logging events across a network, and handle them "
"at the receiving end. A simple way of doing this is attaching a :class:"
"`SocketHandler` instance to the root logger at the sending end::"
msgstr ""
"Припустімо, ви хочете надіслати події журналювання через мережу та обробити "
"їх на приймаючому кінці. Простий спосіб зробити це — приєднати екземпляр :"
"class:`SocketHandler` до кореневого реєстратора на стороні надсилання::"

msgid ""
"At the receiving end, you can set up a receiver using the :mod:"
"`socketserver` module. Here is a basic working example::"
msgstr ""
"На стороні приймача ви можете налаштувати приймача за допомогою модуля :mod:"
"`socketserver`. Ось базовий робочий приклад:"

msgid ""
"First run the server, and then the client. On the client side, nothing is "
"printed on the console; on the server side, you should see something like:"
msgstr ""
"Спочатку запустіть сервер, а потім клієнт. На стороні клієнта на консолі "
"нічого не друкується; на стороні сервера ви повинні побачити щось на кшталт:"

msgid ""
"Note that there are some security issues with pickle in some scenarios. If "
"these affect you, you can use an alternative serialization scheme by "
"overriding the :meth:`~handlers.SocketHandler.makePickle` method and "
"implementing your alternative there, as well as adapting the above script to "
"use your alternative serialization."
msgstr ""
"Зауважте, що в деяких сценаріях із pickle виникають проблеми з безпекою. "
"Якщо це стосується вас, ви можете використати альтернативну схему "
"серіалізації, перевизначивши метод :meth:`~handlers.SocketHandler."
"makePickle` і реалізувавши там свою альтернативу, а також адаптувавши "
"наведений вище сценарій для використання альтернативної серіалізації."

msgid "Running a logging socket listener in production"
msgstr "Запуск прослуховувача сокетів журналювання у виробництві"

msgid ""
"To run a logging listener in production, you may need to use a process-"
"management tool such as `Supervisor <http://supervisord.org/>`_. `Here is a "
"Gist <socket-listener-gist_>`__ which provides the bare-bones files to run "
"the above functionality using Supervisor. It consists of the following files:"
msgstr ""

msgid "File"
msgstr ""

msgid "Purpose"
msgstr "призначення"

msgid ":file:`prepare.sh`"
msgstr ""

msgid "A Bash script to prepare the environment for testing"
msgstr ""

msgid ":file:`supervisor.conf`"
msgstr ""

msgid ""
"The Supervisor configuration file, which has entries for the listener and a "
"multi-process web application"
msgstr ""

msgid ":file:`ensure_app.sh`"
msgstr ""

msgid ""
"A Bash script to ensure that Supervisor is running with the above "
"configuration"
msgstr ""

msgid ":file:`log_listener.py`"
msgstr ""

msgid ""
"The socket listener program which receives log events and records them to a "
"file"
msgstr ""

msgid ":file:`main.py`"
msgstr ""

msgid ""
"A simple web application which performs logging via a socket connected to "
"the listener"
msgstr ""

msgid ":file:`webapp.json`"
msgstr ""

msgid "A JSON configuration file for the web application"
msgstr ""

msgid ":file:`client.py`"
msgstr ""

msgid "A Python script to exercise the web application"
msgstr ""

msgid ""
"The web application uses `Gunicorn <https://gunicorn.org/>`_, which is a "
"popular web application server that starts multiple worker processes to "
"handle requests. This example setup shows how the workers can write to the "
"same log file without conflicting with one another --- they all go through "
"the socket listener."
msgstr ""

msgid "To test these files, do the following in a POSIX environment:"
msgstr ""

msgid ""
"Download `the Gist <socket-listener-gist_>`__ as a ZIP archive using the :"
"guilabel:`Download ZIP` button."
msgstr ""

msgid "Unzip the above files from the archive into a scratch directory."
msgstr ""

msgid ""
"In the scratch directory, run ``bash prepare.sh`` to get things ready. This "
"creates a :file:`run` subdirectory to contain Supervisor-related and log "
"files, and a :file:`venv` subdirectory to contain a virtual environment into "
"which ``bottle``, ``gunicorn`` and ``supervisor`` are installed."
msgstr ""

msgid ""
"Run ``bash ensure_app.sh`` to ensure that Supervisor is running with the "
"above configuration."
msgstr ""

msgid ""
"Run ``venv/bin/python client.py`` to exercise the web application, which "
"will lead to records being written to the log."
msgstr ""

msgid ""
"Inspect the log files in the :file:`run` subdirectory. You should see the "
"most recent log lines in files matching the pattern :file:`app.log*`. They "
"won't be in any particular order, since they have been handled concurrently "
"by different worker processes in a non-deterministic way."
msgstr ""

msgid ""
"You can shut down the listener and the web application by running ``venv/bin/"
"supervisorctl -c supervisor.conf shutdown``."
msgstr ""

msgid ""
"You may need to tweak the configuration files in the unlikely event that the "
"configured ports clash with something else in your test environment."
msgstr ""

msgid "Adding contextual information to your logging output"
msgstr "Додавання контекстної інформації до вихідних даних журналу"

msgid ""
"Sometimes you want logging output to contain contextual information in "
"addition to the parameters passed to the logging call. For example, in a "
"networked application, it may be desirable to log client-specific "
"information in the log (e.g. remote client's username, or IP address). "
"Although you could use the *extra* parameter to achieve this, it's not "
"always convenient to pass the information in this way. While it might be "
"tempting to create :class:`Logger` instances on a per-connection basis, this "
"is not a good idea because these instances are not garbage collected. While "
"this is not a problem in practice, when the number of :class:`Logger` "
"instances is dependent on the level of granularity you want to use in "
"logging an application, it could be hard to manage if the number of :class:"
"`Logger` instances becomes effectively unbounded."
msgstr ""
"Іноді потрібно, щоб вихід журналу містив контекстну інформацію на додаток до "
"параметрів, переданих до виклику журналу. Наприклад, у мережевій програмі "
"може бути бажаним реєструвати інформацію про клієнта в журналі (наприклад, "
"ім’я користувача віддаленого клієнта або IP-адресу). Хоча для цього можна "
"використовувати параметр *extra*, не завжди зручно передавати інформацію "
"таким чином. Хоча може виникнути спокуса створити екземпляри :class:`Logger` "
"для кожного з’єднання, це не дуже гарна ідея, оскільки ці екземпляри не "
"збираються для сміття. Хоча це не є проблемою на практиці, коли кількість "
"екземплярів :class:`Logger` залежить від рівня деталізації, який ви хочете "
"використовувати для реєстрації програми, може бути важко керувати кількістю :"
"class:`Екземпляри Logger` стають фактично необмеженими."

msgid "Using LoggerAdapters to impart contextual information"
msgstr "Використання LoggerAdapters для передачі контекстної інформації"

msgid ""
"An easy way in which you can pass contextual information to be output along "
"with logging event information is to use the :class:`LoggerAdapter` class. "
"This class is designed to look like a :class:`Logger`, so that you can call :"
"meth:`debug`, :meth:`info`, :meth:`warning`, :meth:`error`, :meth:"
"`exception`, :meth:`critical` and :meth:`log`. These methods have the same "
"signatures as their counterparts in :class:`Logger`, so you can use the two "
"types of instances interchangeably."
msgstr ""
"Простий спосіб, за допомогою якого ви можете передати контекстну інформацію "
"для виведення разом із інформацією про подію журналювання, полягає у "
"використанні класу :class:`LoggerAdapter`. Цей клас розроблено так, щоб "
"виглядати як :class:`Logger`, щоб ви могли викликати :meth:`debug`, :meth:"
"`info`, :meth:`warning`, :meth:`error`, :meth:`exception`, :meth:`critical` "
"і :meth:`log`. Ці методи мають ті самі сигнатури, що й їхні аналоги в :class:"
"`Logger`, тому ви можете використовувати обидва типи екземплярів як "
"взаємозамінні."

msgid ""
"When you create an instance of :class:`LoggerAdapter`, you pass it a :class:"
"`Logger` instance and a dict-like object which contains your contextual "
"information. When you call one of the logging methods on an instance of :"
"class:`LoggerAdapter`, it delegates the call to the underlying instance of :"
"class:`Logger` passed to its constructor, and arranges to pass the "
"contextual information in the delegated call. Here's a snippet from the code "
"of :class:`LoggerAdapter`::"
msgstr ""
"Коли ви створюєте екземпляр :class:`LoggerAdapter`, ви передаєте йому "
"екземпляр :class:`Logger` і dict-подібний об’єкт, який містить вашу "
"контекстну інформацію. Коли ви викликаєте один із методів журналювання в "
"екземплярі :class:`LoggerAdapter`, він делегує виклик базовому екземпляру :"
"class:`Logger`, який передається його конструктору, і організовує передачу "
"контекстної інформації в делегованому виклику . Ось фрагмент коду :class:"
"`LoggerAdapter`::"

msgid ""
"The :meth:`~LoggerAdapter.process` method of :class:`LoggerAdapter` is where "
"the contextual information is added to the logging output. It's passed the "
"message and keyword arguments of the logging call, and it passes back "
"(potentially) modified versions of these to use in the call to the "
"underlying logger. The default implementation of this method leaves the "
"message alone, but inserts an 'extra' key in the keyword argument whose "
"value is the dict-like object passed to the constructor. Of course, if you "
"had passed an 'extra' keyword argument in the call to the adapter, it will "
"be silently overwritten."
msgstr ""
"У методі :meth:`~LoggerAdapter.process` :class:`LoggerAdapter` контекстна "
"інформація додається до результатів журналювання. Він передає аргументи "
"повідомлення та ключове слово виклику журналювання, а також повертає "
"(потенційно) модифіковані версії їх для використання у виклику базовому "
"реєстратору. Реалізація цього методу за замовчуванням залишає повідомлення в "
"спокої, але вставляє \"додатковий\" ключ в аргумент ключового слова, "
"значенням якого є dict-подібний об’єкт, переданий конструктору. Звичайно, "
"якщо ви передали \"додатковий\" аргумент ключового слова під час виклику "
"адаптера, він буде мовчки перезаписаний."

msgid ""
"The advantage of using 'extra' is that the values in the dict-like object "
"are merged into the :class:`LogRecord` instance's __dict__, allowing you to "
"use customized strings with your :class:`Formatter` instances which know "
"about the keys of the dict-like object. If you need a different method, e.g. "
"if you want to prepend or append the contextual information to the message "
"string, you just need to subclass :class:`LoggerAdapter` and override :meth:"
"`~LoggerAdapter.process` to do what you need. Here is a simple example::"
msgstr ""
"Перевага використання \"extra\" полягає в тому, що значення в dict-подібному "
"об’єкті об’єднуються в __dict__ екземпляра :class:`LogRecord`, що дозволяє "
"вам використовувати налаштовані рядки з вашими екземплярами :class:"
"`Formatter`, які знають про ключі диктоподібного об’єкта. Якщо вам потрібен "
"інший метод, напр. якщо ви хочете передати або додати контекстну інформацію "
"до рядка повідомлення, вам просто потрібно створити підклас :class:"
"`LoggerAdapter` і перевизначити :meth:`~LoggerAdapter.process`, щоб зробити "
"те, що вам потрібно. Ось простий приклад::"

msgid "which you can use like this::"
msgstr "який можна використовувати таким чином::"

msgid ""
"Then any events that you log to the adapter will have the value of "
"``some_conn_id`` prepended to the log messages."
msgstr ""
"Тоді будь-які події, які ви реєструєте в адаптері, матимуть значення "
"``some_conn_id`` до повідомлень журналу."

msgid "Using objects other than dicts to pass contextual information"
msgstr ""
"Використання об’єктів, відмінних від dicts, для передачі контекстної "
"інформації"

msgid ""
"You don't need to pass an actual dict to a :class:`LoggerAdapter` - you "
"could pass an instance of a class which implements ``__getitem__`` and "
"``__iter__`` so that it looks like a dict to logging. This would be useful "
"if you want to generate values dynamically (whereas the values in a dict "
"would be constant)."
msgstr ""
"Вам не потрібно передавати фактичний dict до :class:`LoggerAdapter` - ви "
"можете передати примірник класу, який реалізує ``__getitem__`` і "
"``__iter__``, щоб він виглядав як dict для журналювання. Це буде корисно, "
"якщо ви хочете генерувати значення динамічно (тоді як значення в dict будуть "
"постійними)."

msgid "Using Filters to impart contextual information"
msgstr "Використання фільтрів для передачі контекстної інформації"

msgid ""
"You can also add contextual information to log output using a user-defined :"
"class:`Filter`. ``Filter`` instances are allowed to modify the "
"``LogRecords`` passed to them, including adding additional attributes which "
"can then be output using a suitable format string, or if needed a custom :"
"class:`Formatter`."
msgstr ""
"Ви також можете додати контекстну інформацію до виведення журналу за "
"допомогою визначеного користувачем :class:`Filter`. Екземплярам ``Filter`` "
"дозволено змінювати ``LogRecords``, передані їм, включаючи додавання "
"додаткових атрибутів, які потім можуть бути виведені за допомогою рядка "
"відповідного формату або, якщо необхідно, спеціального :class:`Formatter`."

msgid ""
"For example in a web application, the request being processed (or at least, "
"the interesting parts of it) can be stored in a threadlocal (:class:"
"`threading.local`) variable, and then accessed from a ``Filter`` to add, "
"say, information from the request - say, the remote IP address and remote "
"user's username - to the ``LogRecord``, using the attribute names 'ip' and "
"'user' as in the ``LoggerAdapter`` example above. In that case, the same "
"format string can be used to get similar output to that shown above. Here's "
"an example script::"
msgstr ""
"Наприклад, у веб-додатку запит, який обробляється (або, принаймні, його "
"цікаві частини) можна зберегти у змінній threadlocal (:class:`threading."
"local`), а потім отримати доступ із ``Фільтра`` щоб додати, скажімо, "
"інформацію із запиту - скажімо, віддалену IP-адресу та ім'я користувача "
"віддаленого користувача - до ``LogRecord``, використовуючи імена атрибутів "
"'ip' і 'user', як у прикладі ``LoggerAdapter`` вище . У цьому випадку можна "
"використати той самий рядок формату, щоб отримати вихід, схожий на показаний "
"вище. Ось приклад сценарію::"

msgid "which, when run, produces something like:"
msgstr "який під час запуску створює щось на зразок:"

msgid "Use of ``contextvars``"
msgstr ""

msgid ""
"Since Python 3.7, the :mod:`contextvars` module has provided context-local "
"storage which works for both :mod:`threading` and :mod:`asyncio` processing "
"needs. This type of storage may thus be generally preferable to thread-"
"locals. The following example shows how, in a multi-threaded environment, "
"logs can populated with contextual information such as, for example, request "
"attributes handled by web applications."
msgstr ""

msgid ""
"For the purposes of illustration, say that you have different web "
"applications, each independent of the other but running in the same Python "
"process and using a library common to them. How can each of these "
"applications have their own log, where all logging messages from the library "
"(and other request processing code) are directed to the appropriate "
"application's log file, while including in the log additional contextual "
"information such as client IP, HTTP request method and client username?"
msgstr ""

msgid "Let's assume that the library can be simulated by the following code:"
msgstr ""

msgid ""
"We can simulate the multiple web applications by means of two simple "
"classes, ``Request`` and ``WebApp``. These simulate how real threaded web "
"applications work - each request is handled by a thread:"
msgstr ""

msgid ""
"If you run the above, you should find that roughly half the requests go "
"into :file:`app1.log` and the rest into :file:`app2.log`, and the all the "
"requests are logged to :file:`app.log`. Each webapp-specific log will "
"contain only log entries for only that webapp, and the request information "
"will be displayed consistently in the log (i.e. the information in each "
"dummy request will always appear together in a log line). This is "
"illustrated by the following shell output:"
msgstr ""

msgid "Imparting contextual information in handlers"
msgstr ""

msgid ""
"Each :class:`~Handler` has its own chain of filters. If you want to add "
"contextual information to a :class:`LogRecord` without leaking it to other "
"handlers, you can use a filter that returns a new :class:`~LogRecord` "
"instead of modifying it in-place, as shown in the following script::"
msgstr ""

msgid "Logging to a single file from multiple processes"
msgstr "Реєстрація в один файл з кількох процесів"

msgid ""
"Although logging is thread-safe, and logging to a single file from multiple "
"threads in a single process *is* supported, logging to a single file from "
"*multiple processes* is *not* supported, because there is no standard way to "
"serialize access to a single file across multiple processes in Python. If "
"you need to log to a single file from multiple processes, one way of doing "
"this is to have all the processes log to a :class:`~handlers.SocketHandler`, "
"and have a separate process which implements a socket server which reads "
"from the socket and logs to file. (If you prefer, you can dedicate one "
"thread in one of the existing processes to perform this function.) :ref:"
"`This section <network-logging>` documents this approach in more detail and "
"includes a working socket receiver which can be used as a starting point for "
"you to adapt in your own applications."
msgstr ""
"Хоча ведення журналу є потокобезпечним і *підтримується* журналювання в один "
"файл із кількох потоків в одному процесі, журналювання в один файл із "
"*кількох процесів *не* підтримується, оскільки немає стандартного способу "
"серіалізації доступу в один файл через кілька процесів у Python. Якщо вам "
"потрібно ввійти до одного файлу з кількох процесів, один із способів зробити "
"це — зареєструвати всі процеси в :class:`~handlers.SocketHandler` і мати "
"окремий процес, який реалізує сервер сокетів, який читає з сокет і журнали в "
"файл. (Якщо ви віддаєте перевагу, ви можете виділити один потік в одному з "
"існуючих процесів для виконання цієї функції.) :ref:`Цей розділ <network-"
"logging>` документує цей підхід більш детально та містить робочий приймач "
"сокетів, який можна використовувати як відправну точку для адаптації у "
"власних програмах."

msgid ""
"You could also write your own handler which uses the :class:"
"`~multiprocessing.Lock` class from the :mod:`multiprocessing` module to "
"serialize access to the file from your processes. The existing :class:"
"`FileHandler` and subclasses do not make use of :mod:`multiprocessing` at "
"present, though they may do so in the future. Note that at present, the :mod:"
"`multiprocessing` module does not provide working lock functionality on all "
"platforms (see https://bugs.python.org/issue3770)."
msgstr ""
"Ви також можете написати власний обробник, який використовує клас :class:"
"`~multiprocessing.Lock` з модуля :mod:`multiprocessing` для серіалізації "
"доступу до файлу з ваших процесів. Існуючий :class:`FileHandler` і підкласи "
"не використовують :mod:`multiprocessing` наразі, хоча вони можуть "
"використовувати це в майбутньому. Зауважте, що наразі модуль :mod:"
"`multiprocessing` не забезпечує робочу функцію блокування на всіх платформах "
"(див. https://bugs.python.org/issue3770)."

msgid ""
"Alternatively, you can use a ``Queue`` and a :class:`QueueHandler` to send "
"all logging events to one of the processes in your multi-process "
"application. The following example script demonstrates how you can do this; "
"in the example a separate listener process listens for events sent by other "
"processes and logs them according to its own logging configuration. Although "
"the example only demonstrates one way of doing it (for example, you may want "
"to use a listener thread rather than a separate listener process -- the "
"implementation would be analogous) it does allow for completely different "
"logging configurations for the listener and the other processes in your "
"application, and can be used as the basis for code meeting your own specific "
"requirements::"
msgstr ""
"Крім того, ви можете використовувати ``Queue`` і :class:`QueueHandler`, щоб "
"надсилати всі події журналювання до одного з процесів у вашій "
"багатопроцесовій програмі. Наступний приклад сценарію демонструє, як це "
"можна зробити; у прикладі окремий процес слухача прослуховує події, "
"надіслані іншими процесами, і реєструє їх відповідно до власної конфігурації "
"журналювання. Хоча приклад демонструє лише один спосіб зробити це "
"(наприклад, ви можете використовувати потік слухача, а не окремий процес "
"слухача — реалізація буде аналогічною), він дозволяє абсолютно різні "
"конфігурації журналювання для слухача та інших процеси у вашій програмі та "
"можуть бути використані як основа для коду, який відповідає вашим власним "
"вимогам:"

msgid ""
"A variant of the above script keeps the logging in the main process, in a "
"separate thread::"
msgstr ""
"Варіант наведеного вище сценарію зберігає журнали в основному процесі в "
"окремому потоці:"

msgid ""
"This variant shows how you can e.g. apply configuration for particular "
"loggers - e.g. the ``foo`` logger has a special handler which stores all "
"events in the ``foo`` subsystem in a file ``mplog-foo.log``. This will be "
"used by the logging machinery in the main process (even though the logging "
"events are generated in the worker processes) to direct the messages to the "
"appropriate destinations."
msgstr ""
"Цей варіант показує, як ви можете напр. застосувати конфігурацію для певних "
"реєстраторів - напр. Логер ``foo`` має спеціальний обробник, який зберігає "
"всі події в підсистемі ``foo`` у файлі ``mplog-foo.log``. Це "
"використовуватиметься механізмом реєстрації в основному процесі (навіть якщо "
"події журналювання генеруються в робочих процесах), щоб спрямувати "
"повідомлення до відповідних адресатів."

msgid "Using concurrent.futures.ProcessPoolExecutor"
msgstr "Використання concurrent.futures.ProcessPoolExecutor"

msgid ""
"If you want to use :class:`concurrent.futures.ProcessPoolExecutor` to start "
"your worker processes, you need to create the queue slightly differently. "
"Instead of"
msgstr ""
"Якщо ви хочете використовувати :class:`concurrent.futures."
"ProcessPoolExecutor` для запуску ваших робочих процесів, вам потрібно "
"створити чергу трохи інакше. Замість"

msgid "you should use"
msgstr "ви повинні використовувати"

msgid "and you can then replace the worker creation from this::"
msgstr "а потім ви можете замінити робоче створення з цього::"

msgid "to this (remembering to first import :mod:`concurrent.futures`)::"
msgstr "до цього (не забувши спочатку імпортувати :mod:`concurrent.futures`)::"

msgid "Deploying Web applications using Gunicorn and uWSGI"
msgstr "Розгортання веб-додатків за допомогою Gunicorn і uWSGI"

msgid ""
"When deploying Web applications using `Gunicorn <https://gunicorn.org/>`_ or "
"`uWSGI <https://uwsgi-docs.readthedocs.io/en/latest/>`_ (or similar), "
"multiple worker processes are created to handle client requests. In such "
"environments, avoid creating file-based handlers directly in your web "
"application. Instead, use a :class:`SocketHandler` to log from the web "
"application to a listener in a separate process. This can be set up using a "
"process management tool such as Supervisor - see `Running a logging socket "
"listener in production`_ for more details."
msgstr ""
"Під час розгортання веб-програм за допомогою `Gunicorn <https://gunicorn.org/"
">`_ або `uWSGI <https://uwsgi-docs.readthedocs.io/en/latest/>`_ (або "
"подібних), для обробки запитів клієнтів створюється кілька робочих процесів. "
"У таких середовищах уникайте створення обробників на основі файлів "
"безпосередньо у вашій веб-програмі. Замість цього використовуйте :class:"
"`SocketHandler`, щоб увійти з веб-програми до слухача в окремому процесі. Це "
"можна налаштувати за допомогою інструменту керування процесами, такого як "
"Supervisor - див. `Running a logging socket listener in production`_ для "
"отримання додаткової інформації."

msgid "Using file rotation"
msgstr "Використання ротації файлів"

msgid ""
"Sometimes you want to let a log file grow to a certain size, then open a new "
"file and log to that. You may want to keep a certain number of these files, "
"and when that many files have been created, rotate the files so that the "
"number of files and the size of the files both remain bounded. For this "
"usage pattern, the logging package provides a :class:`~handlers."
"RotatingFileHandler`::"
msgstr ""
"Іноді потрібно дозволити файлу журналу збільшитися до певного розміру, а "
"потім відкрити новий файл і зареєструвати його. Можливо, ви захочете "
"зберегти певну кількість цих файлів, а коли буде створено таку кількість "
"файлів, чергуйте файли так, щоб кількість і розмір файлів залишалися "
"обмеженими. Для цього шаблону використання пакет журналювання надає :class:"
"`~handlers.RotatingFileHandler`::"

msgid ""
"The result should be 6 separate files, each with part of the log history for "
"the application:"
msgstr ""
"У результаті повинно вийти 6 окремих файлів, кожен з яких містить частину "
"журналу журналу програми:"

msgid ""
"The most current file is always :file:`logging_rotatingfile_example.out`, "
"and each time it reaches the size limit it is renamed with the suffix "
"``.1``. Each of the existing backup files is renamed to increment the suffix "
"(``.1`` becomes ``.2``, etc.)  and the ``.6`` file is erased."
msgstr ""
"Найновішим файлом завжди є :file:`logging_rotatingfile_example.out`, і "
"кожного разу, коли він досягає ліміту розміру, він перейменовується з "
"суфіксом ``.1``. Кожен із наявних файлів резервної копії перейменовується, "
"щоб збільшити суфікс (``.1`` стає ``.2`` тощо), а файл ``.6`` видаляється."

msgid ""
"Obviously this example sets the log length much too small as an extreme "
"example.  You would want to set *maxBytes* to an appropriate value."
msgstr ""
"Очевидно, що цей приклад встановлює занадто малу довжину журналу як "
"екстремальний приклад. Вам потрібно встановити відповідне значення "
"*maxBytes*."

msgid "Use of alternative formatting styles"
msgstr "Використання альтернативних стилів форматування"

msgid ""
"When logging was added to the Python standard library, the only way of "
"formatting messages with variable content was to use the %-formatting "
"method. Since then, Python has gained two new formatting approaches: :class:"
"`string.Template` (added in Python 2.4) and :meth:`str.format` (added in "
"Python 2.6)."
msgstr ""
"Коли журналювання було додано до стандартної бібліотеки Python, єдиним "
"способом форматування повідомлень зі змінним вмістом було використання "
"методу %-formatting. Відтоді Python отримав два нові підходи до "
"форматування: :class:`string.Template` (доданий у Python 2.4) і :meth:`str."
"format` (доданий у Python 2.6)."

msgid ""
"Logging (as of 3.2) provides improved support for these two additional "
"formatting styles. The :class:`Formatter` class been enhanced to take an "
"additional, optional keyword parameter named ``style``. This defaults to "
"``'%'``, but other possible values are ``'{'`` and ``'$'``, which correspond "
"to the other two formatting styles. Backwards compatibility is maintained by "
"default (as you would expect), but by explicitly specifying a style "
"parameter, you get the ability to specify format strings which work with :"
"meth:`str.format` or :class:`string.Template`. Here's an example console "
"session to show the possibilities:"
msgstr ""
"Журналування (станом на 3.2) забезпечує покращену підтримку цих двох "
"додаткових стилів форматування. Клас :class:`Formatter` було вдосконалено, "
"щоб прийняти додатковий необов’язковий параметр ключового слова під назвою "
"``style``. За замовчуванням це ``'%'``, але інші можливі значення ``'{'`` і "
"``'$'``, які відповідають двом іншим стилям форматування. Зворотна "
"сумісність підтримується за замовчуванням (як і слід було очікувати), але, "
"явно вказавши параметр стилю, ви отримуєте можливість вказати рядки формату, "
"які працюють із :meth:`str.format` або :class:`string.Template`. Ось приклад "
"сеансу консолі, щоб показати можливості:"

msgid ""
"Note that the formatting of logging messages for final output to logs is "
"completely independent of how an individual logging message is constructed. "
"That can still use %-formatting, as shown here::"
msgstr ""
"Зверніть увагу, що форматування повідомлень журналу для остаточного "
"виведення в журнали повністю не залежить від того, як побудовано окреме "
"повідомлення журналу. Це все ще може використовувати %-formatting, як "
"показано тут::"

msgid ""
"Logging calls (``logger.debug()``, ``logger.info()`` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the actual "
"logging call (e.g. the ``exc_info`` keyword parameter to indicate that "
"traceback information should be logged, or the ``extra`` keyword parameter "
"to indicate additional contextual information to be added to the log). So "
"you cannot directly make logging calls using :meth:`str.format` or :class:"
"`string.Template` syntax, because internally the logging package uses %-"
"formatting to merge the format string and the variable arguments. There "
"would be no changing this while preserving backward compatibility, since all "
"logging calls which are out there in existing code will be using %-format "
"strings."
msgstr ""
"Виклики журналювання (``logger.debug()``, ``logger.info()`` тощо) приймають "
"лише позиційні параметри для самого фактичного повідомлення журналу, а "
"параметри ключових слів використовуються лише для визначення варіантів "
"обробки фактичного виклик журналювання (наприклад, параметр ключового слова "
"``exc_info``, щоб вказати, що слід реєструвати інформацію відстеження, або "
"параметр ключового слова ``extra``, щоб вказати додаткову контекстну "
"інформацію, яку потрібно додати до журналу). Таким чином, ви не можете "
"безпосередньо здійснювати виклики журналювання за допомогою синтаксису :meth:"
"`str.format` або :class:`string.Template`, тому що внутрішньо пакет "
"журналювання використовує %-formatting для об’єднання рядка формату та "
"змінних аргументів. Це не змінюватиметься, зберігаючи зворотну сумісність, "
"оскільки всі виклики журналювання, які присутні в існуючому коді, "
"використовуватимуть рядки %-format."

msgid ""
"There is, however, a way that you can use {}- and $- formatting to construct "
"your individual log messages. Recall that for a message you can use an "
"arbitrary object as a message format string, and that the logging package "
"will call ``str()`` on that object to get the actual format string. Consider "
"the following two classes::"
msgstr ""
"Однак існує спосіб, за допомогою якого ви можете використовувати "
"форматування {}- і $- для створення ваших індивідуальних повідомлень "
"журналу. Згадайте, що для повідомлення ви можете використовувати довільний "
"об’єкт як рядок формату повідомлення, і що пакет журналювання викличе "
"``str()`` для цього об’єкта, щоб отримати фактичний рядок формату. "
"Розглянемо наступні два класи:"

msgid ""
"Either of these can be used in place of a format string, to allow {}- or $-"
"formatting to be used to build the actual \"message\" part which appears in "
"the formatted log output in place of \"%(message)s\" or \"{message}\" or "
"\"$message\". It's a little unwieldy to use the class names whenever you "
"want to log something, but it's quite palatable if you use an alias such as "
"__ (double underscore --- not to be confused with _, the single underscore "
"used as a synonym/alias for :func:`gettext.gettext` or its brethren)."
msgstr ""
"Будь-який із них можна використовувати замість рядка формату, щоб дозволити "
"використовувати {}- або $-форматування для побудови фактичної частини "
"\"повідомлення\", яка з’являється у відформатованому журналі замість "
"\"%(message)s\" або \"{message\". }\" або \"$message\". Трохи громіздко "
"використовувати назви класів, коли ви хочете щось зареєструвати, але це "
"цілком приємно, якщо ви використовуєте псевдонім, наприклад __ (подвійне "
"підкреслення --- не плутати з _, єдине підкреслення, яке використовується як "
"синонім/псевдонім для :func:`gettext.gettext` або його братів)."

msgid ""
"The above classes are not included in Python, though they're easy enough to "
"copy and paste into your own code. They can be used as follows (assuming "
"that they're declared in a module called ``wherever``):"
msgstr ""
"Наведені вище класи не включені в Python, хоча їх достатньо легко скопіювати "
"та вставити у свій власний код. Їх можна використовувати наступним чином (за "
"умови, що вони оголошені в модулі під назвою ``wherever``):"

msgid ""
"While the above examples use ``print()`` to show how the formatting works, "
"you would of course use ``logger.debug()`` or similar to actually log using "
"this approach."
msgstr ""
"У той час як у наведених вище прикладах використовується ``print()``, щоб "
"показати, як працює форматування, ви, звичайно, скористаєтеся ``logger."
"debug()`` або подібним, щоб справді вести журнал за допомогою цього підходу."

msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to "
"a log by a handler. So the only slightly unusual thing which might trip you "
"up is that the parentheses go around the format string and the arguments, "
"not just the format string. That's because the __ notation is just syntax "
"sugar for a constructor call to one of the XXXMessage classes."
msgstr ""
"Одна річ, яку слід зазначити, полягає в тому, що ви не сплачуєте суттєвої "
"втрати продуктивності за допомогою цього підходу: фактичне форматування "
"відбувається не тоді, коли ви робите виклик журналювання, а коли (і якщо) "
"зареєстроване повідомлення фактично збирається вивести в журнал обробником. "
"Отже, єдина трохи незвичайна річ, яка може вас збентежити, полягає в тому, "
"що круглі дужки охоплюють рядок форматування та аргументи, а не лише рядок "
"форматування. Це тому, що нотація __ є просто синтаксичним цукром для "
"виклику конструктора до одного з класів XXXMessage."

msgid ""
"If you prefer, you can use a :class:`LoggerAdapter` to achieve a similar "
"effect to the above, as in the following example::"
msgstr ""
"Якщо ви віддаєте перевагу, ви можете використовувати :class:`LoggerAdapter`, "
"щоб досягти ефекту, подібного до наведеного вище, як у наступному прикладі::"

msgid ""
"The above script should log the message ``Hello, world!`` when run with "
"Python 3.2 or later."
msgstr ""
"Наведений вище сценарій має реєструвати повідомлення ``Hello, world!`` під "
"час виконання з Python 3.2 або новішої версії."

msgid "Customizing ``LogRecord``"
msgstr "Налаштування ``LogRecord``"

msgid ""
"Every logging event is represented by a :class:`LogRecord` instance. When an "
"event is logged and not filtered out by a logger's level, a :class:"
"`LogRecord` is created, populated with information about the event and then "
"passed to the handlers for that logger (and its ancestors, up to and "
"including the logger where further propagation up the hierarchy is "
"disabled). Before Python 3.2, there were only two places where this creation "
"was done:"
msgstr ""
"Кожна подія журналювання представлена екземпляром :class:`LogRecord`. Коли "
"подія реєструється і не відфільтровується на рівні реєстратора, створюється :"
"class:`LogRecord`, заповнюється інформацією про подію, а потім передається "
"обробникам цього реєстратора (і його предків, аж до реєстратора включно). де "
"подальше поширення вгору по ієрархії вимкнено). До Python 3.2 існувало лише "
"два місця, де це було зроблено:"

msgid ""
":meth:`Logger.makeRecord`, which is called in the normal process of logging "
"an event. This invoked :class:`LogRecord` directly to create an instance."
msgstr ""
":meth:`Logger.makeRecord`, який викликається в звичайному процесі реєстрації "
"події. Це безпосередньо викликало :class:`LogRecord` для створення "
"екземпляра."

msgid ""
":func:`makeLogRecord`, which is called with a dictionary containing "
"attributes to be added to the LogRecord. This is typically invoked when a "
"suitable dictionary has been received over the network (e.g. in pickle form "
"via a :class:`~handlers.SocketHandler`, or in JSON form via an :class:"
"`~handlers.HTTPHandler`)."
msgstr ""
":func:`makeLogRecord`, який викликається зі словником, що містить атрибути, "
"які потрібно додати до LogRecord. Це зазвичай викликається, коли через "
"мережу отримано відповідний словник (наприклад, у формі pickle через :class:"
"`~handlers.SocketHandler` або у формі JSON через :class:`~handlers."
"HTTPHandler`)."

msgid ""
"This has usually meant that if you need to do anything special with a :class:"
"`LogRecord`, you've had to do one of the following."
msgstr ""
"Зазвичай це означало, що якщо вам потрібно зробити щось особливе з :class:"
"`LogRecord`, ви повинні зробити одну з наступних дій."

msgid ""
"Create your own :class:`Logger` subclass, which overrides :meth:`Logger."
"makeRecord`, and set it using :func:`~logging.setLoggerClass` before any "
"loggers that you care about are instantiated."
msgstr ""
"Створіть свій власний підклас :class:`Logger`, який замінює :meth:`Logger."
"makeRecord`, і встановіть його за допомогою :func:`~logging.setLoggerClass` "
"перед створенням будь-яких реєстраторів, які вас цікавлять."

msgid ""
"Add a :class:`Filter` to a logger or handler, which does the necessary "
"special manipulation you need when its :meth:`~Filter.filter` method is "
"called."
msgstr ""
"Додайте :class:`Filter` до реєстратора або обробника, який виконує необхідні "
"спеціальні маніпуляції, які вам потрібні, коли викликається його метод :meth:"
"`~Filter.filter`."

msgid ""
"The first approach would be a little unwieldy in the scenario where (say) "
"several different libraries wanted to do different things. Each would "
"attempt to set its own :class:`Logger` subclass, and the one which did this "
"last would win."
msgstr ""
"Перший підхід був би трохи громіздким у сценарії, коли (скажімо) кілька "
"різних бібліотек хотіли б робити різні речі. Кожен намагатиметься встановити "
"власний підклас :class:`Logger`, і виграє той, хто зробить це останнім."

msgid ""
"The second approach works reasonably well for many cases, but does not allow "
"you to e.g. use a specialized subclass of :class:`LogRecord`. Library "
"developers can set a suitable filter on their loggers, but they would have "
"to remember to do this every time they introduced a new logger (which they "
"would do simply by adding new packages or modules and doing ::"
msgstr ""
"Другий підхід працює досить добре для багатьох випадків, але не дозволяє "
"вам, наприклад, використовувати спеціалізований підклас :class:`LogRecord`. "
"Розробники бібліотек можуть встановити відповідний фільтр для своїх "
"реєстраторів, але вони повинні пам’ятати про це щоразу, коли вводять новий "
"реєстратор (що вони робили б, просто додаючи нові пакунки чи модулі та "
"виконуючи:"

msgid ""
"at module level). It's probably one too many things to think about. "
"Developers could also add the filter to a :class:`~logging.NullHandler` "
"attached to their top-level logger, but this would not be invoked if an "
"application developer attached a handler to a lower-level library logger --- "
"so output from that handler would not reflect the intentions of the library "
"developer."
msgstr ""
"на рівні модуля). Ймовірно, це занадто багато речей, про які варто думати. "
"Розробники також можуть додати фільтр до :class:`~logging.NullHandler`, "
"прикріпленого до їхнього реєстратора верхнього рівня, але це не буде "
"викликано, якщо розробник програми приєднає обробник до реєстратора "
"бібліотеки нижчого рівня --- тому виведіть з цього обробника не "
"відображатиме намірів розробника бібліотеки."

msgid ""
"In Python 3.2 and later, :class:`~logging.LogRecord` creation is done "
"through a factory, which you can specify. The factory is just a callable you "
"can set with :func:`~logging.setLogRecordFactory`, and interrogate with :"
"func:`~logging.getLogRecordFactory`. The factory is invoked with the same "
"signature as the :class:`~logging.LogRecord` constructor, as :class:"
"`LogRecord` is the default setting for the factory."
msgstr ""
"У Python 3.2 і пізніших версіях створення :class:`~logging.LogRecord` "
"здійснюється через фабрику, яку ви можете вказати. Фабрика — це просто "
"виклик, який можна встановити за допомогою :func:`~logging."
"setLogRecordFactory` і запитати за допомогою :func:`~logging."
"getLogRecordFactory`. Фабрика викликається з тим самим підписом, що й "
"конструктор :class:`~logging.LogRecord`, оскільки :class:`LogRecord` є "
"параметром за замовчуванням для фабрики."

msgid ""
"This approach allows a custom factory to control all aspects of LogRecord "
"creation. For example, you could return a subclass, or just add some "
"additional attributes to the record once created, using a pattern similar to "
"this::"
msgstr ""
"Цей підхід дозволяє спеціальній фабрикі контролювати всі аспекти створення "
"LogRecord. Наприклад, ви можете повернути підклас або просто додати деякі "
"додаткові атрибути до створеного запису, використовуючи шаблон, подібний до "
"цього:"

msgid ""
"This pattern allows different libraries to chain factories together, and as "
"long as they don't overwrite each other's attributes or unintentionally "
"overwrite the attributes provided as standard, there should be no surprises. "
"However, it should be borne in mind that each link in the chain adds run-"
"time overhead to all logging operations, and the technique should only be "
"used when the use of a :class:`Filter` does not provide the desired result."
msgstr ""
"Цей шаблон дозволяє різним бібліотекам об’єднувати фабрики разом, і якщо "
"вони не перезаписують атрибути одна одної або ненавмисно перезаписують "
"атрибути, надані як стандартні, не повинно бути сюрпризів. Однак слід мати "
"на увазі, що кожна ланка в ланцюжку додає накладні витрати на час виконання "
"для всіх операцій журналювання, і цю техніку слід використовувати лише тоді, "
"коли використання :class:`Filter` не забезпечує бажаного результату."

msgid "Subclassing QueueHandler - a ZeroMQ example"
msgstr "Підклас QueueHandler - приклад ZeroMQ"

msgid ""
"You can use a :class:`QueueHandler` subclass to send messages to other kinds "
"of queues, for example a ZeroMQ 'publish' socket. In the example below,the "
"socket is created separately and passed to the handler (as its 'queue')::"
msgstr ""
"Ви можете використовувати підклас :class:`QueueHandler` для надсилання "
"повідомлень в інші типи черг, наприклад, сокет ZeroMQ 'publish'. У "
"наведеному нижче прикладі сокет створюється окремо та передається обробнику "
"(як його \"черга\"):"

msgid ""
"Of course there are other ways of organizing this, for example passing in "
"the data needed by the handler to create the socket::"
msgstr ""
"Звичайно, існують інші способи організації цього, наприклад, передача даних, "
"необхідних обробнику для створення сокета::"

msgid "Subclassing QueueListener - a ZeroMQ example"
msgstr "Підкласи QueueListener - приклад ZeroMQ"

msgid ""
"You can also subclass :class:`QueueListener` to get messages from other "
"kinds of queues, for example a ZeroMQ 'subscribe' socket. Here's an example::"
msgstr ""
"Ви також можете створити підклас :class:`QueueListener`, щоб отримувати "
"повідомлення з інших типів черг, наприклад, сокет ZeroMQ 'subscribe'. Ось "
"приклад::"

msgid "Module :mod:`logging`"
msgstr "Модуль :mod:`logging`"

msgid "API reference for the logging module."
msgstr "Довідник API для модуля журналювання."

msgid "Module :mod:`logging.config`"
msgstr "Модуль :mod:`logging.config`"

msgid "Configuration API for the logging module."
msgstr "API конфігурації для модуля журналювання."

msgid "Module :mod:`logging.handlers`"
msgstr "Модуль :mod:`logging.handlers`"

msgid "Useful handlers included with the logging module."
msgstr "Корисні обробники, включені в модуль журналювання."

msgid ":ref:`A basic logging tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Посібник з базового журналювання <logging-basic-tutorial>`"

msgid ":ref:`A more advanced logging tutorial <logging-advanced-tutorial>`"
msgstr ""
":ref:`Більш просунутий підручник з журналювання <logging-advanced-tutorial>`"

msgid "An example dictionary-based configuration"
msgstr "Приклад конфігурації на основі словника"

msgid ""
"Below is an example of a logging configuration dictionary - it's taken from "
"the `documentation on the Django project <https://docs.djangoproject.com/en/"
"stable/topics/logging/#configuring-logging>`_. This dictionary is passed to :"
"func:`~config.dictConfig` to put the configuration into effect::"
msgstr ""
"Нижче наведено приклад словника конфігурації журналювання — його взято з "
"`документації проекту Django <https://docs.djangoproject.com/en/stable/"
"topics/logging/#configuring-logging>`_. Цей словник передається до :func:"
"`~config.dictConfig` для введення в дію конфігурації::"

msgid ""
"For more information about this configuration, you can see the `relevant "
"section <https://docs.djangoproject.com/en/stable/topics/logging/"
"#configuring-logging>`_ of the Django documentation."
msgstr ""
"Для отримання додаткової інформації про цю конфігурацію ви можете "
"переглянути `відповідний розділ <https://docs.djangoproject.com/en/stable/"
"topics/logging/#configuring-logging>`_ документації Django."

msgid "Using a rotator and namer to customize log rotation processing"
msgstr ""
"Використання ротатора та іменника для налаштування обробки ротації журналу"

msgid ""
"An example of how you can define a namer and rotator is given in the "
"following snippet, which shows zlib-based compression of the log file::"
msgstr ""
"Приклад того, як можна визначити іменник і ротатор, наведено в наступному "
"фрагменті, де показано стиснення файлу журналу на основі zlib::"

msgid ""
"These are not \"true\" .gz files, as they are bare compressed data, with no "
"\"container\" such as you’d find in an actual gzip file. This snippet is "
"just for illustration purposes."
msgstr ""
"Це не \"справжні\" файли .gz, оскільки це чисті стиснуті дані без "
"\"контейнера\", який можна знайти у справжньому файлі gzip. Цей фрагмент "
"лише для ілюстрації."

msgid "A more elaborate multiprocessing example"
msgstr "Більш складний приклад багатопроцесорної обробки"

msgid ""
"The following working example shows how logging can be used with "
"multiprocessing using configuration files. The configurations are fairly "
"simple, but serve to illustrate how more complex ones could be implemented "
"in a real multiprocessing scenario."
msgstr ""
"Наступний робочий приклад показує, як журналювання можна використовувати з "
"багатопроцесорною обробкою за допомогою файлів конфігурації. Конфігурації "
"досить прості, але служать для ілюстрації того, як більш складні можуть бути "
"реалізовані в реальному багатопроцесорному сценарії."

msgid ""
"In the example, the main process spawns a listener process and some worker "
"processes. Each of the main process, the listener and the workers have three "
"separate configurations (the workers all share the same configuration). We "
"can see logging in the main process, how the workers log to a QueueHandler "
"and how the listener implements a QueueListener and a more complex logging "
"configuration, and arranges to dispatch events received via the queue to the "
"handlers specified in the configuration. Note that these configurations are "
"purely illustrative, but you should be able to adapt this example to your "
"own scenario."
msgstr ""
"У прикладі головний процес породжує процес слухача та деякі робочі процеси. "
"Кожен із основного процесу, слухача та робочих має три окремі конфігурації "
"(усі робочі мають однакову конфігурацію). Ми можемо побачити реєстрацію в "
"основному процесі, як працівники входять до QueueHandler і як слухач "
"реалізує QueueListener і більш складну конфігурацію журналювання, а також "
"організовує відправку подій, отриманих через чергу, до обробників, указаних "
"у конфігурації. Зауважте, що ці конфігурації є суто ілюстративними, але ви "
"зможете адаптувати цей приклад до власного сценарію."

msgid ""
"Here's the script - the docstrings and the comments hopefully explain how it "
"works::"
msgstr ""
"Ось сценарій - рядки документації та коментарі, сподіваюся, пояснюють, як це "
"працює::"

msgid "Inserting a BOM into messages sent to a SysLogHandler"
msgstr "Вставлення BOM у повідомлення, надіслані до SysLogHandler"

msgid ""
":rfc:`5424` requires that a Unicode message be sent to a syslog daemon as a "
"set of bytes which have the following structure: an optional pure-ASCII "
"component, followed by a UTF-8 Byte Order Mark (BOM), followed by Unicode "
"encoded using UTF-8. (See the :rfc:`relevant section of the specification "
"<5424#section-6>`.)"
msgstr ""
":rfc:`5424` вимагає, щоб повідомлення Unicode надсилалося до демона "
"системного журналу як набір байтів із такою структурою: необов’язковий "
"чистий ASCII-компонент, за яким слідує UTF-8 Byte Order Mark (BOM), за яким "
"слідує Юнікод, закодований за допомогою UTF-8. (Див. :rfc:`відповідний "
"розділ специфікації <5424#section-6>`.)"

msgid ""
"In Python 3.1, code was added to :class:`~logging.handlers.SysLogHandler` to "
"insert a BOM into the message, but unfortunately, it was implemented "
"incorrectly, with the BOM appearing at the beginning of the message and "
"hence not allowing any pure-ASCII component to appear before it."
msgstr ""
"У Python 3.1 до :class:`~logging.handlers.SysLogHandler` було додано код для "
"вставлення BOM у повідомлення, але, на жаль, він був реалізований "
"неправильно, оскільки BOM з’являвся на початку повідомлення, а отже, не "
"дозволяв будь-які компонент pure-ASCII, який з’явиться перед ним."

msgid ""
"As this behaviour is broken, the incorrect BOM insertion code is being "
"removed from Python 3.2.4 and later. However, it is not being replaced, and "
"if you want to produce :rfc:`5424`-compliant messages which include a BOM, "
"an optional pure-ASCII sequence before it and arbitrary Unicode after it, "
"encoded using UTF-8, then you need to do the following:"
msgstr ""
"Оскільки ця поведінка порушена, неправильний код вставки BOM видаляється з "
"Python 3.2.4 і пізніших версій. Однак його не буде замінено, і якщо ви "
"хочете створювати повідомлення, сумісні з :rfc:`5424`, які включають "
"специфікацію матеріалів, необов’язкову чисту послідовність ASCII перед нею "
"та довільний код Unicode після неї, закодований за допомогою UTF-8, тоді ви "
"потрібно зробити наступне:"

msgid ""
"Attach a :class:`~logging.Formatter` instance to your :class:`~logging."
"handlers.SysLogHandler` instance, with a format string such as::"
msgstr ""
"Приєднайте екземпляр :class:`~logging.Formatter` до вашого екземпляра :class:"
"`~logging.handlers.SysLogHandler` із рядком форматування, наприклад:"

msgid ""
"The Unicode code point U+FEFF, when encoded using UTF-8, will be encoded as "
"a UTF-8 BOM -- the byte-string ``b'\\xef\\xbb\\xbf'``."
msgstr ""
"Кодова точка Юнікоду U+FEFF, коли вона кодується за допомогою UTF-8, буде "
"закодована як UTF-8 BOM -- рядок байтів ``b'\\xef\\xbb\\xbf``."

msgid ""
"Replace the ASCII section with whatever placeholders you like, but make sure "
"that the data that appears in there after substitution is always ASCII (that "
"way, it will remain unchanged after UTF-8 encoding)."
msgstr ""
"Замініть розділ ASCII будь-якими заповнювачами, але переконайтеся, що дані, "
"які з’являються в ньому після заміни, завжди мають ASCII (таким чином вони "
"залишаться незмінними після кодування UTF-8)."

msgid ""
"Replace the Unicode section with whatever placeholders you like; if the data "
"which appears there after substitution contains characters outside the ASCII "
"range, that's fine -- it will be encoded using UTF-8."
msgstr ""
"Замініть розділ Unicode будь-якими заповнювачами; якщо дані, які з’являються "
"там після заміни, містять символи поза діапазоном ASCII, це нормально – вони "
"будуть закодовані за допомогою UTF-8."

msgid ""
"The formatted message *will* be encoded using UTF-8 encoding by "
"``SysLogHandler``. If you follow the above rules, you should be able to "
"produce :rfc:`5424`-compliant messages. If you don't, logging may not "
"complain, but your messages will not be RFC 5424-compliant, and your syslog "
"daemon may complain."
msgstr ""
"Відформатоване повідомлення *буде* закодовано за допомогою кодування UTF-8 "
"за допомогою ``SysLogHandler``. Якщо ви дотримуєтеся наведених вище правил, "
"ви зможете створювати :rfc:`5424`-сумісні повідомлення. Якщо ви цього не "
"зробите, журналювання може не скаржитися, але ваші повідомлення не будуть "
"сумісними з RFC 5424, і ваш демон системного журналу може скаржитися."

msgid "Implementing structured logging"
msgstr "Впровадження структурованого журналювання"

msgid ""
"Although most logging messages are intended for reading by humans, and thus "
"not readily machine-parseable, there might be circumstances where you want "
"to output messages in a structured format which *is* capable of being parsed "
"by a program (without needing complex regular expressions to parse the log "
"message). This is straightforward to achieve using the logging package. "
"There are a number of ways in which this could be achieved, but the "
"following is a simple approach which uses JSON to serialise the event in a "
"machine-parseable manner::"
msgstr ""
"Незважаючи на те, що більшість повідомлень журналу призначені для читання "
"людьми, і тому їх не легко аналізувати машиною, можуть виникнути обставини, "
"коли ви захочете вивести повідомлення у структурованому форматі, який *може* "
"проаналізувати програма (без потреби у складних регулярних виразах). щоб "
"проаналізувати повідомлення журналу). Це легко досягти за допомогою пакета "
"журналювання. Існує кілька способів, за допомогою яких цього можна досягти, "
"але нижче наведено простий підхід, який використовує JSON для серіалізації "
"події машинним способом:"

msgid "If the above script is run, it prints:"
msgstr "Якщо наведений вище сценарій запущено, він друкує:"

msgid ""
"Note that the order of items might be different according to the version of "
"Python used."
msgstr ""
"Зауважте, що порядок елементів може відрізнятися залежно від версії Python, "
"що використовується."

msgid ""
"If you need more specialised processing, you can use a custom JSON encoder, "
"as in the following complete example::"
msgstr ""
"Якщо вам потрібна більш спеціалізована обробка, ви можете використовувати "
"спеціальний кодер JSON, як у наступному повному прикладі:"

msgid "When the above script is run, it prints:"
msgstr "Коли наведений вище сценарій виконується, він друкує:"

msgid "Customizing handlers with :func:`dictConfig`"
msgstr "Налаштування обробників за допомогою :func:`dictConfig`"

msgid ""
"There are times when you want to customize logging handlers in particular "
"ways, and if you use :func:`dictConfig` you may be able to do this without "
"subclassing. As an example, consider that you may want to set the ownership "
"of a log file. On POSIX, this is easily done using :func:`shutil.chown`, but "
"the file handlers in the stdlib don't offer built-in support. You can "
"customize handler creation using a plain function such as::"
msgstr ""
"Бувають випадки, коли ви хочете налаштувати обробники журналу певним чином, "
"і якщо ви використовуєте :func:`dictConfig`, ви можете зробити це без "
"підкласів. Як приклад, подумайте, що ви можете встановити право власності на "
"файл журналу. У POSIX це легко зробити за допомогою :func:`shutil.chown`, "
"але обробники файлів у stdlib не пропонують вбудованої підтримки. Ви можете "
"налаштувати створення обробника за допомогою простої функції, такої як:"

msgid ""
"You can then specify, in a logging configuration passed to :func:"
"`dictConfig`, that a logging handler be created by calling this function::"
msgstr ""
"Потім ви можете вказати в конфігурації журналювання, переданій у :func:"
"`dictConfig`, щоб обробник журналювання було створено шляхом виклику цієї "
"функції::"

msgid ""
"In this example I am setting the ownership using the ``pulse`` user and "
"group, just for the purposes of illustration. Putting it together into a "
"working script, ``chowntest.py``::"
msgstr ""
"У цьому прикладі я встановлюю право власності за допомогою користувача та "
"групи ``pulse`` лише для ілюстрації. Об’єднавши це в робочий сценарій, "
"``chowntest.py``::"

msgid "To run this, you will probably need to run as ``root``:"
msgstr "Щоб запустити це, вам, ймовірно, потрібно буде запустити як ``root``:"

msgid ""
"Note that this example uses Python 3.3 because that's where :func:`shutil."
"chown` makes an appearance. This approach should work with any Python "
"version that supports :func:`dictConfig` - namely, Python 2.7, 3.2 or later. "
"With pre-3.3 versions, you would need to implement the actual ownership "
"change using e.g. :func:`os.chown`."
msgstr ""
"Зверніть увагу, що в цьому прикладі використовується Python 3.3, тому що "
"саме там з’являється :func:`shutil.chown`. Цей підхід має працювати з будь-"
"якою версією Python, яка підтримує :func:`dictConfig`, а саме з Python 2.7, "
"3.2 або новішою. У версіях до 3.3 вам потрібно було б реалізувати фактичну "
"зміну власності, використовуючи, наприклад, :func:`os.chown`."

msgid ""
"In practice, the handler-creating function may be in a utility module "
"somewhere in your project. Instead of the line in the configuration::"
msgstr ""
"На практиці функція створення обробника може бути десь у службовому модулі "
"вашого проекту. Замість рядка в конфігурації::"

msgid "you could use e.g.::"
msgstr "ви можете використовувати, наприклад::"

msgid ""
"where ``project.util`` can be replaced with the actual name of the package "
"where the function resides. In the above working script, using ``'ext://"
"__main__.owned_file_handler'`` should work. Here, the actual callable is "
"resolved by :func:`dictConfig` from the ``ext://`` specification."
msgstr ""
"де ``project.util`` можна замінити фактичною назвою пакета, де знаходиться "
"функція. У наведеному вище робочому сценарії використання ``'ext://__main__."
"owned_file_handler`` має працювати. Тут фактичний виклик визначається за "
"допомогою :func:`dictConfig` із специфікації ``ext://``."

msgid ""
"This example hopefully also points the way to how you could implement other "
"types of file change - e.g. setting specific POSIX permission bits - in the "
"same way, using :func:`os.chmod`."
msgstr ""
"Сподіваємось, цей приклад також вказує шлях до того, як ви можете "
"реалізувати інші типи змін файлів - наприклад. встановлення певних бітів "
"дозволу POSIX - таким же чином, за допомогою :func:`os.chmod`."

msgid ""
"Of course, the approach could also be extended to types of handler other "
"than a :class:`~logging.FileHandler` - for example, one of the rotating file "
"handlers, or a different type of handler altogether."
msgstr ""
"Звичайно, цей підхід також можна розширити до типів обробників, відмінних "
"від :class:`~logging.FileHandler` - наприклад, одного з обробників файлів, "
"що обертаються, або зовсім іншого типу обробника."

msgid "Using particular formatting styles throughout your application"
msgstr "Використання певних стилів форматування у вашій програмі"

msgid ""
"In Python 3.2, the :class:`~logging.Formatter` gained a ``style`` keyword "
"parameter which, while defaulting to ``%`` for backward compatibility, "
"allowed the specification of ``{`` or ``$`` to support the formatting "
"approaches supported by :meth:`str.format` and :class:`string.Template`. "
"Note that this governs the formatting of logging messages for final output "
"to logs, and is completely orthogonal to how an individual logging message "
"is constructed."
msgstr ""
"У Python 3.2 :class:`~logging.Formatter` отримав параметр ключового слова "
"``style``, який, незважаючи на значення за умовчанням ``%`` для зворотної "
"сумісності, дозволяв специфікацію ``{`` або ``$`` для підтримки підходів до "
"форматування, які підтримуються :meth:`str.format` і :class:`string."
"Template`. Зауважте, що це керує форматуванням повідомлень журналу для "
"остаточного виведення в журнали та повністю ортогонально до того, як "
"будується окреме повідомлення журналу."

msgid ""
"Logging calls (:meth:`~Logger.debug`, :meth:`~Logger.info` etc.) only take "
"positional parameters for the actual logging message itself, with keyword "
"parameters used only for determining options for how to handle the logging "
"call (e.g. the ``exc_info`` keyword parameter to indicate that traceback "
"information should be logged, or the ``extra`` keyword parameter to indicate "
"additional contextual information to be added to the log). So you cannot "
"directly make logging calls using :meth:`str.format` or :class:`string."
"Template` syntax, because internally the logging package uses %-formatting "
"to merge the format string and the variable arguments. There would no "
"changing this while preserving backward compatibility, since all logging "
"calls which are out there in existing code will be using %-format strings."
msgstr ""
"Виклики журналювання (:meth:`~Logger.debug`, :meth:`~Logger.info` тощо) "
"приймають лише позиційні параметри для самого фактичного повідомлення "
"журналу, а параметри ключових слів використовуються лише для визначення "
"варіантів обробки журналювання виклик (наприклад, параметр ключового слова "
"``exc_info``, щоб вказати, що слід реєструвати інформацію відстеження, або "
"параметр ``extra`` ключового слова, щоб вказати додаткову контекстну "
"інформацію, яку потрібно додати до журналу). Таким чином, ви не можете "
"безпосередньо здійснювати виклики журналювання за допомогою синтаксису :meth:"
"`str.format` або :class:`string.Template`, тому що внутрішньо пакет "
"журналювання використовує %-formatting для об’єднання рядка формату та "
"змінних аргументів. Це не зміниться, зберігаючи зворотну сумісність, "
"оскільки всі виклики журналювання, які присутні в існуючому коді, "
"використовуватимуть рядки %-format."

msgid ""
"There have been suggestions to associate format styles with specific "
"loggers, but that approach also runs into backward compatibility problems "
"because any existing code could be using a given logger name and using %-"
"formatting."
msgstr ""
"Були пропозиції пов’язати стилі формату з певними реєстраторами, але такий "
"підхід також стикається з проблемами зворотної сумісності, оскільки будь-"
"який існуючий код може використовувати дане ім’я реєстратора та "
"використовувати %-formatting."

msgid ""
"For logging to work interoperably between any third-party libraries and your "
"code, decisions about formatting need to be made at the level of the "
"individual logging call. This opens up a couple of ways in which alternative "
"formatting styles can be accommodated."
msgstr ""
"Щоб журналювання працювало сумісно між будь-якими сторонніми бібліотеками та "
"вашим кодом, рішення щодо форматування потрібно приймати на рівні окремого "
"виклику журналювання. Це відкриває кілька способів використання "
"альтернативних стилів форматування."

msgid "Using LogRecord factories"
msgstr "Використання фабрик LogRecord"

msgid ""
"In Python 3.2, along with the :class:`~logging.Formatter` changes mentioned "
"above, the logging package gained the ability to allow users to set their "
"own :class:`LogRecord` subclasses, using the :func:`setLogRecordFactory` "
"function. You can use this to set your own subclass of :class:`LogRecord`, "
"which does the Right Thing by overriding the :meth:`~LogRecord.getMessage` "
"method. The base class implementation of this method is where the ``msg % "
"args`` formatting happens, and where you can substitute your alternate "
"formatting; however, you should be careful to support all formatting styles "
"and allow %-formatting as the default, to ensure interoperability with other "
"code. Care should also be taken to call ``str(self.msg)``, just as the base "
"implementation does."
msgstr ""
"У Python 3.2 разом зі змінами :class:`~logging.Formatter`, згаданими вище, "
"пакет журналювання отримав можливість дозволяти користувачам встановлювати "
"власні підкласи :class:`LogRecord` за допомогою функції :func:"
"`setLogRecordFactory` . Ви можете використовувати це, щоб установити власний "
"підклас :class:`LogRecord`, який робить правильні речі, замінюючи метод :"
"meth:`~LogRecord.getMessage`. Реалізація базового класу цього методу є "
"місцем, де відбувається форматування ``msg % args``, і де ви можете замінити "
"своє альтернативне форматування; однак ви повинні бути обережними, щоб "
"підтримувати всі стилі форматування та дозволити %-formatting як типовий, "
"щоб забезпечити взаємодію з іншим кодом. Слід також подбати про те, щоб "
"викликати ``str(self.msg)``, як це робить базова реалізація."

msgid ""
"Refer to the reference documentation on :func:`setLogRecordFactory` and :"
"class:`LogRecord` for more information."
msgstr ""
"Зверніться до довідкової документації щодо :func:`setLogRecordFactory` і :"
"class:`LogRecord` для отримання додаткової інформації."

msgid "Using custom message objects"
msgstr "Використання настроюваних об’єктів повідомлення"

msgid ""
"There is another, perhaps simpler way that you can use {}- and $- formatting "
"to construct your individual log messages. You may recall (from :ref:"
"`arbitrary-object-messages`) that when logging you can use an arbitrary "
"object as a message format string, and that the logging package will call :"
"func:`str` on that object to get the actual format string. Consider the "
"following two classes::"
msgstr ""
"Існує інший, можливо, простіший спосіб використання форматування {}- і $- "
"для створення індивідуальних повідомлень журналу. Ви можете пам’ятати (з :"
"ref:`arbitrary-object-messages`), що під час журналювання ви можете "
"використовувати довільний об’єкт як рядок формату повідомлення, і що пакет "
"журналювання викличе :func:`str` для цього об’єкта, щоб отримати рядок "
"фактичного формату. Розглянемо наступні два класи:"

msgid ""
"Either of these can be used in place of a format string, to allow {}- or $-"
"formatting to be used to build the actual \"message\" part which appears in "
"the formatted log output in place of “%(message)s” or “{message}” or "
"“$message”. If you find it a little unwieldy to use the class names whenever "
"you want to log something, you can make it more palatable if you use an "
"alias such as ``M`` or ``_`` for the message (or perhaps ``__``, if you are "
"using ``_`` for localization)."
msgstr ""
"Будь-яке з них можна використовувати замість рядка формату, щоб дозволити "
"використовувати {}- або $-форматування для створення фактичної частини "
"\"повідомлення\", яка з’являється у відформатованому журналі замість "
"\"%(message)s\" або \"{message\". }\" або \"$message\". Якщо вам здається "
"трохи громіздким використовувати імена класів, коли ви хочете щось "
"зареєструвати, ви можете зробити це більш приємним, якщо використаєте "
"псевдонім, наприклад ``M`` або ``_`` для повідомлення (або, можливо ``__``, "
"якщо ви використовуєте ``_`` для локалізації)."

msgid ""
"Examples of this approach are given below. Firstly, formatting with :meth:"
"`str.format`::"
msgstr ""
"Приклади цього підходу наведені нижче. По-перше, форматування за допомогою :"
"meth:`str.format`::"

msgid "Secondly, formatting with :class:`string.Template`::"
msgstr "По-друге, форматування за допомогою :class:`string.Template`::"

msgid ""
"One thing to note is that you pay no significant performance penalty with "
"this approach: the actual formatting happens not when you make the logging "
"call, but when (and if) the logged message is actually about to be output to "
"a log by a handler. So the only slightly unusual thing which might trip you "
"up is that the parentheses go around the format string and the arguments, "
"not just the format string. That’s because the __ notation is just syntax "
"sugar for a constructor call to one of the ``XXXMessage`` classes shown "
"above."
msgstr ""
"Одне, що слід зазначити, полягає в тому, що ви не сплачуєте суттєвої втрати "
"продуктивності за допомогою цього підходу: фактичне форматування "
"відбувається не тоді, коли ви робите виклик журналювання, а коли (і якщо) "
"зареєстроване повідомлення фактично збирається вивести в журнал обробником. "
"Отже, єдина трохи незвичайна річ, яка може вас збентежити, полягає в тому, "
"що круглі дужки охоплюють рядок формату та аргументи, а не лише рядок "
"формату. Це тому, що нотація __ є просто синтаксичним цукром для виклику "
"конструктора одного з класів ``XXXMessage``, показаних вище."

msgid "Configuring filters with :func:`dictConfig`"
msgstr "Налаштування фільтрів за допомогою :func:`dictConfig`"

msgid ""
"You *can* configure filters using :func:`~logging.config.dictConfig`, though "
"it might not be obvious at first glance how to do it (hence this recipe). "
"Since :class:`~logging.Filter` is the only filter class included in the "
"standard library, and it is unlikely to cater to many requirements (it's "
"only there as a base class), you will typically need to define your own :"
"class:`~logging.Filter` subclass with an overridden :meth:`~logging.Filter."
"filter` method. To do this, specify the ``()`` key in the configuration "
"dictionary for the filter, specifying a callable which will be used to "
"create the filter (a class is the most obvious, but you can provide any "
"callable which returns a :class:`~logging.Filter` instance). Here is a "
"complete example::"
msgstr ""
"Ви *можете* налаштувати фільтри за допомогою :func:`~logging.config."
"dictConfig`, хоча на перший погляд може бути неочевидно, як це зробити (тому "
"цей рецепт). Оскільки :class:`~logging.Filter` є єдиним класом фільтра, "
"включеним у стандартну бібліотеку, і він навряд чи задовольнить багато вимог "
"(він існує лише як базовий клас), вам зазвичай потрібно буде визначити свій "
"власний Підклас :class:`~logging.Filter` із перевизначеним методом :meth:"
"`~logging.Filter.filter`. Для цього вкажіть ключ ``()`` у словнику "
"конфігурації для фільтра, вказавши виклик, який буде використовуватися для "
"створення фільтра (клас є найбільш очевидним, але ви можете надати будь-який "
"виклик, який повертає :class:`~logging.Filter` екземпляр). Ось повний "
"приклад::"

msgid ""
"This example shows how you can pass configuration data to the callable which "
"constructs the instance, in the form of keyword parameters. When run, the "
"above script will print:"
msgstr ""
"У цьому прикладі показано, як ви можете передати дані конфігурації "
"викликаному, який створює екземпляр, у формі параметрів ключових слів. Під "
"час запуску наведений вище сценарій надрукує:"

msgid "which shows that the filter is working as configured."
msgstr "який показує, що фільтр працює, як налаштовано."

msgid "A couple of extra points to note:"
msgstr "Кілька додаткових моментів, на які варто звернути увагу:"

msgid ""
"If you can't refer to the callable directly in the configuration (e.g. if it "
"lives in a different module, and you can't import it directly where the "
"configuration dictionary is), you can use the form ``ext://...`` as "
"described in :ref:`logging-config-dict-externalobj`. For example, you could "
"have used the text ``'ext://__main__.MyFilter'`` instead of ``MyFilter`` in "
"the above example."
msgstr ""
"Якщо ви не можете звернутися до викликаного безпосередньо в конфігурації "
"(наприклад, якщо він живе в іншому модулі, і ви не можете імпортувати його "
"безпосередньо туди, де знаходиться словник конфігурації), ви можете "
"використовувати форму ``ext://. ..``, як описано в :ref:`logging-config-dict-"
"externalobj`. Наприклад, у наведеному вище прикладі ви могли використати "
"текст ``'ext://__main__.MyFilter`` замість ``MyFilter``."

msgid ""
"As well as for filters, this technique can also be used to configure custom "
"handlers and formatters. See :ref:`logging-config-dict-userdef` for more "
"information on how logging supports using user-defined objects in its "
"configuration, and see the other cookbook recipe :ref:`custom-handlers` "
"above."
msgstr ""
"Як і для фільтрів, цю техніку також можна використовувати для налаштування "
"нестандартних обробників і форматувальників. Перегляньте :ref:`logging-"
"config-dict-userdef`, щоб дізнатися більше про те, як ведення журналу "
"підтримує використання визначених користувачем об’єктів у своїй "
"конфігурації, і перегляньте інший рецепт кулінарної книги :ref:`custom-"
"handlers` вище."

msgid "Customized exception formatting"
msgstr "Індивідуальне форматування винятків"

msgid ""
"There might be times when you want to do customized exception formatting - "
"for argument's sake, let's say you want exactly one line per logged event, "
"even when exception information is present. You can do this with a custom "
"formatter class, as shown in the following example::"
msgstr ""
"Можуть бути випадки, коли ви захочете зробити налаштоване форматування "
"винятків - заради аргументу, припустімо, що вам потрібен рівно один рядок на "
"зареєстровану подію, навіть якщо присутня інформація про винятки. Ви можете "
"зробити це за допомогою спеціального класу форматера, як показано в "
"наступному прикладі:"

msgid "When run, this produces a file with exactly two lines:"
msgstr "Під час запуску створюється файл із рівно двома рядками:"

msgid ""
"While the above treatment is simplistic, it points the way to how exception "
"information can be formatted to your liking. The :mod:`traceback` module may "
"be helpful for more specialized needs."
msgstr ""
"Хоча описане вище лікування є спрощеним, воно вказує шлях до того, як "
"інформацію про винятки можна відформатувати на свій смак. Модуль :mod:"
"`traceback` може бути корисним для більш спеціалізованих потреб."

msgid "Speaking logging messages"
msgstr "Озвучення повідомлень журналу"

msgid ""
"There might be situations when it is desirable to have logging messages "
"rendered in an audible rather than a visible format. This is easy to do if "
"you have text-to-speech (TTS) functionality available in your system, even "
"if it doesn't have a Python binding. Most TTS systems have a command line "
"program you can run, and this can be invoked from a handler using :mod:"
"`subprocess`. It's assumed here that TTS command line programs won't expect "
"to interact with users or take a long time to complete, and that the "
"frequency of logged messages will be not so high as to swamp the user with "
"messages, and that it's acceptable to have the messages spoken one at a time "
"rather than concurrently, The example implementation below waits for one "
"message to be spoken before the next is processed, and this might cause "
"other handlers to be kept waiting. Here is a short example showing the "
"approach, which assumes that the ``espeak`` TTS package is available::"
msgstr ""
"Можуть бути ситуації, коли бажано, щоб повідомлення журналу відтворювалися в "
"звуковому, а не у видимому форматі. Це легко зробити, якщо у вашій системі "
"доступна функція перетворення тексту в мову (TTS), навіть якщо вона не має "
"прив’язки Python. Більшість систем TTS мають програму командного рядка, яку "
"можна запустити, і її можна викликати з обробника за допомогою :mod:"
"`subprocess`. Тут передбачається, що програми командного рядка TTS не будуть "
"взаємодіяти з користувачами або займати багато часу для виконання, і що "
"частота зареєстрованих повідомлень не буде настільки високою, щоб завалювати "
"користувача повідомленнями, і що прийнятно мати повідомлення промовляються "
"по одному, а не одночасно. Приклад реалізації нижче очікує, поки одне "
"повідомлення буде озвучено перед обробкою наступного, і це може спричинити "
"очікування інших обробників. Ось короткий приклад, який демонструє підхід, "
"який передбачає наявність пакета TTS ``espeak``::"

msgid ""
"When run, this script should say \"Hello\" and then \"Goodbye\" in a female "
"voice."
msgstr ""
"Під час запуску цей скрипт має сказати \"Привіт\", а потім \"До побачення\" "
"жіночим голосом."

msgid ""
"The above approach can, of course, be adapted to other TTS systems and even "
"other systems altogether which can process messages via external programs "
"run from a command line."
msgstr ""
"Наведений вище підхід, звичайно, можна адаптувати до інших систем TTS і "
"навіть до інших систем взагалі, які можуть обробляти повідомлення через "
"зовнішні програми, що запускаються з командного рядка."

msgid "Buffering logging messages and outputting them conditionally"
msgstr "Буферизація повідомлень журналу та їх умовне виведення"

msgid ""
"There might be situations where you want to log messages in a temporary area "
"and only output them if a certain condition occurs. For example, you may "
"want to start logging debug events in a function, and if the function "
"completes without errors, you don't want to clutter the log with the "
"collected debug information, but if there is an error, you want all the "
"debug information to be output as well as the error."
msgstr ""
"Можуть виникнути ситуації, коли потрібно реєструвати повідомлення у "
"тимчасовій області та виводити їх лише у разі виникнення певної умови. "
"Наприклад, ви можете почати реєструвати події налагодження у функції, і якщо "
"функція завершиться без помилок, ви не хочете захаращувати журнал зібраною "
"інформацією про налагодження, але якщо є помилка, ви хочете, щоб усі "
"налагодження інформацію, яку потрібно вивести, а також помилку."

msgid ""
"Here is an example which shows how you could do this using a decorator for "
"your functions where you want logging to behave this way. It makes use of "
"the :class:`logging.handlers.MemoryHandler`, which allows buffering of "
"logged events until some condition occurs, at which point the buffered "
"events are ``flushed`` - passed to another handler (the ``target`` handler) "
"for processing. By default, the ``MemoryHandler`` flushed when its buffer "
"gets filled up or an event whose level is greater than or equal to a "
"specified threshold is seen. You can use this recipe with a more specialised "
"subclass of ``MemoryHandler`` if you want custom flushing behavior."
msgstr ""
"Ось приклад, який показує, як ви можете зробити це за допомогою декоратора "
"для ваших функцій, де ви хочете, щоб журналювання поводилося таким чином. "
"Він використовує :class:`logging.handlers.MemoryHandler`, який дозволяє "
"буферизувати зареєстровані події, доки не відбудеться певна умова, після "
"чого буферизовані події ``скидаються`` і передаються іншому обробнику "
"(``ціль`` обробник) для обробки. За замовчуванням ``MemoryHandler`` "
"очищується, коли його буфер заповнюється або спостерігається подія, рівень "
"якої перевищує або дорівнює вказаному порогу. Ви можете використовувати цей "
"рецепт із більш спеціалізованим підкласом ``MemoryHandler``, якщо вам "
"потрібна спеціальна поведінка очищення."

msgid ""
"The example script has a simple function, ``foo``, which just cycles through "
"all the logging levels, writing to ``sys.stderr`` to say what level it's "
"about to log at, and then actually logging a message at that level. You can "
"pass a parameter to ``foo`` which, if true, will log at ERROR and CRITICAL "
"levels - otherwise, it only logs at DEBUG, INFO and WARNING levels."
msgstr ""
"Приклад сценарію має просту функцію, ``foo``, яка просто циклічно перебирає "
"всі рівні журналювання, записуючи в ``sys.stderr``, щоб сказати, на якому "
"рівні він збирається зареєструватися, а потім фактично записує повідомлення "
"на цьому рівень. Ви можете передати параметр у ``foo``, який, якщо істина, "
"буде реєструватися на рівнях ПОМИЛКА та КРИТИЧНИЙ - інакше він реєструватиме "
"лише на рівнях НАЛАШТУВАННЯ, ІНФОРМАЦІЇ та ПОПЕРЕДЖЕННЯ."

msgid ""
"The script just arranges to decorate ``foo`` with a decorator which will do "
"the conditional logging that's required. The decorator takes a logger as a "
"parameter and attaches a memory handler for the duration of the call to the "
"decorated function. The decorator can be additionally parameterised using a "
"target handler, a level at which flushing should occur, and a capacity for "
"the buffer (number of records buffered). These default to a :class:`~logging."
"StreamHandler` which writes to ``sys.stderr``, ``logging.ERROR`` and ``100`` "
"respectively."
msgstr ""
"Сценарій лише організовує декорування ``foo`` за допомогою декоратора, який "
"виконуватиме необхідне умовне журналювання. Декоратор приймає реєстратор як "
"параметр і приєднує обробник пам’яті на час виклику декорованої функції. "
"Декоратор може бути додатково параметризований за допомогою цільового "
"обробника, рівня, на якому має відбуватися очищення, і ємності для буфера "
"(кількість записів, буферизованих). За умовчанням це :class:`~logging."
"StreamHandler`, який записує в ``sys.stderr``, ``logging.ERROR`` і ``100`` "
"відповідно."

msgid "Here's the script::"
msgstr "Ось сценарій::"

msgid "When this script is run, the following output should be observed:"
msgstr "Під час виконання цього сценарію має спостерігатися такий результат:"

msgid ""
"As you can see, actual logging output only occurs when an event is logged "
"whose severity is ERROR or greater, but in that case, any previous events at "
"lower severities are also logged."
msgstr ""
"Як ви можете бачити, фактичний вихід журналу відбувається лише тоді, коли "
"реєструється подія, серйозність якої дорівнює ПОМИЛКІ або вище, але в цьому "
"випадку також реєструються будь-які попередні події з нижчим рівнем "
"серйозності."

msgid "You can of course use the conventional means of decoration::"
msgstr "Ви, звичайно, можете використовувати звичайні засоби декору:"

msgid "Sending logging messages to email, with buffering"
msgstr ""

msgid ""
"To illustrate how you can send log messages via email, so that a set number "
"of messages are sent per email, you can subclass :class:`~logging.handlers."
"BufferingHandler`. In the following  example, which you can adapt to suit "
"your specific needs, a simple test harness is provided which allows you to "
"run the script with command line arguments specifying what you typically "
"need to send things via SMTP. (Run the downloaded script with the ``-h`` "
"argument to see the required and optional arguments.)"
msgstr ""

msgid ""
"If you run this script and your SMTP server is correctly set up, you should "
"find that it sends eleven emails to the addressee you specify. The first ten "
"emails will each have ten log messages, and the eleventh will have two "
"messages. That makes up 102 messages as specified in the script."
msgstr ""

msgid "Formatting times using UTC (GMT) via configuration"
msgstr "Форматування часу за допомогою UTC (GMT) через налаштування"

msgid ""
"Sometimes you want to format times using UTC, which can be done using a "
"class such as ``UTCFormatter``, shown below::"
msgstr ""

msgid ""
"and you can then use the ``UTCFormatter`` in your code instead of :class:"
"`~logging.Formatter`. If you want to do that via configuration, you can use "
"the :func:`~logging.config.dictConfig` API with an approach illustrated by "
"the following complete example::"
msgstr ""
"і тоді ви можете використовувати ``UTCFormatter`` у своєму коді замість :"
"class:`~logging.Formatter`. Якщо ви хочете зробити це за допомогою "
"конфігурації, ви можете використовувати :func:`~logging.config.dictConfig` "
"API з підходом, проілюстрованим таким повним прикладом:"

msgid "When this script is run, it should print something like:"
msgstr "Коли цей сценарій запускається, він має надрукувати щось на кшталт:"

msgid ""
"showing how the time is formatted both as local time and UTC, one for each "
"handler."
msgstr ""
"показує, як час форматується як місцевий час, так і UTC, по одному для "
"кожного обробника."

msgid "Using a context manager for selective logging"
msgstr "Використання контекстного менеджера для вибіркового журналювання"

msgid ""
"There are times when it would be useful to temporarily change the logging "
"configuration and revert it back after doing something. For this, a context "
"manager is the most obvious way of saving and restoring the logging context. "
"Here is a simple example of such a context manager, which allows you to "
"optionally change the logging level and add a logging handler purely in the "
"scope of the context manager::"
msgstr ""
"Бувають випадки, коли було б корисно тимчасово змінити конфігурацію "
"журналювання та повернути її назад після певних дій. Для цього менеджер "
"контексту є найбільш очевидним способом збереження та відновлення контексту "
"журналювання. Ось простий приклад такого менеджера контексту, який дозволяє "
"вам за бажанням змінити рівень журналювання та додати обробник журналювання "
"виключно в межах контекстного менеджера::"

msgid ""
"If you specify a level value, the logger's level is set to that value in the "
"scope of the with block covered by the context manager. If you specify a "
"handler, it is added to the logger on entry to the block and removed on exit "
"from the block. You can also ask the manager to close the handler for you on "
"block exit - you could do this if you don't need the handler any more."
msgstr ""
"Якщо ви вказуєте значення рівня, рівень реєстратора встановлюється на це "
"значення в області блоку with, охопленого менеджером контексту. Якщо ви "
"вкажете обробник, він додається до реєстратора під час входу до блоку та "
"видаляється під час виходу з блоку. Ви також можете попросити менеджера "
"закрити обробник для вас після виходу з блоку - ви можете зробити це, якщо "
"вам більше не потрібен обробник."

msgid ""
"To illustrate how it works, we can add the following block of code to the "
"above::"
msgstr ""
"Щоб проілюструвати, як це працює, ми можемо додати наступний блок коду до "
"наведеного вище:"

msgid ""
"We initially set the logger's level to ``INFO``, so message #1 appears and "
"message #2 doesn't. We then change the level to ``DEBUG`` temporarily in the "
"following ``with`` block, and so message #3 appears. After the block exits, "
"the logger's level is restored to ``INFO`` and so message #4 doesn't appear. "
"In the next ``with`` block, we set the level to ``DEBUG`` again but also add "
"a handler writing to ``sys.stdout``. Thus, message #5 appears twice on the "
"console (once via ``stderr`` and once via ``stdout``). After the ``with`` "
"statement's completion, the status is as it was before so message #6 appears "
"(like message #1) whereas message #7 doesn't (just like message #2)."
msgstr ""
"Спочатку ми встановили рівень реєстратора на ``INFO``, тому повідомлення №1 "
"з’являється, а повідомлення №2 ні. Потім ми тимчасово змінюємо рівень на "
"``DEBUG`` у наступному блоці ``with``, і тому з'являється повідомлення №3. "
"Після виходу з блоку рівень реєстратора відновлюється до ``INFO``, тому "
"повідомлення №4 не з’являється. У наступному блоці ``with`` ми знову "
"встановлюємо рівень ``DEBUG``, але також додаємо запис обробника в ``sys."
"stdout``. Таким чином, повідомлення №5 з’являється двічі на консолі (один "
"раз через ``stderr`` і один раз через ``stdout``). Після завершення "
"оператора ``with`` статус залишається таким же, як і раніше, тому "
"повідомлення №6 з’являється (як повідомлення №1), тоді як повідомлення №7 ні "
"(так само, як повідомлення №2)."

msgid "If we run the resulting script, the result is as follows:"
msgstr "Якщо ми запустимо отриманий сценарій, результат буде таким:"

msgid ""
"If we run it again, but pipe ``stderr`` to ``/dev/null``, we see the "
"following, which is the only message written to ``stdout``:"
msgstr ""
"Якщо ми запустимо його знову, але передаємо ``stderr`` до ``/dev/null``, ми "
"побачимо наступне, яке є єдиним повідомленням, яке записується в ``stdout``:"

msgid "Once again, but piping ``stdout`` to ``/dev/null``, we get:"
msgstr "Ще раз, але передаючи ``stdout`` до ``/dev/null``, ми отримуємо:"

msgid ""
"In this case, the message #5 printed to ``stdout`` doesn't appear, as "
"expected."
msgstr ""
"У цьому випадку повідомлення №5, надруковане в ``stdout``, не з'являється, "
"як очікувалося."

msgid ""
"Of course, the approach described here can be generalised, for example to "
"attach logging filters temporarily. Note that the above code works in Python "
"2 as well as Python 3."
msgstr ""
"Звичайно, описаний тут підхід можна узагальнити, наприклад, тимчасово "
"приєднати фільтри журналювання. Зверніть увагу, що наведений вище код працює "
"як у Python 2, так і в Python 3."

msgid "A CLI application starter template"
msgstr "Початковий шаблон програми CLI"

msgid "Here's an example which shows how you can:"
msgstr "Ось приклад, який показує, як можна:"

msgid "Use a logging level based on command-line arguments"
msgstr ""
"Використовуйте рівень журналювання на основі аргументів командного рядка"

msgid ""
"Dispatch to multiple subcommands in separate files, all logging at the same "
"level in a consistent way"
msgstr ""
"Відправлення до кількох підкоманд в окремих файлах, усі журнали на одному "
"рівні узгоджено"

msgid "Make use of simple, minimal configuration"
msgstr "Використовуйте просту мінімальну конфігурацію"

msgid ""
"Suppose we have a command-line application whose job is to stop, start or "
"restart some services. This could be organised for the purposes of "
"illustration as a file ``app.py`` that is the main script for the "
"application, with individual commands implemented in ``start.py``, ``stop."
"py`` and ``restart.py``. Suppose further that we want to control the "
"verbosity of the application via a command-line argument, defaulting to "
"``logging.INFO``. Here's one way that ``app.py`` could be written::"
msgstr ""
"Припустімо, що у нас є програма командного рядка, завданням якої є зупинка, "
"запуск або перезапуск деяких служб. Для ілюстрації це можна організувати як "
"файл ``app.py``, який є основним сценарієм для програми, з окремими "
"командами, реалізованими в ``start.py``, ``stop.py`` і ``restart.py``. "
"Припустимо далі, що ми хочемо контролювати докладність програми за допомогою "
"аргументу командного рядка, за замовчуванням ``logging.INFO``. Ось один із "
"способів написання ``app.py``:"

msgid ""
"And the ``start``, ``stop`` and ``restart`` commands can be implemented in "
"separate modules, like so for starting::"
msgstr ""
"А команди ``start``, ``stop`` і ``restart`` можна реалізувати в окремих "
"модулях, наприклад, для запуску::"

msgid "and thus for stopping::"
msgstr "і, таким чином, для зупинки::"

msgid "and similarly for restarting::"
msgstr "і аналогічно для перезапуску::"

msgid ""
"If we run this application with the default log level, we get output like "
"this:"
msgstr ""
"Якщо ми запустимо цю програму з рівнем журналу за замовчуванням, ми "
"отримаємо такий результат:"

msgid ""
"The first word is the logging level, and the second word is the module or "
"package name of the place where the event was logged."
msgstr ""
"Перше слово — це рівень журналювання, а друге — ім’я модуля або пакета "
"місця, де було зареєстровано подію."

msgid ""
"If we change the logging level, then we can change the information sent to "
"the log. For example, if we want more information:"
msgstr ""
"Якщо ми змінимо рівень журналювання, ми зможемо змінити інформацію, яка "
"надсилається до журналу. Наприклад, якщо нам потрібна додаткова інформація:"

msgid "And if we want less:"
msgstr "А якщо ми хочемо менше:"

msgid ""
"In this case, the commands don't print anything to the console, since "
"nothing at ``WARNING`` level or above is logged by them."
msgstr ""
"У цьому випадку команди нічого не друкують на консолі, оскільки вони нічого "
"не реєструють на рівні ``ПОПЕРЕДЖЕННЯ`` або вище."

msgid "A Qt GUI for logging"
msgstr "Графічний інтерфейс Qt для журналювання"

msgid ""
"A question that comes up from time to time is about how to log to a GUI "
"application. The `Qt <https://www.qt.io/>`_ framework is a popular cross-"
"platform UI framework with Python bindings using `PySide2 <https://pypi.org/"
"project/PySide2/>`_ or `PyQt5 <https://pypi.org/project/PyQt5/>`_ libraries."
msgstr ""
"Час від часу виникає питання про те, як увійти в програму графічного "
"інтерфейсу користувача. Фреймворк `Qt <https://www.qt.io/>`_ — це популярна "
"кросплатформна структура інтерфейсу користувача з прив’язками Python із "
"використанням бібліотек `PySide2 <https://pypi.org/project/PySide2/>`_ або "
"`PyQt5 <https://pypi.org/project/PyQt5/>`_."

msgid ""
"The following example shows how to log to a Qt GUI. This introduces a simple "
"``QtHandler`` class which takes a callable, which should be a slot in the "
"main thread that does GUI updates. A worker thread is also created to show "
"how you can log to the GUI from both the UI itself (via a button for manual "
"logging) as well as a worker thread doing work in the background (here, just "
"logging messages at random levels with random short delays in between)."
msgstr ""
"У наступному прикладі показано, як увійти до Qt GUI. Це представляє простий "
"клас ``QtHandler``, який приймає callable, який має бути слотом у головному "
"потоці, який виконує оновлення GUI. Робочий потік також створюється, щоб "
"показати, як ви можете входити в графічний інтерфейс як з самого інтерфейсу "
"користувача (за допомогою кнопки для ручного журналювання), так і з робочого "
"потоку, який виконує роботу у фоновому режимі (тут просто реєструє "
"повідомлення на випадкових рівнях з довільним короткі затримки між ними)."

msgid ""
"The worker thread is implemented using Qt's ``QThread`` class rather than "
"the :mod:`threading` module, as there are circumstances where one has to use "
"``QThread``, which offers better integration with other ``Qt`` components."
msgstr ""
"Робочий потік реалізовано за допомогою класу ``QThread`` Qt, а не модуля :"
"mod:`threading`, оскільки є обставини, коли потрібно використовувати "
"``QThread``, який забезпечує кращу інтеграцію з іншим ``Qt`` компоненти."

msgid ""
"The code should work with recent releases of either ``PySide2`` or "
"``PyQt5``. You should be able to adapt the approach to earlier versions of "
"Qt. Please refer to the comments in the code snippet for more detailed "
"information."
msgstr ""
"Код має працювати з останніми випусками ``PySide2`` або ``PyQt5``. Ви "
"повинні мати можливість адаптувати підхід до попередніх версій Qt. Щоб "
"отримати докладнішу інформацію, зверніться до коментарів у фрагменті коду."

msgid "Logging to syslog with RFC5424 support"
msgstr "Вхід до системного журналу з підтримкою RFC5424"

msgid ""
"Although :rfc:`5424` dates from 2009, most syslog servers are configured by "
"detault to use the older :rfc:`3164`, which hails from 2001. When "
"``logging`` was added to Python in 2003, it supported the earlier (and only "
"existing) protocol at the time. Since RFC5424 came out, as there has not "
"been widespread deployment of it in syslog servers, the :class:`~logging."
"handlers.SysLogHandler` functionality has not been updated."
msgstr ""
"Хоча :rfc:`5424` датується 2009 роком, більшість серверів syslog налаштовано "
"detault на використання старішого :rfc:`3164`, який походить з 2001 року. "
"Коли ``logging`` було додано до Python у 2003 році, воно підтримувало "
"попередній (і єдиний існуючий) протокол на той час. З моменту виходу "
"RFC5424, оскільки його широкого розгортання на серверах syslog не було, "
"функціональні можливості :class:`~logging.handlers.SysLogHandler` не "
"оновлювалися."

msgid ""
"RFC 5424 contains some useful features such as support for structured data, "
"and if you need to be able to log to a syslog server with support for it, "
"you can do so with a subclassed handler which looks something like this::"
msgstr ""
"RFC 5424 містить деякі корисні функції, такі як підтримка структурованих "
"даних, і якщо вам потрібно мати можливість увійти на сервер системного "
"журналу з його підтримкою, ви можете зробити це за допомогою обробника "
"підкласів, який виглядає приблизно так:"

msgid ""
"You'll need to be familiar with RFC 5424 to fully understand the above code, "
"and it may be that you have slightly different needs (e.g. for how you pass "
"structural data to the log). Nevertheless, the above should be adaptable to "
"your speciric needs. With the above handler, you'd pass structured data "
"using something like this::"
msgstr ""
"Вам потрібно буде ознайомитися з RFC 5424, щоб повністю зрозуміти наведений "
"вище код, і можливо, у вас є дещо інші потреби (наприклад, щодо того, як ви "
"передаєте структурні дані в журнал). Тим не менш, наведене вище має "
"адаптуватися до ваших конкретних потреб. За допомогою наведеного вище "
"обробника ви передаєте структуровані дані, використовуючи щось на зразок "
"цього::"

msgid "How to treat a logger like an output stream"
msgstr ""

msgid ""
"Sometimes, you need to interface to a third-party API which expects a file-"
"like object to write to, but you want to direct the API's output to a "
"logger. You can do this using a class which wraps a logger with a file-like "
"API. Here's a short script illustrating such a class:"
msgstr ""

msgid "When this script is run, it prints"
msgstr ""

msgid ""
"You could also use ``LoggerWriter`` to redirect ``sys.stdout`` and ``sys."
"stderr`` by doing something like this:"
msgstr ""

msgid ""
"You should do this *after* configuring logging for your needs. In the above "
"example, the :func:`~logging.basicConfig` call does this (using the ``sys."
"stderr`` value *before* it is overwritten by a ``LoggerWriter`` instance). "
"Then, you'd get this kind of result:"
msgstr ""

msgid ""
"Of course, the examples above show output according to the format used by :"
"func:`~logging.basicConfig`, but you can use a different formatter when you "
"configure logging."
msgstr ""

msgid ""
"Note that with the above scheme, you are somewhat at the mercy of buffering "
"and the sequence of write calls which you are intercepting. For example, "
"with the definition of ``LoggerWriter`` above, if you have the snippet"
msgstr ""

msgid "then running the script results in"
msgstr ""

msgid ""
"As you can see, this output isn't ideal. That's because the underlying code "
"which writes to ``sys.stderr`` makes mutiple writes, each of which results "
"in a separate logged line (for example, the last three lines above). To get "
"around this problem, you need to buffer things and only output log lines "
"when newlines are seen. Let's use a slghtly better implementation of "
"``LoggerWriter``:"
msgstr ""

msgid ""
"This just buffers up stuff until a newline is seen, and then logs complete "
"lines. With this approach, you get better output:"
msgstr ""

msgid "Patterns to avoid"
msgstr "Шаблони, яких слід уникати"

msgid ""
"Although the preceding sections have described ways of doing things you "
"might need to do or deal with, it is worth mentioning some usage patterns "
"which are *unhelpful*, and which should therefore be avoided in most cases. "
"The following sections are in no particular order."
msgstr ""
"Незважаючи на те, що в попередніх розділах описано способи виконання речей, "
"які вам можуть знадобитися, варто згадати деякі шаблони використання, які є "
"*некорисними* і яких у більшості випадків слід уникати. Наступні розділи не "
"мають певного порядку."

msgid "Opening the same log file multiple times"
msgstr "Відкриття одного файлу журналу кілька разів"

msgid ""
"On Windows, you will generally not be able to open the same file multiple "
"times as this will lead to a \"file is in use by another process\" error. "
"However, on POSIX platforms you'll not get any errors if you open the same "
"file multiple times. This could be done accidentally, for example by:"
msgstr ""
"У Windows зазвичай ви не зможете відкрити один і той же файл кілька разів, "
"оскільки це призведе до помилки \"файл використовується іншим процесом\". "
"Однак на платформах POSIX ви не отримаєте жодних помилок, якщо відкриєте той "
"самий файл кілька разів. Це може бути зроблено випадково, наприклад:"

msgid ""
"Adding a file handler more than once which references the same file (e.g. by "
"a copy/paste/forget-to-change error)."
msgstr ""
"Додавання обробника файлів більше одного разу, який посилається на той самий "
"файл (наприклад, через помилку копіювання/вставлення/забути змінити)."

msgid ""
"Opening two files that look different, as they have different names, but are "
"the same because one is a symbolic link to the other."
msgstr ""
"Відкриття двох файлів, які виглядають по-різному, оскільки мають різні "
"назви, але однакові, оскільки один є символічним посиланням на інший."

msgid ""
"Forking a process, following which both parent and child have a reference to "
"the same file. This might be through use of the :mod:`multiprocessing` "
"module, for example."
msgstr ""
"Розгалуження процесу, після якого і батьківський, і дочірній елементи мають "
"посилання на той самий файл. Це може бути, наприклад, через використання "
"модуля :mod:`multiprocessing`."

msgid ""
"Opening a file multiple times might *appear* to work most of the time, but "
"can lead to a number of problems in practice:"
msgstr ""
"Багаторазове відкриття файлу може *видаватись* більшу частину часу "
"ефективним, але на практиці це може призвести до ряду проблем:"

msgid ""
"Logging output can be garbled because multiple threads or processes try to "
"write to the same file. Although logging guards against concurrent use of "
"the same handler instance by multiple threads, there is no such protection "
"if concurrent writes are attempted by two different threads using two "
"different handler instances which happen to point to the same file."
msgstr ""
"Вихід журналу може бути спотвореним, оскільки кілька потоків або процесів "
"намагаються записати в той самий файл. Хоча журналювання захищає від "
"одночасного використання одного екземпляра обробника кількома потоками, "
"такого захисту немає, якщо одночасний запис намагаються виконати два різні "
"потоки, використовуючи два різні екземпляри обробника, які випадково "
"вказують на той самий файл."

msgid ""
"An attempt to delete a file (e.g. during file rotation) silently fails, "
"because there is another reference pointing to it. This can lead to "
"confusion and wasted debugging time - log entries end up in unexpected "
"places, or are lost altogether. Or a file that was supposed to be moved "
"remains in place, and grows in size unexpectedly despite size-based rotation "
"being supposedly in place."
msgstr ""

msgid ""
"Use the techniques outlined in :ref:`multiple-processes` to circumvent such "
"issues."
msgstr ""
"Використовуйте методи, описані в :ref:`multiple-processes`, щоб уникнути "
"таких проблем."

msgid "Using loggers as attributes in a class or passing them as parameters"
msgstr ""
"Використання реєстраторів як атрибутів у класі або передача їх як параметрів"

msgid ""
"While there might be unusual cases where you'll need to do this, in general "
"there is no point because loggers are singletons. Code can always access a "
"given logger instance by name using ``logging.getLogger(name)``, so passing "
"instances around and holding them as instance attributes is pointless. Note "
"that in other languages such as Java and C#, loggers are often static class "
"attributes. However, this pattern doesn't make sense in Python, where the "
"module (and not the class) is the unit of software decomposition."
msgstr ""
"Хоча можуть бути незвичайні випадки, коли вам знадобиться це зробити, "
"загалом це не має сенсу, оскільки реєстратори є одиночними. Код завжди може "
"отримати доступ до певного екземпляра реєстратора за назвою за допомогою "
"``logging.getLogger(name)``, тому передавати екземпляри та зберігати їх як "
"атрибути екземпляра безглуздо. Зверніть увагу, що в інших мовах, таких як "
"Java і C#, реєстратори часто є статичними атрибутами класу. Однак цей шаблон "
"не має сенсу в Python, де модуль (а не клас) є одиницею декомпозиції "
"програмного забезпечення."

msgid ""
"Adding handlers other than :class:`NullHandler` to a logger in a library"
msgstr ""
"Додавання обробників, відмінних від :class:`NullHandler`, до реєстратора в "
"бібліотеці"

msgid ""
"Configuring logging by adding handlers, formatters and filters is the "
"responsibility of the application developer, not the library developer. If "
"you are maintaining a library, ensure that you don't add handlers to any of "
"your loggers other than a :class:`~logging.NullHandler` instance."
msgstr ""
"Налаштування журналювання шляхом додавання обробників, засобів форматування "
"та фільтрів є відповідальністю розробника програми, а не розробника "
"бібліотеки. Якщо ви підтримуєте бібліотеку, переконайтеся, що ви не додаєте "
"обробники до жодного з ваших журналів, крім екземпляра :class:`~logging."
"NullHandler`."

msgid "Creating a lot of loggers"
msgstr "Створення великої кількості журналів"

msgid ""
"Loggers are singletons that are never freed during a script execution, and "
"so creating lots of loggers will use up memory which can't then be freed. "
"Rather than create a logger per e.g. file processed or network connection "
"made, use the :ref:`existing mechanisms <context-info>` for passing "
"contextual information into your logs and restrict the loggers created to "
"those describing areas within your application (generally modules, but "
"occasionally slightly more fine-grained than that)."
msgstr ""
"Реєстратори — це одиночні елементи, які ніколи не звільняються під час "
"виконання сценарію, тому створення великої кількості реєстраторів буде "
"використовувати пам’ять, яку потім не можна звільнити. Замість створення "
"реєстратора, наприклад, оброблено файл або встановлено мережеве з’єднання, "
"скористайтеся :ref:`існуючими механізмами <context-info>` для передачі "
"контекстної інформації у ваші журнали та обмежте реєстратори, створені тими, "
"що описують області у вашій програмі (зазвичай модулі, але іноді трохи більш "
"дрібнозернисті, ніж це) ."

msgid "Other resources"
msgstr "Інші ресурси"

msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`Основний посібник <logging-basic-tutorial>`"

msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`Розширений посібник <logging-advanced-tutorial>`"
