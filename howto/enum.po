# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "Enum HOWTO"
msgstr "Enum HOWTO"

msgid ""
"An :class:`Enum` is a set of symbolic names bound to unique values.  They "
"are similar to global variables, but they offer a more useful :func:"
"`repr()`, grouping, type-safety, and a few other features."
msgstr ""
":class:`Enum` — це набір символічних імен, прив’язаних до унікальних "
"значень. Вони подібні до глобальних змінних, але пропонують більш корисні "
"функції :func:`repr()`, групування, безпеку типів і кілька інших функцій."

msgid ""
"They are most useful when you have a variable that can take one of a limited "
"selection of values.  For example, the days of the week::"
msgstr ""
"Вони найбільш корисні, коли у вас є змінна, яка може приймати одне з "
"обмеженого вибору значень. Наприклад, дні тижня::"

msgid "Or perhaps the RGB primary colors::"
msgstr ""

msgid ""
"As you can see, creating an :class:`Enum` is as simple as writing a class "
"that inherits from :class:`Enum` itself."
msgstr ""
"Як бачите, створити :class:`Enum` так само просто, як написати клас, який "
"успадковує сам :class:`Enum`."

msgid "Case of Enum Members"
msgstr "Випадок членів Enum"

msgid ""
"Because Enums are used to represent constants we recommend using UPPER_CASE "
"names for members, and will be using that style in our examples."
msgstr ""
"Оскільки Enum використовуються для представлення констант, ми рекомендуємо "
"використовувати UPPER_CASE імена для членів і використовуватимемо цей стиль "
"у наших прикладах."

msgid ""
"Depending on the nature of the enum a member's value may or may not be "
"important, but either way that value can be used to get the corresponding "
"member::"
msgstr ""
"Залежно від характеру переліку значення члена може бути важливим або "
"неважливим, але в будь-якому випадку це значення можна використовувати для "
"отримання відповідного члена::"

msgid ""
"As you can see, the ``repr()`` of a member shows the enum name, the member "
"name, and the value.  The ``str()`` of a member shows only the enum name and "
"member name::"
msgstr ""

msgid "The *type* of an enumeration member is the enum it belongs to::"
msgstr "*Тип* члена переліку — це enum, якому він належить::"

msgid "Enum members have an attribute that contains just their :attr:`name`::"
msgstr "Члени Enum мають атрибут, який містить лише їх :attr:`name`::"

msgid "Likewise, they have an attribute for their :attr:`value`::"
msgstr "Так само вони мають атрибут для свого :attr:`value`::"

msgid ""
"Unlike many languages that treat enumerations solely as name/value pairs, "
"Python Enums can have behavior added.  For example, :class:`datetime.date` "
"has two methods for returning the weekday: :meth:`weekday` and :meth:"
"`isoweekday`. The difference is that one of them counts from 0-6 and the "
"other from 1-7. Rather than keep track of that ourselves we can add a method "
"to the :class:`Weekday` enum to extract the day from the :class:`date` "
"instance and return the matching enum member::"
msgstr ""
"На відміну від багатьох мов, які розглядають перерахування виключно як пари "
"ім’я/значення, Python Enums може мати додану поведінку. Наприклад, :class:"
"`datetime.date` має два методи для повернення дня тижня: :meth:`weekday` і :"
"meth:`isoweekday`. Різниця в тому, що один з них рахує від 0 до 6, а інший "
"від 1 до 7. Замість того, щоб відслідковувати це самостійно, ми можемо "
"додати метод до переліку :class:`Weekday`, щоб отримати день із примірника :"
"class:`date` і повернути відповідний член переліку::"

msgid "The complete :class:`Weekday` enum now looks like this::"
msgstr "Повний перелік :class:`Weekday` виглядає так:"

msgid "Now we can find out what today is!  Observe::"
msgstr "Тепер ми можемо дізнатися, що таке сьогодні! Спостерігати::"

msgid ""
"Of course, if you're reading this on some other day, you'll see that day "
"instead."
msgstr "Звичайно, якщо ви читаєте це в інший день, ви побачите цей день."

msgid ""
"This :class:`Weekday` enum is great if our variable only needs one day, but "
"what if we need several?  Maybe we're writing a function to plot chores "
"during a week, and don't want to use a :class:`list` -- we could use a "
"different type of :class:`Enum`::"
msgstr ""
"Цей перелік :class:`Weekday` чудово підходить, якщо нашій змінній потрібен "
"лише один день, але що, якщо нам потрібно декілька? Можливо, ми пишемо "
"функцію для графіку роботи протягом тижня, і не хочемо використовувати :"
"class:`list` -- ми можемо використати інший тип :class:`Enum`::"

msgid ""
"We've changed two things: we're inherited from :class:`Flag`, and the values "
"are all powers of 2."
msgstr ""
"Ми змінили дві речі: ми успадковані від :class:`Flag`, і всі значення є "
"степенями 2."

msgid ""
"Just like the original :class:`Weekday` enum above, we can have a single "
"selection::"
msgstr ""
"Як і в оригінальному переліку :class:`Weekday` вище, ми можемо мати один "
"вибір::"

msgid ""
"But :class:`Flag` also allows us to combine several members into a single "
"variable::"
msgstr ""
"Але :class:`Flag` також дозволяє нам об’єднати кілька членів в одну змінну::"

msgid "You can even iterate over a :class:`Flag` variable::"
msgstr "Ви навіть можете перебирати змінну :class:`Flag`::"

msgid "Okay, let's get some chores set up::"
msgstr "Гаразд, давайте приступимо до роботи::"

msgid "And a function to display the chores for a given day::"
msgstr "І функція для відображення справ за певний день::"

msgid ""
"In cases where the actual values of the members do not matter, you can save "
"yourself some work and use :func:`auto()` for the values::"
msgstr ""
"У випадках, коли фактичні значення членів не мають значення, ви можете "
"заощадити собі трохи праці та використати :func:`auto()` для значень::"

msgid "Programmatic access to enumeration members and their attributes"
msgstr "Програмний доступ до елементів переліку та їх атрибутів"

msgid ""
"Sometimes it's useful to access members in enumerations programmatically (i."
"e. situations where ``Color.RED`` won't do because the exact color is not "
"known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"Іноді корисно отримати доступ до членів у перерахуваннях програмно (тобто "
"ситуації, коли ``Color.RED`` не підійде, оскільки точний колір невідомий під "
"час написання програми). ``Enum`` дозволяє такий доступ:"

msgid "If you want to access enum members by *name*, use item access::"
msgstr ""
"Якщо ви хочете отримати доступ до членів enum за *ім’ям*, використовуйте "
"доступ до елемента::"

msgid "If you have an enum member and need its :attr:`name` or :attr:`value`::"
msgstr ""
"Якщо у вас є член enum і вам потрібно його :attr:`name` або :attr:`value`::"

msgid "Duplicating enum members and values"
msgstr "Дублювання членів enum і значень"

msgid "Having two enum members with the same name is invalid::"
msgstr "Наявність двох членів переліку з однаковими іменами недійсна::"

msgid ""
"However, an enum member can have other names associated with it.  Given two "
"entries ``A`` and ``B`` with the same value (and ``A`` defined first), ``B`` "
"is an alias for the member ``A``.  By-value lookup of the value of ``A`` "
"will return the member ``A``.  By-name lookup of ``A`` will return the "
"member ``A``. By-name lookup of ``B`` will also return the member ``A``::"
msgstr ""
"Однак член enum може мати інші імена, пов’язані з ним. За наявності двох "
"записів ``A`` і ``B`` з однаковим значенням (і ``A``, визначеним першим), "
"``B`` є псевдонімом для члена ``A``. Пошук за значенням значення ``A`` "
"поверне член ``A``. Пошук за назвою ``A`` поверне член ``A``. Пошук за "
"назвою ``B`` також поверне член ``A``::"

msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr ""
"Спроба створити член із тим же ім’ям, що й уже визначений атрибут (інший "
"член, метод тощо), або спроба створити атрибут із тим же ім’ям, що й член, "
"не дозволяється."

msgid "Ensuring unique enumeration values"
msgstr "Забезпечення унікальних значень перерахування"

msgid ""
"By default, enumerations allow multiple names as aliases for the same value. "
"When this behavior isn't desired, you can use the :func:`unique` decorator::"
msgstr ""
"За замовчуванням перерахування дозволяють використовувати кілька імен як "
"псевдоніми для одного значення. Якщо така поведінка небажана, ви можете "
"використати декоратор :func:`unique`::"

msgid "Using automatic values"
msgstr "Використання автоматичних значень"

msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr ""
"Якщо точне значення неважливе, ви можете використовувати :class:`auto`::"

msgid ""
"The values are chosen by :func:`_generate_next_value_`, which can be "
"overridden::"
msgstr ""
"Значення вибираються :func:`_generate_next_value_`, які можна замінити:"

msgid ""
"The :meth:`_generate_next_value_` method must be defined before any members."
msgstr ""
"Метод :meth:`_generate_next_value_` має бути визначений перед будь-якими "
"членами."

msgid "Iteration"
msgstr "Ітерація"

msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr "Перебір членів enum не забезпечує псевдоніми::"

msgid ""
"The special attribute ``__members__`` is a read-only ordered mapping of "
"names to members.  It includes all names defined in the enumeration, "
"including the aliases::"
msgstr ""
"Спеціальний атрибут ``__members__`` — це впорядковане відображення імен "
"учасників лише для читання. Він включає всі імена, визначені в переліку, "
"включаючи псевдоніми::"

msgid ""
"The ``__members__`` attribute can be used for detailed programmatic access "
"to the enumeration members.  For example, finding all the aliases::"
msgstr ""
"Атрибут ``__members__`` можна використовувати для детального програмного "
"доступу до елементів переліку. Наприклад, пошук усіх псевдонімів::"

msgid "Comparisons"
msgstr "Порівняння"

msgid "Enumeration members are compared by identity::"
msgstr "Члени переліку порівнюються за ідентичністю::"

msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum "
"members are not integers (but see `IntEnum`_ below)::"
msgstr ""
"Упорядковані порівняння між значеннями перерахування *не* підтримуються. "
"Члени Enum не є цілими числами (але дивіться `IntEnum`_ нижче):"

msgid "Equality comparisons are defined though::"
msgstr "Однак порівняння рівності визначено:"

msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, see "
"below)::"
msgstr ""
"Порівняння зі значеннями, не пов’язаними з перерахуванням, завжди "
"порівнюватиметься нерівними (знову ж таки, :class:`IntEnum` був явно "
"розроблений для іншої поведінки, див. нижче)::"

msgid "Allowed members and attributes of enumerations"
msgstr "Дозволені члени та атрибути перерахувань"

msgid ""
"Most of the examples above use integers for enumeration values.  Using "
"integers is short and handy (and provided by default by the `Functional "
"API`_), but not strictly enforced.  In the vast majority of use-cases, one "
"doesn't care what the actual value of an enumeration is.  But if the value "
"*is* important, enumerations can have arbitrary values."
msgstr ""
"Більшість наведених вище прикладів використовують цілі числа для значень "
"перерахування. Використання цілих чисел є коротким і зручним (і надається за "
"замовчуванням `Functional API`_), але не суворо дотримується. У переважній "
"більшості варіантів використання байдуже, яке фактичне значення "
"перерахування. Але якщо значення *є* важливим, перерахування можуть мати "
"довільні значення."

msgid ""
"Enumerations are Python classes, and can have methods and special methods as "
"usual.  If we have this enumeration::"
msgstr ""
"Перерахування є класами Python і, як зазвичай, можуть мати методи та "
"спеціальні методи. Якщо ми маємо цей перелік::"

msgid "Then::"
msgstr "Потім::"

msgid ""
"The rules for what is allowed are as follows: names that start and end with "
"a single underscore are reserved by enum and cannot be used; all other "
"attributes defined within an enumeration will become members of this "
"enumeration, with the exception of special methods (:meth:`__str__`, :meth:"
"`__add__`, etc.), descriptors (methods are also descriptors), and variable "
"names listed in :attr:`_ignore_`."
msgstr ""
"Дозволені правила такі: імена, які починаються і закінчуються одним "
"підкресленням, зарезервовані enum і не можуть використовуватися; усі інші "
"атрибути, визначені в переліку, стануть членами цього переліку, за винятком "
"спеціальних методів (:meth:`__str__`, :meth:`__add__` тощо), дескрипторів "
"(методи також є дескрипторами) і імен змінних перераховані в :attr:"
"`_ignore_`."

msgid ""
"Note:  if your enumeration defines :meth:`__new__` and/or :meth:`__init__` "
"then any value(s) given to the enum member will be passed into those "
"methods. See `Planet`_ for an example."
msgstr ""
"Примітка: якщо ваш перелік визначає :meth:`__new__` та/або :meth:`__init__`, "
"тоді будь-яке значення, надане члену enum, буде передано в ці методи. "
"Перегляньте `Planet`_ для прикладу."

msgid "Restricted Enum subclassing"
msgstr "Обмежений підклас Enum"

msgid ""
"A new :class:`Enum` class must have one base enum class, up to one concrete "
"data type, and as many :class:`object`-based mixin classes as needed.  The "
"order of these base classes is::"
msgstr ""
"Новий клас :class:`Enum` повинен мати один базовий клас enum, до одного "
"конкретного типу даних і стільки класів міксину на основі :class:`object`, "
"скільки потрібно. Порядок цих базових класів:"

msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does not "
"define any members.  So this is forbidden::"
msgstr ""
"Крім того, створення підкласу переліку дозволяється, лише якщо перелік не "
"визначає жодних членів. Тому це заборонено::"

msgid "But this is allowed::"
msgstr "Але це дозволено::"

msgid ""
"Allowing subclassing of enums that define members would lead to a violation "
"of some important invariants of types and instances.  On the other hand, it "
"makes sense to allow sharing some common behavior between a group of "
"enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"Дозвіл створення підкласів для переліків, які визначають члени, призведе до "
"порушення деяких важливих інваріантів типів і екземплярів. З іншого боку, "
"має сенс дозволити спільну поведінку між групою перерахувань. (Див. "
"`OrderedEnum`_ для прикладу.)"

msgid "Pickling"
msgstr "Соління"

msgid "Enumerations can be pickled and unpickled::"
msgstr "Перерахування можна маринувати і не маринувати:"

msgid ""
"The usual restrictions for pickling apply: picklable enums must be defined "
"in the top level of a module, since unpickling requires them to be "
"importable from that module."
msgstr ""
"Застосовуються звичайні обмеження для маркування: переліки, які можна "
"піклувати, повинні бути визначені на верхньому рівні модуля, оскільки для "
"скасування потрібно, щоб їх можна було імпортувати з цього модуля."

msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums nested "
"in other classes."
msgstr ""
"За допомогою протоколу pickle версії 4 можна легко маринувати переліки, "
"вкладені в інші класи."

msgid ""
"It is possible to modify how enum members are pickled/unpickled by defining :"
"meth:`__reduce_ex__` in the enumeration class."
msgstr ""
"Можна змінити те, як члени enum вибираються/розбираються, визначивши :meth:"
"`__reduce_ex__` у класі переліку."

msgid "Functional API"
msgstr "Функціональний API"

msgid ""
"The :class:`Enum` class is callable, providing the following functional API::"
msgstr ""
"Клас :class:`Enum` можна викликати, забезпечуючи такий функціональний API:"

msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the enumeration."
msgstr ""
"Семантика цього API нагадує :class:`~collections.namedtuple`. Першим "
"аргументом виклику :class:`Enum` є назва переліку."

msgid ""
"The second argument is the *source* of enumeration member names.  It can be "
"a whitespace-separated string of names, a sequence of names, a sequence of 2-"
"tuples with key/value pairs, or a mapping (e.g. dictionary) of names to "
"values.  The last two options enable assigning arbitrary values to "
"enumerations; the others auto-assign increasing integers starting with 1 "
"(use the ``start`` parameter to specify a different starting value).  A new "
"class derived from :class:`Enum` is returned.  In other words, the above "
"assignment to :class:`Animal` is equivalent to::"
msgstr ""
"Другим аргументом є *джерело* імен членів переліку. Це може бути рядок імен, "
"розділених пробілами, послідовність імен, послідовність 2-кортежів із парами "
"ключ/значення або зіставлення (наприклад, словник) імен із значеннями. "
"Останні два параметри дозволяють присвоювати довільні значення "
"перерахуванням; інші автоматично призначають зростаючі цілі числа, починаючи "
"з 1 (використовуйте параметр ``start``, щоб вказати інше початкове "
"значення). Повертається новий клас, похідний від :class:`Enum`. Іншими "
"словами, наведене вище призначення :class:`Animal` еквівалентне::"

msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` is "
"that ``0`` is ``False`` in a boolean sense, but by default enum members all "
"evaluate to ``True``."
msgstr ""
"Причина того, що за замовчуванням початковим числом є ``1``, а не ``0``, "
"полягає в тому, що ``0`` є ``False`` у логічному сенсі, але за замовчуванням "
"усі члени enum оцінюються як ``True``."

msgid ""
"Pickling enums created with the functional API can be tricky as frame stack "
"implementation details are used to try and figure out which module the "
"enumeration is being created in (e.g. it will fail if you use a utility "
"function in a separate module, and also may not work on IronPython or "
"Jython). The solution is to specify the module name explicitly as follows::"
msgstr ""

msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the new "
"Enum members will not be unpicklable; to keep errors closer to the source, "
"pickling will be disabled."
msgstr ""
"Якщо ``module`` не вказано, і Enum не може визначити, що це таке, нові члени "
"Enum не можна буде вибрати; щоб зберегти помилки ближче до джерела, "
"травлення буде вимкнено."

msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on :attr:"
"`~definition.__qualname__` being set to the location where pickle will be "
"able to find the class.  For example, if the class was made available in "
"class SomeData in the global scope::"
msgstr ""
"Новий протокол pickle 4 також, за деяких обставин, покладається на те, що :"
"attr:`~definition.__qualname__` встановлено на місце, де pickle зможе знайти "
"клас. Наприклад, якщо клас був доступний у класі SomeData у глобальній "
"області::"

msgid "The complete signature is::"
msgstr "Повний підпис:"

msgid "value"
msgstr "значення"

msgid "What the new enum class will record as its name."
msgstr "Те, що новий клас enum записуватиме як своє ім’я."

msgid "names"
msgstr "імена"

msgid ""
"The enum members.  This can be a whitespace- or comma-separated string "
"(values will start at 1 unless otherwise specified)::"
msgstr ""

msgid "or an iterator of names::"
msgstr "або ітератор імен::"

msgid "or an iterator of (name, value) pairs::"
msgstr "або ітератор пар (ім'я, значення)::"

msgid "or a mapping::"
msgstr "або відображення::"

msgid "module"
msgstr "модуль"

msgid "name of module where new enum class can be found."
msgstr "назва модуля, де можна знайти новий клас enum."

msgid "qualname"
msgstr "qualname"

msgid "where in module new enum class can be found."
msgstr "де в модулі можна знайти новий клас enum."

msgid "type"
msgstr "типу"

msgid "type to mix in to new enum class."
msgstr "введіть, щоб додати до нового класу enum."

msgid "start"
msgstr "початок"

msgid "number to start counting at if only names are passed in."
msgstr "число для початку підрахунку, якщо передано лише імена."

msgid "The *start* parameter was added."
msgstr "Додано параметр *start*."

msgid "Derived Enumerations"
msgstr "Похідні перерахування"

msgid "IntEnum"
msgstr "IntEnum"

msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass of :"
"class:`int`.  Members of an :class:`IntEnum` can be compared to integers; by "
"extension, integer enumerations of different types can also be compared to "
"each other::"
msgstr ""
"Перший наданий варіант :class:`Enum` також є підкласом :class:`int`. Члени :"
"class:`IntEnum` можна порівняти з цілими числами; за розширенням, "
"цілочисельні перерахування різних типів також можна порівнювати один з одним:"

msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr ""
"Однак їх все ще не можна порівняти зі стандартними перерахуваннями :class:"
"`Enum`::"

msgid ""
":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr "Значення :class:`IntEnum` поводяться як цілі числа іншим чином:"

msgid "StrEnum"
msgstr "StrEnum"

msgid ""
"The second variation of :class:`Enum` that is provided is also a subclass "
"of :class:`str`.  Members of a :class:`StrEnum` can be compared to strings; "
"by extension, string enumerations of different types can also be compared to "
"each other."
msgstr ""

msgid "IntFlag"
msgstr "IntFlag"

msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can be "
"combined using the bitwise operators (&, \\|, ^, ~) and the result is still "
"an :class:`IntFlag` member, if possible.  Like :class:`IntEnum`, :class:"
"`IntFlag` members are also integers and can be used wherever an :class:`int` "
"is used."
msgstr ""

msgid ""
"Any operation on an :class:`IntFlag` member besides the bit-wise operations "
"will lose the :class:`IntFlag` membership."
msgstr ""
"Будь-яка операція з членом :class:`IntFlag`, крім побітових операцій, "
"втрачає членство :class:`IntFlag`."

msgid ""
"Bit-wise operations that result in invalid :class:`IntFlag` values will lose "
"the :class:`IntFlag` membership.  See :class:`FlagBoundary` for details."
msgstr ""
"Побітові операції, які призводять до недійсних значень :class:`IntFlag`, "
"втратять членство :class:`IntFlag`. Перегляньте :class:`FlagBoundary` для "
"деталей."

msgid "Sample :class:`IntFlag` class::"
msgstr "Приклад :class:`IntFlag` class::"

msgid "It is also possible to name the combinations::"
msgstr "Також можна назвати комбінації:"

msgid ""
"Named combinations are considered aliases.  Aliases do not show up during "
"iteration, but can be returned from by-value lookups."
msgstr ""
"Іменовані комбінації вважаються псевдонімами. Псевдоніми не відображаються "
"під час ітерації, але їх можна повернути під час пошуку за значенням."

msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` is "
"that if no flags are set (the value is 0), its boolean evaluation is :data:"
"`False`::"
msgstr ""
"Ще одна важлива відмінність між :class:`IntFlag` і :class:`Enum` полягає в "
"тому, що якщо не встановлено жодного прапора (значення дорівнює 0), його "
"логічна оцінка буде :data:`False`::"

msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they "
"can be combined with them (but may lose :class:`IntFlag` membership::"
msgstr ""
"Оскільки члени :class:`IntFlag` також є підкласами :class:`int`, їх можна "
"поєднувати з ними (але вони можуть втратити членство :class:`IntFlag`::"

msgid ""
"The negation operator, ``~``, always returns an :class:`IntFlag` member with "
"a positive value::"
msgstr ""
"Оператор заперечення, ``~``, завжди повертає член :class:`IntFlag` із "
"позитивним значенням::"

msgid ":class:`IntFlag` members can also be iterated over::"
msgstr "Члени :class:`IntFlag` також можна повторювати:"

msgid "Flag"
msgstr "Прапор"

msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, :class:`Flag` "
"members can be combined using the bitwise operators (&, \\|, ^, ~).  Unlike :"
"class:`IntFlag`, they cannot be combined with, nor compared against, any "
"other :class:`Flag` enumeration, nor :class:`int`.  While it is possible to "
"specify the values directly it is recommended to use :class:`auto` as the "
"value and let :class:`Flag` select an appropriate value."
msgstr ""
"Останнім варіантом є :class:`Flag`. Подібно до :class:`IntFlag`, члени :"
"class:`Flag` можна комбінувати за допомогою порозрядних операторів (&, \\|, "
"^, ~). На відміну від :class:`IntFlag`, їх не можна комбінувати з будь-яким "
"іншим переліком :class:`Flag` або :class:`int`, ані порівнювати з ними. Хоча "
"можна вказати значення безпосередньо, рекомендується використовувати :class:"
"`auto` як значення, а :class:`Flag` вибрати відповідне значення."

msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results in "
"no flags being set, the boolean evaluation is :data:`False`::"
msgstr ""
"Подібно до :class:`IntFlag`, якщо комбінація членів :class:`Flag` не "
"призводить до встановлення прапорів, логічна оцінка буде :data:`False`::"

msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, "
"8, ...), while combinations of flags won't::"
msgstr ""
"Індивідуальні прапори повинні мати значення, які є степенями двійки (1, 2, "
"4, 8, ...), тоді як комбінації прапорів не матимуть:"

msgid ""
"Giving a name to the \"no flags set\" condition does not change its boolean "
"value::"
msgstr ""
"Присвоєння назви умові \"прапори не встановлено\" не змінює її логічного "
"значення::"

msgid ":class:`Flag` members can also be iterated over::"
msgstr "Члени :class:`Flag` також можна повторювати:"

msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are strongly "
"recommended, since :class:`IntEnum` and :class:`IntFlag` break some semantic "
"promises of an enumeration (by being comparable to integers, and thus by "
"transitivity to other unrelated enumerations).  :class:`IntEnum` and :class:"
"`IntFlag` should be used only in cases where :class:`Enum` and :class:`Flag` "
"will not do; for example, when integer constants are replaced with "
"enumerations, or for interoperability with other systems."
msgstr ""
"Для більшості нового коду наполегливо рекомендується використовувати :class:"
"`Enum` і :class:`Flag`, оскільки :class:`IntEnum` і :class:`IntFlag` "
"порушують деякі семантичні обіцянки перерахування (через їх порівняння з "
"цілі числа, і, таким чином, через перехідність до інших непов’язаних "
"перерахувань). :class:`IntEnum` і :class:`IntFlag` слід використовувати лише "
"у випадках, коли :class:`Enum` і :class:`Flag` не підходять; наприклад, коли "
"цілі константи замінюються перерахуваннями або для взаємодії з іншими "
"системами."

msgid "Others"
msgstr "інші"

msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be very "
"simple to implement independently::"
msgstr ""
"Хоча :class:`IntEnum` є частиною модуля :mod:`enum`, його було б дуже просто "
"реалізувати незалежно:"

msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`FloatEnum` that mixes in :class:`float` instead of :class:"
"`int`."
msgstr ""

msgid "Some rules:"
msgstr "Деякі правила:"

msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before :class:"
"`Enum` itself in the sequence of bases, as in the :class:`IntEnum` example "
"above."
msgstr ""
"Під час створення підкласу :class:`Enum` змішані типи повинні з’являтися "
"перед самим :class:`Enum` у послідовності основ, як у прикладі :class:"
"`IntEnum` вище."

msgid ""
"Mix-in types must be subclassable. For example, :class:`bool` and :class:"
"`range` are not subclassable and will throw an error during Enum creation if "
"used as the mix-in type."
msgstr ""

msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. :class:"
"`int` above.  This restriction does not apply to mix-ins which only add "
"methods and don't specify another type."
msgstr ""
"Хоча :class:`Enum` може мати члени будь-якого типу, коли ви додаєте "
"додатковий тип, усі члени повинні мати значення цього типу, наприклад. :"
"class:`int` вище. Це обмеження не стосується змішувань, які лише додають "
"методи і не вказують інший тип."

msgid ""
"When another data type is mixed in, the :attr:`value` attribute is *not the "
"same* as the enum member itself, although it is equivalent and will compare "
"equal."
msgstr ""
"Коли додається інший тип даних, атрибут :attr:`value` *не такий самий*, як "
"сам член переліку, хоча він еквівалентний і порівнюватиметься рівним."

msgid ""
"%-style formatting:  ``%s`` and ``%r`` call the :class:`Enum` class's :meth:"
"`__str__` and :meth:`__repr__` respectively; other codes (such as ``%i`` or "
"``%h`` for IntEnum) treat the enum member as its mixed-in type."
msgstr ""

msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and :func:"
"`format` will use the enum's :meth:`__str__` method."
msgstr ""

msgid ""
"Because :class:`IntEnum`, :class:`IntFlag`, and :class:`StrEnum` are "
"designed to be drop-in replacements for existing constants, their :meth:"
"`__str__` method has been reset to their data types :meth:`__str__` method."
msgstr ""

msgid "When to use :meth:`__new__` vs. :meth:`__init__`"
msgstr "Коли використовувати :meth:`__new__` проти :meth:`__init__`"

msgid ""
":meth:`__new__` must be used whenever you want to customize the actual value "
"of the :class:`Enum` member.  Any other modifications may go in either :meth:"
"`__new__` or :meth:`__init__`, with :meth:`__init__` being preferred."
msgstr ""
":meth:`__new__` потрібно використовувати щоразу, коли ви хочете налаштувати "
"фактичне значення члена :class:`Enum`. Будь-які інші модифікації можна "
"вносити в :meth:`__new__` або :meth:`__init__`, причому перевага віддається :"
"meth:`__init__`."

msgid ""
"For example, if you want to pass several items to the constructor, but only "
"want one of them to be the value::"
msgstr ""
"Наприклад, якщо ви хочете передати кілька елементів у конструктор, але "
"хочете, щоб лише один із них був значенням::"

msgid "Finer Points"
msgstr "Більш тонкі точки"

msgid "Supported ``__dunder__`` names"
msgstr "Підтримувані імена ``__dunder__``"

msgid ""
":attr:`__members__` is a read-only ordered mapping of ``member_name``:"
"``member`` items.  It is only available on the class."
msgstr ""
":attr:`__members__` — це впорядковане зіставлення елементів ``member_name``:"
"``member`` лише для читання. Це доступно лише в класі."

msgid ""
":meth:`__new__`, if specified, must create and return the enum members; it "
"is also a very good idea to set the member's :attr:`_value_` appropriately.  "
"Once all the members are created it is no longer used."
msgstr ""
":meth:`__new__`, якщо вказано, має створити та повернути члени enum; також "
"дуже гарна ідея належним чином встановити :attr:`_value_` члена. Після "
"створення всіх учасників він більше не використовується."

msgid "Supported ``_sunder_`` names"
msgstr "Підтримувані імена ``_sunder_``"

msgid "``_name_`` -- name of the member"
msgstr "``_name_`` -- ім'я учасника"

msgid ""
"``_value_`` -- value of the member; can be set / modified in ``__new__``"
msgstr "``_value_`` -- значення члена; можна встановити/змінити в ``__new__``"

msgid ""
"``_missing_`` -- a lookup function used when a value is not found; may be "
"overridden"
msgstr ""
"``_missing_`` -- функція пошуку, яка використовується, коли значення не "
"знайдено; може бути перевизначено"

msgid ""
"``_ignore_`` -- a list of names, either as a :class:`list` or a :class:"
"`str`, that will not be transformed into members, and will be removed from "
"the final class"
msgstr ""
"``_ignore_`` -- список імен у вигляді :class:`list` або :class:`str`, які не "
"будуть перетворені в члени та будуть видалені з остаточного класу"

msgid ""
"``_order_`` -- used in Python 2/3 code to ensure member order is consistent "
"(class attribute, removed during class creation)"
msgstr ""
"``_order_`` -- використовується в коді Python 2/3 для забезпечення "
"узгодженості порядку членів (атрибут класу, видалений під час створення "
"класу)"

msgid ""
"``_generate_next_value_`` -- used by the `Functional API`_ and by :class:"
"`auto` to get an appropriate value for an enum member; may be overridden"
msgstr ""
"``_generate_next_value_`` -- використовується `Functional API`_ і :class:"
"`auto` для отримання відповідного значення для члена enum; може бути "
"перевизначено"

msgid ""
"For standard :class:`Enum` classes the next value chosen is the last value "
"seen incremented by one."
msgstr ""
"Для стандартних класів :class:`Enum` наступним вибраним значенням є останнє "
"значення, збільшене на одиницю."

msgid ""
"For :class:`Flag` classes the next value chosen will be the next highest "
"power-of-two, regardless of the last value seen."
msgstr ""
"Для класів :class:`Flag` наступним вибраним значенням буде наступний "
"найвищий ступінь двох, незалежно від останнього побаченого значення."

msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

msgid "``_ignore_``"
msgstr "``_ігнорувати_``"

msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`_order_` attribute "
"can be provided.  It will be checked against the actual order of the "
"enumeration and raise an error if the two do not match::"
msgstr ""
"Щоб підтримувати синхронізацію коду Python 2 / Python 3, можна надати "
"атрибут :attr:`_order_`. Його буде перевірено на фактичний порядок "
"перерахування та викличе помилку, якщо вони не збігаються:"

msgid ""
"In Python 2 code the :attr:`_order_` attribute is necessary as definition "
"order is lost before it can be recorded."
msgstr ""
"У коді Python 2 атрибут :attr:`_order_` необхідний, оскільки порядок "
"визначення втрачається, перш ніж його можна записати."

msgid "_Private__names"
msgstr "_Private__names"

msgid ""
":ref:`Private names <private-name-mangling>` are not converted to enum "
"members, but remain normal attributes."
msgstr ""

msgid "``Enum`` member type"
msgstr "Тип члена ``Enum``"

msgid ""
"Enum members are instances of their enum class, and are normally accessed as "
"``EnumClass.member``.  In Python versions ``3.5`` to ``3.10`` you could "
"access members from other members -- this practice was discouraged, and in "
"``3.11`` :class:`Enum` returns to not allowing it::"
msgstr ""

msgid "Creating members that are mixed with other data types"
msgstr "Створення елементів, змішаних з іншими типами даних"

msgid ""
"When subclassing other data types, such as :class:`int` or :class:`str`, "
"with an :class:`Enum`, all values after the ``=`` are passed to that data "
"type's constructor.  For example::"
msgstr ""

msgid "Boolean value of ``Enum`` classes and members"
msgstr "Логічне значення класів і членів ``Enum``"

msgid ""
"Enum classes that are mixed with non-:class:`Enum` types (such as :class:"
"`int`, :class:`str`, etc.) are evaluated according to the mixed-in type's "
"rules; otherwise, all members evaluate as :data:`True`.  To make your own "
"enum's boolean evaluation depend on the member's value add the following to "
"your class::"
msgstr ""
"Класи Enum, змішані з типами не :class:`Enum` (такими як :class:`int`, :"
"class:`str` тощо), оцінюються відповідно до правил змішаного типу; інакше "
"всі члени оцінюються як :data:`True`. Щоб зробити логічне обчислення вашого "
"власного переліку залежним від значення члена, додайте наступне до свого "
"класу:"

msgid "Plain :class:`Enum` classes always evaluate as :data:`True`."
msgstr "Класи Plain :class:`Enum` завжди оцінюються як :data:`True`."

msgid "``Enum`` classes with methods"
msgstr "``Enum`` класи з методами"

msgid ""
"If you give your enum subclass extra methods, like the `Planet`_ class "
"below, those methods will show up in a :func:`dir` of the member, but not of "
"the class::"
msgstr ""

msgid "Combining members of ``Flag``"
msgstr "Об'єднання членів ``Прапора``"

msgid ""
"Iterating over a combination of :class:`Flag` members will only return the "
"members that are comprised of a single bit::"
msgstr ""
"Ітерація по комбінації елементів :class:`Flag` поверне лише елементи, які "
"складаються з одного біта::"

msgid "``Flag`` and ``IntFlag`` minutia"
msgstr "Деталі ``Flag`` і ``IntFlag``"

msgid "Using the following snippet for our examples::"
msgstr "Використовуючи наступний фрагмент для наших прикладів:"

msgid "the following are true:"
msgstr "вірно наступне:"

msgid "single-bit flags are canonical"
msgstr "однобітові прапори є канонічними"

msgid "multi-bit and zero-bit flags are aliases"
msgstr "багатобітні та нульові бітові прапорці є псевдонімами"

msgid "only canonical flags are returned during iteration::"
msgstr "під час ітерації повертаються лише канонічні прапори::"

msgid ""
"negating a flag or flag set returns a new flag/flag set with the "
"corresponding positive integer value::"
msgstr ""
"заперечення прапора або набору прапорів повертає новий прапор/набір прапорів "
"із відповідним додатним цілим значенням::"

msgid "names of pseudo-flags are constructed from their members' names::"
msgstr "імена псевдо-прапорів складаються з імен їх членів::"

msgid "multi-bit flags, aka aliases, can be returned from operations::"
msgstr ""
"багатобітові прапорці, або псевдоніми, можуть бути повернуті з операцій::"

msgid ""
"membership / containment checking: zero-valued flags are always considered "
"to be contained::"
msgstr ""

msgid ""
"otherwise, only if all bits of one flag are in the other flag will True be "
"returned::"
msgstr ""

msgid ""
"There is a new boundary mechanism that controls how out-of-range / invalid "
"bits are handled: ``STRICT``, ``CONFORM``, ``EJECT``, and ``KEEP``:"
msgstr ""
"Існує новий граничний механізм, який контролює, як обробляються біти за "
"межами діапазону/недійсні: ``STRICT``, ``CONFORM``, ``EJECT`` і ``KEEP``:"

msgid "STRICT --> raises an exception when presented with invalid values"
msgstr "STRICT --> створює виняток, якщо надає недійсні значення"

msgid "CONFORM --> discards any invalid bits"
msgstr "CONFORM --> відкидає всі недійсні біти"

msgid "EJECT --> lose Flag status and become a normal int with the given value"
msgstr ""
"EJECT --> втрачає статус прапора та стає звичайним int із заданим значенням"

msgid "KEEP --> keep the extra bits"
msgstr "KEEP --> збережіть зайві біти"

msgid "keeps Flag status and extra bits"
msgstr "зберігає статус прапора та додаткові біти"

msgid "extra bits do not show up in iteration"
msgstr "зайві біти не відображаються в ітерації"

msgid "extra bits do show up in repr() and str()"
msgstr "додаткові біти з’являються в repr() і str()"

msgid ""
"The default for Flag is ``STRICT``, the default for ``IntFlag`` is "
"``EJECT``, and the default for ``_convert_`` is ``KEEP`` (see ``ssl."
"Options`` for an example of when ``KEEP`` is needed)."
msgstr ""
"Типовим значенням для прапора є ``STRICT``, значенням за замовчуванням "
"``IntFlag`` є ``EJECT``, а за умовчанням для ``_convert_`` є ``KEEP`` (див. "
"``ssl.Options`` для прикладу того, коли потрібен ``KEEP``)."

msgid "How are Enums different?"
msgstr "Чим відрізняються Enum?"

msgid ""
"Enums have a custom metaclass that affects many aspects of both derived :"
"class:`Enum` classes and their instances (members)."
msgstr ""
"Переліки мають спеціальний метаклас, який впливає на багато аспектів як "
"похідних класів :class:`Enum`, так і їх екземплярів (членів)."

msgid "Enum Classes"
msgstr "Класи Enum"

msgid ""
"The :class:`EnumType` metaclass is responsible for providing the :meth:"
"`__contains__`, :meth:`__dir__`, :meth:`__iter__` and other methods that "
"allow one to do things with an :class:`Enum` class that fail on a typical "
"class, such as ``list(Color)`` or ``some_enum_var in Color``.  :class:"
"`EnumType` is responsible for ensuring that various other methods on the "
"final :class:`Enum` class are correct (such as :meth:`__new__`, :meth:"
"`__getnewargs__`, :meth:`__str__` and :meth:`__repr__`)."
msgstr ""

msgid "Enum Members (aka instances)"
msgstr "Члени Enum (також відомі як екземпляри)"

msgid ""
"The most interesting thing about enum members is that they are singletons. :"
"class:`EnumType` creates them all while it is creating the enum class "
"itself, and then puts a custom :meth:`__new__` in place to ensure that no "
"new ones are ever instantiated by returning only the existing member "
"instances."
msgstr ""
"Найцікавіше в членах enum те, що вони є одиночними. :class:`EnumType` "
"створює їх усі під час створення самого класу enum, а потім розміщує "
"спеціальний :meth:`__new__`, щоб гарантувати, що нові екземпляри ніколи не "
"створюватимуться, повертаючи лише наявні екземпляри членів."

msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :class:`Flag`, and :"
"class:`IntFlag` are expected to cover the majority of use-cases, they cannot "
"cover them all.  Here are recipes for some different types of enumerations "
"that can be used directly, or as examples for creating one's own."
msgstr ""
"Хоча очікується, що :class:`Enum`, :class:`IntEnum`, :class:`StrEnum`, :"
"class:`Flag` і :class:`IntFlag` охоплять більшість варіантів використання, "
"вони не можуть охопити їх усіх. Ось рецепти для деяких різних типів "
"перерахувань, які можна використовувати безпосередньо або як приклади для "
"створення власних."

msgid "Omitting values"
msgstr "Пропуск значень"

msgid ""
"In many use-cases, one doesn't care what the actual value of an enumeration "
"is. There are several ways to define this type of simple enumeration:"
msgstr ""

msgid "use instances of :class:`auto` for the value"
msgstr "використовувати екземпляри :class:`auto` для значення"

msgid "use instances of :class:`object` as the value"
msgstr "використовуйте екземпляри :class:`object` як значення"

msgid "use a descriptive string as the value"
msgstr "використовуйте описовий рядок як значення"

msgid ""
"use a tuple as the value and a custom :meth:`__new__` to replace the tuple "
"with an :class:`int` value"
msgstr ""
"використовуйте кортеж як значення та спеціальний :meth:`__new__`, щоб "
"замінити кортеж на значення :class:`int`"

msgid ""
"Using any of these methods signifies to the user that these values are not "
"important, and also enables one to add, remove, or reorder members without "
"having to renumber the remaining members."
msgstr ""
"Використання будь-якого з цих методів означає для користувача, що ці "
"значення не є важливими, а також дозволяє додавати, видаляти або змінювати "
"порядок членів без необхідності перенумеровувати решту членів."

msgid "Using :class:`auto`"
msgstr "Використання :class:`auto`"

msgid "Using :class:`auto` would look like::"
msgstr "Використання :class:`auto` виглядатиме так::"

msgid "Using :class:`object`"
msgstr "Використання :class:`object`"

msgid "Using :class:`object` would look like::"
msgstr "Використання :class:`object` виглядатиме так::"

msgid ""
"This is also a good example of why you might want to write your own :meth:"
"`__repr__`::"
msgstr ""

msgid "Using a descriptive string"
msgstr "Використання описового рядка"

msgid "Using a string as the value would look like::"
msgstr "Використання рядка як значення виглядатиме так::"

msgid "Using a custom :meth:`__new__`"
msgstr "Використання спеціального :meth:`__new__`"

msgid "Using an auto-numbering :meth:`__new__` would look like::"
msgstr "Використання автоматичної нумерації :meth:`__new__` виглядатиме так::"

msgid ""
"To make a more general purpose ``AutoNumber``, add ``*args`` to the "
"signature::"
msgstr ""
"Щоб зробити ``AutoNumber`` більш загального призначення, додайте ``*args`` "
"до підпису::"

msgid ""
"Then when you inherit from ``AutoNumber`` you can write your own "
"``__init__`` to handle any extra arguments::"
msgstr ""
"Тоді, коли ви успадкуєте від ``AutoNumber``, ви можете написати свій власний "
"``__init__`` для обробки будь-яких додаткових аргументів::"

msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the Enum "
"members; it is then replaced by Enum's :meth:`__new__` which is used after "
"class creation for lookup of existing members."
msgstr ""
"Метод :meth:`__new__`, якщо його визначено, використовується під час "
"створення елементів Enum; потім його замінює :meth:`__new__` Enum, який "
"використовується після створення класу для пошуку існуючих членів."

msgid "OrderedEnum"
msgstr "OrderedEnum"

msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being comparable "
"to other enumerations)::"
msgstr ""
"Упорядковане перерахування, яке не базується на :class:`IntEnum` і тому "
"підтримує звичайні інваріанти :class:`Enum` (наприклад, не порівнюється з "
"іншими переліками):"

msgid "DuplicateFreeEnum"
msgstr "DuplicateFreeEnum"

msgid ""
"Raises an error if a duplicate member value is found instead of creating an "
"alias::"
msgstr ""

msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"Це корисний приклад для підкласу Enum для додавання або зміни іншої "
"поведінки, а також заборони псевдонімів. Якщо єдиною бажаною зміною є "
"заборона псевдонімів, натомість можна використати декоратор :func:`unique`."

msgid "Planet"
msgstr "Планета"

msgid ""
"If :meth:`__new__` or :meth:`__init__` is defined, the value of the enum "
"member will be passed to those methods::"
msgstr ""

msgid "TimePeriod"
msgstr "Період часу"

msgid "An example to show the :attr:`_ignore_` attribute in use::"
msgstr "Приклад використання атрибута :attr:`_ignore_`::"

msgid "Subclassing EnumType"
msgstr "Підклас EnumType"

msgid ""
"While most enum needs can be met by customizing :class:`Enum` subclasses, "
"either with class decorators or custom functions, :class:`EnumType` can be "
"subclassed to provide a different Enum experience."
msgstr ""
"У той час як більшість потреб enum можна задовольнити, налаштувавши "
"підкласи :class:`Enum`, або за допомогою декораторів класів, або "
"користувацьких функцій, :class:`EnumType` можна створити підкласи, щоб "
"забезпечити інший досвід Enum."
