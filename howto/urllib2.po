# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2022, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Dmytro Kazanzhy, 2022
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.11\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2022-11-12 16:28+0000\n"
"PO-Revision-Date: 2021-06-28 00:53+0000\n"
"Last-Translator: Dmytro Kazanzhy, 2022\n"
"Language-Team: Ukrainian (https://www.transifex.com/python-doc/teams/5390/"
"uk/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: uk\n"
"Plural-Forms: nplurals=4; plural=(n % 1 == 0 && n % 10 == 1 && n % 100 != "
"11 ? 0 : n % 1 == 0 && n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 12 || n % "
"100 > 14) ? 1 : n % 1 == 0 && (n % 10 ==0 || (n % 10 >=5 && n % 10 <=9) || "
"(n % 100 >=11 && n % 100 <=14 )) ? 2: 3);\n"

msgid "HOWTO Fetch Internet Resources Using The urllib Package"
msgstr "HOWTO Отримати Інтернет-ресурси за допомогою пакета urllib"

msgid "Author"
msgstr "Автор"

msgid "`Michael Foord <https://agileabstractions.com/>`_"
msgstr ""

msgid ""
"There is a French translation of an earlier revision of this HOWTO, "
"available at `urllib2 - Le Manuel manquant <https://web.archive.org/"
"web/20200910051922/http://www.voidspace.org.uk/python/articles/"
"urllib2_francais.shtml>`_."
msgstr ""

msgid "Introduction"
msgstr "вступ"

msgid ""
"You may also find useful the following article on fetching web resources "
"with Python:"
msgstr ""
"Вам також може бути корисною наступна стаття про отримання веб-ресурсів за "
"допомогою Python:"

msgid ""
"`Basic Authentication <https://web.archive.org/web/20201215133350/http://www."
"voidspace.org.uk/python/articles/authentication.shtml>`_"
msgstr ""

msgid "A tutorial on *Basic Authentication*, with examples in Python."
msgstr "Посібник із *базової автентифікації* з прикладами на Python."

msgid ""
"**urllib.request** is a Python module for fetching URLs (Uniform Resource "
"Locators). It offers a very simple interface, in the form of the *urlopen* "
"function. This is capable of fetching URLs using a variety of different "
"protocols. It also offers a slightly more complex interface for handling "
"common situations - like basic authentication, cookies, proxies and so on. "
"These are provided by objects called handlers and openers."
msgstr ""
"**urllib.request** — це модуль Python для отримання URL-адрес (уніфікованих "
"покажчиків ресурсів). Він пропонує дуже простий інтерфейс у формі функції "
"*urlopen*. Це здатне отримувати URL-адреси за допомогою різних протоколів. "
"Він також пропонує дещо складніший інтерфейс для обробки поширених ситуацій, "
"таких як базова автентифікація, файли cookie, проксі тощо. Вони "
"забезпечуються об’єктами, які називаються обробниками та відкривачами."

msgid ""
"urllib.request supports fetching URLs for many \"URL schemes\" (identified "
"by the string before the ``\":\"`` in URL - for example ``\"ftp\"`` is the "
"URL scheme of ``\"ftp://python.org/\"``) using their associated network "
"protocols (e.g. FTP, HTTP). This tutorial focuses on the most common case, "
"HTTP."
msgstr ""
"urllib.request підтримує отримання URL-адрес для багатьох \"схем URL-"
"адрес\" (визначених рядком перед ``\":\"`` в URL-адресі - наприклад, "
"``\"ftp\"`` є схемою URL-адреси ``\"ftp:// python.org/\"``), використовуючи "
"відповідні мережеві протоколи (наприклад, FTP, HTTP). Цей підручник "
"присвячено найпоширенішому випадку, HTTP."

msgid ""
"For straightforward situations *urlopen* is very easy to use. But as soon as "
"you encounter errors or non-trivial cases when opening HTTP URLs, you will "
"need some understanding of the HyperText Transfer Protocol. The most "
"comprehensive and authoritative reference to HTTP is :rfc:`2616`. This is a "
"technical document and not intended to be easy to read. This HOWTO aims to "
"illustrate using *urllib*, with enough detail about HTTP to help you "
"through. It is not intended to replace the :mod:`urllib.request` docs, but "
"is supplementary to them."
msgstr ""
"Для простих ситуацій *urlopen* дуже простий у використанні. Але як тільки ви "
"зіткнетеся з помилками або нетривіальними випадками під час відкриття URL-"
"адрес HTTP, вам знадобиться деяке розуміння протоколу передачі гіпертексту. "
"Найбільш повним і авторитетним посиланням на HTTP є :rfc:`2616`. Це "
"технічний документ, який не призначений для легкого читання. Цей HOWTO має "
"на меті проілюструвати використання *urllib* з достатньою кількістю деталей "
"про HTTP, щоб допомогти вам у цьому. Він не призначений для заміни "
"документів :mod:`urllib.request`, а є доповненням до них."

msgid "Fetching URLs"
msgstr "Отримання URL-адрес"

msgid "The simplest way to use urllib.request is as follows::"
msgstr "Найпростіший спосіб використання urllib.request такий:"

msgid ""
"If you wish to retrieve a resource via URL and store it in a temporary "
"location, you can do so via the :func:`shutil.copyfileobj` and :func:"
"`tempfile.NamedTemporaryFile` functions::"
msgstr ""
"Якщо ви бажаєте отримати ресурс через URL-адресу та зберегти його у "
"тимчасовому місці, ви можете зробити це за допомогою функцій :func:`shutil."
"copyfileobj` і :func:`tempfile.NamedTemporaryFile`::"

msgid ""
"Many uses of urllib will be that simple (note that instead of an 'http:' URL "
"we could have used a URL starting with 'ftp:', 'file:', etc.).  However, "
"it's the purpose of this tutorial to explain the more complicated cases, "
"concentrating on HTTP."
msgstr ""
"У багатьох випадках використання urllib буде таким простим (зауважте, що "
"замість URL-адреси \"http:\" ми могли б використовувати URL-адресу, яка "
"починається з \"ftp:\", \"file:\" тощо). Однак мета цього підручника — "
"пояснити складніші випадки, зосереджуючись на HTTP."

msgid ""
"HTTP is based on requests and responses - the client makes requests and "
"servers send responses. urllib.request mirrors this with a ``Request`` "
"object which represents the HTTP request you are making. In its simplest "
"form you create a Request object that specifies the URL you want to fetch. "
"Calling ``urlopen`` with this Request object returns a response object for "
"the URL requested. This response is a file-like object, which means you can "
"for example call ``.read()`` on the response::"
msgstr ""
"HTTP базується на запитах і відповідях - клієнт робить запити, а сервери "
"надсилають відповіді. urllib.request відображає це за допомогою об’єкта "
"``Request``, який представляє HTTP-запит, який ви робите. У найпростішій "
"формі ви створюєте об’єкт Request, який визначає URL-адресу, яку ви хочете "
"отримати. Виклик ``urlopen`` із цим об’єктом Request повертає об’єкт "
"відповіді для запитуваної URL-адреси. Ця відповідь є файлоподібним об’єктом, "
"що означає, що ви можете, наприклад, викликати ``.read()`` у відповіді::"

msgid ""
"Note that urllib.request makes use of the same Request interface to handle "
"all URL schemes.  For example, you can make an FTP request like so::"
msgstr ""
"Зауважте, що urllib.request використовує той самий інтерфейс Request для "
"обробки всіх схем URL-адрес. Наприклад, ви можете зробити FTP-запит так:"

msgid ""
"In the case of HTTP, there are two extra things that Request objects allow "
"you to do: First, you can pass data to be sent to the server.  Second, you "
"can pass extra information (\"metadata\") *about* the data or about the "
"request itself, to the server - this information is sent as HTTP "
"\"headers\".  Let's look at each of these in turn."
msgstr ""
"У випадку HTTP об’єкти Request дозволяють робити дві додаткові речі: по-"
"перше, ви можете передавати дані для надсилання на сервер. По-друге, ви "
"можете передати на сервер додаткову інформацію (\"метадані\") *про* дані або "
"про сам запит — ця інформація надсилається як \"заголовки\" HTTP. Давайте по "
"черзі розглянемо кожен із них."

msgid "Data"
msgstr "Дані"

msgid ""
"Sometimes you want to send data to a URL (often the URL will refer to a CGI "
"(Common Gateway Interface) script or other web application). With HTTP, this "
"is often done using what's known as a **POST** request. This is often what "
"your browser does when you submit a HTML form that you filled in on the web. "
"Not all POSTs have to come from forms: you can use a POST to transmit "
"arbitrary data to your own application. In the common case of HTML forms, "
"the data needs to be encoded in a standard way, and then passed to the "
"Request object as the ``data`` argument. The encoding is done using a "
"function from the :mod:`urllib.parse` library. ::"
msgstr ""
"Іноді потрібно надіслати дані за URL-адресою (часто URL-адреса "
"посилатиметься на сценарій CGI (Common Gateway Interface) або іншу веб-"
"програму). За допомогою HTTP це часто робиться за допомогою так званого "
"запиту **POST**. Це часто робить ваш браузер, коли ви надсилаєте форму HTML, "
"яку ви заповнили в Інтернеті. Не всі повідомлення POST мають надходити з "
"форм: ви можете використовувати POST для передачі довільних даних у власну "
"програму. У звичайному випадку форм HTML дані потрібно закодувати "
"стандартним способом, а потім передати в об’єкт Request як аргумент "
"``data``. Кодування виконується за допомогою функції з бібліотеки :mod:"
"`urllib.parse`. ::"

msgid ""
"Note that other encodings are sometimes required (e.g. for file upload from "
"HTML forms - see `HTML Specification, Form Submission <https://www.w3.org/TR/"
"REC-html40/interact/forms.html#h-17.13>`_ for more details)."
msgstr ""
"Зауважте, що іноді потрібні інші кодування (наприклад, для завантаження "
"файлів із форм HTML – див. `Специфікація HTML, Подання форми <https://www.w3."
"org/TR/REC-html40/interact/forms.html#h-17.13>`_ для отримання додаткової "
"інформації)."

msgid ""
"If you do not pass the ``data`` argument, urllib uses a **GET** request. One "
"way in which GET and POST requests differ is that POST requests often have "
"\"side-effects\": they change the state of the system in some way (for "
"example by placing an order with the website for a hundredweight of tinned "
"spam to be delivered to your door).  Though the HTTP standard makes it clear "
"that POSTs are intended to *always* cause side-effects, and GET requests "
"*never* to cause side-effects, nothing prevents a GET request from having "
"side-effects, nor a POST requests from having no side-effects. Data can also "
"be passed in an HTTP GET request by encoding it in the URL itself."
msgstr ""
"Якщо ви не передаєте аргумент ``data``, urllib використовує запит **GET**. "
"Запити GET і POST відрізняються тим, що запити POST часто мають \"побічні "
"ефекти\": вони певним чином змінюють стан системи (наприклад, розміщуючи на "
"веб-сайті замовлення на доставку сотень консервованого спаму). до ваших "
"дверей). Хоча стандарт HTTP чітко визначає, що POST призначені *завжди* "
"спричиняти побічні ефекти, а запити GET *ніколи* не спричиняти побічних "
"ефектів, ніщо не заважає запитам GET мати побічні ефекти, а запитам POST — "
"не мати побічних ефектів. побічні ефекти. Дані також можна передати в запиті "
"HTTP GET, закодувавши їх у самій URL-адресі."

msgid "This is done as follows::"
msgstr "Це робиться наступним чином:"

msgid ""
"Notice that the full URL is created by adding a ``?`` to the URL, followed "
"by the encoded values."
msgstr ""
"Зауважте, що повна URL-адреса створюється шляхом додавання ``?`` до URL-"
"адреси, а потім закодованих значень."

msgid "Headers"
msgstr "Заголовки"

msgid ""
"We'll discuss here one particular HTTP header, to illustrate how to add "
"headers to your HTTP request."
msgstr ""
"Ми обговоримо тут один конкретний HTTP-заголовок, щоб проілюструвати, як "
"додати заголовки до вашого HTTP-запиту."

msgid ""
"Some websites [#]_ dislike being browsed by programs, or send different "
"versions to different browsers [#]_. By default urllib identifies itself as "
"``Python-urllib/x.y`` (where ``x`` and ``y`` are the major and minor version "
"numbers of the Python release, e.g. ``Python-urllib/2.5``), which may "
"confuse the site, or just plain not work. The way a browser identifies "
"itself is through the ``User-Agent`` header [#]_. When you create a Request "
"object you can pass a dictionary of headers in. The following example makes "
"the same request as above, but identifies itself as a version of Internet "
"Explorer [#]_. ::"
msgstr ""
"Деяким веб-сайтам [#]_ не подобається, коли їх переглядають програми, або "
"вони надсилають різні версії в різні браузери [#]_. За замовчуванням urllib "
"ідентифікує себе як ``Python-urllib/x.y`` (де ``x`` і ``y`` — номер основної "
"та другорядної версій випуску Python, наприклад ``Python-urllib/2.5`` ), що "
"може заплутати сайт або просто не працювати. Браузер ідентифікує себе через "
"заголовок ``User-Agent`` [#]_. Коли ви створюєте об’єкт Request, ви можете "
"передати словник заголовків. Наступний приклад робить той самий запит, що й "
"вище, але ідентифікує себе як версію Internet Explorer [#]_. ::"

msgid ""
"The response also has two useful methods. See the section on `info and "
"geturl`_ which comes after we have a look at what happens when things go "
"wrong."
msgstr ""
"Відповідь також має два корисні методи. Перегляньте розділ про `info та "
"geturl`_, який йде після того, як ми подивимося, що відбувається, коли щось "
"йде не так."

msgid "Handling Exceptions"
msgstr "Обробка винятків"

msgid ""
"*urlopen* raises :exc:`URLError` when it cannot handle a response (though as "
"usual with Python APIs, built-in exceptions such as :exc:`ValueError`, :exc:"
"`TypeError` etc. may also be raised)."
msgstr ""
"*urlopen* викликає :exc:`URLError`, коли не може обробити відповідь (хоча, "
"як зазвичай з Python API, також можуть виникати вбудовані винятки, такі як :"
"exc:`ValueError`, :exc:`TypeError` тощо) ."

msgid ""
":exc:`HTTPError` is the subclass of :exc:`URLError` raised in the specific "
"case of HTTP URLs."
msgstr ""
":exc:`HTTPError` є підкласом :exc:`URLError`, що виникає в конкретному "
"випадку URL-адрес HTTP."

msgid "The exception classes are exported from the :mod:`urllib.error` module."
msgstr "Класи винятків експортуються з модуля :mod:`urllib.error`."

msgid "URLError"
msgstr "URLError"

msgid ""
"Often, URLError is raised because there is no network connection (no route "
"to the specified server), or the specified server doesn't exist.  In this "
"case, the exception raised will have a 'reason' attribute, which is a tuple "
"containing an error code and a text error message."
msgstr ""
"Часто URLError виникає через відсутність підключення до мережі (немає "
"маршруту до вказаного сервера) або вказаний сервер не існує. У цьому випадку "
"викликаний виняток матиме атрибут \"причина\", який є кортежем, що містить "
"код помилки та текстове повідомлення про помилку."

msgid "e.g. ::"
msgstr "напр. ::"

msgid "HTTPError"
msgstr "HTTPError"

msgid ""
"Every HTTP response from the server contains a numeric \"status code\". "
"Sometimes the status code indicates that the server is unable to fulfil the "
"request. The default handlers will handle some of these responses for you "
"(for example, if the response is a \"redirection\" that requests the client "
"fetch the document from a different URL, urllib will handle that for you). "
"For those it can't handle, urlopen will raise an :exc:`HTTPError`. Typical "
"errors include '404' (page not found), '403' (request forbidden), and "
"'401' (authentication required)."
msgstr ""
"Кожна відповідь HTTP від сервера містить числовий \"код стану\". Іноді код "
"стану вказує на те, що сервер не може виконати запит. Обробники за "
"замовчуванням оброблять деякі з цих відповідей за вас (наприклад, якщо "
"відповідь є \"переспрямуванням\", яке вимагає від клієнта отримати документ "
"з іншої URL-адреси, urllib обробить це за вас). Для тих, хто не може "
"впоратися, urlopen викличе :exc:`HTTPError`. Типові помилки включають "
"\"404\" (сторінку не знайдено), \"403\" (запит заборонено) і "
"\"401\" (потрібна автентифікація)."

msgid ""
"See section 10 of :rfc:`2616` for a reference on all the HTTP error codes."
msgstr ""
"Перегляньте розділ 10 :rfc:`2616` для довідки про всі коди помилок HTTP."

msgid ""
"The :exc:`HTTPError` instance raised will have an integer 'code' attribute, "
"which corresponds to the error sent by the server."
msgstr ""
"Викликаний екземпляр :exc:`HTTPError` матиме цілочисельний атрибут \"code\", "
"який відповідає помилці, надісланій сервером."

msgid "Error Codes"
msgstr "Коди помилок"

msgid ""
"Because the default handlers handle redirects (codes in the 300 range), and "
"codes in the 100--299 range indicate success, you will usually only see "
"error codes in the 400--599 range."
msgstr ""
"Оскільки обробники за замовчуванням обробляють переспрямування (коди в "
"діапазоні 300), а коди в діапазоні 100--299 вказують на успіх, зазвичай ви "
"побачите коди помилок лише в діапазоні 400--599."

msgid ""
":attr:`http.server.BaseHTTPRequestHandler.responses` is a useful dictionary "
"of response codes in that shows all the response codes used by :rfc:`2616`. "
"The dictionary is reproduced here for convenience ::"
msgstr ""
":attr:`http.server.BaseHTTPRequestHandler.responses` — це корисний словник "
"кодів відповідей, який показує всі коди відповідей, які використовує :rfc:"
"`2616`. Для зручності словник наведено тут ::"

msgid ""
"When an error is raised the server responds by returning an HTTP error code "
"*and* an error page. You can use the :exc:`HTTPError` instance as a response "
"on the page returned. This means that as well as the code attribute, it also "
"has read, geturl, and info, methods as returned by the ``urllib.response`` "
"module::"
msgstr ""
"Коли виникає помилка, сервер відповідає, повертаючи код помилки HTTP *і* "
"сторінку помилки. Ви можете використовувати екземпляр :exc:`HTTPError` як "
"відповідь на повернуту сторінку. Це означає, що окрім атрибута code, він "
"також має методи read, geturl та info, які повертає модуль urllib.response::"

msgid "Wrapping it Up"
msgstr "Загортання"

msgid ""
"So if you want to be prepared for :exc:`HTTPError` *or* :exc:`URLError` "
"there are two basic approaches. I prefer the second approach."
msgstr ""
"Отже, якщо ви хочете бути готовими до :exc:`HTTPError` *або* :exc:"
"`URLError`, є два основні підходи. Я віддаю перевагу другому підходу."

msgid "Number 1"
msgstr "Номер 1"

msgid ""
"The ``except HTTPError`` *must* come first, otherwise ``except URLError`` "
"will *also* catch an :exc:`HTTPError`."
msgstr ""
"``except HTTPError`` *має* бути першим, інакше ``except URLError`` *також* "
"перехопить :exc:`HTTPEror`."

msgid "Number 2"
msgstr "Номер 2"

msgid "info and geturl"
msgstr "інформація та geturl"

msgid ""
"The response returned by urlopen (or the :exc:`HTTPError` instance) has two "
"useful methods :meth:`info` and :meth:`geturl` and is defined in the module :"
"mod:`urllib.response`.."
msgstr ""
"Відповідь, яку повертає urlopen (або екземпляр :exc:`HTTPError`), має два "
"корисні методи :meth:`info` та :meth:`geturl` і визначено в модулі :mod:"
"`urllib.response`.."

msgid ""
"**geturl** - this returns the real URL of the page fetched. This is useful "
"because ``urlopen`` (or the opener object used) may have followed a "
"redirect. The URL of the page fetched may not be the same as the URL "
"requested."
msgstr ""
"**geturl** - повертає справжню URL-адресу отриманої сторінки. Це корисно, "
"оскільки ``urlopen`` (або використаний об’єкт відкриття) міг слідувати за "
"перенаправленням. URL-адреса отриманої сторінки може не збігатися з "
"запитуваною URL-адресою."

msgid ""
"**info** - this returns a dictionary-like object that describes the page "
"fetched, particularly the headers sent by the server. It is currently an :"
"class:`http.client.HTTPMessage` instance."
msgstr ""
"**info** - це повертає об’єкт, схожий на словник, який описує отриману "
"сторінку, зокрема заголовки, надіслані сервером. Зараз це екземпляр :class:"
"`http.client.HTTPMessage`."

msgid ""
"Typical headers include 'Content-length', 'Content-type', and so on. See the "
"`Quick Reference to HTTP Headers <https://jkorpela.fi/http.html>`_ for a "
"useful listing of HTTP headers with brief explanations of their meaning and "
"use."
msgstr ""

msgid "Openers and Handlers"
msgstr "Відкривачки та обробники"

msgid ""
"When you fetch a URL you use an opener (an instance of the perhaps "
"confusingly named :class:`urllib.request.OpenerDirector`). Normally we have "
"been using the default opener - via ``urlopen`` - but you can create custom "
"openers. Openers use handlers. All the \"heavy lifting\" is done by the "
"handlers. Each handler knows how to open URLs for a particular URL scheme "
"(http, ftp, etc.), or how to handle an aspect of URL opening, for example "
"HTTP redirections or HTTP cookies."
msgstr ""

msgid ""
"You will want to create openers if you want to fetch URLs with specific "
"handlers installed, for example to get an opener that handles cookies, or to "
"get an opener that does not handle redirections."
msgstr ""
"Ви захочете створити відкривачі, якщо хочете отримати URL-адреси з "
"установленими певними обробниками, наприклад, щоб отримати відкривач, який "
"обробляє файли cookie, або щоб отримати відкривач, який не обробляє "
"переспрямування."

msgid ""
"To create an opener, instantiate an ``OpenerDirector``, and then call ``."
"add_handler(some_handler_instance)`` repeatedly."
msgstr ""
"Щоб створити відкривач, створіть екземпляр ``OpenerDirector``, а потім "
"кілька разів викличте ``.add_handler(some_handler_instance)``."

msgid ""
"Alternatively, you can use ``build_opener``, which is a convenience function "
"for creating opener objects with a single function call.  ``build_opener`` "
"adds several handlers by default, but provides a quick way to add more and/"
"or override the default handlers."
msgstr ""
"Крім того, ви можете використовувати ``build_opener``, яка є зручною "
"функцією для створення відкриваючих об’єктів за допомогою одного виклику "
"функції. ``build_opener`` додає кілька обробників за замовчуванням, але "
"забезпечує швидкий спосіб додати більше та/або замінити обробники за "
"замовчуванням."

msgid ""
"Other sorts of handlers you might want to can handle proxies, "
"authentication, and other common but slightly specialised situations."
msgstr ""
"Інші типи обробників, які вам можуть знадобитися, можуть обробляти проксі, "
"автентифікацію та інші типові, але трохи спеціалізовані ситуації."

msgid ""
"``install_opener`` can be used to make an ``opener`` object the (global) "
"default opener. This means that calls to ``urlopen`` will use the opener you "
"have installed."
msgstr ""
"``install_opener`` можна використовувати, щоб зробити об’єкт ``opener`` "
"(глобальним) відкривачем за замовчуванням. Це означає, що виклики "
"``urlopen`` використовуватимуть встановлений вами відкривач."

msgid ""
"Opener objects have an ``open`` method, which can be called directly to "
"fetch urls in the same way as the ``urlopen`` function: there's no need to "
"call ``install_opener``, except as a convenience."
msgstr ""
"Об’єкти Opener мають метод ``open``, який можна викликати безпосередньо для "
"отримання URL-адрес так само, як і функцію ``urlopen``: немає необхідності "
"викликати ``install_opener``, окрім як для зручності."

msgid "Basic Authentication"
msgstr "Базова автентифікація"

msgid ""
"To illustrate creating and installing a handler we will use the "
"``HTTPBasicAuthHandler``. For a more detailed discussion of this subject -- "
"including an explanation of how Basic Authentication works - see the `Basic "
"Authentication Tutorial <http://www.voidspace.org.uk/python/articles/"
"authentication.shtml>`_."
msgstr ""
"Щоб проілюструвати створення та встановлення обробника, ми використаємо "
"``HTTPBasicAuthHandler``. Для більш детального обговорення цієї теми, "
"включаючи пояснення того, як працює базова автентифікація, дивіться "
"`Навчальний посібник з базової автентифікації <http://www.voidspace.org.uk/"
"python/articles/authentication.shtml>`_."

msgid ""
"When authentication is required, the server sends a header (as well as the "
"401 error code) requesting authentication.  This specifies the "
"authentication scheme and a 'realm'. The header looks like: ``WWW-"
"Authenticate: SCHEME realm=\"REALM\"``."
msgstr ""
"Коли потрібна автентифікація, сервер надсилає заголовок (а також код помилки "
"401) із запитом на автентифікацію. Це визначає схему автентифікації та "
"\"сферу\". Заголовок виглядає так: ``WWW-Authenticate: SCHEME "
"realm=\"REALM\"``."

msgid "e.g."
msgstr "напр."

msgid ""
"The client should then retry the request with the appropriate name and "
"password for the realm included as a header in the request. This is 'basic "
"authentication'. In order to simplify this process we can create an instance "
"of ``HTTPBasicAuthHandler`` and an opener to use this handler."
msgstr ""
"Потім клієнт повинен повторити запит із відповідним іменем і паролем для "
"області, включеними як заголовок запиту. Це \"базова автентифікація\". Щоб "
"спростити цей процес, ми можемо створити екземпляр ``HTTPBasicAuthHandler`` "
"і засіб відкриття для використання цього обробника."

msgid ""
"The ``HTTPBasicAuthHandler`` uses an object called a password manager to "
"handle the mapping of URLs and realms to passwords and usernames. If you "
"know what the realm is (from the authentication header sent by the server), "
"then you can use a ``HTTPPasswordMgr``. Frequently one doesn't care what the "
"realm is. In that case, it is convenient to use "
"``HTTPPasswordMgrWithDefaultRealm``. This allows you to specify a default "
"username and password for a URL. This will be supplied in the absence of you "
"providing an alternative combination for a specific realm. We indicate this "
"by providing ``None`` as the realm argument to the ``add_password`` method."
msgstr ""
"``HTTPBasicAuthHandler`` використовує об’єкт під назвою менеджер паролів для "
"обробки зіставлення URL-адрес і областей з паролями та іменами користувачів. "
"Якщо ви знаєте, що таке область (із заголовка автентифікації, надісланого "
"сервером), ви можете використовувати ``HTTPPasswordMgr``. Часто байдуже, що "
"таке царство. У такому випадку зручно використовувати "
"``HTTPPasswordMgrWithDefaultRealm``. Це дозволяє вказати ім’я користувача та "
"пароль за умовчанням для URL-адреси. Це буде надано, якщо ви не надасте "
"альтернативну комбінацію для певного царства. Ми вказуємо на це, надаючи "
"``None`` як аргумент області для методу ``add_password``."

msgid ""
"The top-level URL is the first URL that requires authentication. URLs "
"\"deeper\" than the URL you pass to .add_password() will also match. ::"
msgstr ""
"URL-адреса верхнього рівня – це перша URL-адреса, яка вимагає "
"автентифікації. URL-адреси, \"глибші\" за URL-адресу, яку ви передаєте в ."
"add_password(), також відповідатимуть. ::"

msgid ""
"In the above example we only supplied our ``HTTPBasicAuthHandler`` to "
"``build_opener``. By default openers have the handlers for normal situations "
"-- ``ProxyHandler`` (if a proxy setting such as an :envvar:`http_proxy` "
"environment variable is set), ``UnknownHandler``, ``HTTPHandler``, "
"``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, ``FTPHandler``, "
"``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."
msgstr ""
"У наведеному вище прикладі ми лише надали наш ``HTTPBasicAuthHandler`` до "
"``build_opener``. За замовчуванням відкривачі мають обробники для звичайних "
"ситуацій -- ``ProxyHandler`` (якщо встановлено налаштування проксі, "
"наприклад змінну середовища :envvar:`http_proxy`), ``UnknownHandler``, "
"``HTTPHandler``, ``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, "
"``FTPHandler``, ``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."

msgid ""
"``top_level_url`` is in fact *either* a full URL (including the 'http:' "
"scheme component and the hostname and optionally the port number) e.g. "
"``\"http://example.com/\"`` *or* an \"authority\" (i.e. the hostname, "
"optionally including the port number) e.g. ``\"example.com\"`` or "
"``\"example.com:8080\"`` (the latter example includes a port number).  The "
"authority, if present, must NOT contain the \"userinfo\" component - for "
"example ``\"joe:password@example.com\"`` is not correct."
msgstr ""
"``top_level_url`` насправді є *або* повною URL-адресою (включно з "
"компонентом схеми 'http:' та ім'ям хоста та, необов'язково, номером порту), "
"напр. ``\"http://example.com/\"`` *або* \"орган\" (тобто ім’я хоста, "
"необов’язково включаючи номер порту), наприклад. ``\"example.com\"`` або "
"``\"example.com:8080\"`` (останній приклад містить номер порту). "
"Повноваження, якщо вони присутні, НЕ повинні містити компонент \"userinfo\" "
"- наприклад, ``\"joe:password@example.com\"`` є неправильним."

msgid "Proxies"
msgstr "Проксі"

msgid ""
"**urllib** will auto-detect your proxy settings and use those. This is "
"through the ``ProxyHandler``, which is part of the normal handler chain when "
"a proxy setting is detected.  Normally that's a good thing, but there are "
"occasions when it may not be helpful [#]_. One way to do this is to setup "
"our own ``ProxyHandler``, with no proxies defined. This is done using "
"similar steps to setting up a `Basic Authentication`_ handler: ::"
msgstr ""
"**urllib** автоматично визначить ваші налаштування проксі та використає їх. "
"Це відбувається через ``ProxyHandler``, який є частиною звичайного ланцюжка "
"обробників, коли виявляється налаштування проксі. Зазвичай це добре, але "
"бувають випадки, коли це може бути некорисним [#]_. Один із способів зробити "
"це — налаштувати наш власний ``ProxyHandler`` без визначених проксі. Це "
"робиться за допомогою подібних кроків до налаштування обробника `Basic "
"Authentication`_: ::"

msgid ""
"Currently ``urllib.request`` *does not* support fetching of ``https`` "
"locations through a proxy.  However, this can be enabled by extending urllib."
"request as shown in the recipe [#]_."
msgstr ""
"Наразі ``urllib.request`` *не* підтримує отримання адрес ``https`` через "
"проксі. Однак це можна ввімкнути, розширивши urllib.request, як показано в "
"рецепті [#]_."

msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; see "
"the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"``HTTP_PROXY`` ігноруватиметься, якщо встановлено змінну ``REQUEST_METHOD``; "
"перегляньте документацію на :func:`~urllib.request.getproxies`."

msgid "Sockets and Layers"
msgstr "Розетки та шари"

msgid ""
"The Python support for fetching resources from the web is layered.  urllib "
"uses the :mod:`http.client` library, which in turn uses the socket library."
msgstr ""
"Підтримка Python для отримання ресурсів з Інтернету є багаторівневою. urllib "
"використовує бібліотеку :mod:`http.client`, яка, у свою чергу, використовує "
"бібліотеку сокетів."

msgid ""
"As of Python 2.3 you can specify how long a socket should wait for a "
"response before timing out. This can be useful in applications which have to "
"fetch web pages. By default the socket module has *no timeout* and can hang. "
"Currently, the socket timeout is not exposed at the http.client or urllib."
"request levels. However, you can set the default timeout globally for all "
"sockets using ::"
msgstr ""
"Починаючи з Python 2.3, ви можете вказати, як довго сокет повинен чекати "
"відповіді перед закінченням часу очікування. Це може бути корисним у "
"програмах, які мають отримати веб-сторінки. За замовчуванням модуль сокета "
"*не має часу очікування* і може зависати. Наразі час очікування сокета не "
"розкривається на рівнях http.client або urllib.request. Однак ви можете "
"глобально встановити тайм-аут за замовчуванням для всіх сокетів за "
"допомогою ::"

msgid "Footnotes"
msgstr "Виноски"

msgid "This document was reviewed and revised by John Lee."
msgstr "Цей документ переглянув і відредагував Джон Лі."

msgid "Google for example."
msgstr "Google наприклад."

msgid ""
"Browser sniffing is a very bad practice for website design - building sites "
"using web standards is much more sensible. Unfortunately a lot of sites "
"still send different versions to different browsers."
msgstr ""
"Перегляд веб-переглядача є дуже поганою практикою для дизайну веб-сайтів - "
"створювати сайти за допомогою веб-стандартів набагато розумніше. На жаль, "
"багато сайтів досі надсилають різні версії в різні браузери."

msgid ""
"The user agent for MSIE 6 is *'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT "
"5.1; SV1; .NET CLR 1.1.4322)'*"
msgstr ""
"Агентом користувача для MSIE 6 є *\"Mozilla/4.0 (сумісний; MSIE 6.0; Windows "
"NT 5.1; SV1; .NET CLR 1.1.4322)\"*"

msgid ""
"For details of more HTTP request headers, see `Quick Reference to HTTP "
"Headers`_."
msgstr ""
"Додаткову інформацію про заголовки HTTP-запитів див. у розділі `Короткий "
"довідник із заголовками HTTP`_."

msgid ""
"In my case I have to use a proxy to access the internet at work. If you "
"attempt to fetch *localhost* URLs through this proxy it blocks them. IE is "
"set to use the proxy, which urllib picks up on. In order to test scripts "
"with a localhost server, I have to prevent urllib from using the proxy."
msgstr ""
"У моєму випадку мені доводиться використовувати проксі для доступу до "
"Інтернету на роботі. Якщо ви намагаєтесь отримати URL-адреси *localhost* "
"через цей проксі, він блокує їх. IE налаштовано на використання проксі, який "
"підбирає urllib. Щоб перевірити сценарії на локальному сервері, я повинен "
"заборонити urllib використовувати проксі."

msgid ""
"urllib opener for SSL proxy (CONNECT method): `ASPN Cookbook Recipe <https://"
"code.activestate.com/recipes/456195/>`_."
msgstr ""
"urllib для відкриття SSL-проксі (метод CONNECT): `ASPN Cookbook Recipe "
"<https://code.activestate.com/recipes/456195/>`_."
